// Copyright 2024 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package org.chromium.chrome.browser.provider;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Intent;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.net.Uri;
import android.util.Pair;

import androidx.annotation.GuardedBy;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.VisibleForTesting;

import org.json.JSONException;
import org.json.JSONObject;

import org.chromium.base.ContextUtils;
import org.chromium.base.PackageUtils;
import org.chromium.base.ThreadUtils;
import org.chromium.base.TimeUtils;
import org.chromium.base.TraceEvent;
import org.chromium.base.metrics.RecordHistogram;
import org.chromium.base.task.PostTask;
import org.chromium.base.task.TaskTraits;
import org.chromium.build.annotations.UsedByReflection;
import org.chromium.chrome.browser.ActivityTabProvider;
import org.chromium.chrome.browser.base.SplitCompatContentProvider;
import org.chromium.chrome.browser.content_extraction.InnerTextBridge;
import org.chromium.chrome.browser.flags.ChromeFeatureList;
import org.chromium.chrome.browser.provider.PageContentProviderMetrics.PageContentProviderEvent;
import org.chromium.chrome.browser.tab.Tab;
import org.chromium.content_public.browser.RenderFrameHost;

import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * ContentProvider that returns the InnerText of the current web page. It generates a URI for the
 * current web page that is attached to {@link android.app.assist.AssistContent} whenever an
 * assistant is invoked when ChromeActivity is visible. The assistant app calls the query method to
 * start the text extraction process and it gets the resulting text in a synchronous fashion.
 * switches).
 */
@UsedByReflection("PageContentProvider.java")
public class PageContentProviderImpl extends SplitCompatContentProvider.Impl {

    private static final int INVALIDATE_URI_DELAY_MS = 60_000;
    private static final int PAGE_EXTRACTION_TIMEOUT_MS = 30_000;

    static final class PageContentInvocationState {

        public PageContentInvocationState(
                @NonNull String invocationId,
                @NonNull String invokedUrl,
                @NonNull ActivityTabProvider activityTabProvider) {
            mInvocationId = invocationId;
            mInvokedUrl = invokedUrl;
            mActivityTabProvider = activityTabProvider;
            mInvocationStartTimestampMs = TimeUtils.elapsedRealtimeMillis();
        }

        @NonNull private final String mInvocationId;
        @NonNull private final String mInvokedUrl;
        @NonNull private final ActivityTabProvider mActivityTabProvider;

        private long mInvocationStartTimestampMs;
        private long mExtractionStartTimestampMs;
    }

    private static final String AUTHORITY_SUFFIX = ".PageContentProvider";
    private static final String CONTENT_PATH = "*";

    private static final int URI_MATCH_INVOCATION_URL = 1;

    private UriMatcher mUriMatcher;

    @GuardedBy("sLock")
    private static PageContentInvocationState sInvocationState;

    private static final Object sLock = new Object();

    private void ensureUriMatcherInitialized() {
        if (mUriMatcher != null) {
            return;
        }

        mUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
        String authority = ContextUtils.getApplicationContext().getPackageName() + AUTHORITY_SUFFIX;
        mUriMatcher.addURI(authority, CONTENT_PATH, URI_MATCH_INVOCATION_URL);
    }

    /**
     * Method called by external apps. {@link uri} must be a valid URI generated by {@code
     * getContentUriForURL()}.
     *
     * <p>Calling with a valid URI starts the text extraction process for the associated page. The
     * call will block the binder thread until the text is extracted from the page or the task times
     * out.
     *
     * <p>It returns a {@link Cursor} with 4 columns and 1 row: - "_id": The current page URL. -
     * "success": 1 if page extraction is successful, 0 otherwise. - "contents": The text from the
     * current page if "success" is 1, empty string otherwise. - "error_message": An error message
     * if "success" is 0.
     */
    @Nullable
    @Override
    public Cursor query(
            @NonNull Uri uri,
            @Nullable String[] strings,
            @Nullable String s,
            @Nullable String[] strings1,
            @Nullable String s1) {
        try (var t = TraceEvent.scoped("PageContentProviderImpl.query")) {
            ThreadUtils.assertOnBackgroundThread();
            if (!ChromeFeatureList.isEnabled(ChromeFeatureList.PAGE_CONTENT_PROVIDER)) {
                return null;
            }

            synchronized (sLock) {
                PageContentProviderMetrics.recordPageProviderEvent(PageContentProviderEvent.QUERY);
                ensureUriMatcherInitialized();
                final int match = mUriMatcher.match(uri);

                MatrixCursor cursor =
                        new MatrixCursor(
                                new String[] {"_id", "success", "contents", "error_message"});
                switch (match) {
                    case URI_MATCH_INVOCATION_URL -> {}
                    default -> {
                        PageContentProviderMetrics.recordPageProviderEvent(
                                PageContentProviderEvent.QUERY_FAILED_INVALID_URL);
                        setErrorToCursor(cursor, "Invalid URI");
                        return cursor;
                    }
                }

                String id = uri.getLastPathSegment();

                if (id == null
                        || sInvocationState == null
                        || !id.equals(sInvocationState.mInvocationId)) {
                    PageContentProviderMetrics.recordPageProviderEvent(
                            PageContentProviderEvent.QUERY_FAILED_INVALID_ID);
                    setErrorToCursor(cursor, "Invalid ID");
                    return cursor;
                }

                ActivityTabProvider tabProvider = sInvocationState.mActivityTabProvider;
                Pair<String, RenderFrameHost> currentTabUrlAndFrameHost =
                        ThreadUtils.runOnUiThreadBlocking(
                                () -> {
                                    try (var u =
                                            TraceEvent.scoped(
                                                    "PageContentProviderImpl.queryGetVisibleUrl")) {
                                        Tab currentTab = tabProvider.get();

                                        if (currentTab == null
                                                || currentTab.getUrl() == null
                                                || currentTab.getWebContents() == null
                                                || currentTab.getWebContents().getMainFrame()
                                                        == null) {
                                            return null;
                                        }

                                        return Pair.create(
                                                currentTab.getUrl().getSpec(),
                                                currentTab.getWebContents().getMainFrame());
                                    }
                                });

                if (currentTabUrlAndFrameHost == null
                        || !sInvocationState.mInvokedUrl.equals(currentTabUrlAndFrameHost.first)) {
                    if (currentTabUrlAndFrameHost == null) {
                        PageContentProviderMetrics.recordPageProviderEvent(
                                PageContentProviderEvent.QUERY_FAILED_TO_GET_CURRENT_TAB);
                        setErrorToCursor(cursor, "Failed to get current tab");
                    } else {
                        PageContentProviderMetrics.recordPageProviderEvent(
                                PageContentProviderEvent.QUERY_FAILED_CURRENT_TAB_CHANGED);
                        setErrorToCursor(cursor, "Current tab changed before extraction");
                    }
                    return cursor;
                }

                try {
                    recordCreateToExtractionStartLatency();
                    CompletableFuture<Optional<String>> pageContentsFuture =
                            requestPageContentsAsync(currentTabUrlAndFrameHost.second);
                    // Block while getting result, this happens on the binder thread.
                    var result =
                            pageContentsFuture.get(
                                    PAGE_EXTRACTION_TIMEOUT_MS, TimeUnit.MILLISECONDS);
                    if (result.isEmpty()) {
                        PageContentProviderMetrics.recordPageProviderEvent(
                                PageContentProviderEvent.QUERY_FAILED_EMPTY_RESULT);
                        setErrorToCursor(cursor, "Error during extraction");
                        return cursor;
                    }

                    recordExtractionStartToEndLatency();
                    PageContentProviderMetrics.recordPageProviderEvent(
                            PageContentProviderEvent.QUERY_SUCCEEDED_RETURNED_EXTRACTED);
                    setResultToCursor(cursor, sInvocationState.mInvokedUrl, result.get());

                } catch (InterruptedException e) {
                    PageContentProviderMetrics.recordPageProviderEvent(
                            PageContentProviderEvent.QUERY_FAILED_INTERRUPTED);
                    setErrorToCursor(cursor, "Extraction process was interrupted");
                } catch (TimeoutException e) {
                    PageContentProviderMetrics.recordPageProviderEvent(
                            PageContentProviderEvent.QUERY_FAILED_TIMED_OUT);
                    setErrorToCursor(cursor, "Timed out during extraction");
                } catch (ExecutionException e) {
                    PageContentProviderMetrics.recordPageProviderEvent(
                            PageContentProviderEvent.QUERY_FAILED_EXCEPTION);
                    setErrorToCursor(cursor, "ExecutionException during extraction");
                }

                return cursor;
            }
        }
    }

    @Nullable
    @Override
    public String getType(@NonNull Uri uri) {
        return null;
    }

    @Nullable
    @Override
    public Uri insert(@NonNull Uri uri, @Nullable ContentValues contentValues) {
        return null;
    }

    @Override
    public int delete(@NonNull Uri uri, @Nullable String s, @Nullable String[] strings) {
        return 0;
    }

    @Override
    public int update(
            @NonNull Uri uri,
            @Nullable ContentValues contentValues,
            @Nullable String s,
            @Nullable String[] strings) {
        return 0;
    }

    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
    protected static String getContentUriForUrl(
            String url, ActivityTabProvider activityTabProvider) {
        if (!ChromeFeatureList.isEnabled(ChromeFeatureList.PAGE_CONTENT_PROVIDER)) {
            return null;
        }

        synchronized (sLock) {
            if (url == null) return null;

            if (sInvocationState != null && sInvocationState.mInvokedUrl.equals(url)) {
                return buildContentUri(sInvocationState.mInvocationId).toString();
            } else {
                clearCachedContent();

                sInvocationState =
                        new PageContentInvocationState(
                                UUID.randomUUID().toString(), url, activityTabProvider);

                Uri uri = buildContentUri(sInvocationState.mInvocationId);
                grantAccessToUri(uri);

                // Invalidate this ID after 60 seconds.
                String invocationId = sInvocationState.mInvocationId;
                PostTask.postDelayedTask(
                        TaskTraits.UI_DEFAULT,
                        () -> clearCachedContentWithId(invocationId),
                        INVALIDATE_URI_DELAY_MS);

                return uri.toString();
            }
        }
    }

    private void setResultToCursor(
            @NonNull MatrixCursor cursor, String pageUrl, String pageContents) {
        assert cursor.getCount() == 0 : "Only one row should be set";

        cursor.addRow(new Object[] {pageUrl, 1, pageContents, ""});
    }

    private void setErrorToCursor(@NonNull MatrixCursor cursor, String errorMessage) {
        assert cursor.getCount() == 0 : "Only one row should be set";
        cursor.addRow(new Object[] {"", 0, "", errorMessage});
    }

    /**
     * Generates a JSON string to be attached to AssistContent to be shared with an assistant app.
     *
     * @param url The URL of the currently active page, the returned URI will only work for this
     *     URL.
     * @param activityTabProvider Provider used to ensure that {@code url} is still active on all
     *     calls to {@code query()}
     * @param isManagedProfile Whether the current profile has an enterprise owner.
     * @return A JSON string containing a URI to be used with the {@code query()} method to extract
     *     the text of {@code url}.
     */
    @Nullable
    public static String getAssistContentStructuredDataForUrl(
            String url, ActivityTabProvider activityTabProvider, boolean isManagedProfile) {
        String contentUri = getContentUriForUrl(url, activityTabProvider);
        if (contentUri == null) return null;

        String structuredData;

        try {
            structuredData =
                    new JSONObject()
                            .put(
                                    "page_metadata",
                                    new JSONObject()
                                            .put("is_work_profile", isManagedProfile)
                                            .put("content_uri", contentUri))
                            .toString();
        } catch (JSONException e) {
            return null;
        }

        return structuredData;
    }

    private static Uri buildContentUri(String id) {
        Uri uri =
                new Uri.Builder()
                        .scheme(ContentResolver.SCHEME_CONTENT)
                        .authority(
                                ContextUtils.getApplicationContext().getPackageName()
                                        + AUTHORITY_SUFFIX)
                        .path(id)
                        .build();
        return uri;
    }

    private static void grantAccessToUri(Uri uri) {
        var assistantPackageName =
                PackageUtils.getDefaultAssistantPackageName(ContextUtils.getApplicationContext());
        RecordHistogram.recordBooleanHistogram(
                "Android.AssistContent.WebPageContentProvider.GetAssistantPackageResult",
                assistantPackageName != null);
        if (assistantPackageName == null) {
            return;
        }

        ContextUtils.getApplicationContext()
                .grantUriPermission(
                        assistantPackageName, uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
    }

    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
    protected static void clearCachedContent() {
        synchronized (sLock) {
            if (sInvocationState != null) {
                Uri previousUri = buildContentUri(sInvocationState.mInvocationId);
                ContextUtils.getApplicationContext()
                        .revokeUriPermission(previousUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
            }

            sInvocationState = null;
        }
    }

    /**
     * Clears the cached content related to an invocationId, meant to be used with a timer to clear
     * out data related to URIs that are never queried.
     *
     * @param invocationId Invocation ID to clear, used to avoid clearing a newer request
     *     prematurely.
     */
    private static void clearCachedContentWithId(String invocationId) {
        synchronized (sLock) {
            if (sInvocationState == null || !sInvocationState.mInvocationId.equals(invocationId)) {
                return;
            }

            PageContentProviderMetrics.recordPageProviderEvent(PageContentProviderEvent.TIMEOUT);
            clearCachedContent();
        }
    }

    private CompletableFuture<Optional<String>> requestPageContentsAsync(
            RenderFrameHost renderFrameHost) {
        var pageContentFuture = new CompletableFuture<Optional<String>>();

        try (var t = TraceEvent.scoped("PageContentProvider.requestPageContents")) {
            ThreadUtils.runOnUiThread(
                    new Runnable() {
                        @Override
                        public void run() {
                            try (var u =
                                    TraceEvent.scoped(
                                            "PageContentProvider.requestContentsOnUiThread")) {
                                InnerTextBridge.getInnerText(
                                        renderFrameHost,
                                        result -> onPageTextReceived(result, pageContentFuture));
                            }
                        }
                    });
        }
        return pageContentFuture;
    }

    private static void recordCreateToExtractionStartLatency() {
        synchronized (sLock) {
            if (sInvocationState == null) return;

            if (sInvocationState.mInvocationStartTimestampMs != 0) {
                RecordHistogram.recordMediumTimesHistogram(
                        "Android.AssistContent.WebPageContentProvider.Latency.CreateToExtractionStart",
                        TimeUtils.elapsedRealtimeMillis()
                                - sInvocationState.mInvocationStartTimestampMs);
                sInvocationState.mExtractionStartTimestampMs = TimeUtils.elapsedRealtimeMillis();
            }
        }
    }

    private static void recordExtractionStartToEndLatency() {
        synchronized (sLock) {
            if (sInvocationState == null) return;

            if (sInvocationState.mExtractionStartTimestampMs != 0) {
                RecordHistogram.recordMediumTimesHistogram(
                        "Android.AssistContent.WebPageContentProvider.Latency.ExtractionStartToEnd",
                        TimeUtils.elapsedRealtimeMillis()
                                - sInvocationState.mExtractionStartTimestampMs);
                sInvocationState.mExtractionStartTimestampMs = 0;
            }

            if (sInvocationState.mInvocationStartTimestampMs != 0) {
                RecordHistogram.recordMediumTimesHistogram(
                        "Android.AssistContent.WebPageContentProvider.Latency.TotalLatency",
                        TimeUtils.elapsedRealtimeMillis()
                                - sInvocationState.mInvocationStartTimestampMs);
                sInvocationState.mInvocationStartTimestampMs = 0;
            }
        }
    }

    private void onPageTextReceived(
            Optional<String> pageText, CompletableFuture<Optional<String>> pageContentsFuture) {
        try (var u = TraceEvent.scoped("PageContentProvider.onPageTextReceived")) {
            pageContentsFuture.complete(pageText);
        }
    }
}
