{{+bindTo:partials.standard_nacl_api}}
<h1>pp::FileIO Class Reference</h1>
<div id="doxygen-ref">
{{- dummy div to appease doxygen -}}
  <div>
<!-- Generated by Doxygen 1.7.6.1 -->



</div>
<!--header-->
<div class="contents">
<!-- doxytag: class="pp::FileIO" --><!-- doxytag: inherits="pp::Resource" --><div class="dynheader">
Inheritance diagram for pp::FileIO:</div>
<div class="dyncontent">
<div class="center"><img src="classpp_1_1_file_i_o__inherit__graph.png" border="0" usemap="#pp_1_1_file_i_o_inherit__map" alt="Inheritance graph" /></div>
<map name="pp_1_1_file_i_o_inherit__map" id="pp_1_1_file_i_o_inherit__map">
<area shape="rect" id="node2" href="classpp_1_1_resource.html" title="A reference counted module resource." alt="" coords="5,5,109,32"></area></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<p><a href="classpp_1_1_file_i_o-members.html">List of all members.</a></p>
<h2>
Classes</h2><table class="memberdecls">

<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>CallbackData1_0</b></td></tr>
</table><h2>
Public Member Functions</h2><table class="memberdecls">
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_file_i_o.html#a67b9da7adaadcb58c7429aa1984f757e">FileIO</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_file_i_o.html#a7c3f17d75a139e92b2cdc52d8f2f5fd0">FileIO</a> (const <a class="el" href="classpp_1_1_instance_handle.html">InstanceHandle</a> &amp;instance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_file_i_o.html#a7bc6f391da690a381874111e350692f0">FileIO</a> (const <a class="el" href="classpp_1_1_file_i_o.html">FileIO</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_file_i_o.html#adafce7733e27fc3bf12cdb7833927bae">Open</a> (const <a class="el" href="classpp_1_1_file_ref.html">FileRef</a> &amp;file_ref, int32_t open_flags, const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_file_i_o.html#a0e1cb3e0e2f1cd73c0d5a08a20e60fab">Query</a> (PP_FileInfo *result_buf, const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_file_i_o.html#a30766070559c1b719784ebc4f8d369f4">Touch</a> (PP_Time last_access_time, PP_Time last_modified_time, const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_file_i_o.html#a9e4576a9a5c946b4aa971daca526e457">Read</a> (int64_t offset, char *buffer, int32_t bytes_to_read, const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_file_i_o.html#a809ad6c8aa27f647c044c7053a84867a">Read</a> (int32_t offset, int32_t max_read_length, const <a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a>&lt; std::vector&lt; char &gt; &gt; &amp;cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_file_i_o.html#a9ef23f569178ce6a53536fb27d459bcf">Write</a> (int64_t offset, const char *buffer, int32_t bytes_to_write, const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_file_i_o.html#a49014400d013c27b9950368f54974935">SetLength</a> (int64_t length, const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_file_i_o.html#a074d9c13b5825b378c343e5dd890d789">Flush</a> (const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_file_i_o.html#a5f08c15cc2b23548b2e401c55102d709">Close</a> ()</td></tr>
</table>
<hr /><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The <code><a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a></code> class represents a regular file. </p>
</div><hr /><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a67b9da7adaadcb58c7429aa1984f757e"></a><!-- doxytag: member="pp::FileIO::FileIO" ref="a67b9da7adaadcb58c7429aa1984f757e" args="()" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_file_i_o.html#a67b9da7adaadcb58c7429aa1984f757e">pp::FileIO::FileIO</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Default constructor for creating an <a class="el" href="classpp_1_1_resource.html#a859068e34cdc2dc0b78754c255323aa9" title="This functions determines if this resource is invalid or uninitialized.">is_null()</a> <code><a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a></code> object. </p>
</div>
</div>
<a class="anchor" id="a7c3f17d75a139e92b2cdc52d8f2f5fd0"></a><!-- doxytag: member="pp::FileIO::FileIO" ref="a7c3f17d75a139e92b2cdc52d8f2f5fd0" args="(const InstanceHandle &amp;instance)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_file_i_o.html#a67b9da7adaadcb58c7429aa1984f757e">pp::FileIO::FileIO</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_instance_handle.html">InstanceHandle</a> &amp;&#160;</td>
<td class="paramname"><em>instance</em></td><td>)</td>
<td><code> [explicit]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>A constructor used to create a <code><a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a></code> and associate it with the provided <code><a class="el" href="classpp_1_1_instance.html">Instance</a></code>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>The instance with which this resource will be associated. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a7bc6f391da690a381874111e350692f0"></a><!-- doxytag: member="pp::FileIO::FileIO" ref="a7bc6f391da690a381874111e350692f0" args="(const FileIO &amp;other)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_file_i_o.html#a67b9da7adaadcb58c7429aa1984f757e">pp::FileIO::FileIO</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_file_i_o.html">FileIO</a> &amp;&#160;</td>
<td class="paramname"><em>other</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>The copy constructor for <code><a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a></code>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>A reference to a <code><a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a></code>. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<hr /><h2>Member Function Documentation</h2>
<a class="anchor" id="a5f08c15cc2b23548b2e401c55102d709"></a><!-- doxytag: member="pp::FileIO::Close" ref="a5f08c15cc2b23548b2e401c55102d709" args="()" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void <a class="el" href="classpp_1_1_file_i_o.html#a5f08c15cc2b23548b2e401c55102d709">pp::FileIO::Close</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_file_i_o.html#a5f08c15cc2b23548b2e401c55102d709" title="Close() cancels any IO that may be pending, and closes the FileIO object.">Close()</a> cancels any IO that may be pending, and closes the <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a> object. </p>
<p>Any pending callbacks will still run, reporting <code>PP_ERROR_ABORTED</code> if pending IO was interrupted. It is not valid to call <a class="el" href="classpp_1_1_file_i_o.html#adafce7733e27fc3bf12cdb7833927bae" title="Open() opens the specified regular file for I/O according to the given open flags, which is a bit-mask of the PP_FileOpenFlags values.">Open()</a> again after a call to this method.</p>
<p><b>Note:</b> If the <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a> object is destroyed, and it is still open, then it will be implicitly closed, so you are not required to call <a class="el" href="classpp_1_1_file_i_o.html#a5f08c15cc2b23548b2e401c55102d709" title="Close() cancels any IO that may be pending, and closes the FileIO object.">Close()</a>. </p>
</div>
</div>
<a class="anchor" id="a074d9c13b5825b378c343e5dd890d789"></a><!-- doxytag: member="pp::FileIO::Flush" ref="a074d9c13b5825b378c343e5dd890d789" args="(const CompletionCallback &amp;cc)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_file_i_o.html#a074d9c13b5825b378c343e5dd890d789">pp::FileIO::Flush</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;&#160;</td>
<td class="paramname"><em>cc</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_file_i_o.html#a074d9c13b5825b378c343e5dd890d789" title="Flush() flushes changes to disk.">Flush()</a> flushes changes to disk. </p>
<p>This call can be very expensive!</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> to be called upon completion of <a class="el" href="classpp_1_1_file_i_o.html#a074d9c13b5825b378c343e5dd890d789" title="Flush() flushes changes to disk.">Flush()</a>.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing an error code from <code>pp_errors.h</code>. </dd></dl>
</div>
</div>
<a class="anchor" id="adafce7733e27fc3bf12cdb7833927bae"></a><!-- doxytag: member="pp::FileIO::Open" ref="adafce7733e27fc3bf12cdb7833927bae" args="(const FileRef &amp;file_ref, int32_t open_flags, const CompletionCallback &amp;cc)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_file_i_o.html#adafce7733e27fc3bf12cdb7833927bae">pp::FileIO::Open</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_file_ref.html">FileRef</a> &amp;&#160;</td>
<td class="paramname"><em>file_ref</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>open_flags</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;&#160;</td>
<td class="paramname"><em>cc</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_file_i_o.html#adafce7733e27fc3bf12cdb7833927bae" title="Open() opens the specified regular file for I/O according to the given open flags, which is a bit-mask of the PP_FileOpenFlags values.">Open()</a> opens the specified regular file for I/O according to the given open flags, which is a bit-mask of the PP_FileOpenFlags values. </p>
<p>Upon success, the corresponding file is classified as "in use" by this <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a> object until such time as the <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a> object is closed or destroyed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">file_ref</td><td>A <code>PP_Resource</code> corresponding to a file reference.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">open_flags</td><td>A bit-mask of the <code>PP_FileOpenFlags</code> values. Valid values are:<ul>
<li>PP_FILEOPENFLAG_READ</li>
<li>PP_FILEOPENFLAG_WRITE</li>
<li>PP_FILEOPENFLAG_CREATE</li>
<li>PP_FILEOPENFLAG_TRUNCATE</li>
<li>PP_FILEOPENFLAG_EXCLUSIVE See <code>PP_FileOpenFlags</code> in <code>ppb_file_io.h</code> for more details on these flags.</li>
</ul>
</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> to be called upon completion of <a class="el" href="classpp_1_1_file_i_o.html#adafce7733e27fc3bf12cdb7833927bae" title="Open() opens the specified regular file for I/O according to the given open flags, which is a bit-mask of the PP_FileOpenFlags values.">Open()</a>.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing an error code from <code>pp_errors.h</code>. </dd></dl>
</div>
</div>
<a class="anchor" id="a0e1cb3e0e2f1cd73c0d5a08a20e60fab"></a><!-- doxytag: member="pp::FileIO::Query" ref="a0e1cb3e0e2f1cd73c0d5a08a20e60fab" args="(PP_FileInfo *result_buf, const CompletionCallback &amp;cc)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_file_i_o.html#a0e1cb3e0e2f1cd73c0d5a08a20e60fab">pp::FileIO::Query</a> </td>
<td>(</td>
<td class="paramtype">PP_FileInfo *&#160;</td>
<td class="paramname"><em>result_buf</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;&#160;</td>
<td class="paramname"><em>cc</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_file_i_o.html#a0e1cb3e0e2f1cd73c0d5a08a20e60fab" title="Query() queries info about the file opened by this FileIO object.">Query()</a> queries info about the file opened by this <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a> object. </p>
<p>This function will fail if the <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a> object has not been opened.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">result_buf</td><td>The <code>PP_FileInfo</code> structure representing all information about the file. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> to be called upon completion of <a class="el" href="classpp_1_1_file_i_o.html#a0e1cb3e0e2f1cd73c0d5a08a20e60fab" title="Query() queries info about the file opened by this FileIO object.">Query()</a>. <code>result_buf</code> must remain valid until after the callback runs. If you pass a blocking callback, <code>result_buf</code> must remain valid until after <a class="el" href="classpp_1_1_file_i_o.html#a0e1cb3e0e2f1cd73c0d5a08a20e60fab" title="Query() queries info about the file opened by this FileIO object.">Query()</a> returns.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing an error code from <code>pp_errors.h</code>. </dd></dl>
</div>
</div>
<a class="anchor" id="a9e4576a9a5c946b4aa971daca526e457"></a><!-- doxytag: member="pp::FileIO::Read" ref="a9e4576a9a5c946b4aa971daca526e457" args="(int64_t offset, char *buffer, int32_t bytes_to_read, const CompletionCallback &amp;cc)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_file_i_o.html#a9e4576a9a5c946b4aa971daca526e457">pp::FileIO::Read</a> </td>
<td>(</td>
<td class="paramtype">int64_t&#160;</td>
<td class="paramname"><em>offset</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">char *&#160;</td>
<td class="paramname"><em>buffer</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>bytes_to_read</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;&#160;</td>
<td class="paramname"><em>cc</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Reads from an offset in the file. </p>
<p>The size of the buffer must be large enough to hold the specified number of bytes to read. This function might perform a partial read, meaning that all the requested bytes might not be returned, even if the end of the file has not been reached.</p>
<p>This function reads into a buffer that the caller supplies. This buffer must remain valid as long as the <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a> resource is alive. If you use a completion callback factory and it goes out of scope, it will not issue the callback on your class, BUT the callback factory can NOT cancel the request from the browser's perspective. This means that the browser will still try to write to your buffer even if the callback factory is destroyed!</p>
<p>So you must ensure that your buffer outlives the <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a> resource. If you have one class and use the <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a> resource exclusively from that class and never make any copies, this will be fine: the resource will be destroyed when your class is. But keep in mind that copying a <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">pp::FileIO</a> object just creates a second reference to the original resource. For example, if you have a function like this: <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">pp::FileIO</a> MyClass::GetFileIO(); where a copy of your <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a> resource could outlive your class, the callback will still be pending when your class goes out of scope, creating the possibility of writing into invalid memory. So it's recommended to keep your <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a> resource and any output buffers tightly controlled in the same scope.</p>
<p><b>Caveat:</b> This <a class="el" href="classpp_1_1_file_i_o.html#a9e4576a9a5c946b4aa971daca526e457" title="Reads from an offset in the file.">Read()</a> is potentially unsafe if you're using a <a class="el" href="classpp_1_1_completion_callback_factory.html" title="CompletionCallbackFactory&lt;T&gt; may be used to create CompletionCallback objects that are bound to membe...">CompletionCallbackFactory</a> to scope callbacks to the lifetime of your class. When your class goes out of scope, the callback factory will not actually cancel the callback, but will rather just skip issuing the callback on your class. This means that if the <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a> object outlives your class (if you made a copy saved somewhere else, for example), then the browser will still try to write into your buffer when the asynchronous read completes, potentially causing a crash.</p>
<p>See the other version of <a class="el" href="classpp_1_1_file_i_o.html#a9e4576a9a5c946b4aa971daca526e457" title="Reads from an offset in the file.">Read()</a> which avoids this problem by writing into <a class="el" href="classpp_1_1_completion_callback_with_output.html" title="A CompletionCallbackWithOutput defines a completion callback that additionally stores a pointer to so...">CompletionCallbackWithOutput</a>, where the output buffer is automatically managed by the callback.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset into the file. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The buffer to hold the specified number of bytes read. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">bytes_to_read</td><td>The number of bytes to read from <code>offset</code>. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> to be called upon completion of <a class="el" href="classpp_1_1_file_i_o.html#a9e4576a9a5c946b4aa971daca526e457" title="Reads from an offset in the file.">Read()</a>. <code>buffer</code> must remain valid until after the callback runs. If you pass a blocking callback, <code>buffer</code> must remain valid until after <a class="el" href="classpp_1_1_file_i_o.html#a9e4576a9a5c946b4aa971daca526e457" title="Reads from an offset in the file.">Read()</a> returns.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An The number of bytes read an error code from <code>pp_errors.h</code>. If the return value is 0, then end-of-file was reached. It is valid to call <a class="el" href="classpp_1_1_file_i_o.html#a9e4576a9a5c946b4aa971daca526e457" title="Reads from an offset in the file.">Read()</a> multiple times with a completion callback to queue up parallel reads from the file at different offsets. </dd></dl>
</div>
</div>
<a class="anchor" id="a809ad6c8aa27f647c044c7053a84867a"></a><!-- doxytag: member="pp::FileIO::Read" ref="a809ad6c8aa27f647c044c7053a84867a" args="(int32_t offset, int32_t max_read_length, const CompletionCallbackWithOutput&lt; std::vector&lt; char &gt; &gt; &amp;cc)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_file_i_o.html#a9e4576a9a5c946b4aa971daca526e457">pp::FileIO::Read</a> </td>
<td>(</td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>offset</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>max_read_length</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a>&lt; std::vector&lt; char &gt; &gt; &amp;&#160;</td>
<td class="paramname"><em>cc</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_file_i_o.html#a9e4576a9a5c946b4aa971daca526e457" title="Reads from an offset in the file.">Read()</a> reads from an offset in the file. </p>
<p>A PP_ArrayOutput must be provided so that output will be stored in its allocated buffer. This function might perform a partial read.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">file_io</td><td>A <code>PP_Resource</code> corresponding to a file <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a>. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset into the file. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">max_read_length</td><td>The maximum number of bytes to read from <code>offset</code>. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>A <code>PP_ArrayOutput</code> to hold the output data. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A <code>PP_CompletionCallback</code> to be called upon completion of <a class="el" href="classpp_1_1_file_i_o.html#a9e4576a9a5c946b4aa971daca526e457" title="Reads from an offset in the file.">Read()</a>.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes read or an error code from <code>pp_errors.h</code>. If the return value is 0, then end-of-file was reached. It is valid to call <a class="el" href="classpp_1_1_file_i_o.html#a9e4576a9a5c946b4aa971daca526e457" title="Reads from an offset in the file.">Read()</a> multiple times with a completion callback to queue up parallel reads from the file, but pending reads cannot be interleaved with other operations. </dd></dl>
</div>
</div>
<a class="anchor" id="a49014400d013c27b9950368f54974935"></a><!-- doxytag: member="pp::FileIO::SetLength" ref="a49014400d013c27b9950368f54974935" args="(int64_t length, const CompletionCallback &amp;cc)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_file_i_o.html#a49014400d013c27b9950368f54974935">pp::FileIO::SetLength</a> </td>
<td>(</td>
<td class="paramtype">int64_t&#160;</td>
<td class="paramname"><em>length</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;&#160;</td>
<td class="paramname"><em>cc</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_file_i_o.html#a49014400d013c27b9950368f54974935" title="SetLength() sets the length of the file.">SetLength()</a> sets the length of the file. </p>
<p>If the file size is extended, then the extended area of the file is zero-filled. The <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a> object must have been opened with write access.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the file to be set. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> to be called upon completion of <a class="el" href="classpp_1_1_file_i_o.html#a49014400d013c27b9950368f54974935" title="SetLength() sets the length of the file.">SetLength()</a>.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing an error code from <code>pp_errors.h</code>. </dd></dl>
</div>
</div>
<a class="anchor" id="a30766070559c1b719784ebc4f8d369f4"></a><!-- doxytag: member="pp::FileIO::Touch" ref="a30766070559c1b719784ebc4f8d369f4" args="(PP_Time last_access_time, PP_Time last_modified_time, const CompletionCallback &amp;cc)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_file_i_o.html#a30766070559c1b719784ebc4f8d369f4">pp::FileIO::Touch</a> </td>
<td>(</td>
<td class="paramtype">PP_Time&#160;</td>
<td class="paramname"><em>last_access_time</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">PP_Time&#160;</td>
<td class="paramname"><em>last_modified_time</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;&#160;</td>
<td class="paramname"><em>cc</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_file_i_o.html#a30766070559c1b719784ebc4f8d369f4" title="Touch() Updates time stamps for the file opened by this FileIO object.">Touch()</a> Updates time stamps for the file opened by this <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a> object. </p>
<p>This function will fail if the <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a> object has not been opened.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">last_access_time</td><td>The last time the <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a> was accessed. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">last_modified_time</td><td>The last time the <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a> was modified. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> to be called upon completion of <a class="el" href="classpp_1_1_file_i_o.html#a30766070559c1b719784ebc4f8d369f4" title="Touch() Updates time stamps for the file opened by this FileIO object.">Touch()</a>.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing an error code from <code>pp_errors.h</code>. </dd></dl>
</div>
</div>
<a class="anchor" id="a9ef23f569178ce6a53536fb27d459bcf"></a><!-- doxytag: member="pp::FileIO::Write" ref="a9ef23f569178ce6a53536fb27d459bcf" args="(int64_t offset, const char *buffer, int32_t bytes_to_write, const CompletionCallback &amp;cc)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_file_i_o.html#a9ef23f569178ce6a53536fb27d459bcf">pp::FileIO::Write</a> </td>
<td>(</td>
<td class="paramtype">int64_t&#160;</td>
<td class="paramname"><em>offset</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *&#160;</td>
<td class="paramname"><em>buffer</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>bytes_to_write</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;&#160;</td>
<td class="paramname"><em>cc</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_file_i_o.html#a9ef23f569178ce6a53536fb27d459bcf" title="Write() writes to an offset in the file.">Write()</a> writes to an offset in the file. </p>
<p>This function might perform a partial write. The <a class="el" href="classpp_1_1_file_i_o.html" title="The FileIO class represents a regular file.">FileIO</a> object must have been opened with write access.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset into the file. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The buffer to hold the specified number of bytes read. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">bytes_to_write</td><td>The number of bytes to write to <code>offset</code>. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> to be called upon completion of <a class="el" href="classpp_1_1_file_i_o.html#a9ef23f569178ce6a53536fb27d459bcf" title="Write() writes to an offset in the file.">Write()</a>.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An The number of bytes written or an error code from <code>pp_errors.h</code>. If the return value is 0, then end-of-file was reached. It is valid to call <a class="el" href="classpp_1_1_file_i_o.html#a9ef23f569178ce6a53536fb27d459bcf" title="Write() writes to an offset in the file.">Write()</a> multiple times with a completion callback to queue up parallel writes to the file at different offsets. </dd></dl>
</div>
</div>
<hr />The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="file__io_8h.html">file_io.h</a></li>
</ul>
</div><!-- contents -->
</div>
{{/partials.standard_nacl_api}}
