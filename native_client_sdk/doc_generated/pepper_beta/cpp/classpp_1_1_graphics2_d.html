{{+bindTo:partials.standard_nacl_api}}
<h1>pp::Graphics2D Class Reference</h1>
<div id="doxygen-ref">
{{- dummy div to appease doxygen -}}
  <div>
<!-- Generated by Doxygen 1.7.6.1 -->



</div>
<!--header-->
<div class="contents">
<!-- doxytag: class="pp::Graphics2D" --><!-- doxytag: inherits="pp::Resource" --><div class="dynheader">
Inheritance diagram for pp::Graphics2D:</div>
<div class="dyncontent">
<div class="center"><img src="classpp_1_1_graphics2_d__inherit__graph.png" border="0" usemap="#pp_1_1_graphics2_d_inherit__map" alt="Inheritance graph" /></div>
<map name="pp_1_1_graphics2_d_inherit__map" id="pp_1_1_graphics2_d_inherit__map">
<area shape="rect" id="node2" href="classpp_1_1_resource.html" title="A reference counted module resource." alt="" coords="13,5,117,32"></area></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<p><a href="classpp_1_1_graphics2_d-members.html">List of all members.</a></p>
<h2>
Public Member Functions</h2><table class="memberdecls">

<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_graphics2_d.html#aef2cf8f0798d4980309f9bc888a73463">Graphics2D</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_graphics2_d.html#a144e483e91d77dd7314698a87d57c7ca">Graphics2D</a> (const <a class="el" href="classpp_1_1_graphics2_d.html">Graphics2D</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_graphics2_d.html#a193584685783cfcf3ab4bd01a5ca6e14">Graphics2D</a> (const <a class="el" href="classpp_1_1_instance_handle.html">InstanceHandle</a> &amp;instance, const <a class="el" href="classpp_1_1_size.html">Size</a> &amp;<a class="el" href="classpp_1_1_graphics2_d.html#ad623f80db2c0cc679619303a0c0b9eff">size</a>, bool is_always_opaque)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_graphics2_d.html#aa40a889094d345add38f16d559ae0ebd">~Graphics2D</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpp_1_1_graphics2_d.html">Graphics2D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_graphics2_d.html#ad19b4539e1c1fdacc6ff41383b6cd3ba">operator=</a> (const <a class="el" href="classpp_1_1_graphics2_d.html">Graphics2D</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpp_1_1_size.html">Size</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_graphics2_d.html#ad623f80db2c0cc679619303a0c0b9eff">size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_graphics2_d.html#ab61e3018d1f5c4301f71ad0001d3ad8e">PaintImageData</a> (const <a class="el" href="classpp_1_1_image_data.html">ImageData</a> &amp;image, const <a class="el" href="classpp_1_1_point.html">Point</a> &amp;top_left)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_graphics2_d.html#af779f51bfb0c4064535ea91b2470ddc7">PaintImageData</a> (const <a class="el" href="classpp_1_1_image_data.html">ImageData</a> &amp;image, const <a class="el" href="classpp_1_1_point.html">Point</a> &amp;top_left, const <a class="el" href="classpp_1_1_rect.html">Rect</a> &amp;src_rect)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_graphics2_d.html#a6a4256bb84cab71909821699d7aea369">Scroll</a> (const <a class="el" href="classpp_1_1_rect.html">Rect</a> &amp;clip, const <a class="el" href="classpp_1_1_point.html">Point</a> &amp;amount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_graphics2_d.html#a73185e278ea87d33cfec2f00a56314d9">ReplaceContents</a> (<a class="el" href="classpp_1_1_image_data.html">ImageData</a> *image)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_graphics2_d.html#a3c1e23ad48ad62860a125d471b7664a4">Flush</a> (const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_graphics2_d.html#a96a91958227a7e42a829033241fac6b1">SetScale</a> (float scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_graphics2_d.html#a5b927eaabdd78b1a0094aa1a3695bae2">GetScale</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_graphics2_d.html#a3babd6bb9c922a650b3c7c57d1e36d8c">SetLayerTransform</a> (float scale, const <a class="el" href="classpp_1_1_point.html">Point</a> &amp;origin, const <a class="el" href="classpp_1_1_point.html">Point</a> &amp;translate)</td></tr>
</table>
<hr /><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aef2cf8f0798d4980309f9bc888a73463"></a><!-- doxytag: member="pp::Graphics2D::Graphics2D" ref="aef2cf8f0798d4980309f9bc888a73463" args="()" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_graphics2_d.html#aef2cf8f0798d4980309f9bc888a73463">pp::Graphics2D::Graphics2D</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Default constructor for creating an <a class="el" href="classpp_1_1_resource.html#a859068e34cdc2dc0b78754c255323aa9" title="This functions determines if this resource is invalid or uninitialized.">is_null()</a> <code><a class="el" href="classpp_1_1_graphics2_d.html">Graphics2D</a></code> object. </p>
</div>
</div>
<a class="anchor" id="a144e483e91d77dd7314698a87d57c7ca"></a><!-- doxytag: member="pp::Graphics2D::Graphics2D" ref="a144e483e91d77dd7314698a87d57c7ca" args="(const Graphics2D &amp;other)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_graphics2_d.html#aef2cf8f0798d4980309f9bc888a73463">pp::Graphics2D::Graphics2D</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_graphics2_d.html">Graphics2D</a> &amp;&#160;</td>
<td class="paramname"><em>other</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>The copy constructor for <a class="el" href="classpp_1_1_graphics2_d.html">Graphics2D</a>. </p>
<p>The underlying 2D context is not copied; this constructor creates another reference to the original 2D context.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>A pointer to a <code><a class="el" href="classpp_1_1_graphics2_d.html">Graphics2D</a></code> context. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a193584685783cfcf3ab4bd01a5ca6e14"></a><!-- doxytag: member="pp::Graphics2D::Graphics2D" ref="a193584685783cfcf3ab4bd01a5ca6e14" args="(const InstanceHandle &amp;instance, const Size &amp;size, bool is_always_opaque)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_graphics2_d.html#aef2cf8f0798d4980309f9bc888a73463">pp::Graphics2D::Graphics2D</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_instance_handle.html">InstanceHandle</a> &amp;&#160;</td>
<td class="paramname"><em>instance</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_size.html">Size</a> &amp;&#160;</td>
<td class="paramname"><em>size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&#160;</td>
<td class="paramname"><em>is_always_opaque</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>A constructor allocating a new 2D graphics context with the given size in the browser, resulting object will be <a class="el" href="classpp_1_1_resource.html#a859068e34cdc2dc0b78754c255323aa9" title="This functions determines if this resource is invalid or uninitialized.">is_null()</a> if the allocation failed. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>The instance with which this resource will be associated.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the 2D graphics context in the browser, measured in pixels. See <code><a class="el" href="classpp_1_1_graphics2_d.html#a96a91958227a7e42a829033241fac6b1" title="SetScale() sets the scale factor that will be applied when painting the graphics context onto the out...">SetScale()</a></code> for more information.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">is_always_opaque</td><td>Set the <code>is_always_opaque</code> flag to true if you know that you will be painting only opaque data to this context. This option will disable blending when compositing the module with the web page, which might give higher performance on some computers.</td></tr>
</table>
</dd>
</dl>
<p>If you set <code>is_always_opaque</code>, your alpha channel should always be set to 0xFF or there may be painting artifacts. The alpha values overwrite the destination alpha values without blending when <code>is_always_opaque</code> is true. </p>
</div>
</div>
<a class="anchor" id="aa40a889094d345add38f16d559ae0ebd"></a><!-- doxytag: member="pp::Graphics2D::~Graphics2D" ref="aa40a889094d345add38f16d559ae0ebd" args="()" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">virtual <a class="el" href="classpp_1_1_graphics2_d.html#aa40a889094d345add38f16d559ae0ebd">pp::Graphics2D::~Graphics2D</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td><code> [virtual]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>A destructor that decrements the reference count of a <code><a class="el" href="classpp_1_1_graphics2_d.html">Graphics2D</a></code> object made using the previous copy constructor. </p>
<p>It is possible that the destructor does not totally destroy the underlying 2D context if there are outstanding references to it. </p>
</div>
</div>
<hr /><h2>Member Function Documentation</h2>
<a class="anchor" id="a3c1e23ad48ad62860a125d471b7664a4"></a><!-- doxytag: member="pp::Graphics2D::Flush" ref="a3c1e23ad48ad62860a125d471b7664a4" args="(const CompletionCallback &amp;cc)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_graphics2_d.html#a3c1e23ad48ad62860a125d471b7664a4">pp::Graphics2D::Flush</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;&#160;</td>
<td class="paramname"><em>cc</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_graphics2_d.html#a3c1e23ad48ad62860a125d471b7664a4" title="Flush() flushes any enqueued paint, scroll, and replace commands to the backing store.">Flush()</a> flushes any enqueued paint, scroll, and replace commands to the backing store. </p>
<p>This actually executes the updates, and causes a repaint of the webpage, assuming this graphics context is bound to a module instance.</p>
<p><a class="el" href="classpp_1_1_graphics2_d.html#a3c1e23ad48ad62860a125d471b7664a4" title="Flush() flushes any enqueued paint, scroll, and replace commands to the backing store.">Flush()</a> runs in asynchronous mode. Specify a callback function and the argument for that callback function. The callback function will be executed on the calling thread when the image has been painted to the screen. While you are waiting for a <code>Flush</code> callback, additional calls to <a class="el" href="classpp_1_1_graphics2_d.html#a3c1e23ad48ad62860a125d471b7664a4" title="Flush() flushes any enqueued paint, scroll, and replace commands to the backing store.">Flush()</a> will fail.</p>
<p>Because the callback is executed (or thread unblocked) only when the module's image is actually on the screen, this function provides a way to rate limit animations. By waiting until the image is on the screen before painting the next frame, you can ensure you're not flushing 2D graphics faster than the screen can be updated.</p>
<p><b>Unbound contexts</b> If the context is not bound to a module instance, you will still get a callback. The callback will execute after <a class="el" href="classpp_1_1_graphics2_d.html#a3c1e23ad48ad62860a125d471b7664a4" title="Flush() flushes any enqueued paint, scroll, and replace commands to the backing store.">Flush()</a> returns to avoid reentrancy. The callback will not wait until anything is painted to the screen because there will be nothing on the screen. The timing of this callback is not guaranteed and may be deprioritized by the browser because it is not affecting the user experience.</p>
<p><b>Off-screen instances</b> If the context is bound to an instance that is currently not visible (for example, scrolled out of view) it will behave like the "unbound context" case.</p>
<p><b>Detaching a context</b> If you detach a context from a module instance, any pending flush callbacks will be converted into the "unbound context" case.</p>
<p><b>Released contexts</b> A callback may or may not still get called even if you have released all of your references to the context. This can occur if there are internal references to the context that means it has not been internally destroyed (for example, if it is still bound to an instance) or due to other implementation details. As a result, you should be careful to check that flush callbacks are for the context you expect and that you're capable of handling callbacks for context that you may have released your reference to.</p>
<p><b>Shutdown</b> If a module instance is removed when a Flush is pending, the callback will not be executed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> to be called when the image has been painted on the screen.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>PP_OK</code> on success or <code>PP_ERROR_BADRESOURCE</code> if the graphics context is invalid, <code>PP_ERROR_BADARGUMENT</code> if the callback is null and flush is being called from the main thread of the module, or <code>PP_ERROR_INPROGRESS</code> if a flush is already pending that has not issued its callback yet. In the failure case, nothing will be updated and no callback will be scheduled. </dd></dl>
</div>
</div>
<a class="anchor" id="a5b927eaabdd78b1a0094aa1a3695bae2"></a><!-- doxytag: member="pp::Graphics2D::GetScale" ref="a5b927eaabdd78b1a0094aa1a3695bae2" args="()" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">float <a class="el" href="classpp_1_1_graphics2_d.html#a5b927eaabdd78b1a0094aa1a3695bae2">pp::Graphics2D::GetScale</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_graphics2_d.html#a5b927eaabdd78b1a0094aa1a3695bae2" title="GetScale() gets the scale factor that will be applied when painting the graphics context onto the out...">GetScale()</a> gets the scale factor that will be applied when painting the graphics context onto the output device. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the scale factor for the graphics context. If the resource is invalid, 0.0 will be returned. The default scale for a graphics context is 1.0. </dd></dl>
</div>
</div>
<a class="anchor" id="ad19b4539e1c1fdacc6ff41383b6cd3ba"></a><!-- doxytag: member="pp::Graphics2D::operator=" ref="ad19b4539e1c1fdacc6ff41383b6cd3ba" args="(const Graphics2D &amp;other)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_graphics2_d.html">Graphics2D</a>&amp; pp::Graphics2D::operator= </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_graphics2_d.html">Graphics2D</a> &amp;&#160;</td>
<td class="paramname"><em>other</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>This function assigns one 2D graphics context to this 2D graphics context. </p>
<p>This function increases the reference count of the 2D resource of the other 2D graphics context while decrementing the reference counter of this 2D graphics context.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>An other 2D graphics context.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new <a class="el" href="classpp_1_1_graphics2_d.html">Graphics2D</a> context. </dd></dl>
</div>
</div>
<a class="anchor" id="ab61e3018d1f5c4301f71ad0001d3ad8e"></a><!-- doxytag: member="pp::Graphics2D::PaintImageData" ref="ab61e3018d1f5c4301f71ad0001d3ad8e" args="(const ImageData &amp;image, const Point &amp;top_left)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void <a class="el" href="classpp_1_1_graphics2_d.html#ab61e3018d1f5c4301f71ad0001d3ad8e">pp::Graphics2D::PaintImageData</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_image_data.html">ImageData</a> &amp;&#160;</td>
<td class="paramname"><em>image</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_point.html">Point</a> &amp;&#160;</td>
<td class="paramname"><em>top_left</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_graphics2_d.html#ab61e3018d1f5c4301f71ad0001d3ad8e" title="PaintImageData() enqueues a paint command of the given image into the context.">PaintImageData()</a> enqueues a paint command of the given image into the context. </p>
<p>This command has no effect until you call <a class="el" href="classpp_1_1_graphics2_d.html#a3c1e23ad48ad62860a125d471b7664a4" title="Flush() flushes any enqueued paint, scroll, and replace commands to the backing store.">Flush()</a>. As a result, what counts is the contents of the bitmap when you call Flush, not when you call this function.</p>
<p>The provided image will be placed at <code>top_left</code> from the top left of the context's internal backing store. This version of PaintImageData paints the entire image. Refer to the other version of this function to paint only part of the area.</p>
<p>The painted area of the source bitmap must fall entirely within the context. Attempting to paint outside of the context will result in an error.</p>
<p>There are two methods most modules will use for painting. The first method is to generate a new <code><a class="el" href="classpp_1_1_image_data.html">ImageData</a></code> and then paint it. In this case, you'll set the location of your painting to <code>top_left</code> and set <code>src_rect</code> to <code>NULL</code>. The second is that you're generating small invalid regions out of a larger bitmap representing your entire module's image.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The <code><a class="el" href="classpp_1_1_image_data.html">ImageData</a></code> to be painted. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">top_left</td><td>A <code><a class="el" href="classpp_1_1_point.html" title="A 2 dimensional point with 0,0 being the upper-left starting coordinate.">Point</a></code> representing the <code>top_left</code> location where the <code><a class="el" href="classpp_1_1_image_data.html">ImageData</a></code> will be painted. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="af779f51bfb0c4064535ea91b2470ddc7"></a><!-- doxytag: member="pp::Graphics2D::PaintImageData" ref="af779f51bfb0c4064535ea91b2470ddc7" args="(const ImageData &amp;image, const Point &amp;top_left, const Rect &amp;src_rect)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void <a class="el" href="classpp_1_1_graphics2_d.html#ab61e3018d1f5c4301f71ad0001d3ad8e">pp::Graphics2D::PaintImageData</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_image_data.html">ImageData</a> &amp;&#160;</td>
<td class="paramname"><em>image</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_point.html">Point</a> &amp;&#160;</td>
<td class="paramname"><em>top_left</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_rect.html">Rect</a> &amp;&#160;</td>
<td class="paramname"><em>src_rect</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_graphics2_d.html#ab61e3018d1f5c4301f71ad0001d3ad8e" title="PaintImageData() enqueues a paint command of the given image into the context.">PaintImageData()</a> enqueues a paint command of the given image into the context. </p>
<p>This command has no effect until you call <a class="el" href="classpp_1_1_graphics2_d.html#a3c1e23ad48ad62860a125d471b7664a4" title="Flush() flushes any enqueued paint, scroll, and replace commands to the backing store.">Flush()</a>. As a result, what counts is the contents of the bitmap when you call <a class="el" href="classpp_1_1_graphics2_d.html#a3c1e23ad48ad62860a125d471b7664a4" title="Flush() flushes any enqueued paint, scroll, and replace commands to the backing store.">Flush()</a>, not when you call this function.</p>
<p>The provided image will be placed at <code>top_left</code> from the top left of the context's internal backing store. Then the pixels contained in <code>src_rect</code> will be copied into the backing store. This means that the rectangle being painted will be at <code>src_rect</code> offset by <code>top_left</code>.</p>
<p>The <code>src_rect</code> is specified in the coordinate system of the image being painted, not the context. For the common case of copying the entire image, you may specify an empty <code>src_rect</code>.</p>
<p>The painted area of the source bitmap must fall entirely within the context. Attempting to paint outside of the context will result in an error. However, the source bitmap may fall outside the context, as long as the <code>src_rect</code> subset of it falls entirely within the context.</p>
<p>There are two methods most modules will use for painting. The first method is to generate a new <code><a class="el" href="classpp_1_1_image_data.html">ImageData</a></code> and then paint it. In this case, you'll set the location of your painting to <code>top_left</code> and set <code>src_rect</code> to <code>NULL</code>. The second is that you're generating small invalid regions out of a larger bitmap representing your entire module. In this case, you would set the location of your image to (0,0) and then set <code>src_rect</code> to the pixels you changed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The <code><a class="el" href="classpp_1_1_image_data.html">ImageData</a></code> to be painted. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">top_left</td><td>A <code><a class="el" href="classpp_1_1_point.html" title="A 2 dimensional point with 0,0 being the upper-left starting coordinate.">Point</a></code> representing the <code>top_left</code> location where the <code><a class="el" href="classpp_1_1_image_data.html">ImageData</a></code> will be painted. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">src_rect</td><td>The rectangular area where the <code><a class="el" href="classpp_1_1_image_data.html">ImageData</a></code> will be painted. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a73185e278ea87d33cfec2f00a56314d9"></a><!-- doxytag: member="pp::Graphics2D::ReplaceContents" ref="a73185e278ea87d33cfec2f00a56314d9" args="(ImageData *image)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void <a class="el" href="classpp_1_1_graphics2_d.html#a73185e278ea87d33cfec2f00a56314d9">pp::Graphics2D::ReplaceContents</a> </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classpp_1_1_image_data.html">ImageData</a> *&#160;</td>
<td class="paramname"><em>image</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_graphics2_d.html#a73185e278ea87d33cfec2f00a56314d9" title="ReplaceContents() provides a slightly more efficient way to paint the entire module's image...">ReplaceContents()</a> provides a slightly more efficient way to paint the entire module's image. </p>
<p>Normally, calling <a class="el" href="classpp_1_1_graphics2_d.html#ab61e3018d1f5c4301f71ad0001d3ad8e" title="PaintImageData() enqueues a paint command of the given image into the context.">PaintImageData()</a> requires that the browser copy the pixels out of the image and into the graphics context's backing store. This function replaces the graphics context's backing store with the given image, avoiding the copy.</p>
<p>The new image must be the exact same size as this graphics context. If the new image uses a different image format than the browser's native bitmap format (use <a class="el" href="classpp_1_1_image_data.html#a4208e7eabf98df7b91c01ed6fcd92425" title="GetNativeImageDataFormat() determines the browser's preferred format for images.">ImageData::GetNativeImageDataFormat()</a> to retrieve the format), then a conversion will be done inside the browser which may slow the performance a little bit.</p>
<p><b>Note:</b> The new image will not be painted until you call <a class="el" href="classpp_1_1_graphics2_d.html#a3c1e23ad48ad62860a125d471b7664a4" title="Flush() flushes any enqueued paint, scroll, and replace commands to the backing store.">Flush()</a>.</p>
<p>After this call, you should take care to release your references to the image. If you paint to the image after <a class="el" href="classpp_1_1_graphics2_d.html#a73185e278ea87d33cfec2f00a56314d9" title="ReplaceContents() provides a slightly more efficient way to paint the entire module's image...">ReplaceContents()</a>, there is the possibility of significant painting artifacts because the page might use partially-rendered data when copying out of the backing store.</p>
<p>In the case of an animation, you will want to allocate a new image for the next frame. It is best if you wait until the flush callback has executed before allocating this bitmap. This gives the browser the option of caching the previous backing store and handing it back to you (assuming the sizes match). In the optimal case, this means no bitmaps are allocated during the animation, and the backing store and "front buffer" (which the module is painting into) are just being swapped back and forth.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The <code><a class="el" href="classpp_1_1_image_data.html">ImageData</a></code> to be painted. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6a4256bb84cab71909821699d7aea369"></a><!-- doxytag: member="pp::Graphics2D::Scroll" ref="a6a4256bb84cab71909821699d7aea369" args="(const Rect &amp;clip, const Point &amp;amount)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void <a class="el" href="classpp_1_1_graphics2_d.html#a6a4256bb84cab71909821699d7aea369">pp::Graphics2D::Scroll</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_rect.html">Rect</a> &amp;&#160;</td>
<td class="paramname"><em>clip</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_point.html">Point</a> &amp;&#160;</td>
<td class="paramname"><em>amount</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_graphics2_d.html#a6a4256bb84cab71909821699d7aea369" title="Scroll() enqueues a scroll of the context's backing store.">Scroll()</a> enqueues a scroll of the context's backing store. </p>
<p>This function has no effect until you call <a class="el" href="classpp_1_1_graphics2_d.html#a3c1e23ad48ad62860a125d471b7664a4" title="Flush() flushes any enqueued paint, scroll, and replace commands to the backing store.">Flush()</a>. The data within the provided clipping rectangle will be shifted by (dx, dy) pixels.</p>
<p>This function will result in some exposed region which will have undefined contents. The module should call <a class="el" href="classpp_1_1_graphics2_d.html#ab61e3018d1f5c4301f71ad0001d3ad8e" title="PaintImageData() enqueues a paint command of the given image into the context.">PaintImageData()</a> on these exposed regions to give the correct contents.</p>
<p>The scroll can be larger than the area of the clipping rectangle, which means the current image will be scrolled out of the rectangle. This scenario is not an error but will result in a no-op.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">clip</td><td>The clipping rectangle. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">amount</td><td>The amount the area in the clipping rectangle will shifted. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a3babd6bb9c922a650b3c7c57d1e36d8c"></a><!-- doxytag: member="pp::Graphics2D::SetLayerTransform" ref="a3babd6bb9c922a650b3c7c57d1e36d8c" args="(float scale, const Point &amp;origin, const Point &amp;translate)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool <a class="el" href="classpp_1_1_graphics2_d.html#a3babd6bb9c922a650b3c7c57d1e36d8c">pp::Graphics2D::SetLayerTransform</a> </td>
<td>(</td>
<td class="paramtype">float&#160;</td>
<td class="paramname"><em>scale</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_point.html">Point</a> &amp;&#160;</td>
<td class="paramname"><em>origin</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_point.html">Point</a> &amp;&#160;</td>
<td class="paramname"><em>translate</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
</div>
</div>
<a class="anchor" id="a96a91958227a7e42a829033241fac6b1"></a><!-- doxytag: member="pp::Graphics2D::SetScale" ref="a96a91958227a7e42a829033241fac6b1" args="(float scale)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool <a class="el" href="classpp_1_1_graphics2_d.html#a96a91958227a7e42a829033241fac6b1">pp::Graphics2D::SetScale</a> </td>
<td>(</td>
<td class="paramtype">float&#160;</td>
<td class="paramname"><em>scale</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_graphics2_d.html#a96a91958227a7e42a829033241fac6b1" title="SetScale() sets the scale factor that will be applied when painting the graphics context onto the out...">SetScale()</a> sets the scale factor that will be applied when painting the graphics context onto the output device. </p>
<p>Typically, if rendering at device resolution is desired, the context would be created with the width and height scaled up by the view's GetDeviceScale and SetScale called with a scale of 1.0 / GetDeviceScale(). For example, if the view resource passed to DidChangeView has a rectangle of (w=200, h=100) and a device scale of 2.0, one would call Create with a size of (w=400, h=200) and then call SetScale with 0.5. One would then treat each pixel in the context as a single device pixel.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>The scale to apply when painting.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>true</code> on success or <code>false</code> if the resource is invalid or the scale factor is 0 or less. </dd></dl>
</div>
</div>
<a class="anchor" id="ad623f80db2c0cc679619303a0c0b9eff"></a><!-- doxytag: member="pp::Graphics2D::size" ref="ad623f80db2c0cc679619303a0c0b9eff" args="() const " -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">const <a class="el" href="classpp_1_1_size.html">Size</a>&amp; <a class="el" href="classpp_1_1_graphics2_d.html#ad623f80db2c0cc679619303a0c0b9eff">pp::Graphics2D::size</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const<code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Getter function for returning size of the 2D graphics context. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The size of the 2D graphics context measured in pixels. </dd></dl>
</div>
</div>
<hr />The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="graphics__2d_8h.html">graphics_2d.h</a></li>
</ul>
</div><!-- contents -->
</div>
{{/partials.standard_nacl_api}}
