<!DOCTYPE html>
<!--
Copyright 2022 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<!--
These metrics are designed to read off Core Web Vitals metrics (and their
important diagnostic metrics like First Contentful Paint) from the trace events
generated by the UkmPageLoadMetricsObserver, doing as little post-processing as
possible. These should therefore automatically stay updated as the definitions
in chromium C++ code evolve. See http://go/cwv-ukm-lab-metrics for more details.
-->

<link rel="import" href="/tracing/base/unit.html">
<link rel="import" href="/tracing/metrics/metric_registry.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/value/diagnostics/alert_groups.html">
<link rel="import" href="/tracing/value/histogram.html">


<script>
'use strict';

tr.exportTo('tr.metrics', function() {
  const CWV_HISTOGRAM_NAMES = {
    FCP_HISTOGRAM_NAME: 'cwv:first_contentful_paint',
    LCP_HISTOGRAM_NAME: 'cwv:largest_contentful_paint',
    CLS_HISTOGRAM_NAME: 'cwv:cumulative_layout_shift',
  };

  function coreWebVitalsMetric(histograms, model) {
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    if (chromeHelper === undefined) return;

    const firstContentfulPaintHistogram =
      histograms.createHistogram(CWV_HISTOGRAM_NAMES.FCP_HISTOGRAM_NAME,
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, [], {
            alertGrouping: [tr.v.d.ALERT_GROUPS.LOADING_PAINT],
        });
    const largestContentfulPaintHistogram =
      histograms.createHistogram(CWV_HISTOGRAM_NAMES.LCP_HISTOGRAM_NAME,
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, [], {
            alertGrouping: [tr.v.d.ALERT_GROUPS.LOADING_PAINT],
        });
    const cumulativeLayoutShiftHistogram =
      histograms.createHistogram(CWV_HISTOGRAM_NAMES.CLS_HISTOGRAM_NAME,
        tr.b.Unit.byName.unitlessNumber_smallerIsBetter, [], {
          alertGrouping: [tr.v.d.ALERT_GROUPS.LOADING_LAYOUT],
        });

    for (const browserHelper of Object.values(chromeHelper.browserHelpers)) {
      const mainThread = browserHelper.mainThread;
      const latestTimingBySourceId = new Map();

      for (const event of mainThread.sliceGroup.childEvents()) {
        if (event.category === 'loading' &&
            event.title === 'UkmPageLoadTimingUpdate') {
          if (browserHelper.modelHelper.isTelemetryInternalEvent(event)) {
            continue;
          }
          const timingUpdate = event.args['ukm_page_load_timing_update'];
          const sourceId = timingUpdate['ukm_source_id'];
          latestTimingBySourceId.set(sourceId, timingUpdate);
        }
      }

      for (const timingUpdate of latestTimingBySourceId.values()) {
        const timingUpdateDiagnostic = {
          'page_load_timing': new tr.v.d.GenericSet([timingUpdate]),
        };

        // Note: This might always be a perfect round number because as of
        // 2022/09/13, FCP values are clamped to 1ms resolution when sent to the
        // browser process to prevent timing attacks.
        const firstContentfulPaint =
            timingUpdate['first_contentful_paint_ms'];

        // Do not add any core web vitals metrics if page did not reach FCP.
        if (firstContentfulPaint === undefined) continue;

        firstContentfulPaintHistogram.addSample(
            firstContentfulPaint, timingUpdateDiagnostic);

        // Note: this could be undefined if somehow the browser determined the
        // LCP data is invalid. They should be exactly the same cases where we
        // also do not report data to UKM.
        largestContentfulPaintHistogram.addSample(
            timingUpdate['latest_largest_contentful_paint_ms'],
            timingUpdateDiagnostic);

        // Note: There is no need to specially handle the case when there are no
        // layout shifts on the page. The latest_cumulative_layout_shift value
        // should be reported as 0 in the trace event by the browser in that
        // case, not undefined. Not that CLS can still be undefined if data
        // is invalidated for some reason, e.g. see
        // https://crsrc.org/c/components/page_load_metrics/browser/layout_shift_normalization.cc;l=25;drc=8d399817282e3c12ed54eb23ec42a5e418298ec6
        cumulativeLayoutShiftHistogram.addSample(
            timingUpdate['latest_cumulative_layout_shift'],
            timingUpdateDiagnostic);
      }
    }
  }

  tr.metrics.MetricRegistry.register(coreWebVitalsMetric);

  return {
    coreWebVitalsMetric,
    CWV_HISTOGRAM_NAMES,
  };
});
</script>
