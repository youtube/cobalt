// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "media/base/media_switches.h"

#include "base/command_line.h"
#include "build/build_config.h"
#include "build/chromeos_buildflags.h"
#include "components/system_media_controls/linux/buildflags/buildflags.h"

#if defined(OS_LINUX)
#include "base/cpu.h"
#endif

#if BUILDFLAG(IS_CHROMEOS_ASH)
#include "ash/constants/ash_features.h"
#endif

namespace switches {

// Allow users to specify a custom buffer size for debugging purpose.
const char kAudioBufferSize[] = "audio-buffer-size";

// Set a timeout (in milliseconds) for the audio service to quit if there are no
// client connections to it. If the value is negative the service never quits.
const char kAudioServiceQuitTimeoutMs[] = "audio-service-quit-timeout-ms";

// Command line flag name to set the autoplay policy.
const char kAutoplayPolicy[] = "autoplay-policy";

const char kDisableAudioOutput[] = "disable-audio-output";

// Causes the AudioManager to fail creating audio streams. Used when testing
// various failure cases.
const char kFailAudioStreamCreation[] = "fail-audio-stream-creation";

// Set number of threads to use for video decoding.
const char kVideoThreads[] = "video-threads";

// Do not immediately suspend media in background tabs.
const char kDisableBackgroundMediaSuspend[] =
    "disable-background-media-suspend";

// Force to report VP9 as an unsupported MIME type.
const char kReportVp9AsAnUnsupportedMimeType[] =
    "report-vp9-as-an-unsupported-mime-type";

#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FREEBSD) || \
    defined(OS_SOLARIS)
// The Alsa device to use when opening an audio input stream.
const char kAlsaInputDevice[] = "alsa-input-device";
// The Alsa device to use when opening an audio stream.
const char kAlsaOutputDevice[] = "alsa-output-device";
#endif  // defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_FREEBSD) ||
        // defined(OS_SOLARIS)

#if defined(OS_WIN)
// Use exclusive mode audio streaming for Windows Vista and higher.
// Leads to lower latencies for audio streams which uses the
// AudioParameters::AUDIO_PCM_LOW_LATENCY audio path.
// See http://msdn.microsoft.com/en-us/library/windows/desktop/dd370844.aspx
// for details.
const char kEnableExclusiveAudio[] = "enable-exclusive-audio";

// Use Windows WaveOut/In audio API even if Core Audio is supported.
const char kForceWaveAudio[] = "force-wave-audio";

// Instead of always using the hardware channel layout, check if a driver
// supports the source channel layout.  Avoids outputting empty channels and
// permits drivers to enable stereo to multichannel expansion.  Kept behind a
// flag since some drivers lie about supported layouts and hang when used.  See
// http://crbug.com/259165 for more details.
const char kTrySupportedChannelLayouts[] = "try-supported-channel-layouts";

// Number of buffers to use for WaveOut.
const char kWaveOutBuffers[] = "waveout-buffers";
#endif  // defined(OS_WIN)

#if defined(OS_FUCHSIA)
// Enables protected buffers for encrypted video streams.
const char kEnableProtectedVideoBuffers[] = "enable-protected-video-buffers";

// Forces protected memory for all output video buffers generated by
// FuchsiaVideoDecoder, including unencrypted streams. Ignored unless
// --enable-protected-video-buffers is also specified.
const char kForceProtectedVideoOutputBuffers[] =
    "force-protected-video-output-buffers";

const char kDisableAudioInput[] = "disable-audio-input";

// Present video content as overlays.
const char kUseOverlaysForVideo[] = "use-overlays-for-video";
#endif  // defined(OS_FUCHSIA)

#if defined(USE_CRAS)
// Use CRAS, the ChromeOS audio server.
const char kUseCras[] = "use-cras";
#endif  // defined(USE_CRAS)

// For automated testing of protected content, this switch allows specific
// domains (e.g. example.com) to always allow the permission to share the
// protected media identifier. In this context, domain does not include the
// port number. User's content settings will not be affected by enabling this
// switch.
// Reference: http://crbug.com/718608
// Example:
// --unsafely-allow-protected-media-identifier-for-domain=a.com,b.ca
const char kUnsafelyAllowProtectedMediaIdentifierForDomain[] =
    "unsafely-allow-protected-media-identifier-for-domain";

// Use fake device for Media Stream to replace actual camera and microphone.
// For the list of allowed parameters, see
// FakeVideoCaptureDeviceFactory::ParseFakeDevicesConfigFromOptionsString().
const char kUseFakeDeviceForMediaStream[] = "use-fake-device-for-media-stream";

// Use an .y4m file to play as the webcam. See the comments in
// media/capture/video/file_video_capture_device.h for more details.
const char kUseFileForFakeVideoCapture[] = "use-file-for-fake-video-capture";

// Play a .wav file as the microphone. Note that for WebRTC calls we'll treat
// the bits as if they came from the microphone, which means you should disable
// audio processing (lest your audio file will play back distorted). The input
// file is converted to suit Chrome's audio buses if necessary, so most sane
// .wav files should work. You can pass either <path> to play the file looping
// or <path>%noloop to stop after playing the file to completion.
const char kUseFileForFakeAudioCapture[] = "use-file-for-fake-audio-capture";

// Use a fake device for accelerated decoding of MJPEG. This allows, for
// example, testing of the communication to the GPU service without requiring
// actual accelerator hardware to be present.
const char kUseFakeMjpegDecodeAccelerator[] =
    "use-fake-mjpeg-decode-accelerator";

// Disable hardware acceleration of mjpeg decode for captured frame, where
// available.
const char kDisableAcceleratedMjpegDecode[] =
    "disable-accelerated-mjpeg-decode";

// When running tests on a system without the required hardware or libraries,
// this flag will cause the tests to fail. Otherwise, they silently succeed.
const char kRequireAudioHardwareForTesting[] =
    "require-audio-hardware-for-testing";

// Mutes audio sent to the audio device so it is not audible during
// automated testing.
const char kMuteAudio[] = "mute-audio";

// Allows clients to override the threshold for when the media renderer will
// declare the underflow state for the video stream when audio is present.
// TODO(dalecurtis): Remove once experiments for http://crbug.com/470940 finish.
const char kVideoUnderflowThresholdMs[] = "video-underflow-threshold-ms";

// Disables the new rendering algorithm for webrtc, which is designed to improve
// the rendering smoothness.
const char kDisableRTCSmoothnessAlgorithm[] =
    "disable-rtc-smoothness-algorithm";

// Force media player using SurfaceView instead of SurfaceTexture on Android.
const char kForceVideoOverlays[] = "force-video-overlays";

// Allows explicitly specifying MSE audio/video buffer sizes as megabytes.
// Default values are 150M for video and 12M for audio.
const char kMSEAudioBufferSizeLimitMb[] = "mse-audio-buffer-size-limit-mb";
const char kMSEVideoBufferSizeLimitMb[] = "mse-video-buffer-size-limit-mb";

// Specifies the path to the Clear Key CDM for testing, which is necessary to
// support External Clear Key key system when library CDM is enabled. Note that
// External Clear Key key system support is also controlled by feature
// kExternalClearKeyForTesting.
const char kClearKeyCdmPathForTesting[] = "clear-key-cdm-path-for-testing";

// Overrides the default enabled library CDM interface version(s) with the one
// specified with this switch, which will be the only version enabled. For
// example, on a build where CDM 8, CDM 9 and CDM 10 are all supported
// (implemented), but only CDM 8 and CDM 9 are enabled by default:
//  --override-enabled-cdm-interface-version=8 : Only CDM 8 is enabled
//  --override-enabled-cdm-interface-version=9 : Only CDM 9 is enabled
//  --override-enabled-cdm-interface-version=10 : Only CDM 10 is enabled
//  --override-enabled-cdm-interface-version=11 : No CDM interface is enabled
// This can be used for local testing and debugging. It can also be used to
// enable an experimental CDM interface (which is always disabled by default)
// for testing while it's still in development.
const char kOverrideEnabledCdmInterfaceVersion[] =
    "override-enabled-cdm-interface-version";

// Overrides hardware secure codecs support for testing. If specified, real
// platform hardware secure codecs check will be skipped. Codecs are separated
// by comma. Valid video codecs are "vp8", "vp9", "avc1" and "hevc", and valid
// audio codecs are "mp4a" and "vorbis". For example:
//  --override-hardware-secure-codecs-for-testing=vp8,vp9
//  --override-hardware-secure-codecs-for-testing=avc1
// CENC encryption scheme is assumed to be supported for the specified codecs.
// If no valid codecs specified, no hardware secure codecs are supported. This
// can be used to disable hardware secure codecs support:
//  --override-hardware-secure-codecs-for-testing
const char kOverrideHardwareSecureCodecsForTesting[] =
    "override-hardware-secure-codecs-for-testing";

// Sets the default value for the kLiveCaptionEnabled preference to true.
const char kEnableLiveCaptionPrefForTesting[] =
    "enable-live-caption-pref-for-testing";

#if BUILDFLAG(ENABLE_PLATFORM_HEVC)
// Enables playback of clear (unencrypted) HEVC content for testing purposes.
const char kEnableClearHevcForTesting[] = "enable-clear-hevc-for-testing";
#endif

#if defined(OS_CHROMEOS)
// These are flags passed from ash-chrome to lacros-chrome that correspond to
// buildflags for the platform we are running on. lacros-chrome only builds for
// x86/arm differences, so we unconditionally build in the below features into
// the relevant parts of lacros-chrome and then filter the functionality based
// on these command line flags.
MEDIA_EXPORT extern const char kLacrosEnablePlatformEncryptedHevc[] =
    "lacros-enable-platform-encrypted-hevc";
MEDIA_EXPORT extern const char kLacrosEnablePlatformHevc[] =
    "lacros-enable-platform-hevc";
MEDIA_EXPORT extern const char kLacrosUseChromeosProtectedMedia[] =
    "lacros-use-chromeos-protected-media";
MEDIA_EXPORT extern const char kLacrosUseChromeosProtectedAv1[] =
    "lacros-use-chromeos-protected-av1";
#endif  // defined(OS_CHROMEOS)

namespace autoplay {

// Autoplay policy that requires a document user activation.
const char kDocumentUserActivationRequiredPolicy[] =
    "document-user-activation-required";

// Autoplay policy that does not require any user gesture.
const char kNoUserGestureRequiredPolicy[] = "no-user-gesture-required";

// Autoplay policy to require a user gesture in order to play.
const char kUserGestureRequiredPolicy[] = "user-gesture-required";

}  // namespace autoplay

#if BUILDFLAG(USE_CHROMEOS_MEDIA_ACCELERATION)
// Some (Qualcomm only at the moment) V4L2 video decoders require setting the
// framerate so that the hardware decoder can scale the clocks efficiently.
// This provides a mechanism during testing to lock the decoder framerate
// to a specific value.
const char kHardwareVideoDecodeFrameRate[] = "hardware-video-decode-framerate";
#endif
}  // namespace switches

namespace media {

// Prefer FFmpeg to LibVPX for Vp8 decoding with opaque alpha mode.
const base::Feature kFFmpegDecodeOpaqueVP8{"FFmpegDecodeOpaqueVP8",
                                           base::FEATURE_ENABLED_BY_DEFAULT};

// Only used for disabling overlay fullscreen (aka SurfaceView) in Clank.
const base::Feature kOverlayFullscreenVideo{"overlay-fullscreen-video",
                                            base::FEATURE_ENABLED_BY_DEFAULT};

// TODO(crbug.com/1146594): Flip this to disabled in M92.
const base::Feature kEnableMediaInternals{"enable-media-internals",
                                          base::FEATURE_ENABLED_BY_DEFAULT};

// Enables user control over muting tab audio from the tab strip.
const base::Feature kEnableTabMuting{"enable-tab-muting",
                                     base::FEATURE_DISABLED_BY_DEFAULT};

// Enable Picture-in-Picture.
const base::Feature kPictureInPicture {
  "PictureInPicture",
#if defined(OS_ANDROID)
      base::FEATURE_DISABLED_BY_DEFAULT
#else
      base::FEATURE_ENABLED_BY_DEFAULT
#endif
};

// Only decode preload=metadata elements upon visibility.
// TODO(crbug.com/879406): Remove this after M76 ships to stable
const base::Feature kPreloadMetadataLazyLoad{"PreloadMetadataLazyLoad",
                                             base::FEATURE_ENABLED_BY_DEFAULT};

// Let videos be resumed via remote controls (for example, the notification)
// when in background.
const base::Feature kResumeBackgroundVideo {
  "resume-background-video",
#if defined(OS_ANDROID)
      base::FEATURE_ENABLED_BY_DEFAULT
#else
      base::FEATURE_DISABLED_BY_DEFAULT
#endif
};

// Experimental: Try to avoid destroying the media player when transferring a
// media element to a new document.  This is a work in progress, and may cause
// security and/or stability issues.
const base::Feature kReuseMediaPlayer{"ReuseMediaPlayer",
                                      base::FEATURE_DISABLED_BY_DEFAULT};

// When enabled, MediaCapabilities will check with GPU Video Accelerator
// Factories to determine isPowerEfficient = true/false.
const base::Feature kMediaCapabilitiesQueryGpuFactories{
    "MediaCapabilitiesQueryGpuFactories", base::FEATURE_ENABLED_BY_DEFAULT};

// Enable Media Capabilities with finch-parameters.
const base::Feature kMediaCapabilitiesWithParameters{
    "MediaCapabilitiesWithParameters", base::FEATURE_ENABLED_BY_DEFAULT};

// Display the Cast overlay button on the media controls.
const base::Feature kMediaCastOverlayButton{"MediaCastOverlayButton",
                                            base::FEATURE_ENABLED_BY_DEFAULT};

// Use AndroidOverlay only if required for secure video playback. This requires
// that |kOverlayFullscreenVideo| is true, else it is ignored.
const base::Feature kUseAndroidOverlayForSecureOnly{
    "UseAndroidOverlayForSecureOnly", base::FEATURE_DISABLED_BY_DEFAULT};

// If enabled, RTCVideoDecoderAdapter will wrap a DecoderStream as a video
// decoder, rather than using MojoVideoDecoder.  This causes the RTC external
// decoder to have all the decoder selection / fallback/forward logic of the
// non-RTC pipeline.
// TODO(liberato): This also causes the external decoder to use software
// decoding sometimes, which changes the interpretation of "ExternalDecoder".
const base::Feature kUseDecoderStreamForWebRTC{
    "UseDecoderStreamForWebRTC", base::FEATURE_DISABLED_BY_DEFAULT};

// If enabled, when RTCVideoDecoderAdapter is used then SW decoders will be
// exposed directly to WebRTC.
const base::Feature kExposeSwDecodersToWebRTC{
    "ExposeSwDecodersToWebRTC", base::FEATURE_DISABLED_BY_DEFAULT};

// Let video without audio be paused when it is playing in the background.
const base::Feature kBackgroundVideoPauseOptimization{
    "BackgroundVideoPauseOptimization", base::FEATURE_ENABLED_BY_DEFAULT};

// CDM host verification is enabled by default. Can be disabled for testing.
// Has no effect if ENABLE_CDM_HOST_VERIFICATION buildflag is false.
const base::Feature kCdmHostVerification{"CdmHostVerification",
                                         base::FEATURE_ENABLED_BY_DEFAULT};

// Use per-CDM-type, per-user and per-site CDM processes (for library CDM). If
// disabled, the CDM processes are only per-CDM-type, meaning different sites
// using the same CDM type would share one CDM process.
const base::Feature kCdmProcessSiteIsolation{"CdmProcessSiteIsolation",
                                             base::FEATURE_ENABLED_BY_DEFAULT};

// Make MSE garbage collection algorithm more aggressive when we are under
// moderate or critical memory pressure. This will relieve memory pressure by
// releasing stale data from MSE buffers.
const base::Feature kMemoryPressureBasedSourceBufferGC{
    "MemoryPressureBasedSourceBufferGC", base::FEATURE_DISABLED_BY_DEFAULT};

// Enable binding multiple shared images to a single GpuMemoryBuffer for video
// frames created by video capture.
const base::Feature kMultiPlaneVideoCaptureSharedImages {
  "MultiPlaneVideoCaptureSharedImages",
#if defined(OS_MAC)
      base::FEATURE_ENABLED_BY_DEFAULT
#else
      base::FEATURE_DISABLED_BY_DEFAULT
#endif
};

// Approach original pre-REC MSE object URL autorevoking behavior, though await
// actual attempt to use the object URL for attachment to perform revocation.
// This will hopefully reduce runtime memory bloat for pages that do not
// explicitly detach their HTMLME+MSE object collections nor explicitly revoke
// the object URLs used to attach HTMLME+MSE. When disabled, revocation only
// occurs when application explicitly revokes the object URL, or upon the
// execution context teardown for the MediaSource object. When enabled,
// revocation occurs upon successful start of attachment of HTMLME to the object
// URL. Note, rather than immediately scheduling a task to revoke upon the URL's
// creation, as at least one other browser does and the original File API
// pattern used to follow, this delay until attachment start enables new
// scenarios that could use the object URL for attaching HTMLME+MSE cross-thread
// (MSE-in-workers), where there could be significant delay between the worker
// thread creation of the object URL and the main thread usage of the object URL
// for starting attachment to HTMLME.
const base::Feature kRevokeMediaSourceObjectURLOnAttach{
    "RevokeMediaSourceObjectURLOnAttach", base::FEATURE_ENABLED_BY_DEFAULT};

// Enable saving playback information in a crash trace, to see if some codecs
// are crashier than others.
const base::Feature kD3D11PrintCodecOnCrash{"D3D11PrintCodecOnCrash",
                                            base::FEATURE_DISABLED_BY_DEFAULT};

// Enable The D3D11 Video decoder.
const base::Feature kD3D11VideoDecoder{"D3D11VideoDecoder",
                                       base::FEATURE_ENABLED_BY_DEFAULT};

// Tell D3D11VideoDecoder to ignore workarounds for zero copy.  Requires that
// kD3D11VideoDecoder is enabled.
const base::Feature kD3D11VideoDecoderIgnoreWorkarounds{
    "D3D11VideoDecoderIgnoreWorkarounds", base::FEATURE_DISABLED_BY_DEFAULT};

// Enable D3D11VideoDecoder to decode VP9 profile 2 (10 bit) video.
const base::Feature kD3D11VideoDecoderVP9Profile2{
    "D3D11VideoDecoderEnableVP9Profile2", base::FEATURE_ENABLED_BY_DEFAULT};

// Enable D3D11VideoDecoder to decode AV1 video.
const base::Feature kD3D11VideoDecoderAV1{"D3D11VideoDecoderEnableAV1",
                                          base::FEATURE_ENABLED_BY_DEFAULT};

const base::Feature kD3D11VideoDecoderUseSharedHandle{
    "D3D11VideoDecoderUseSharedHandle", base::FEATURE_DISABLED_BY_DEFAULT};

// Falls back to other decoders after audio/video decode error happens. The
// implementation may choose different strategies on when to fallback. See
// DecoderStream for details. When disabled, playback will fail immediately
// after a decode error happens. This can be useful in debugging and testing
// because the behavior is simpler and more predictable.
const base::Feature kFallbackAfterDecodeError{"FallbackAfterDecodeError",
                                              base::FEATURE_ENABLED_BY_DEFAULT};

// Use Gav1VideoDecoder to decode AV1 streams.
const base::Feature kGav1VideoDecoder{"Gav1VideoDecoder",
                                      base::FEATURE_DISABLED_BY_DEFAULT};

// Show toolbar button that opens dialog for controlling media sessions.
const base::Feature kGlobalMediaControls {
  "GlobalMediaControls",
#if defined(OS_WIN) || defined(OS_MAC) || defined(OS_LINUX) || \
    BUILDFLAG(IS_CHROMEOS_LACROS)
      base::FEATURE_ENABLED_BY_DEFAULT
#else
      base::FEATURE_DISABLED_BY_DEFAULT
#endif
};

// Auto-dismiss global media controls.
const base::Feature kGlobalMediaControlsAutoDismiss{
    "GlobalMediaControlsAutoDismiss", base::FEATURE_ENABLED_BY_DEFAULT};

// Show Cast sessions in Global Media Controls. It is no-op if
// kGlobalMediaControls is not enabled.
const base::Feature kGlobalMediaControlsForCast{
    "GlobalMediaControlsForCast", base::FEATURE_ENABLED_BY_DEFAULT};

// Allow Global Media Controls in system tray of CrOS.
const base::Feature kGlobalMediaControlsForChromeOS{
    "GlobalMediaControlsForChromeOS", base::FEATURE_ENABLED_BY_DEFAULT};

constexpr base::FeatureParam<kCrosGlobalMediaControlsPinOptions>::Option
    kCrosGlobalMediaControlsParamOptions[] = {
        {kCrosGlobalMediaControlsPinOptions::kPin, "default-pinned"},
        {kCrosGlobalMediaControlsPinOptions::kNotPin, "default-unpinned"},
        {kCrosGlobalMediaControlsPinOptions::kHeuristic, "heuristic"}};

constexpr base::FeatureParam<kCrosGlobalMediaControlsPinOptions>
    kCrosGlobalMediaControlsPinParam(
        &kGlobalMediaControlsForChromeOS,
        "CrosGlobalMediaControlsPinParam",
        kCrosGlobalMediaControlsPinOptions::kHeuristic,
        &kCrosGlobalMediaControlsParamOptions);

// Show picture-in-picture button in Global Media Controls.
const base::Feature kGlobalMediaControlsPictureInPicture {
  "GlobalMediaControlsPictureInPicture",
#if defined(OS_WIN) || defined(OS_MAC) || defined(OS_LINUX) || \
    defined(OS_CHROMEOS) || BUILDFLAG(IS_CHROMEOS_LACROS)
      base::FEATURE_ENABLED_BY_DEFAULT
#else
      base::FEATURE_DISABLED_BY_DEFAULT
#endif
};

// Enable selection of audio output device in Global Media Controls.
const base::Feature kGlobalMediaControlsSeamlessTransfer{
    "GlobalMediaControlsSeamlessTransfer", base::FEATURE_DISABLED_BY_DEFAULT};

// Enable an updated version of the Global Media Controls UI.
const base::Feature kGlobalMediaControlsModernUI{
    "GlobalMediaControlsModernUI", base::FEATURE_DISABLED_BY_DEFAULT};

// CanPlayThrough issued according to standard.
const base::Feature kSpecCompliantCanPlayThrough{
    "SpecCompliantCanPlayThrough", base::FEATURE_ENABLED_BY_DEFAULT};

// Controls usage of SurfaceLayer for MediaStreams.
const base::Feature kSurfaceLayerForMediaStreams{
    "SurfaceLayerForMediaStreams", base::FEATURE_ENABLED_BY_DEFAULT};

// Disables the real audio output stream after silent audio has been delivered
// for too long. Should save quite a bit of power in the muted video case.
const base::Feature kSuspendMutedAudio{"SuspendMutedAudio",
                                       base::FEATURE_ENABLED_BY_DEFAULT};

// Enables using the media history store to store media engagement metrics.
const base::Feature kUseMediaHistoryStore{"UseMediaHistoryStore",
                                          base::FEATURE_DISABLED_BY_DEFAULT};

// Use R16 texture for 9-16 bit channel instead of half-float conversion by CPU.
const base::Feature kUseR16Texture{"use-r16-texture",
                                   base::FEATURE_DISABLED_BY_DEFAULT};

// Enables the Unified Autoplay policy by overriding the platform's default
// autoplay policy.
const base::Feature kUnifiedAutoplay{"UnifiedAutoplay",
                                     base::FEATURE_ENABLED_BY_DEFAULT};

#if defined(OS_LINUX)
// Enable vaapi video decoding on linux. This is already enabled by default on
// chromeos, but needs an experiment on linux.
const base::Feature kVaapiVideoDecodeLinux{"VaapiVideoDecoder",
                                           base::FEATURE_DISABLED_BY_DEFAULT};

const base::Feature kVaapiVideoEncodeLinux{"VaapiVideoEncoder",
                                           base::FEATURE_DISABLED_BY_DEFAULT};
#endif  // defined(OS_LINUX)

// Enable VA-API hardware decode acceleration for AV1.
const base::Feature kVaapiAV1Decoder{"VaapiAV1Decoder",
                                     base::FEATURE_ENABLED_BY_DEFAULT};

// Enable VA-API hardware low power encoder for all codecs on intel Gen9x gpu.
const base::Feature kVaapiLowPowerEncoderGen9x{
    "VaapiLowPowerEncoderGen9x", base::FEATURE_DISABLED_BY_DEFAULT};

// Reject creation of encode/decode VAContexts when the requested resolution is
// outside the enumerated minimum and maximum. TODO(b/171041334): Remove and
// enable by default once the ARC++ hw codecs issue is fixed.
const base::Feature kVaapiEnforceVideoMinMaxResolution{
    "VaapiEnforceVideoMinMaxResolution", base::FEATURE_DISABLED_BY_DEFAULT};

// Ensure the advertised minimum supported resolution is larger than or equal to
// a given one (likely QVGA + 1) for certain codecs/modes and platforms, for
// performance reasons. This does not affect JPEG decoding.
const base::Feature kVaapiVideoMinResolutionForPerformance{
    "VaapiVideoMinResolutionForPerformance", base::FEATURE_ENABLED_BY_DEFAULT};

// Enable VA-API hardware encode acceleration for VP8.
const base::Feature kVaapiVP8Encoder{"VaapiVP8Encoder",
                                     base::FEATURE_ENABLED_BY_DEFAULT};

// Enable VA-API hardware encode acceleration for VP9.
const base::Feature kVaapiVP9Encoder{"VaapiVP9Encoder",
                                     base::FEATURE_ENABLED_BY_DEFAULT};

#if defined(ARCH_CPU_X86_FAMILY) && BUILDFLAG(IS_CHROMEOS_ASH)
// Enable H264 temporal layer encoding with HW encoder on ChromeOS.
const base::Feature kVaapiH264TemporalLayerHWEncoding{
    "VaapiH264TemporalLayerEncoding", base::FEATURE_ENABLED_BY_DEFAULT};
// Enable VP9 k-SVC decoding with HW decoder for webrtc use case on ChromeOS.
const base::Feature kVaapiVp9kSVCHWDecoding{"VaapiVp9kSVCHWDecoding",
                                            base::FEATURE_ENABLED_BY_DEFAULT};
// Enable VP9 k-SVC encoding with HW encoder for webrtc use case on ChromeOS.
const base::Feature kVaapiVp9kSVCHWEncoding{"VaapiVp9kSVCHWEncoding",
                                            base::FEATURE_DISABLED_BY_DEFAULT};

#endif  // defined(ARCH_CPU_X86_FAMILY) && BUILDFLAG(IS_CHROMEOS_ASH)

// Inform video blitter of video color space.
const base::Feature kVideoBlitColorAccuracy{"video-blit-color-accuracy",
                                            base::FEATURE_ENABLED_BY_DEFAULT};

// Enables support for External Clear Key (ECK) key system for testing on
// supported platforms. On platforms that do not support ECK, this feature has
// no effect.
const base::Feature kExternalClearKeyForTesting{
    "ExternalClearKeyForTesting", base::FEATURE_DISABLED_BY_DEFAULT};

// Enables the Live Caption feature on supported devices.
const base::Feature kLiveCaption{"LiveCaption",
                                 base::FEATURE_ENABLED_BY_DEFAULT};

// Use the Speech On-Device API (SODA) to power the Live Caption feature instead
// of the Cloud-based Open Speech API.
const base::Feature kUseSodaForLiveCaption{"UseSodaForLiveCaption",
                                           base::FEATURE_ENABLED_BY_DEFAULT};

// Enable the Speaker Change Detection feature, which inserts a line break when
// the Speech On-Device API (SODA) detects a speaker change.
const base::Feature kSpeakerChangeDetection{"SpeakerChangeDetection",
                                            base::FEATURE_DISABLED_BY_DEFAULT};

// Live Caption can be used in multiple languages, as opposed to just English.
const base::Feature kLiveCaptionMultiLanguage{
    "LiveCaptionMultiLanguage", base::FEATURE_DISABLED_BY_DEFAULT};

// Live Caption runs system-wide on ChromeOS, as opposed to just in the browser.
const base::Feature kLiveCaptionSystemWideOnChromeOS{
    "LiveCaptionSystemWideOnChromeOS", base::FEATURE_DISABLED_BY_DEFAULT};

// Prevents UrlProvisionFetcher from making a provisioning request. If
// specified, any provisioning request made will not be sent to the provisioning
// server, and the response will indicate a failure to communicate with the
// provisioning server.
const base::Feature kFailUrlProvisionFetcherForTesting{
    "FailUrlProvisionFetcherForTesting", base::FEATURE_DISABLED_BY_DEFAULT};

// Enables hardware secure decryption if supported by hardware and CDM.
// TODO(xhwang): Currently this is only used for development of new features.
// Apply this to Android and ChromeOS as well where hardware secure decryption
// is already available.
const base::Feature kHardwareSecureDecryption{
    "HardwareSecureDecryption", base::FEATURE_DISABLED_BY_DEFAULT};

const base::Feature kWakeLockOptimisationHiddenMuted{
    "kWakeLockOptimisationHiddenMuted", base::FEATURE_ENABLED_BY_DEFAULT};

// Enables handling of hardware media keys for controlling media.
const base::Feature kHardwareMediaKeyHandling {
  "HardwareMediaKeyHandling",
#if BUILDFLAG(IS_CHROMEOS_ASH) || defined(OS_WIN) || defined(OS_MAC) || \
    BUILDFLAG(USE_MPRIS)
      base::FEATURE_ENABLED_BY_DEFAULT
#else
      base::FEATURE_DISABLED_BY_DEFAULT
#endif
};

// Enables a platform-specific resolution cutoff for prioritizing platform
// decoders over software decoders or vice-versa.
const base::Feature kResolutionBasedDecoderPriority{
    "ResolutionBasedDecoderPriority", base::FEATURE_DISABLED_BY_DEFAULT};

// Forces use of hardware (platform) video decoders in
// `media::DecoderSelector`.
const base::Feature kForceHardwareVideoDecoders{
    "ForceHardwareVideoDecoders", base::FEATURE_DISABLED_BY_DEFAULT};

// Forces use of hardware (platform) audio decoders in
// `media::DecoderSelector`.
const base::Feature kForceHardwareAudioDecoders{
    "ForceHardwareAudioDecoders", base::FEATURE_DISABLED_BY_DEFAULT};

// Enables low-delay video rendering in media pipeline on "live" stream.
const base::Feature kLowDelayVideoRenderingOnLiveStream{
    "low-delay-video-rendering-on-live-stream",
    base::FEATURE_ENABLED_BY_DEFAULT};

// Whether the autoplay policy should ignore Web Audio. When ignored, the
// autoplay policy will be hardcoded to be the legacy one on based on the
// platform
const base::Feature kAutoplayIgnoreWebAudio{"AutoplayIgnoreWebAudio",
                                            base::FEATURE_DISABLED_BY_DEFAULT};

// Whether we should show a setting to disable autoplay policy.
const base::Feature kAutoplayDisableSettings{"AutoplayDisableSettings",
                                             base::FEATURE_DISABLED_BY_DEFAULT};

#if defined(OS_ANDROID)
// Should we allow video playback to use an overlay if it's not needed for
// security?  Normally, we'd always want to allow this, except as part of the
// power testing A/B experiment.  https://crbug.com/1081346 .
const base::Feature kAllowNonSecureOverlays{"AllowNonSecureOverlays",
                                            base::FEATURE_ENABLED_BY_DEFAULT};

// Enable a gesture to make the media controls expaned into the display cutout.
// TODO(beccahughes): Remove this.
const base::Feature kMediaControlsExpandGesture{
    "MediaControlsExpandGesture", base::FEATURE_ENABLED_BY_DEFAULT};

// An experimental feature to enable persistent-license type support in MediaDrm
// when using Encrypted Media Extensions (EME) API.
// TODO(xhwang): Remove this after feature launch. See http://crbug.com/493521
const base::Feature kMediaDrmPersistentLicense{
    "MediaDrmPersistentLicense", base::FEATURE_ENABLED_BY_DEFAULT};

// Enables MediaDrmOriginIdManager to provide preprovisioned origin IDs for
// MediaDrmBridge. If disabled, MediaDrmBridge will get unprovisioned origin IDs
// which will trigger provisioning process after MediaDrmBridge is created.
const base::Feature kMediaDrmPreprovisioning{"MediaDrmPreprovisioning",
                                             base::FEATURE_ENABLED_BY_DEFAULT};

// Determines if MediaDrmOriginIdManager should attempt to pre-provision origin
// IDs at startup (whenever a profile is loaded). Also used by tests that
// disable it so that the tests can setup before pre-provisioning is done.
// Note: Has no effect if kMediaDrmPreprovisioning feature is disabled.
const base::Feature kMediaDrmPreprovisioningAtStartup{
    "MediaDrmPreprovisioningAtStartup", base::FEATURE_ENABLED_BY_DEFAULT};

// Enable picture in picture web api for android.
const base::Feature kPictureInPictureAPI{"PictureInPictureAPI",
                                         base::FEATURE_DISABLED_BY_DEFAULT};

// Enables CanPlayType() (and other queries) for HLS MIME types. Note that
// disabling this also causes navigation to .m3u8 files to trigger downloading
// instead of playback.
const base::Feature kCanPlayHls{"CanPlayHls", base::FEATURE_ENABLED_BY_DEFAULT};

// Enables the use of MediaPlayerRenderer for HLS playback. When disabled,
// HLS manifests will fail to load (triggering source fallback or load error).
const base::Feature kHlsPlayer{"HlsPlayer", base::FEATURE_ENABLED_BY_DEFAULT};

// When enabled, Playing media sessions will request audio focus from the
// Android system.
const base::Feature kRequestSystemAudioFocus{"RequestSystemAudioFocus",
                                             base::FEATURE_ENABLED_BY_DEFAULT};

// Use the (hacky) AudioManager.getOutputLatency() call to get the estimated
// hardware latency for a stream for OpenSLES playback.  This is normally not
// needed, except for some Android TV devices.
const base::Feature kUseAudioLatencyFromHAL{"UseAudioLatencyFromHAL",
                                            base::FEATURE_DISABLED_BY_DEFAULT};

// Enable pooling of SharedImageVideo objects for use by MCVD, to save a hop to
// the GPU main thread during VideoFrame construction.
const base::Feature kUsePooledSharedImageVideoProvider{
    "UsePooledSharedImageVideoProvider", base::FEATURE_ENABLED_BY_DEFAULT};
#endif  // defined(OS_ANDROID)

#if defined(OS_CHROMEOS) && BUILDFLAG(USE_CHROMEOS_MEDIA_ACCELERATION)
// Enable the hardware-accelerated direct video decoder instead of the one
// needing the VdaVideoDecoder adapter. This flag is used mainly as a
// chrome:flag for developers debugging issues. TODO(b/159825227): remove when
// the direct video decoder is fully launched.
const base::Feature kUseChromeOSDirectVideoDecoder{
    "UseChromeOSDirectVideoDecoder", base::FEATURE_ENABLED_BY_DEFAULT};

// ChromeOS has one of two VideoDecoder implementations active based on
// SoC/board specific configurations that are sent via command line flags. This
// switch allows using the non default implementation for testing.
// TODO(b/159825227): remove when the "old" video decoder is fully launched.
const base::Feature kUseAlternateVideoDecoderImplementation{
    "UseAlternateVideoDecoderImplementation",
    base::FEATURE_DISABLED_BY_DEFAULT};
#endif  // defined(OS_CHROMEOS) && BUILDFLAG(USE_CHROMEOS_MEDIA_ACCELERATION)

#if defined(OS_MAC)
// Enable binding multiple shared images to a single GpuMemoryBuffer for
// accelerated video decode using VideoToolbox.
const base::Feature kMultiPlaneVideoToolboxSharedImages{
    "MultiPlaneVideoToolboxSharedImages", base::FEATURE_ENABLED_BY_DEFAULT};
#endif

#if defined(OS_WIN)
// Does NV12->NV12 video copy on the main thread right before the texture's
// used by GL.
const base::Feature kDelayCopyNV12Textures{"DelayCopyNV12Textures",
                                           base::FEATURE_ENABLED_BY_DEFAULT};

// Enables DirectShow GetPhotoState implementation
// Created to act as a kill switch by disabling it, in the case of the
// resurgence of https://crbug.com/722038
const base::Feature kDirectShowGetPhotoState{"DirectShowGetPhotoState",
                                             base::FEATURE_ENABLED_BY_DEFAULT};

// Includes Infrared cameras in the list returned for EnumerateDevices() on
// Windows.
const base::Feature kIncludeIRCamerasInDeviceEnumeration{
    "IncludeIRCamerasInDeviceEnumeration", base::FEATURE_DISABLED_BY_DEFAULT};

// Enables asynchronous H264 HW encode acceleration using Media Foundation for
// Windows.
const base::Feature kMediaFoundationAsyncH264Encoding{
    "MediaFoundationAsyncH264Encoding", base::FEATURE_ENABLED_BY_DEFAULT};

// Enables AV1 decode acceleration for Windows.
const base::Feature MEDIA_EXPORT kMediaFoundationAV1Decoding{
    "MediaFoundationAV1Decoding", base::FEATURE_ENABLED_BY_DEFAULT};

// Enables MediaFoundation based video capture
const base::Feature kMediaFoundationVideoCapture{
    "MediaFoundationVideoCapture", base::FEATURE_ENABLED_BY_DEFAULT};

// Enables MediaFoundation based video capture with D3D11
const base::Feature kMediaFoundationD3D11VideoCapture{
    "MediaFoundationD3D11VideoCapture", base::FEATURE_DISABLED_BY_DEFAULT};

// Enables VP8 decode acceleration for Windows.
const base::Feature MEDIA_EXPORT kMediaFoundationVP8Decoding{
    "MediaFoundationVP8Decoding", base::FEATURE_DISABLED_BY_DEFAULT};

// Use the AUDCLNT_STREAMOPTIONS_RAW option on WASAPI input audio streams in
// combination with  the IAudioClient2::SetClientProperties() API.
// The audio stream is a 'raw' stream that bypasses all signal processing except
// for endpoint specific, always-on processing in the Audio Processing Object
// (APO), driver, and hardware.
// https://docs.microsoft.com/en-us/windows/win32/api/audioclient/ne-audioclient-audclnt_streamoptions
const base::Feature MEDIA_EXPORT kWasapiRawAudioCapture{
    "WASAPIRawAudioCapture", base::FEATURE_ENABLED_BY_DEFAULT};

#endif  // defined(OS_WIN)

#if defined(OS_CHROMEOS)
const base::Feature MEDIA_EXPORT kDeprecateLowUsageCodecs{
    "DeprecateLowUsageCodecs", base::FEATURE_ENABLED_BY_DEFAULT};
#endif  // defined(OS_CHROMEOS)

std::string GetEffectiveAutoplayPolicy(const base::CommandLine& command_line) {
  // Return the autoplay policy set in the command line, if any.
  if (command_line.HasSwitch(switches::kAutoplayPolicy))
    return command_line.GetSwitchValueASCII(switches::kAutoplayPolicy);

  if (base::FeatureList::IsEnabled(media::kUnifiedAutoplay))
    return switches::autoplay::kDocumentUserActivationRequiredPolicy;

// The default value is platform dependent.
#if defined(OS_ANDROID)
  return switches::autoplay::kUserGestureRequiredPolicy;
#else
  return switches::autoplay::kNoUserGestureRequiredPolicy;
#endif
}

// Enables Media Engagement Index recording. This data will be used to determine
// when to bypass autoplay policies. This is recorded on all platforms.
const base::Feature kRecordMediaEngagementScores{
    "RecordMediaEngagementScores", base::FEATURE_ENABLED_BY_DEFAULT};

// Enables Media Engagement Index recording for Web Audio playbacks.
const base::Feature kRecordWebAudioEngagement{"RecordWebAudioEngagement",
                                              base::FEATURE_ENABLED_BY_DEFAULT};

// The following Media Engagement flags are not enabled on mobile platforms:
// - MediaEngagementBypassAutoplayPolicies: enables the Media Engagement Index
//   data to be esude to override autoplay policies. An origin with a high MEI
//   will be allowed to autoplay.
// - PreloadMediaEngagementData: enables a list of origins to be considered as
//   having a high MEI until there is enough local data to determine the user's
//   preferred behaviour.
#if defined(OS_ANDROID) || defined(OS_IOS)
const base::Feature kMediaEngagementBypassAutoplayPolicies{
    "MediaEngagementBypassAutoplayPolicies", base::FEATURE_DISABLED_BY_DEFAULT};
const base::Feature kPreloadMediaEngagementData{
    "PreloadMediaEngagementData", base::FEATURE_DISABLED_BY_DEFAULT};
#else
const base::Feature kMediaEngagementBypassAutoplayPolicies{
    "MediaEngagementBypassAutoplayPolicies", base::FEATURE_ENABLED_BY_DEFAULT};
const base::Feature kPreloadMediaEngagementData{
    "PreloadMediaEngagementData", base::FEATURE_ENABLED_BY_DEFAULT};
#endif

const base::Feature kMediaEngagementHTTPSOnly{
    "MediaEngagementHTTPSOnly", base::FEATURE_DISABLED_BY_DEFAULT};

// Enables experimental local learning for media. Used in the context of media
// capabilities only. Adds reporting only; does not change media behavior.
const base::Feature kMediaLearningExperiment{"MediaLearningExperiment",
                                             base::FEATURE_DISABLED_BY_DEFAULT};

// Enables the general purpose media machine learning framework. Adds reporting
// only; does not change media behavior.
const base::Feature kMediaLearningFramework{"MediaLearningFramework",
                                            base::FEATURE_DISABLED_BY_DEFAULT};

// Enables the smoothness prediction experiment.  Requires
// kMediaLearningFramework to be enabled also, else it does nothing.
const base::Feature kMediaLearningSmoothnessExperiment{
    "MediaLearningSmoothnessExperiment", base::FEATURE_DISABLED_BY_DEFAULT};

// Enable the prototype global optimization of tuneables via finch.  See
// media/base/tuneable.h for how to create tuneable parameters.
const base::Feature kMediaOptimizer{"JointMediaOptimizer",
                                    base::FEATURE_DISABLED_BY_DEFAULT};

// Enable aggregate power measurement for media playback.
const base::Feature kMediaPowerExperiment{"MediaPowerExperiment",
                                          base::FEATURE_DISABLED_BY_DEFAULT};

// Enable WebRTC actions for the Media Session API.
const base::Feature kMediaSessionWebRTC{"MediaSessionWebRTC",
                                        base::FEATURE_ENABLED_BY_DEFAULT};

// Enables flash to be ducked by audio focus. This is enabled on Chrome OS which
// has audio focus enabled.
const base::Feature kAudioFocusDuckFlash {
  "AudioFocusDuckFlash",
#if BUILDFLAG(IS_CHROMEOS_ASH)
      base::FEATURE_ENABLED_BY_DEFAULT
#else
      base::FEATURE_DISABLED_BY_DEFAULT
#endif
};

// Only affects Android. Suspends a media session when audio focus is lost; when
// this setting is disabled, an Android media session will not be suspended when
// Audio focus is lost. This is used by Cast which sometimes needs to drive
// multiple media sessions.
const base::Feature kAudioFocusLossSuspendMediaSession{
    "AudioFocusMediaSession", base::FEATURE_ENABLED_BY_DEFAULT};

// Enables the internal Media Session logic without enabling the Media Session
// service.
const base::Feature kInternalMediaSession {
  "InternalMediaSession",
#if defined(OS_ANDROID)
      base::FEATURE_ENABLED_BY_DEFAULT
#else
      base::FEATURE_DISABLED_BY_DEFAULT
#endif
};

const base::Feature kKaleidoscope{"Kaleidoscope",
                                  base::FEATURE_ENABLED_BY_DEFAULT};

const base::Feature kKaleidoscopeInMenu{"KaleidoscopeInMenu",
                                        base::FEATURE_DISABLED_BY_DEFAULT};

const base::Feature kKaleidoscopeForceShowFirstRunExperience{
    "KaleidoscopeForceShowFirstRunExperience",
    base::FEATURE_DISABLED_BY_DEFAULT};

// Keypress detection which serves as input to noise suppression methods
// in WebRTC clients. This functionality is enabled by default but it can be
// disabled experemantally by using --disable-features=KeyPressMonitoring.
const base::Feature kKeyPressMonitoring{"KeyPressMonitoring",
                                        base::FEATURE_ENABLED_BY_DEFAULT};

const base::Feature kUseFakeDeviceForMediaStream{
    "use-fake-device-for-media-stream", base::FEATURE_DISABLED_BY_DEFAULT};

// Makes VideoCadenceEstimator use Bresenham-like algorithm for frame cadence
// estimations.
const base::Feature kBresenhamCadence{"BresenhamCadence",
                                      base::FEATURE_DISABLED_BY_DEFAULT};

// Display the playback speed button on the media controls.
const base::Feature kPlaybackSpeedButton{"PlaybackSpeedButton",
                                         base::FEATURE_ENABLED_BY_DEFAULT};

bool IsVideoCaptureAcceleratedJpegDecodingEnabled() {
  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDisableAcceleratedMjpegDecode)) {
    return false;
  }
  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kUseFakeMjpegDecodeAccelerator)) {
    return true;
  }
#if BUILDFLAG(IS_CHROMEOS_ASH)
  return true;
#else
  return false;
#endif
}

bool IsLiveCaptionFeatureEnabled() {
  if (!base::FeatureList::IsEnabled(media::kLiveCaption))
    return false;

#if BUILDFLAG(IS_CHROMEOS_ASH)
  // Some Chrome OS devices do not support on-device speech.
  if (!base::FeatureList::IsEnabled(ash::features::kOnDeviceSpeechRecognition))
    return false;
#endif

#if defined(OS_LINUX)
  if (base::FeatureList::IsEnabled(media::kUseSodaForLiveCaption)) {
    // Check if the CPU has the required instruction set to run the Speech
    // On-Device API (SODA) library.
    static bool has_sse41 = base::CPU().has_sse41();
    if (!has_sse41)
      return false;
  }
#endif

#if defined(OS_WIN) && defined(ARCH_CPU_ARM64)
  if (base::FeatureList::IsEnabled(media::kUseSodaForLiveCaption)) {
    // The Speech On-Device API (SODA) component does not support Windows on
    // arm64.
    return false;
  }
#endif

  return true;
}

}  // namespace media
