name: 'Gemini Commit Message Generator'

# This workflow is triggered when a new comment is created on a Pull Request.
on:
  issue_comment:
    types: [created]

# This block defines the job that will run.
jobs:
  generate_commit_message:
    # This condition ensures the workflow only runs if the comment is on a PR
    # and the comment body is exactly '/gemini-commit-message'.
    if: github.event.issue.pull_request && github.event.comment.body == '/gemini-commit-message'

    # The workflow will run on the latest version of Ubuntu.
    runs-on: ubuntu-latest

    # We need to grant the workflow permission to write comments on pull requests.
    permissions:
      pull-requests: write

    steps:
      # Step 1: Check out the code from the pull request branch.
      # This is necessary to be able to run git commands on the code.
      - name: 'Checkout PR Branch'
        uses: actions/checkout@v4
        with:
          # Fetch the entire history to be able to diff against the base branch.
          fetch-depth: 0

      # Step 2: Get the code changes (the "diff") from the pull request.
      # This is the most important piece of information for generating a good commit message.
      - name: 'Get PR Diff'
        id: diff
        run: |
          # The target branch (e.g., main, develop) is needed to compare against.
          target_branch=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -H "Accept: application/vnd.github.v3+json" ${{ github.event.issue.pull_request.url }} | jq -r .base.ref)

          # Generate the diff between the PR branch and the target branch.
          # The '...' syntax is a git shortcut to find the best common ancestor.
          diff_content=$(git diff "origin/$target_branch"...)

          # The following lines save the diff content into a GitHub Actions output variable,
          # which allows us to use it in later steps. This method is robust for multiline strings.
          echo "diff_content<<EOF" >> $GITHUB_OUTPUT
          echo "$diff_content" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Step 3: Call the Gemini API directly with a detailed prompt.
      # This approach avoids third-party actions and gives us full control over the request.
      - name: 'Generate Commit Message with Gemini'
        id: gemini
        env:
          # Store the multiline prompt in an environment variable to handle special characters safely.
          PROMPT: |
            Act as an expert software engineer specializing in the Cobalt codebase, which is a fork of Chromium. Your task is to generate a professional and informative Git commit message based on the provided pull request details. The final output should be only the commit message itself, without any extra conversational text or markdown formatting. Do not use backticks (`) in your response.

            You must strictly adhere to the following rules:

            **Commit Message Structure:**
            1.  **Tag Prefix:** The subject line MUST be prefixed with a tag followed by a colon (e.g., "media: Add support for AV1"). Prefer component tags over type tags.
            2.  **Subject:** Capitalize the subject line, use the imperative mood, limit it to 50 characters, and do not end it with a period.
            3.  **Body:** Separate the subject from the body with a blank line. The body should explain the 'what' and 'why' of the change, not the 'how', and wrap at 72 characters.

            **Tag Selection (Prefix the subject line with one of these):**
            * **Component Tags (Preferred):**
                * `android`: Android-specific changes.
                * `tvos`: tvOS-specific changes.
                * `build`: Changes to the build system (GN files, build scripts).
                * `cobalt`: Changes specific to the Cobalt browser logic.
                * `evergreen`: For Evergreen-specific changes.
                * `linux`: Linux-specific changes.
                * `media`: Changes related to the media pipeline (player, demuxer, etc.).
                * `net`: For networking changes (e.g., QUIC, sockets).
                * `posix`: POSIX-related changes.
                * `starboard`: Changes to the Starboard abstraction layer.
            * **Type Tags (Use if no component tag applies):**
                * `ci`: Changes to CI/CD workflows.
                * `cleanup`: Code cleanup (e.g., removing unused code, style fixes).
                * `docs`: Documentation updates.
                * `feat`: A new feature.
                * `fix`: A bug fix.
                * `refactor`: Code refactoring without changing functionality.
                * `revert`: Reverting a previous commit.
                * `test`: For changes to tests (e.g., nplb, unit tests).

            Given your expertise with Cobalt/Chromium, infer the context of the changes to select the most relevant tag.

            **Analyze the following pull request information and generate the commit message:**

            **Pull Request URL:** ${{ github.event.issue.html_url }}
            **Pull Request Title:** ${{ github.event.issue.title }}
            **Original PR Description:**
            ${{ github.event.issue.body }}

            **Code Diff to Analyze:**
            ${{ steps.diff.outputs.diff_content }}
        run: |
          # Use jq to safely construct the JSON payload, reading the prompt from the environment variable.
          json_payload=$(jq -n --arg prompt "$PROMPT" '{ "contents": [ { "parts": [ { "text": $prompt } ] } ] }')

          # Make the API call to the Gemini model using curl.
          api_response=$(curl -s -X POST \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro-latest:generateContent?key=${{ secrets.GEMINI_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d "$json_payload")

          # --- DEBUGGING STEP ---
          # Print the raw API response to the logs to see what Gemini is actually returning.
          echo "--- RAW API RESPONSE ---"
          echo "$api_response"
          echo "--- END RAW API RESPONSE ---"

          # Extract only the text content from the API's JSON response using jq.
          # The 'jq -r' command outputs the raw string without quotes.
          # The fallback message provides clearer error handling if the response is unexpected.
          gemini_text_response=$(echo "$api_response" | jq -r '.candidates[0].content.parts[0].text // "Error: Could not parse a valid response from the Gemini API. Please check the API response logs in the workflow run."')

          # Set the final text as an output variable for the next step to use.
          echo "response<<EOF" >> $GITHUB_OUTPUT
          echo "$gemini_text_response" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Step 4: Post Gemini's generated commit message back to the PR.
      # This step now uses the direct response from the Gemini step.
      - name: 'Post Commit Message as Comment'
        uses: actions/github-script@v7
        with:
          script: |
            const body = `### ðŸ¤– Gemini Suggested Commit Message\n\n---\n\n\`\`\`\n${{ steps.gemini.outputs.response }}\n\`\`\``;
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });
