// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import {PageCallbackRouter} from 'chrome://contextual-tasks/contextual_tasks.mojom-webui.js';
import type {PageHandlerInterface, PageInterface, PageRemote, Tab} from 'chrome://contextual-tasks/contextual_tasks.mojom-webui.js';
import type {BrowserProxy} from 'chrome://contextual-tasks/contextual_tasks_browser_proxy.js';
import type {PostMessageHandler} from 'chrome://contextual-tasks/post_message_handler.js';
import type {PageHandler as ComposeboxPageHandler, PageHandlerFactory as ComposeboxPageHandlerFactory} from 'chrome://resources/cr_components/composebox/composebox.mojom-webui.js';
import type {Uuid} from 'chrome://resources/mojo/mojo/public/mojom/base/uuid.mojom-webui.js';
import type {Url} from 'chrome://resources/mojo/url/mojom/url.mojom-webui.js';
import {TestBrowserProxy} from 'chrome://webui-test/test_browser_proxy.js';

import {TestSearchboxPageHandler} from './test_searchbox_page_handler.js';
import {HANDSHAKE_RESPONSE_BYTES} from './test_utils.js';

class MockPage extends TestBrowserProxy implements PageInterface {
  private postMessageHandler_: PostMessageHandler|null = null;


  constructor() {
    super([
      'hideInput',
      'postMessageToWebview',
      'onAiPageStatusChanged',
      'onContextUpdated',
      'onHandshakeComplete',
      'onLensOverlayStateChanged',
      'onSidePanelStateChanged',
      'restoreInput',
      'setOAuthToken',
      'setTaskDetails',
      'setThreadTitle',
    ]);
  }

  setPostMessageHandler(handler: PostMessageHandler) {
    this.postMessageHandler_ = handler;
  }

  setThreadTitle(title: string) {
    this.methodCalled('setThreadTitle', title);
  }

  postMessageToWebview(message: number[]) {
    this.methodCalled('postMessageToWebview', message);
  }


  onContextUpdated(message: Tab[]) {
    this.methodCalled('onContextUpdated', message);
  }

  onHandshakeComplete() {
    this.methodCalled('onHandshakeComplete');
    if (this.postMessageHandler_) {
      this.postMessageHandler_.completeHandshake();
    }
  }

  onSidePanelStateChanged() {
    this.methodCalled('onSidePanelStateChanged');
  }

  // This name is generated by mojom, and the convention is to use OAuth, which
  // violates the linter check. To keep conventions, disable the linter here.
  // eslint-disable-next-line @typescript-eslint/naming-convention
  setOAuthToken(oauthToken: string) {
    this.methodCalled('setOAuthToken', oauthToken);
  }

  hideInput() {
    this.methodCalled('hideInput');
  }

  restoreInput() {
    this.methodCalled('restoreInput');
  }

  onZeroStateChange() {
    this.methodCalled('onZeroStateChange');
  }

  onAiPageStatusChanged(isAiPage: boolean) {
    this.methodCalled('onAiPageStatusChanged', isAiPage);
  }

  onLensOverlayStateChanged(isOverlayShowing: boolean) {
    this.methodCalled('onLensOverlayStateChanged', isOverlayShowing);
  }

  setTaskDetails(taskId: Uuid, threadId: string, turnId: string) {
    this.methodCalled('setTaskDetails', taskId, threadId, turnId);
  }

  showErrorPage() {
    this.methodCalled('showErrorPage');
  }

  hideErrorPage() {
    this.methodCalled('hideErrorPage');
  }
}

/**
 * Test version of the ContextualTasksPageHandler used to verify calls to the
 * browser from WebUI.
 */
class TestContextualTasksPageHandler extends TestBrowserProxy implements
    PageHandlerInterface {
  private url_: Url;
  private isInTab_: boolean = true;
  private page_: MockPage;

  constructor(url: string, page: MockPage) {
    super([
      'closeSidePanel',
      'getCommonSearchParams',
      'getRecentTabs',
      'getSearchUrl',
      'getThreadUrl',
      'getUrlForTask',
      'isShownInTab',
      'isZeroState',
      'moveTaskUiToNewTab',
      'onboardingTooltipDismissed',
      'onTabClickedFromSourcesMenu',
      'onWebviewMessage',
      'openHelpUi',
      'openMyActivityUi',
      'openOnboardingHelpUi',
      'setTaskId',
      'setThreadTitle',
      'showThreadHistory',
      'submitQuery',
    ]);

    this.url_ = {url};
    this.page_ = page;
  }

  getThreadUrl() {
    this.methodCalled('getThreadUrl');
    return Promise.resolve({url: this.url_});
  }

  getUrlForTask(uuid: Uuid) {
    this.methodCalled('getUrlForTask', uuid);
    return Promise.resolve({url: this.url_});
  }

  setTaskId(uuid: Uuid) {
    this.methodCalled('setTaskId', uuid);
  }

  setThreadTitle(title: string) {
    this.methodCalled('setThreadTitle', title);
  }

  closeSidePanel() {
    this.methodCalled('closeSidePanel');
  }

  showThreadHistory() {
    this.methodCalled('showThreadHistory');
  }

  setIsShownInTab(isInTab: boolean) {
    this.isInTab_ = isInTab;
  }

  isShownInTab() {
    this.methodCalled('isShownInTab');
    return Promise.resolve({isInTab: this.isInTab_});
  }

  isZeroState(url: Url) {
    this.methodCalled('isZeroState', url);
    return Promise.resolve({isZeroState: false});
  }

  openMyActivityUi() {
    this.methodCalled('openMyActivityUi');
  }

  openHelpUi() {
    this.methodCalled('openHelpUi');
  }

  openOnboardingHelpUi() {
    this.methodCalled('openOnboardingHelpUi');
  }

  onboardingTooltipDismissed() {
    this.methodCalled('onboardingTooltipDismissed');
  }

  moveTaskUiToNewTab() {
    this.methodCalled('moveTaskUiToNewTab');
  }

  // This name is generated by mojom, and the convention is to use OAuth, which
  // violates the linter check. To keep conventions, disable the linter here.
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getOAuthToken() {
    this.methodCalled('getOAuthToken');
    return Promise.resolve({oauthToken: 'fake_token'});
  }

  getRecentTabs() {
    this.methodCalled('getRecentTabs');
    return Promise.resolve({tabs: []});
  }

  getCommonSearchParams(isDarkMode: boolean, isSidePanel: boolean) {
    this.methodCalled('getCommonSearchParams', isDarkMode, isSidePanel);
    const params: {[key: string]: string} = {
      'hl': 'en-US',
      'cs': isDarkMode ? '1' : '0',
      'gsc': isSidePanel ? '2' : '',
    };
    return Promise.resolve({params});
  }

  onTabClickedFromSourcesMenu(tabId: number, url: Url) {
    this.methodCalled('onTabClickedFromSourcesMenu', tabId, url);
  }

  getSearchUrl(query: string) {
    this.methodCalled('getSearchUrl', query);
    return Promise.resolve({url: {url: 'https://test.com/?q=' + query}});
  }

  onWebviewMessage(message: number[]) {
    this.methodCalled('onWebviewMessage', message);
    // Simulate the C++ side calling onHandshakeComplete on the Page remote
    // if the message is a handshake response.
    const messageUint8 = new Uint8Array(message);
    let isHandshakeResponse =
        messageUint8.length === HANDSHAKE_RESPONSE_BYTES.length;
    if (isHandshakeResponse) {
      for (let i = 0; i < messageUint8.length; i++) {
        if (messageUint8[i] !== HANDSHAKE_RESPONSE_BYTES[i]) {
          isHandshakeResponse = false;
          break;
        }
      }
    }

    if (isHandshakeResponse) {
      this.page_.onHandshakeComplete();
    }
  }

  submitQuery(
      query: string, mouseButton: number, altKey: boolean, ctrlKey: boolean,
      metaKey: boolean, shiftKey: boolean) {
    this.methodCalled(
        'submitQuery', query, mouseButton, altKey, ctrlKey, metaKey, shiftKey);
    return Promise.resolve();
  }

  postMessageToWebview(message: number[]) {
    this.methodCalled('postMessageToWebview', message);
  }
}

/**
 * Test version of the BrowserProxy used in connecting the Contextual
 * Tasks page to the browser on start up.
 */
export class TestContextualTasksBrowserProxy extends TestBrowserProxy implements
    BrowserProxy, ComposeboxPageHandlerFactory {
  callbackRouter: PageCallbackRouter;
  handler: TestContextualTasksPageHandler;
  composeboxHandler: TestBrowserProxy&ComposeboxPageHandler;
  searchboxHandler: TestSearchboxPageHandler;
  page: MockPage;
  callbackRouterRemote: PageRemote;

  /**
   * @param url The URL to load in the webview.
   */
  constructor(url: string) {
    super([
      'createPageHandler',
    ]);
    this.callbackRouter = new PageCallbackRouter();
    this.page = new MockPage();
    this.handler = new TestContextualTasksPageHandler(url, this.page);
    this.composeboxHandler = new TestBrowserProxy();
    this.searchboxHandler = new TestSearchboxPageHandler();
    this.callbackRouterRemote =
        this.callbackRouter.$.bindNewPipeAndPassRemote();
  }

  createPageHandler() {
    this.methodCalled('createPageHandler');
    return {
      handler: this.handler,
      composeboxHandler: this.composeboxHandler,
      searchboxHandler: this.searchboxHandler,
    };
  }
}
