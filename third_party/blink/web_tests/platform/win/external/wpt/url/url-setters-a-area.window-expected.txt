This is a testharness.js-based test.
Found 435 tests; 247 PASS, 188 FAIL, 0 TIMEOUT, 0 NOTRUN.
PASS Loading data…
FAIL <a>: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged. assert_equals: expected "a://example.net" but got "file:///A://example.net"
FAIL <area>: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged. assert_equals: expected "a://example.net" but got "file:///A://example.net"
FAIL <a>: Setting <a://example.net>.protocol = 'b' assert_equals: expected "b://example.net" but got "file:///B:///A://example.net"
FAIL <area>: Setting <a://example.net>.protocol = 'b' assert_equals: expected "b://example.net" but got "file:///B:///A://example.net"
PASS <a>: Setting <javascript:alert(1)>.protocol = 'defuse'
PASS <area>: Setting <javascript:alert(1)>.protocol = 'defuse'
FAIL <a>: Setting <a://example.net>.protocol = 'B' Upper-case ASCII is lower-cased assert_equals: expected "b://example.net" but got "file:///B:///A://example.net"
FAIL <area>: Setting <a://example.net>.protocol = 'B' Upper-case ASCII is lower-cased assert_equals: expected "b://example.net" but got "file:///B:///A://example.net"
FAIL <a>: Setting <a://example.net>.protocol = 'é' Non-ASCII is rejected assert_equals: expected "a://example.net" but got "file:///A://example.net"
FAIL <area>: Setting <a://example.net>.protocol = 'é' Non-ASCII is rejected assert_equals: expected "a://example.net" but got "file:///A://example.net"
FAIL <a>: Setting <a://example.net>.protocol = '0b' No leading digit assert_equals: expected "a://example.net" but got "file:///A://example.net"
FAIL <area>: Setting <a://example.net>.protocol = '0b' No leading digit assert_equals: expected "a://example.net" but got "file:///A://example.net"
FAIL <a>: Setting <a://example.net>.protocol = '+b' No leading punctuation assert_equals: expected "a://example.net" but got "file:///A://example.net"
FAIL <area>: Setting <a://example.net>.protocol = '+b' No leading punctuation assert_equals: expected "a://example.net" but got "file:///A://example.net"
FAIL <a>: Setting <a://example.net>.protocol = 'bC0+-.' assert_equals: expected "bc0+-.://example.net" but got "bc0+-.:///A://example.net"
FAIL <area>: Setting <a://example.net>.protocol = 'bC0+-.' assert_equals: expected "bc0+-.://example.net" but got "bc0+-.:///A://example.net"
FAIL <a>: Setting <a://example.net>.protocol = 'b,c' Only some punctuation is acceptable assert_equals: expected "a://example.net" but got "file:///A://example.net"
FAIL <area>: Setting <a://example.net>.protocol = 'b,c' Only some punctuation is acceptable assert_equals: expected "a://example.net" but got "file:///A://example.net"
FAIL <a>: Setting <a://example.net>.protocol = 'bé' Non-ASCII is rejected assert_equals: expected "a://example.net" but got "file:///A://example.net"
FAIL <area>: Setting <a://example.net>.protocol = 'bé' Non-ASCII is rejected assert_equals: expected "a://example.net" but got "file:///A://example.net"
PASS <a>: Setting <http://test@example.net>.protocol = 'file' Can’t switch from URL containing username/password/port to file
PASS <area>: Setting <http://test@example.net>.protocol = 'file' Can’t switch from URL containing username/password/port to file
PASS <a>: Setting <https://example.net:1234>.protocol = 'file'
PASS <area>: Setting <https://example.net:1234>.protocol = 'file'
PASS <a>: Setting <wss://x:x@example.net:1234>.protocol = 'file'
PASS <area>: Setting <wss://x:x@example.net:1234>.protocol = 'file'
FAIL <a>: Setting <file://localhost/>.protocol = 'http' Can’t switch from file URL with no host assert_equals: expected "file:///" but got "http://localhost/"
FAIL <area>: Setting <file://localhost/>.protocol = 'http' Can’t switch from file URL with no host assert_equals: expected "file:///" but got "http://localhost/"
PASS <a>: Setting <file:///test>.protocol = 'https'
PASS <area>: Setting <file:///test>.protocol = 'https'
PASS <a>: Setting <file:>.protocol = 'wss'
PASS <area>: Setting <file:>.protocol = 'wss'
FAIL <a>: Setting <http://example.net>.protocol = 'b' Can’t switch from special scheme to non-special assert_equals: expected "http://example.net/" but got "file:///B://example.net/"
FAIL <area>: Setting <http://example.net>.protocol = 'b' Can’t switch from special scheme to non-special assert_equals: expected "http://example.net/" but got "file:///B://example.net/"
FAIL <a>: Setting <file://hi/path>.protocol = 's' assert_equals: expected "file://hi/path" but got "file:///S://hi/path"
FAIL <area>: Setting <file://hi/path>.protocol = 's' assert_equals: expected "file://hi/path" but got "file:///S://hi/path"
FAIL <a>: Setting <https://example.net>.protocol = 's' assert_equals: expected "https://example.net/" but got "file:///S://example.net/"
FAIL <area>: Setting <https://example.net>.protocol = 's' assert_equals: expected "https://example.net/" but got "file:///S://example.net/"
FAIL <a>: Setting <ftp://example.net>.protocol = 'test' assert_equals: expected "ftp://example.net/" but got "test://example.net/"
FAIL <area>: Setting <ftp://example.net>.protocol = 'test' assert_equals: expected "ftp://example.net/" but got "test://example.net/"
FAIL <a>: Setting <mailto:me@example.net>.protocol = 'http' Cannot-be-a-base URL doesn’t have a host, but URL in a special scheme must. assert_equals: expected "mailto:me@example.net" but got "http://me@example.net/"
FAIL <area>: Setting <mailto:me@example.net>.protocol = 'http' Cannot-be-a-base URL doesn’t have a host, but URL in a special scheme must. assert_equals: expected "mailto:me@example.net" but got "http://me@example.net/"
FAIL <a>: Setting <ssh://me@example.net>.protocol = 'http' Can’t switch from non-special scheme to special assert_equals: expected "ssh://me@example.net" but got "http://me@example.net/"
FAIL <area>: Setting <ssh://me@example.net>.protocol = 'http' Can’t switch from non-special scheme to special assert_equals: expected "ssh://me@example.net" but got "http://me@example.net/"
FAIL <a>: Setting <ssh://me@example.net>.protocol = 'https' assert_equals: expected "ssh://me@example.net" but got "https://me@example.net/"
FAIL <area>: Setting <ssh://me@example.net>.protocol = 'https' assert_equals: expected "ssh://me@example.net" but got "https://me@example.net/"
FAIL <a>: Setting <ssh://me@example.net>.protocol = 'file' assert_equals: expected "ssh://me@example.net" but got "file://me%40example.net/"
FAIL <area>: Setting <ssh://me@example.net>.protocol = 'file' assert_equals: expected "ssh://me@example.net" but got "file://me%40example.net/"
FAIL <a>: Setting <ssh://example.net>.protocol = 'file' assert_equals: expected "ssh://example.net" but got "file://example.net/"
FAIL <area>: Setting <ssh://example.net>.protocol = 'file' assert_equals: expected "ssh://example.net" but got "file://example.net/"
FAIL <a>: Setting <nonsense:///test>.protocol = 'https' assert_equals: expected "nonsense:///test" but got "https://test/"
FAIL <area>: Setting <nonsense:///test>.protocol = 'https' assert_equals: expected "nonsense:///test" but got "https://test/"
PASS <a>: Setting <http://example.net>.protocol = 'https:foo : bar' Stuff after the first ':' is ignored
PASS <area>: Setting <http://example.net>.protocol = 'https:foo : bar' Stuff after the first ':' is ignored
PASS <a>: Setting <data:text/html,<p>Test>.protocol = 'view-source+data:foo : bar' Stuff after the first ':' is ignored
PASS <area>: Setting <data:text/html,<p>Test>.protocol = 'view-source+data:foo : bar' Stuff after the first ':' is ignored
PASS <a>: Setting <http://foo.com:443/>.protocol = 'https' Port is set to null if it is the default for new scheme.
PASS <area>: Setting <http://foo.com:443/>.protocol = 'https' Port is set to null if it is the default for new scheme.
PASS <a>: Setting <file:///home/you/index.html>.username = 'me' No host means no username
PASS <area>: Setting <file:///home/you/index.html>.username = 'me' No host means no username
PASS <a>: Setting <unix:/run/foo.socket>.username = 'me' No host means no username
PASS <area>: Setting <unix:/run/foo.socket>.username = 'me' No host means no username
PASS <a>: Setting <mailto:you@example.net>.username = 'me' Cannot-be-a-base means no username
PASS <area>: Setting <mailto:you@example.net>.username = 'me' Cannot-be-a-base means no username
PASS <a>: Setting <javascript:alert(1)>.username = 'wario'
PASS <area>: Setting <javascript:alert(1)>.username = 'wario'
PASS <a>: Setting <http://example.net>.username = 'me'
PASS <area>: Setting <http://example.net>.username = 'me'
PASS <a>: Setting <http://:secret@example.net>.username = 'me'
PASS <area>: Setting <http://:secret@example.net>.username = 'me'
PASS <a>: Setting <http://me@example.net>.username = ''
PASS <area>: Setting <http://me@example.net>.username = ''
PASS <a>: Setting <http://me:secret@example.net>.username = ''
PASS <area>: Setting <http://me:secret@example.net>.username = ''
FAIL <a>: Setting <http://example.net>.username = '\0	
\r !"#$%&'()*+,-./09:;<=>?@AZ[\]^_`az{|}~Éé' UTF-8 percent encoding with the userinfo encode set. assert_equals: expected "http://%00%01%09%0A%0D%1F%20!%22%23$%&'()*+,-.%2F09%3A%3B%3C%3D%3E%3F%40AZ%5B%5C%5D%5E_%60az%7B%7C%7D~%7F%C2%80%C2%81%C3%89%C3%A9@example.net/" but got "http://%00%01%09%0A%0D%1F%20!%22%23$%&%27()*+,-.%2F09%3A%3B%3C%3D%3E%3F%40AZ%5B%5C%5D%5E_%60az%7B%7C%7D~%7F%C2%80%C2%81%C3%89%C3%A9@example.net/"
FAIL <area>: Setting <http://example.net>.username = '\0	
\r !"#$%&'()*+,-./09:;<=>?@AZ[\]^_`az{|}~Éé' UTF-8 percent encoding with the userinfo encode set. assert_equals: expected "http://%00%01%09%0A%0D%1F%20!%22%23$%&'()*+,-.%2F09%3A%3B%3C%3D%3E%3F%40AZ%5B%5C%5D%5E_%60az%7B%7C%7D~%7F%C2%80%C2%81%C3%89%C3%A9@example.net/" but got "http://%00%01%09%0A%0D%1F%20!%22%23$%&%27()*+,-.%2F09%3A%3B%3C%3D%3E%3F%40AZ%5B%5C%5D%5E_%60az%7B%7C%7D~%7F%C2%80%C2%81%C3%89%C3%A9@example.net/"
PASS <a>: Setting <http://example.net>.username = '%c3%89té' Bytes already percent-encoded are left as-is.
PASS <area>: Setting <http://example.net>.username = '%c3%89té' Bytes already percent-encoded are left as-is.
PASS <a>: Setting <sc:///>.username = 'x'
PASS <area>: Setting <sc:///>.username = 'x'
FAIL <a>: Setting <javascript://x/>.username = 'wario' assert_equals: expected "javascript://wario@x/" but got "javascript://x/"
FAIL <area>: Setting <javascript://x/>.username = 'wario' assert_equals: expected "javascript://wario@x/" but got "javascript://x/"
PASS <a>: Setting <file://test/>.username = 'test'
PASS <area>: Setting <file://test/>.username = 'test'
PASS <a>: Setting <file:///home/me/index.html>.password = 'secret' No host means no password
PASS <area>: Setting <file:///home/me/index.html>.password = 'secret' No host means no password
PASS <a>: Setting <unix:/run/foo.socket>.password = 'secret' No host means no password
PASS <area>: Setting <unix:/run/foo.socket>.password = 'secret' No host means no password
PASS <a>: Setting <mailto:me@example.net>.password = 'secret' Cannot-be-a-base means no password
PASS <area>: Setting <mailto:me@example.net>.password = 'secret' Cannot-be-a-base means no password
PASS <a>: Setting <http://example.net>.password = 'secret'
PASS <area>: Setting <http://example.net>.password = 'secret'
PASS <a>: Setting <http://me@example.net>.password = 'secret'
PASS <area>: Setting <http://me@example.net>.password = 'secret'
PASS <a>: Setting <http://:secret@example.net>.password = ''
PASS <area>: Setting <http://:secret@example.net>.password = ''
PASS <a>: Setting <http://me:secret@example.net>.password = ''
PASS <area>: Setting <http://me:secret@example.net>.password = ''
FAIL <a>: Setting <http://example.net>.password = '\0	
\r !"#$%&'()*+,-./09:;<=>?@AZ[\]^_`az{|}~Éé' UTF-8 percent encoding with the userinfo encode set. assert_equals: expected "http://:%00%01%09%0A%0D%1F%20!%22%23$%&'()*+,-.%2F09%3A%3B%3C%3D%3E%3F%40AZ%5B%5C%5D%5E_%60az%7B%7C%7D~%7F%C2%80%C2%81%C3%89%C3%A9@example.net/" but got "http://:%00%01%09%0A%0D%1F%20!%22%23$%&%27()*+,-.%2F09%3A%3B%3C%3D%3E%3F%40AZ%5B%5C%5D%5E_%60az%7B%7C%7D~%7F%C2%80%C2%81%C3%89%C3%A9@example.net/"
FAIL <area>: Setting <http://example.net>.password = '\0	
\r !"#$%&'()*+,-./09:;<=>?@AZ[\]^_`az{|}~Éé' UTF-8 percent encoding with the userinfo encode set. assert_equals: expected "http://:%00%01%09%0A%0D%1F%20!%22%23$%&'()*+,-.%2F09%3A%3B%3C%3D%3E%3F%40AZ%5B%5C%5D%5E_%60az%7B%7C%7D~%7F%C2%80%C2%81%C3%89%C3%A9@example.net/" but got "http://:%00%01%09%0A%0D%1F%20!%22%23$%&%27()*+,-.%2F09%3A%3B%3C%3D%3E%3F%40AZ%5B%5C%5D%5E_%60az%7B%7C%7D~%7F%C2%80%C2%81%C3%89%C3%A9@example.net/"
PASS <a>: Setting <http://example.net>.password = '%c3%89té' Bytes already percent-encoded are left as-is.
PASS <area>: Setting <http://example.net>.password = '%c3%89té' Bytes already percent-encoded are left as-is.
PASS <a>: Setting <sc:///>.password = 'x'
PASS <area>: Setting <sc:///>.password = 'x'
FAIL <a>: Setting <javascript://x/>.password = 'bowser' assert_equals: expected "javascript://:bowser@x/" but got "javascript://x/"
FAIL <area>: Setting <javascript://x/>.password = 'bowser' assert_equals: expected "javascript://:bowser@x/" but got "javascript://x/"
PASS <a>: Setting <file://test/>.password = 'test'
PASS <area>: Setting <file://test/>.password = 'test'
FAIL <a>: Setting <sc://x/>.host = '\0' Non-special scheme assert_equals: expected "x" but got ""
FAIL <area>: Setting <sc://x/>.host = '\0' Non-special scheme assert_equals: expected "x" but got ""
FAIL <a>: Setting <sc://x/>.host = '	' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <area>: Setting <sc://x/>.host = '	' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <a>: Setting <sc://x/>.host = '
' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <area>: Setting <sc://x/>.host = '
' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <a>: Setting <sc://x/>.host = '\r' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <area>: Setting <sc://x/>.host = '\r' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <a>: Setting <sc://x/>.host = ' ' assert_equals: expected "x" but got ""
FAIL <area>: Setting <sc://x/>.host = ' ' assert_equals: expected "x" but got ""
FAIL <a>: Setting <sc://x/>.host = '#' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <area>: Setting <sc://x/>.host = '#' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <a>: Setting <sc://x/>.host = '/' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <area>: Setting <sc://x/>.host = '/' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <a>: Setting <sc://x/>.host = '?' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <area>: Setting <sc://x/>.host = '?' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <a>: Setting <sc://x/>.host = '@' assert_equals: expected "x" but got ""
FAIL <area>: Setting <sc://x/>.host = '@' assert_equals: expected "x" but got ""
FAIL <a>: Setting <sc://x/>.host = 'ß' assert_equals: expected "sc://%C3%9F/" but got "sc://x/"
FAIL <area>: Setting <sc://x/>.host = 'ß' assert_equals: expected "sc://%C3%9F/" but got "sc://x/"
PASS <a>: Setting <https://x/>.host = 'ß' IDNA Nontransitional_Processing
PASS <area>: Setting <https://x/>.host = 'ß' IDNA Nontransitional_Processing
PASS <a>: Setting <mailto:me@example.net>.host = 'example.com' Cannot-be-a-base means no host
PASS <area>: Setting <mailto:me@example.net>.host = 'example.com' Cannot-be-a-base means no host
PASS <a>: Setting <data:text/plain,Stuff>.host = 'example.net' Cannot-be-a-base means no host
PASS <area>: Setting <data:text/plain,Stuff>.host = 'example.net' Cannot-be-a-base means no host
PASS <a>: Setting <http://example.net>.host = 'example.com:8080'
PASS <area>: Setting <http://example.net>.host = 'example.com:8080'
PASS <a>: Setting <http://example.net:8080>.host = 'example.com' Port number is unchanged if not specified in the new value
PASS <area>: Setting <http://example.net:8080>.host = 'example.com' Port number is unchanged if not specified in the new value
PASS <a>: Setting <http://example.net:8080>.host = 'example.com:' Port number is unchanged if not specified
PASS <area>: Setting <http://example.net:8080>.host = 'example.com:' Port number is unchanged if not specified
PASS <a>: Setting <http://example.net>.host = '' The empty host is not valid for special schemes
PASS <area>: Setting <http://example.net>.host = '' The empty host is not valid for special schemes
FAIL <a>: Setting <view-source+http://example.net/foo>.host = '' The empty host is OK for non-special schemes assert_equals: expected "view-source+http:///foo" but got "view-source+http://example.net/foo"
FAIL <area>: Setting <view-source+http://example.net/foo>.host = '' The empty host is OK for non-special schemes assert_equals: expected "view-source+http:///foo" but got "view-source+http://example.net/foo"
FAIL <a>: Setting <a:/foo>.host = 'example.net' Path-only URLs can gain a host assert_equals: expected "a://example.net/foo" but got "file://example.net/A:/foo"
FAIL <area>: Setting <a:/foo>.host = 'example.net' Path-only URLs can gain a host assert_equals: expected "a://example.net/foo" but got "file://example.net/A:/foo"
PASS <a>: Setting <http://example.net>.host = '0x7F000001:8080' IPv4 address syntax is normalized
PASS <area>: Setting <http://example.net>.host = '0x7F000001:8080' IPv4 address syntax is normalized
PASS <a>: Setting <http://example.net>.host = '[::0:01]:2' IPv6 address syntax is normalized
PASS <area>: Setting <http://example.net>.host = '[::0:01]:2' IPv6 address syntax is normalized
PASS <a>: Setting <http://example.net>.host = '[2001:db8::2]:4002' IPv6 literal address with port, crbug.com/1012416
PASS <area>: Setting <http://example.net>.host = '[2001:db8::2]:4002' IPv6 literal address with port, crbug.com/1012416
PASS <a>: Setting <http://example.net>.host = 'example.com:80' Default port number is removed
PASS <area>: Setting <http://example.net>.host = 'example.com:80' Default port number is removed
PASS <a>: Setting <https://example.net>.host = 'example.com:443' Default port number is removed
PASS <area>: Setting <https://example.net>.host = 'example.com:443' Default port number is removed
PASS <a>: Setting <https://example.net>.host = 'example.com:80' Default port number is only removed for the relevant scheme
PASS <area>: Setting <https://example.net>.host = 'example.com:80' Default port number is only removed for the relevant scheme
PASS <a>: Setting <http://example.net:8080>.host = 'example.com:80' Port number is removed if new port is scheme default and existing URL has a non-default port
PASS <area>: Setting <http://example.net:8080>.host = 'example.com:80' Port number is removed if new port is scheme default and existing URL has a non-default port
PASS <a>: Setting <http://example.net/path>.host = 'example.com/stuff' Stuff after a / delimiter is ignored
PASS <area>: Setting <http://example.net/path>.host = 'example.com/stuff' Stuff after a / delimiter is ignored
PASS <a>: Setting <http://example.net/path>.host = 'example.com:8080/stuff' Stuff after a / delimiter is ignored
PASS <area>: Setting <http://example.net/path>.host = 'example.com:8080/stuff' Stuff after a / delimiter is ignored
PASS <a>: Setting <http://example.net/path>.host = 'example.com?stuff' Stuff after a ? delimiter is ignored
PASS <area>: Setting <http://example.net/path>.host = 'example.com?stuff' Stuff after a ? delimiter is ignored
PASS <a>: Setting <http://example.net/path>.host = 'example.com:8080?stuff' Stuff after a ? delimiter is ignored
PASS <area>: Setting <http://example.net/path>.host = 'example.com:8080?stuff' Stuff after a ? delimiter is ignored
PASS <a>: Setting <http://example.net/path>.host = 'example.com#stuff' Stuff after a # delimiter is ignored
PASS <area>: Setting <http://example.net/path>.host = 'example.com#stuff' Stuff after a # delimiter is ignored
PASS <a>: Setting <http://example.net/path>.host = 'example.com:8080#stuff' Stuff after a # delimiter is ignored
PASS <area>: Setting <http://example.net/path>.host = 'example.com:8080#stuff' Stuff after a # delimiter is ignored
PASS <a>: Setting <http://example.net/path>.host = 'example.com\stuff' Stuff after a \ delimiter is ignored for special schemes
PASS <area>: Setting <http://example.net/path>.host = 'example.com\stuff' Stuff after a \ delimiter is ignored for special schemes
PASS <a>: Setting <http://example.net/path>.host = 'example.com:8080\stuff' Stuff after a \ delimiter is ignored for special schemes
PASS <area>: Setting <http://example.net/path>.host = 'example.com:8080\stuff' Stuff after a \ delimiter is ignored for special schemes
FAIL <a>: Setting <view-source+http://example.net/path>.host = 'example.com\stuff' \ is not a delimiter for non-special schemes, but still forbidden in hosts assert_equals: expected "example.net" but got ""
FAIL <area>: Setting <view-source+http://example.net/path>.host = 'example.com\stuff' \ is not a delimiter for non-special schemes, but still forbidden in hosts assert_equals: expected "example.net" but got ""
FAIL <a>: Setting <view-source+http://example.net/path>.host = 'example.com:8080stuff2' Anything other than ASCII digit stops the port parser in a setter but is not an error assert_equals: expected "view-source+http://example.com:8080/path" but got "view-source+http://example.net/path"
FAIL <area>: Setting <view-source+http://example.net/path>.host = 'example.com:8080stuff2' Anything other than ASCII digit stops the port parser in a setter but is not an error assert_equals: expected "view-source+http://example.com:8080/path" but got "view-source+http://example.net/path"
PASS <a>: Setting <http://example.net/path>.host = 'example.com:8080stuff2' Anything other than ASCII digit stops the port parser in a setter but is not an error
PASS <area>: Setting <http://example.net/path>.host = 'example.com:8080stuff2' Anything other than ASCII digit stops the port parser in a setter but is not an error
PASS <a>: Setting <http://example.net/path>.host = 'example.com:8080+2' Anything other than ASCII digit stops the port parser in a setter but is not an error
PASS <area>: Setting <http://example.net/path>.host = 'example.com:8080+2' Anything other than ASCII digit stops the port parser in a setter but is not an error
PASS <a>: Setting <http://example.net/path>.host = 'example.com:65535' Port numbers are 16 bit integers
PASS <area>: Setting <http://example.net/path>.host = 'example.com:65535' Port numbers are 16 bit integers
PASS <a>: Setting <http://example.net/path>.host = 'example.com:65536' Port numbers are 16 bit integers, overflowing is an error. Hostname is still set, though.
PASS <area>: Setting <http://example.net/path>.host = 'example.com:65536' Port numbers are 16 bit integers, overflowing is an error. Hostname is still set, though.
PASS <a>: Setting <http://example.net/>.host = '[google.com]' Broken IPv6
PASS <area>: Setting <http://example.net/>.host = '[google.com]' Broken IPv6
PASS <a>: Setting <http://example.net/>.host = '[::1.2.3.4x]'
PASS <area>: Setting <http://example.net/>.host = '[::1.2.3.4x]'
FAIL <a>: Setting <http://example.net/>.host = '[::1.2.3.]' assert_equals: expected "http://example.net/" but got "http://[::102:3]/"
FAIL <area>: Setting <http://example.net/>.host = '[::1.2.3.]' assert_equals: expected "http://example.net/" but got "http://[::102:3]/"
FAIL <a>: Setting <http://example.net/>.host = '[::1.2.]' assert_equals: expected "http://example.net/" but got "http://[::100:2]/"
FAIL <area>: Setting <http://example.net/>.host = '[::1.2.]' assert_equals: expected "http://example.net/" but got "http://[::100:2]/"
FAIL <a>: Setting <http://example.net/>.host = '[::1.]' assert_equals: expected "http://example.net/" but got "http://[::1]/"
FAIL <area>: Setting <http://example.net/>.host = '[::1.]' assert_equals: expected "http://example.net/" but got "http://[::1]/"
FAIL <a>: Setting <file://y/>.host = 'x:123' assert_equals: expected "file://y/" but got "file://x/"
FAIL <area>: Setting <file://y/>.host = 'x:123' assert_equals: expected "file://y/" but got "file://x/"
FAIL <a>: Setting <file://y/>.host = 'loc%41lhost' assert_equals: expected "file:///" but got "file://localhost/"
FAIL <area>: Setting <file://y/>.host = 'loc%41lhost' assert_equals: expected "file:///" but got "file://localhost/"
FAIL <a>: Setting <file://hi/x>.host = '' assert_equals: expected "file:///x" but got "file://hi/x"
FAIL <area>: Setting <file://hi/x>.host = '' assert_equals: expected "file:///x" but got "file://hi/x"
FAIL <a>: Setting <sc://test@test/>.host = '' assert_equals: expected "test" but got ""
FAIL <area>: Setting <sc://test@test/>.host = '' assert_equals: expected "test" but got ""
FAIL <a>: Setting <sc://test:12/>.host = '' assert_equals: expected "test:12" but got ""
FAIL <area>: Setting <sc://test:12/>.host = '' assert_equals: expected "test:12" but got ""
PASS <a>: Setting <http://example.com/>.host = '///bad.com' Leading / is not stripped
PASS <area>: Setting <http://example.com/>.host = '///bad.com' Leading / is not stripped
FAIL <a>: Setting <sc://example.com/>.host = '///bad.com' Leading / is not stripped assert_equals: expected "sc:///" but got "sc://example.com/"
FAIL <area>: Setting <sc://example.com/>.host = '///bad.com' Leading / is not stripped assert_equals: expected "sc:///" but got "sc://example.com/"
FAIL <a>: Setting <sc://x/>.hostname = '\0' Non-special scheme assert_equals: expected "x" but got ""
FAIL <area>: Setting <sc://x/>.hostname = '\0' Non-special scheme assert_equals: expected "x" but got ""
FAIL <a>: Setting <sc://x/>.hostname = '	' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <area>: Setting <sc://x/>.hostname = '	' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <a>: Setting <sc://x/>.hostname = '
' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <area>: Setting <sc://x/>.hostname = '
' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <a>: Setting <sc://x/>.hostname = '\r' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <area>: Setting <sc://x/>.hostname = '\r' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <a>: Setting <sc://x/>.hostname = ' ' assert_equals: expected "x" but got ""
FAIL <area>: Setting <sc://x/>.hostname = ' ' assert_equals: expected "x" but got ""
FAIL <a>: Setting <sc://x/>.hostname = '#' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <area>: Setting <sc://x/>.hostname = '#' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <a>: Setting <sc://x/>.hostname = '/' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <area>: Setting <sc://x/>.hostname = '/' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <a>: Setting <sc://x/>.hostname = '?' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <area>: Setting <sc://x/>.hostname = '?' assert_equals: expected "sc:///" but got "sc://x/"
FAIL <a>: Setting <sc://x/>.hostname = '@' assert_equals: expected "x" but got ""
FAIL <area>: Setting <sc://x/>.hostname = '@' assert_equals: expected "x" but got ""
PASS <a>: Setting <mailto:me@example.net>.hostname = 'example.com' Cannot-be-a-base means no host
PASS <area>: Setting <mailto:me@example.net>.hostname = 'example.com' Cannot-be-a-base means no host
PASS <a>: Setting <data:text/plain,Stuff>.hostname = 'example.net' Cannot-be-a-base means no host
PASS <area>: Setting <data:text/plain,Stuff>.hostname = 'example.net' Cannot-be-a-base means no host
PASS <a>: Setting <http://example.net:8080>.hostname = 'example.com'
PASS <area>: Setting <http://example.net:8080>.hostname = 'example.com'
PASS <a>: Setting <http://example.net>.hostname = '' The empty host is not valid for special schemes
PASS <area>: Setting <http://example.net>.hostname = '' The empty host is not valid for special schemes
FAIL <a>: Setting <view-source+http://example.net/foo>.hostname = '' The empty host is OK for non-special schemes assert_equals: expected "view-source+http:///foo" but got "view-source+http://example.net/foo"
FAIL <area>: Setting <view-source+http://example.net/foo>.hostname = '' The empty host is OK for non-special schemes assert_equals: expected "view-source+http:///foo" but got "view-source+http://example.net/foo"
FAIL <a>: Setting <a:/foo>.hostname = 'example.net' Path-only URLs can gain a host assert_equals: expected "a://example.net/foo" but got "file://example.net/A:/foo"
FAIL <area>: Setting <a:/foo>.hostname = 'example.net' Path-only URLs can gain a host assert_equals: expected "a://example.net/foo" but got "file://example.net/A:/foo"
PASS <a>: Setting <http://example.net:8080>.hostname = '0x7F000001' IPv4 address syntax is normalized
PASS <area>: Setting <http://example.net:8080>.hostname = '0x7F000001' IPv4 address syntax is normalized
PASS <a>: Setting <http://example.net>.hostname = '[::0:01]' IPv6 address syntax is normalized
PASS <area>: Setting <http://example.net>.hostname = '[::0:01]' IPv6 address syntax is normalized
PASS <a>: Setting <http://example.net/path>.hostname = 'example.com:8080' : delimiter invalidates entire value
PASS <area>: Setting <http://example.net/path>.hostname = 'example.com:8080' : delimiter invalidates entire value
PASS <a>: Setting <http://example.net:8080/path>.hostname = 'example.com:' : delimiter invalidates entire value
PASS <area>: Setting <http://example.net:8080/path>.hostname = 'example.com:' : delimiter invalidates entire value
PASS <a>: Setting <http://example.net/path>.hostname = 'example.com/stuff' Stuff after a / delimiter is ignored
PASS <area>: Setting <http://example.net/path>.hostname = 'example.com/stuff' Stuff after a / delimiter is ignored
PASS <a>: Setting <http://example.net/path>.hostname = 'example.com?stuff' Stuff after a ? delimiter is ignored
PASS <area>: Setting <http://example.net/path>.hostname = 'example.com?stuff' Stuff after a ? delimiter is ignored
PASS <a>: Setting <http://example.net/path>.hostname = 'example.com#stuff' Stuff after a # delimiter is ignored
PASS <area>: Setting <http://example.net/path>.hostname = 'example.com#stuff' Stuff after a # delimiter is ignored
PASS <a>: Setting <http://example.net/path>.hostname = 'example.com\stuff' Stuff after a \ delimiter is ignored for special schemes
PASS <area>: Setting <http://example.net/path>.hostname = 'example.com\stuff' Stuff after a \ delimiter is ignored for special schemes
FAIL <a>: Setting <view-source+http://example.net/path>.hostname = 'example.com\stuff' \ is not a delimiter for non-special schemes, but still forbidden in hosts assert_equals: expected "example.net" but got ""
FAIL <area>: Setting <view-source+http://example.net/path>.hostname = 'example.com\stuff' \ is not a delimiter for non-special schemes, but still forbidden in hosts assert_equals: expected "example.net" but got ""
PASS <a>: Setting <http://example.net/>.hostname = '[google.com]' Broken IPv6
PASS <area>: Setting <http://example.net/>.hostname = '[google.com]' Broken IPv6
PASS <a>: Setting <http://example.net/>.hostname = '[::1.2.3.4x]'
PASS <area>: Setting <http://example.net/>.hostname = '[::1.2.3.4x]'
FAIL <a>: Setting <http://example.net/>.hostname = '[::1.2.3.]' assert_equals: expected "http://example.net/" but got "http://[::102:3]/"
FAIL <area>: Setting <http://example.net/>.hostname = '[::1.2.3.]' assert_equals: expected "http://example.net/" but got "http://[::102:3]/"
FAIL <a>: Setting <http://example.net/>.hostname = '[::1.2.]' assert_equals: expected "http://example.net/" but got "http://[::100:2]/"
FAIL <area>: Setting <http://example.net/>.hostname = '[::1.2.]' assert_equals: expected "http://example.net/" but got "http://[::100:2]/"
FAIL <a>: Setting <http://example.net/>.hostname = '[::1.]' assert_equals: expected "http://example.net/" but got "http://[::1]/"
FAIL <area>: Setting <http://example.net/>.hostname = '[::1.]' assert_equals: expected "http://example.net/" but got "http://[::1]/"
PASS <a>: Setting <file://y/>.hostname = 'x:123'
PASS <area>: Setting <file://y/>.hostname = 'x:123'
FAIL <a>: Setting <file://y/>.hostname = 'loc%41lhost' assert_equals: expected "file:///" but got "file://localhost/"
FAIL <area>: Setting <file://y/>.hostname = 'loc%41lhost' assert_equals: expected "file:///" but got "file://localhost/"
FAIL <a>: Setting <file://hi/x>.hostname = '' assert_equals: expected "file:///x" but got "file://hi/x"
FAIL <area>: Setting <file://hi/x>.hostname = '' assert_equals: expected "file:///x" but got "file://hi/x"
FAIL <a>: Setting <sc://test@test/>.hostname = '' assert_equals: expected "test" but got ""
FAIL <area>: Setting <sc://test@test/>.hostname = '' assert_equals: expected "test" but got ""
FAIL <a>: Setting <sc://test:12/>.hostname = '' assert_equals: expected "test:12" but got ""
FAIL <area>: Setting <sc://test:12/>.hostname = '' assert_equals: expected "test:12" but got ""
FAIL <a>: Setting <non-spec:/.//p>.hostname = 'h' Drop /. from path assert_equals: expected "non-spec://h//p" but got "non-spec:/.//p"
FAIL <area>: Setting <non-spec:/.//p>.hostname = 'h' Drop /. from path assert_equals: expected "non-spec://h//p" but got "non-spec:/.//p"
FAIL <a>: Setting <non-spec:/.//p>.hostname = '' assert_equals: expected "non-spec:////p" but got "non-spec:/.//p"
FAIL <area>: Setting <non-spec:/.//p>.hostname = '' assert_equals: expected "non-spec:////p" but got "non-spec:/.//p"
PASS <a>: Setting <http://example.com/>.hostname = '///bad.com' Leading / is not stripped
PASS <area>: Setting <http://example.com/>.hostname = '///bad.com' Leading / is not stripped
FAIL <a>: Setting <sc://example.com/>.hostname = '///bad.com' Leading / is not stripped assert_equals: expected "sc:///" but got "sc://example.com/"
FAIL <area>: Setting <sc://example.com/>.hostname = '///bad.com' Leading / is not stripped assert_equals: expected "sc:///" but got "sc://example.com/"
PASS <a>: Setting <http://example.net>.port = '8080'
PASS <area>: Setting <http://example.net>.port = '8080'
PASS <a>: Setting <http://example.net:8080>.port = '' Port number is removed if empty is the new value
PASS <area>: Setting <http://example.net:8080>.port = '' Port number is removed if empty is the new value
PASS <a>: Setting <http://example.net:8080>.port = '80' Default port number is removed
PASS <area>: Setting <http://example.net:8080>.port = '80' Default port number is removed
PASS <a>: Setting <https://example.net:4433>.port = '443' Default port number is removed
PASS <area>: Setting <https://example.net:4433>.port = '443' Default port number is removed
PASS <a>: Setting <https://example.net>.port = '80' Default port number is only removed for the relevant scheme
PASS <area>: Setting <https://example.net>.port = '80' Default port number is only removed for the relevant scheme
PASS <a>: Setting <http://example.net/path>.port = '8080/stuff' Stuff after a / delimiter is ignored
PASS <area>: Setting <http://example.net/path>.port = '8080/stuff' Stuff after a / delimiter is ignored
PASS <a>: Setting <http://example.net/path>.port = '8080?stuff' Stuff after a ? delimiter is ignored
PASS <area>: Setting <http://example.net/path>.port = '8080?stuff' Stuff after a ? delimiter is ignored
PASS <a>: Setting <http://example.net/path>.port = '8080#stuff' Stuff after a # delimiter is ignored
PASS <area>: Setting <http://example.net/path>.port = '8080#stuff' Stuff after a # delimiter is ignored
PASS <a>: Setting <http://example.net/path>.port = '8080\stuff' Stuff after a \ delimiter is ignored for special schemes
PASS <area>: Setting <http://example.net/path>.port = '8080\stuff' Stuff after a \ delimiter is ignored for special schemes
FAIL <a>: Setting <view-source+http://example.net/path>.port = '8080stuff2' Anything other than ASCII digit stops the port parser in a setter but is not an error assert_equals: expected "view-source+http://example.net:8080/path" but got "view-source+http://example.net/path"
FAIL <area>: Setting <view-source+http://example.net/path>.port = '8080stuff2' Anything other than ASCII digit stops the port parser in a setter but is not an error assert_equals: expected "view-source+http://example.net:8080/path" but got "view-source+http://example.net/path"
PASS <a>: Setting <http://example.net/path>.port = '8080stuff2' Anything other than ASCII digit stops the port parser in a setter but is not an error
PASS <area>: Setting <http://example.net/path>.port = '8080stuff2' Anything other than ASCII digit stops the port parser in a setter but is not an error
PASS <a>: Setting <http://example.net/path>.port = '8080+2' Anything other than ASCII digit stops the port parser in a setter but is not an error
PASS <area>: Setting <http://example.net/path>.port = '8080+2' Anything other than ASCII digit stops the port parser in a setter but is not an error
PASS <a>: Setting <http://example.net/path>.port = '65535' Port numbers are 16 bit integers
PASS <area>: Setting <http://example.net/path>.port = '65535' Port numbers are 16 bit integers
FAIL <a>: Setting <http://example.net:8080/path>.port = '65536' Port numbers are 16 bit integers, overflowing is an error assert_equals: expected "http://example.net:8080/path" but got "http://example.net:0/path"
FAIL <area>: Setting <http://example.net:8080/path>.port = '65536' Port numbers are 16 bit integers, overflowing is an error assert_equals: expected "http://example.net:8080/path" but got "http://example.net:0/path"
FAIL <a>: Setting <non-special://example.net:8080/path>.port = '65536' Port numbers are 16 bit integers, overflowing is an error assert_equals: expected "example.net:8080" but got ""
FAIL <area>: Setting <non-special://example.net:8080/path>.port = '65536' Port numbers are 16 bit integers, overflowing is an error assert_equals: expected "example.net:8080" but got ""
PASS <a>: Setting <file://test/>.port = '12'
PASS <area>: Setting <file://test/>.port = '12'
FAIL <a>: Setting <file://localhost/>.port = '12' assert_equals: expected "file:///" but got "file://localhost/"
FAIL <area>: Setting <file://localhost/>.port = '12' assert_equals: expected "file:///" but got "file://localhost/"
PASS <a>: Setting <non-base:value>.port = '12'
PASS <area>: Setting <non-base:value>.port = '12'
PASS <a>: Setting <sc:///>.port = '12'
PASS <area>: Setting <sc:///>.port = '12'
FAIL <a>: Setting <sc://x/>.port = '12' assert_equals: expected "sc://x:12/" but got "sc://x/"
FAIL <area>: Setting <sc://x/>.port = '12' assert_equals: expected "sc://x:12/" but got "sc://x/"
FAIL <a>: Setting <javascript://x/>.port = '12' assert_equals: expected "javascript://x:12/" but got "javascript://x/"
FAIL <area>: Setting <javascript://x/>.port = '12' assert_equals: expected "javascript://x:12/" but got "javascript://x/"
PASS <a>: Setting <mailto:me@example.net>.pathname = '/foo' Cannot-be-a-base don’t have a path
PASS <area>: Setting <mailto:me@example.net>.pathname = '/foo' Cannot-be-a-base don’t have a path
PASS <a>: Setting <file:///some/path>.pathname = '' Special URLs cannot have their paths erased
PASS <area>: Setting <file:///some/path>.pathname = '' Special URLs cannot have their paths erased
FAIL <a>: Setting <foo://somehost/some/path>.pathname = '' Non-special URLs can have their paths erased assert_equals: expected "foo://somehost" but got "foo://somehost/some/path"
FAIL <area>: Setting <foo://somehost/some/path>.pathname = '' Non-special URLs can have their paths erased assert_equals: expected "foo://somehost" but got "foo://somehost/some/path"
FAIL <a>: Setting <foo:///some/path>.pathname = '' Non-special URLs with an empty host can have their paths erased assert_equals: expected "foo://" but got "foo:///some/path"
FAIL <area>: Setting <foo:///some/path>.pathname = '' Non-special URLs with an empty host can have their paths erased assert_equals: expected "foo://" but got "foo:///some/path"
FAIL <a>: Setting <foo:/some/path>.pathname = '' Path-only URLs cannot have their paths erased assert_equals: expected "foo:/" but got "foo:/some/path"
FAIL <area>: Setting <foo:/some/path>.pathname = '' Path-only URLs cannot have their paths erased assert_equals: expected "foo:/" but got "foo:/some/path"
FAIL <a>: Setting <foo:/some/path>.pathname = 'test' Path-only URLs always have an initial slash assert_equals: expected "foo:/test" but got "foo:/some/path"
FAIL <area>: Setting <foo:/some/path>.pathname = 'test' Path-only URLs always have an initial slash assert_equals: expected "foo:/test" but got "foo:/some/path"
FAIL <a>: Setting <unix:/run/foo.socket?timeout=10>.pathname = '/var/log/../run/bar.socket' assert_equals: expected "unix:/var/run/bar.socket?timeout=10" but got "unix:/run/foo.socket?timeout=10"
FAIL <area>: Setting <unix:/run/foo.socket?timeout=10>.pathname = '/var/log/../run/bar.socket' assert_equals: expected "unix:/var/run/bar.socket?timeout=10" but got "unix:/run/foo.socket?timeout=10"
PASS <a>: Setting <https://example.net#nav>.pathname = 'home'
PASS <area>: Setting <https://example.net#nav>.pathname = 'home'
PASS <a>: Setting <https://example.net#nav>.pathname = '../home'
PASS <area>: Setting <https://example.net#nav>.pathname = '../home'
PASS <a>: Setting <http://example.net/home?lang=fr#nav>.pathname = '\a\%2E\b\%2e.\c' \ is a segment delimiter for 'special' URLs
PASS <area>: Setting <http://example.net/home?lang=fr#nav>.pathname = '\a\%2E\b\%2e.\c' \ is a segment delimiter for 'special' URLs
FAIL <a>: Setting <view-source+http://example.net/home?lang=fr#nav>.pathname = '\a\%2E\b\%2e.\c' \ is *not* a segment delimiter for non-'special' URLs assert_equals: expected "view-source+http://example.net/\\a\\%2E\\b\\%2e.\\c?lang=fr#nav" but got "view-source+http://example.net/home?lang=fr#nav"
FAIL <area>: Setting <view-source+http://example.net/home?lang=fr#nav>.pathname = '\a\%2E\b\%2e.\c' \ is *not* a segment delimiter for non-'special' URLs assert_equals: expected "view-source+http://example.net/\\a\\%2E\\b\\%2e.\\c?lang=fr#nav" but got "view-source+http://example.net/home?lang=fr#nav"
FAIL <a>: Setting <a:/>.pathname = '\0	
\r !"#$%&'()*+,-./09:;<=>?@AZ[\]^_`az{|}~Éé' UTF-8 percent encoding with the default encode set. Tabs and newlines are removed. assert_equals: expected "a:/%00%01%1F%20!%22%23$%&'()*+,-./09:;%3C=%3E%3F@AZ[\\]^_%60az%7B|%7D~%7F%C2%80%C2%81%C3%89%C3%A9" but got "file:///A:/"
FAIL <area>: Setting <a:/>.pathname = '\0	
\r !"#$%&'()*+,-./09:;<=>?@AZ[\]^_`az{|}~Éé' UTF-8 percent encoding with the default encode set. Tabs and newlines are removed. assert_equals: expected "a:/%00%01%1F%20!%22%23$%&'()*+,-./09:;%3C=%3E%3F@AZ[\\]^_%60az%7B|%7D~%7F%C2%80%C2%81%C3%89%C3%A9" but got "file:///A:/"
FAIL <a>: Setting <http://example.net>.pathname = '%2e%2E%c3%89té' Bytes already percent-encoded are left as-is, including %2E outside dotted segments. assert_equals: expected "http://example.net/%2e%2E%c3%89t%C3%A9" but got "http://example.net/..%c3%89t%C3%A9"
FAIL <area>: Setting <http://example.net>.pathname = '%2e%2E%c3%89té' Bytes already percent-encoded are left as-is, including %2E outside dotted segments. assert_equals: expected "http://example.net/%2e%2E%c3%89t%C3%A9" but got "http://example.net/..%c3%89t%C3%A9"
PASS <a>: Setting <http://example.net>.pathname = '?' ? needs to be encoded
PASS <area>: Setting <http://example.net>.pathname = '?' ? needs to be encoded
PASS <a>: Setting <http://example.net>.pathname = '#' # needs to be encoded
PASS <area>: Setting <http://example.net>.pathname = '#' # needs to be encoded
FAIL <a>: Setting <sc://example.net>.pathname = '?' ? needs to be encoded, non-special scheme assert_equals: expected "sc://example.net/%3F" but got "sc://example.net"
FAIL <area>: Setting <sc://example.net>.pathname = '?' ? needs to be encoded, non-special scheme assert_equals: expected "sc://example.net/%3F" but got "sc://example.net"
FAIL <a>: Setting <sc://example.net>.pathname = '#' # needs to be encoded, non-special scheme assert_equals: expected "sc://example.net/%23" but got "sc://example.net"
FAIL <area>: Setting <sc://example.net>.pathname = '#' # needs to be encoded, non-special scheme assert_equals: expected "sc://example.net/%23" but got "sc://example.net"
PASS <a>: Setting <http://example.net>.pathname = '/?é' ? doesn't mess up encoding
PASS <area>: Setting <http://example.net>.pathname = '/?é' ? doesn't mess up encoding
PASS <a>: Setting <http://example.net>.pathname = '/#é' # doesn't mess up encoding
PASS <area>: Setting <http://example.net>.pathname = '/#é' # doesn't mess up encoding
PASS <a>: Setting <file://monkey/>.pathname = '\\' File URLs and (back)slashes
PASS <area>: Setting <file://monkey/>.pathname = '\\' File URLs and (back)slashes
FAIL <a>: Setting <file:///unicorn>.pathname = '//\/' File URLs and (back)slashes assert_equals: expected "file://////" but got "file:///"
FAIL <area>: Setting <file:///unicorn>.pathname = '//\/' File URLs and (back)slashes assert_equals: expected "file://////" but got "file:///"
FAIL <a>: Setting <file:///unicorn>.pathname = '//monkey/..//' File URLs and (back)slashes assert_equals: expected "file://///" but got "file:///"
FAIL <area>: Setting <file:///unicorn>.pathname = '//monkey/..//' File URLs and (back)slashes assert_equals: expected "file://///" but got "file:///"
FAIL <a>: Setting <non-spec:/>.pathname = '/.//p' Serialize /. in path assert_equals: expected "non-spec:/.//p" but got "non-spec:/"
FAIL <area>: Setting <non-spec:/>.pathname = '/.//p' Serialize /. in path assert_equals: expected "non-spec:/.//p" but got "non-spec:/"
FAIL <a>: Setting <non-spec:/>.pathname = '/..//p' assert_equals: expected "non-spec:/.//p" but got "non-spec:/"
FAIL <area>: Setting <non-spec:/>.pathname = '/..//p' assert_equals: expected "non-spec:/.//p" but got "non-spec:/"
FAIL <a>: Setting <non-spec:/>.pathname = '//p' assert_equals: expected "non-spec:/.//p" but got "non-spec:/"
FAIL <area>: Setting <non-spec:/>.pathname = '//p' assert_equals: expected "non-spec:/.//p" but got "non-spec:/"
FAIL <a>: Setting <non-spec:/.//>.pathname = 'p' Drop /. from path assert_equals: expected "non-spec:/p" but got "non-spec:/.//"
FAIL <area>: Setting <non-spec:/.//>.pathname = 'p' Drop /. from path assert_equals: expected "non-spec:/p" but got "non-spec:/.//"
PASS <a>: Setting <https://example.net#nav>.search = 'lang=fr'
PASS <area>: Setting <https://example.net#nav>.search = 'lang=fr'
PASS <a>: Setting <https://example.net?lang=en-US#nav>.search = 'lang=fr'
PASS <area>: Setting <https://example.net?lang=en-US#nav>.search = 'lang=fr'
PASS <a>: Setting <https://example.net?lang=en-US#nav>.search = '?lang=fr'
PASS <area>: Setting <https://example.net?lang=en-US#nav>.search = '?lang=fr'
PASS <a>: Setting <https://example.net?lang=en-US#nav>.search = '??lang=fr'
PASS <area>: Setting <https://example.net?lang=en-US#nav>.search = '??lang=fr'
FAIL <a>: Setting <https://example.net?lang=en-US#nav>.search = '?' assert_equals: expected "https://example.net/?#nav" but got "https://example.net/#nav"
FAIL <area>: Setting <https://example.net?lang=en-US#nav>.search = '?' assert_equals: expected "https://example.net/?#nav" but got "https://example.net/#nav"
PASS <a>: Setting <https://example.net?lang=en-US#nav>.search = ''
PASS <area>: Setting <https://example.net?lang=en-US#nav>.search = ''
PASS <a>: Setting <https://example.net?lang=en-US>.search = ''
PASS <area>: Setting <https://example.net?lang=en-US>.search = ''
PASS <a>: Setting <https://example.net>.search = ''
PASS <area>: Setting <https://example.net>.search = ''
FAIL <a>: Setting <a:/>.search = '\0	
\r !"#$%&'()*+,-./09:;<=>?@AZ[\]^_`az{|}~Éé' UTF-8 percent encoding with the query encode set. Tabs and newlines are removed. assert_equals: expected "a:/?%00%01%1F%20!%22%23$%&'()*+,-./09:;%3C=%3E?@AZ[\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9" but got "file:///A:/?%00%01%1F%20!%22%23$%&%27()*+,-./09:;%3C=%3E?@AZ[\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9"
FAIL <area>: Setting <a:/>.search = '\0	
\r !"#$%&'()*+,-./09:;<=>?@AZ[\]^_`az{|}~Éé' UTF-8 percent encoding with the query encode set. Tabs and newlines are removed. assert_equals: expected "a:/?%00%01%1F%20!%22%23$%&'()*+,-./09:;%3C=%3E?@AZ[\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9" but got "file:///A:/?%00%01%1F%20!%22%23$%&%27()*+,-./09:;%3C=%3E?@AZ[\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9"
PASS <a>: Setting <http://example.net>.search = '%c3%89té' Bytes already percent-encoded are left as-is
PASS <area>: Setting <http://example.net>.search = '%c3%89té' Bytes already percent-encoded are left as-is
PASS <a>: Setting <https://example.net>.hash = 'main'
PASS <area>: Setting <https://example.net>.hash = 'main'
PASS <a>: Setting <https://example.net#nav>.hash = 'main'
PASS <area>: Setting <https://example.net#nav>.hash = 'main'
PASS <a>: Setting <https://example.net?lang=en-US>.hash = '##nav'
PASS <area>: Setting <https://example.net?lang=en-US>.hash = '##nav'
PASS <a>: Setting <https://example.net?lang=en-US#nav>.hash = '#main'
PASS <area>: Setting <https://example.net?lang=en-US#nav>.hash = '#main'
PASS <a>: Setting <https://example.net?lang=en-US#nav>.hash = '#'
PASS <area>: Setting <https://example.net?lang=en-US#nav>.hash = '#'
PASS <a>: Setting <https://example.net?lang=en-US#nav>.hash = ''
PASS <area>: Setting <https://example.net?lang=en-US#nav>.hash = ''
PASS <a>: Setting <http://example.net>.hash = '#foo bar'
PASS <area>: Setting <http://example.net>.hash = '#foo bar'
PASS <a>: Setting <http://example.net>.hash = '#foo"bar'
PASS <area>: Setting <http://example.net>.hash = '#foo"bar'
PASS <a>: Setting <http://example.net>.hash = '#foo<bar'
PASS <area>: Setting <http://example.net>.hash = '#foo<bar'
PASS <a>: Setting <http://example.net>.hash = '#foo>bar'
PASS <area>: Setting <http://example.net>.hash = '#foo>bar'
PASS <a>: Setting <http://example.net>.hash = '#foo`bar'
PASS <area>: Setting <http://example.net>.hash = '#foo`bar'
FAIL <a>: Setting <a:/>.hash = '\0	
\r !"#$%&'()*+,-./09:;<=>?@AZ[\]^_`az{|}~Éé' Simple percent-encoding; tabs and newlines are removed assert_equals: expected "a:/#%00%01%1F%20!%22#$%&'()*+,-./09:;%3C=%3E?@AZ[\\]^_%60az{|}~%7F%C2%80%C2%81%C3%89%C3%A9" but got "file:///A:/#%00%01%1F%20!%22#$%&'()*+,-./09:;%3C=%3E?@AZ[\\]^_%60az{|}~%7F%C2%80%C2%81%C3%89%C3%A9"
FAIL <area>: Setting <a:/>.hash = '\0	
\r !"#$%&'()*+,-./09:;<=>?@AZ[\]^_`az{|}~Éé' Simple percent-encoding; tabs and newlines are removed assert_equals: expected "a:/#%00%01%1F%20!%22#$%&'()*+,-./09:;%3C=%3E?@AZ[\\]^_%60az{|}~%7F%C2%80%C2%81%C3%89%C3%A9" but got "file:///A:/#%00%01%1F%20!%22#$%&'()*+,-./09:;%3C=%3E?@AZ[\\]^_%60az{|}~%7F%C2%80%C2%81%C3%89%C3%A9"
PASS <a>: Setting <http://example.net>.hash = 'a\0b' Percent-encode NULLs in fragment
PASS <area>: Setting <http://example.net>.hash = 'a\0b' Percent-encode NULLs in fragment
PASS <a>: Setting <non-spec:/>.hash = 'a\0b' Percent-encode NULLs in fragment
PASS <area>: Setting <non-spec:/>.hash = 'a\0b' Percent-encode NULLs in fragment
PASS <a>: Setting <http://example.net>.hash = '%c3%89té' Bytes already percent-encoded are left as-is
PASS <area>: Setting <http://example.net>.hash = '%c3%89té' Bytes already percent-encoded are left as-is
PASS <a>: Setting <javascript:alert(1)>.hash = 'castle'
PASS <area>: Setting <javascript:alert(1)>.hash = 'castle'
Harness: the test ran to completion.

