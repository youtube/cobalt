// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/new_tab_page/chrome_colors/chrome_colors_service.h"

#include "base/metrics/histogram_functions.h"
#include "base/ranges/algorithm.h"
#include "chrome/browser/new_tab_page/chrome_colors/generated_colors_info.h"
#include "chrome/browser/new_tab_page/chrome_colors/selected_colors_info.h"
#include "chrome/browser/themes/theme_service_factory.h"
#include "chrome/browser/ui/webui/cr_components/theme_color_picker/customize_chrome_colors.h"
#include "ui/base/mojom/themes.mojom.h"

namespace chrome_colors {

namespace {

// These values are persisted to logs. Entries should not be renumbered and
// numeric values should never be reused.
enum class ChromeColorType {
  kChromeColor = 0,
  kDynamicChromeColor = 1,
  kMaxValue = kDynamicChromeColor,
};

int GetDynamicColorId(const SkColor color,
                      ui::mojom::BrowserColorVariant variant) {
  auto* it = base::ranges::find_if(kDynamicCustomizeChromeColors,
                                   [&](const DynamicColorInfo& dynamic_color) {
                                     return dynamic_color.color == color &&
                                            dynamic_color.variant == variant;
                                   });
  return it == kDynamicCustomizeChromeColors.end() ? kOtherDynamicColorId
                                                   : it->id;
}

void RecordChromeColorsColorType(ChromeColorType type) {
  base::UmaHistogramEnumeration("ChromeColors.ColorType", type);
}

void RecordChromeColorsDynamicColor(int color_id) {
  base::UmaHistogramExactLinear(
      "ChromeColors.DynamicColorOnLoad", color_id,
      base::ranges::max_element(kDynamicCustomizeChromeColors, {},
                                &DynamicColorInfo::id)
          ->id);
  RecordChromeColorsColorType(ChromeColorType::kDynamicChromeColor);
}

}  // namespace

ChromeColorsService::ChromeColorsService(Profile* profile)
    : theme_service_(ThemeServiceFactory::GetForProfile(profile)) {}

ChromeColorsService::~ChromeColorsService() = default;

// static
int ChromeColorsService::GetColorId(const SkColor color) {
  for (chrome_colors::ColorInfo color_info :
       chrome_colors::kGeneratedColorsInfo) {
    if (color == color_info.color)
      return color_info.id;
  }

  return kOtherColorId;
}

// static
void ChromeColorsService::RecordColorOnLoadHistogram(SkColor color) {
  base::UmaHistogramExactLinear("ChromeColors.ColorOnLoad", GetColorId(color),
                                kNumColorsInfo);
  RecordChromeColorsColorType(ChromeColorType::kChromeColor);
}

// static
void ChromeColorsService::RecordDynamicColorOnLoadHistogramForGrayscale() {
  RecordChromeColorsDynamicColor(kGrayscaleDynamicColorId);
}

// static
void ChromeColorsService::RecordDynamicColorOnLoadHistogram(
    SkColor color,
    ui::mojom::BrowserColorVariant variant) {
  RecordChromeColorsDynamicColor(GetDynamicColorId(color, variant));
}

void ChromeColorsService::ApplyDefaultTheme(content::WebContents* tab) {
  SaveThemeRevertState(tab);
  theme_service_->UseDefaultTheme();
}

void ChromeColorsService::ApplyAutogeneratedTheme(SkColor color,
                                                  content::WebContents* tab) {
  SaveThemeRevertState(tab);
  theme_service_->BuildAutogeneratedThemeFromColor(color);
}

void ChromeColorsService::RevertThemeChangesForTab(content::WebContents* tab) {
  if (dialog_tab_ != tab)
    return;
  RevertThemeChangesInternal();
}

void ChromeColorsService::RevertThemeChanges() {
  RevertThemeChangesInternal();
}

void ChromeColorsService::ConfirmThemeChanges() {
  prev_theme_reinstaller_ = nullptr;
  dialog_tab_ = nullptr;
}

void ChromeColorsService::RevertThemeChangesInternal() {
  if (prev_theme_reinstaller_) {
    prev_theme_reinstaller_->Reinstall();
    prev_theme_reinstaller_ = nullptr;
    dialog_tab_ = nullptr;
  }
}

void ChromeColorsService::SaveThemeRevertState(content::WebContents* tab) {
  // TODO(crbug.com/980745): Support theme reverting for multiple tabs.
  if (!prev_theme_reinstaller_) {
    prev_theme_reinstaller_ = theme_service_->BuildReinstallerForCurrentTheme();
    dialog_tab_ = tab;
  }
}

void ChromeColorsService::Shutdown() {
  RevertThemeChangesInternal();
}

}  // namespace chrome_colors
