<!DOCTYPE html>
<!--
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/model/event_set.html">

<script>
'use strict';

tr.exportTo('tr.ui.analysis', function() {
  const FLOW_IN = 0x1;
  const FLOW_OUT = 0x2;
  const FLOW_IN_OUT = FLOW_IN | FLOW_OUT;

  function FlowClassifier() {
    this.numEvents_ = 0;
    this.eventsByGUID_ = {};
  }

  FlowClassifier.prototype = {
    getFS_(event) {
      let fs = this.eventsByGUID_[event.guid];
      if (fs === undefined) {
        this.numEvents_++;
        fs = {
          state: 0,
          event
        };
        this.eventsByGUID_[event.guid] = fs;
      }
      return fs;
    },

    addInFlow(event) {
      const fs = this.getFS_(event);
      fs.state |= FLOW_IN;
      return event;
    },

    addOutFlow(event) {
      const fs = this.getFS_(event);
      fs.state |= FLOW_OUT;
      return event;
    },

    hasEvents() {
      return this.numEvents_ > 0;
    },

    get inFlowEvents() {
      const selection = new tr.model.EventSet();
      for (const guid in this.eventsByGUID_) {
        const fs = this.eventsByGUID_[guid];
        if (fs.state === FLOW_IN) {
          selection.push(fs.event);
        }
      }
      return selection;
    },

    get outFlowEvents() {
      const selection = new tr.model.EventSet();
      for (const guid in this.eventsByGUID_) {
        const fs = this.eventsByGUID_[guid];
        if (fs.state === FLOW_OUT) {
          selection.push(fs.event);
        }
      }
      return selection;
    },

    get internalFlowEvents() {
      const selection = new tr.model.EventSet();
      for (const guid in this.eventsByGUID_) {
        const fs = this.eventsByGUID_[guid];
        if (fs.state === FLOW_IN_OUT) {
          selection.push(fs.event);
        }
      }
      return selection;
    }
  };

  return {
    FlowClassifier,
  };
});
</script>

