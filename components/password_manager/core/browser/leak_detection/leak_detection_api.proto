syntax = "proto3";

// See the following for the server side definition:
// http://google3/google/internal/identity/passwords/leak/check/v1/service.proto
package google.internal.identity.passwords.leak.check.v1;

option optimize_for = LITE_RUNTIME;

message LookupSingleLeakRequest {
  // The prefix of the username hash (algorithm: SHA-256;
  // string encoding: UTF8).
  //
  // The underlying username is expected to be canonicalized by lower-casing
  // and stripping a mail-address host in case the username is a mail address.
  //
  // Only a most significant bit prefix with the length of
  // username_hash_prefix_length bits is to be set, the rest needs to be filled
  // with 0.
  //
  // The client can request all known leaks for a given username bucket.
  // This specifies the requested username bucket. All returned
  // `encrypted_leak_match_prefix` values will belong to that requested bucket.
  bytes username_hash_prefix = 1;

  // The length of the username hash prefix in bits.
  // We only allow 24 bits at the moment.
  //
  // Note: the prefix length is limited in order to:
  // - Protect client against too low anonymity (upper limit)
  // - Protect server against full database download (lower limit)
  uint32 username_hash_prefix_length = 2;

  // The full hash of username and password which was encrypted using a
  // commutative cipher.
  // The hashing algorithm used is Scrypt.
  //
  // Essentially:
  // cipher_with_client_key(scrypt(username, password))
  //
  // The underlying username is expected to be canonicalized the same as
  // described for username_hash_prefix.
  //
  // The key should be randomly generated by the client. It can choose a new one
  // per request, or even per hash. The server can't decrypt this and
  // won't know the difference.
  bytes encrypted_lookup_hash = 3;

  // The self-declared use case that the leak check is performed for.
  enum ClientUseCase {
    reserved 1 to 4, 8 to 10, 12 to 14;
    CLIENT_USE_CASE_UNSPECIFIED = 0;
    // Leak checks done by Chrome during sign in to a website.
    CHROME_SIGN_IN_CHECK = 5;
    // Leak checks done by Chrome for checking a bulk of passwords (similar to
    // Password Checkup).
    CHROME_BULK_SYNCED_PASSWORDS_CHECK = 6;
    // Leak checks done by Chrome Desktop for checking a bulk of passwords in
    // On-device Proactive Password Checkup.
    // Note: This use case can only be used for checking passwords of users that
    // are signed in to the Google Account.
    // See go/odppc-dd
    CHROME_DESKTOP_SIGNED_IN_ON_DEVICE_PROACTIVE_PASSWORD_CHECKUP = 7;
    // Leak checks done for bulk checking synced passwords on iGA.
    IGA_BULK_SYNCED_PASSWORDS_CHECK = 11;
    // Leak checks done by Chrome on password edit.
    CHROME_EDIT_CHECK = 15;
    // Leak checks done by Chrome iOS for checking a bulk of passwords in
    // On-device Proactive Password Checkup.
    // Note: This use case can only be used for checking passwords of users that
    // are signed in to the Google Account.
    // See go/odppc-dd
    CHROME_IOS_SIGNED_IN_ON_DEVICE_PROACTIVE_PASSWORD_CHECKUP = 18;
  }
  ClientUseCase client_use_case = 4;
}

message LookupSingleLeakResponse {
  // The leaks that match the requested `username_hash_prefix`.
  // A prefix of the SHA256 hash of the encrypted hashed username and password
  // pair that was discovered in a leak. It was encrypted using a commutative
  // cipher with a private key picked by the server.
  // The prefix length can vary depending on the response size but will be long
  // enough in order to not cause any false positives. This is a pure bandwidth
  // optimization measure.
  //
  // Essentially:
  // prefix(sha256(cipher_with_server_key(scrypt(username, password))))
  //
  // Note: There are no guarantees that the server key stays the same between
  // subsequent requests.
  repeated bytes encrypted_leak_match_prefix = 1;

  // The `encrypted_lookup_hash` reencrypted with the server's private key
  // (the same key that is used for encrypting `encrypted_leak_match_prefix`).
  // This enables the client to reverse their own encryption, giving the
  // client a server-side only encrypted leak entry which it can use to check
  // if `encrypted_leak_match_prefix` contains it.
  //
  // Essentially:
  // cipher_with_server_key(cipher_with_client_key(scrypt(username, password)))
  bytes reencrypted_lookup_hash = 2;
}
