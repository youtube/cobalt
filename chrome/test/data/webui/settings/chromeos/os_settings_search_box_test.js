// Copyright 2020 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import {OpenWindowProxyImpl, OsSettingsSearchBoxBrowserProxyImpl, personalizationSearchMojom, Router, routes, routesMojom, searchMojom, searchResultIconMojom, setPersonalizationSearchHandlerForTesting, setSettingsSearchHandlerForTesting, settingMojom, setUserActionRecorderForTesting, userActionRecorderMojom} from 'chrome://os-settings/chromeos/os_settings.js';
import {loadTimeData} from 'chrome://resources/ash/common/load_time_data.m.js';
import {flush} from 'chrome://resources/polymer/v3_0/polymer/polymer_bundled.min.js';
import {assertDeepEquals, assertEquals, assertFalse, assertNotEquals, assertTrue} from 'chrome://webui-test/chai_assert.js';
import {TestBrowserProxy} from 'chrome://webui-test/test_browser_proxy.js';
import {eventToPromise} from 'chrome://webui-test/test_util.js';

import {FakePersonalizationSearchHandler} from './fake_personalization_search_handler.js';
import {FakeSettingsSearchHandler} from './fake_settings_search_handler.js';
import {FakeUserActionRecorder} from './fake_user_action_recorder.js';
import {TestOsSettingsSearchBoxBrowserProxy} from './test_os_settings_search_box_browser_proxy.js';

/** @fileoverview Runs tests for the OS settings search box. */

/**
 * @implements {OpenWindowProxy}
 */
class TestOpenWindowProxy extends TestBrowserProxy {
  constructor() {
    super([
      'openUrl',
    ]);
  }

  /** @override */
  openUrl(url) {
    this.methodCalled('openUrl', url);
  }
}

suite('OSSettingsSearchBox', () => {
  // TODO(hsuregan): Keep count and add getters for metrics.
  class MockMetricsPrivate {
    recordEnumerationValue(metricName, value, enumSize) {}

    recordSparseValue(metricName, value) {}

    recordTime(metricName, value) {}

    recordSparseValueWithHashMetricName(metricName, value) {}

    recordSparseValueWithPersistentHash(metricName, value) {}
  }

  /** @const {number} */
  const DEFAULT_RELEVANCE_SCORE = 0.5;

  /** @const {!Array<mojoBase.mojom.String16>} */
  const DEFAULT_PAGE_HIERARCHY = [];

  /** @type {?OsToolbar} */
  let toolbar;

  /** @type {?OsSettingsSearchBox} */
  let searchBox;

  /** @type {?CrSearchFieldElement} */
  let field;

  /** @type {?IronDropdownElement} */
  let dropDown;

  /** @type {?IronListElement} */
  let resultList;

  /** @type {FakePersonalizationSearchHandler} */
  let personalizationSearchHandler;

  /** @type {*} */
  let settingsSearchHandler;

  /** @type {?userActionRecorderMojom.UserActionRecorderInterface} */
  let userActionRecorder;

  /** @type {?HTMLElement} */
  let noResultsSection;

  /** @type {?TestOpenWindowProxy} */
  let openWindowProxy = null;

  function isTextSelected() {
    const input = field.$.searchInput;
    return input.selectionStart === 0 &&
        input.selectionEnd === input.value.length;
  }

  /** @param {string} term */
  async function simulateSearch(term) {
    field.$.searchInput.value = term;
    field.onSearchTermInput();
    field.onSearchTermSearch();
    if (term && term.trim().length !== 0) {
      // search-results-fetched only fires on a non-empty search term.
      await waitForResultsFetched();
    }
    flush();
  }

  async function waitForListUpdate() {
    // Wait for iron-list to complete resizing.
    await eventToPromise('iron-resize', resultList);
    flush();
  }

  async function waitForResultsFetched() {
    // Wait for search results to be fetched.
    await eventToPromise('search-results-fetched', searchBox);
    flush();
  }

  /**
   * @param {string} text Exact string of the result to be displayed.
   * @param {string} path Url path with optional params.
   * @param {?searchResultIconMojom.SearchResultIcon} icon Result
   *     icon enum.
   * @param {?Boolean} wasGeneratedFromTextMatch If result was generated by
   *     text match, defaults to true.
   * @param {?number} relevanceScore the score of this search result, defaults
   *     to |DEFAULT_RELEVANCE_SCORE|
   * @return {!searchMojom.SearchResult} A search result.
   */
  function fakeSettingsResult(
      text, urlPathWithParameters, icon, wasGeneratedFromTextMatch,
      relevanceScore) {
    return /** @type {!mojom.SearchResult} */ ({
      text: {
        data: Array.from(text, c => c.charCodeAt()),
      },
      canonicalText: {
        data: Array.from(text, c => c.charCodeAt()),
      },
      urlPathWithParameters: urlPathWithParameters,
      icon: icon ? icon : searchResultIconMojom.SearchResultIcon.MIN_VALUE,
      wasGeneratedFromTextMatch: wasGeneratedFromTextMatch === undefined ?
          true :
          wasGeneratedFromTextMatch,
      id: {
        section: routesMojom.Section.MIN_VALUE,
        subpage: routesMojom.Subpage.MIN_VALUE,
        setting: settingMojom.Setting.MIN_VALUE,
      },
      type: searchMojom.SearchResultType.MIN_VALUE,
      relevanceScore: typeof relevanceScore === 'number' ?
          relevanceScore :
          DEFAULT_RELEVANCE_SCORE,
      settingsPageHierarchy: DEFAULT_PAGE_HIERARCHY,
    });
  }

  /**
   * @param {string} text
   * @param {string} relativeUrl
   * @param {number} relevanceScore
   * @return {!personalizationSearchMojom.SearchResult}
   */
  function fakePersonalizationResult(
      text, relativeUrl = '', relevanceScore = DEFAULT_RELEVANCE_SCORE) {
    return /** @type {!personalizationSearchMojom.SearchResult} */ ({
      searchConceptId: personalizationSearchMojom.SearchConceptId.MIN_VALUE,
      text: {
        data: Array.from(text, c => c.charCodeAt()),
      },
      relativeUrl,
      relevanceScore,
    });
  }

  function setupSearchBox() {
    chrome.metricsPrivate = new MockMetricsPrivate();

    personalizationSearchHandler = new FakePersonalizationSearchHandler();
    setPersonalizationSearchHandlerForTesting(personalizationSearchHandler);

    settingsSearchHandler = new FakeSettingsSearchHandler();
    setSettingsSearchHandlerForTesting(settingsSearchHandler);

    userActionRecorder = new FakeUserActionRecorder();
    setUserActionRecorderForTesting(userActionRecorder);

    toolbar = document.createElement('os-toolbar');
    assertTrue(!!toolbar);
    document.body.appendChild(toolbar);
    flush();

    searchBox = toolbar.shadowRoot.querySelector('os-settings-search-box');
    assertTrue(!!searchBox);
    field = searchBox.shadowRoot.querySelector('cr-toolbar-search-field');
    assertTrue(!!field);
    dropDown = searchBox.shadowRoot.querySelector('iron-dropdown');
    assertTrue(!!dropDown);
    resultList = searchBox.shadowRoot.querySelector('iron-list');
    assertTrue(!!resultList);
    noResultsSection =
        searchBox.shadowRoot.querySelector('#noSearchResultsContainer');
    assertTrue(!!noResultsSection);
  }

  setup(function() {
    Router.getInstance().navigateTo(routes.BASIC);

    openWindowProxy = new TestOpenWindowProxy();
    OpenWindowProxyImpl.setInstance(openWindowProxy);
  });

  teardown(async () => {
    // Clear search field for next test.
    await simulateSearch('');
    setPersonalizationSearchHandlerForTesting(null);
    setSettingsSearchHandlerForTesting(null);
    setUserActionRecorderForTesting(null);
  });

  test('Search availability changed', async () => {
    setupSearchBox();
    settingsSearchHandler.setFakeResults([fakeSettingsResult('result')]);
    await simulateSearch('test query');
    assertTrue(dropDown.opened);
    assertEquals(searchBox.searchResults_.length, 1);

    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('1'), fakeSettingsResult('2')]);
    assertTrue(dropDown.opened);
    assertEquals(searchBox.searchResults_.length, 1);

    // Check that the list updates when the dropdown is open, and the dropdown
    // remains open.
    settingsSearchHandler.simulateSearchResultsChanged();
    await waitForResultsFetched();
    assertTrue(dropDown.opened);
    assertEquals(searchBox.searchResults_.length, 2);

    // Personalization search results should also result in a new search.
    personalizationSearchHandler.setFakeResults(
        [fakePersonalizationResult('personalization')]);
    assertTrue(dropDown.opened);
    assertEquals(searchBox.searchResults_.length, 2);

    personalizationSearchHandler.simulateSearchResultsChanged();
    await waitForResultsFetched();
    assertTrue(dropDown.opened);
    assertEquals(searchBox.searchResults_.length, 3);

    // User clicks outside the search box, closing the dropdown.
    searchBox.blur();
    assertFalse(dropDown.opened);

    settingsSearchHandler.setFakeResults([fakeSettingsResult('result')]);
    assertFalse(dropDown.opened);
    assertEquals(searchBox.searchResults_.length, 3);

    // Check that the list updates when the dropdown is closed, and the dropdown
    // remains closed.
    settingsSearchHandler.simulateSearchResultsChanged();
    await waitForResultsFetched();
    assertFalse(dropDown.opened);
    assertEquals(searchBox.searchResults_.length, 2);

    // The first item should be selected immediately when the search results
    // change even if the change occurred while the dropdown was closed.
    field.$.searchInput.focus();
    await waitForListUpdate();
    assertTrue(dropDown.opened);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().searchResult.resultText,
        searchBox.selectedItem_.resultText);
  });

  test('User action search event', async () => {
    setupSearchBox();
    settingsSearchHandler.setFakeResults([]);

    assertEquals(userActionRecorder.searchCount, 0);
    await simulateSearch('query');
    assertEquals(userActionRecorder.searchCount, 1);
  });

  test(
      'Clicking magnifying glass shows dropdown and selects all text',
      async () => {
        setupSearchBox();
        settingsSearchHandler.setFakeResults([fakeSettingsResult('a')]);
        await simulateSearch('query');
        await waitForListUpdate();
        assertTrue(dropDown.opened);
        searchBox.blur();

        assertFalse(dropDown.opened);
        assertFalse(isTextSelected());
        field.$.icon.click();
        assertTrue(isTextSelected());
        assertTrue(dropDown.opened);
      });

  test('Dropdown opens correctly when results are fetched', async () => {
    setupSearchBox();
    // Show no results in dropdown if no results are returned.
    settingsSearchHandler.setFakeResults([]);
    personalizationSearchHandler.setFakeResults([]);
    assertFalse(dropDown.opened);
    await simulateSearch('query 1');
    assertTrue(dropDown.opened);
    assertEquals(searchBox.searchResults_.length, 0);
    assertFalse(noResultsSection.hidden);

    assertEquals(userActionRecorder.searchCount, 1);

    // Show result list if results are returned, and hide no results div.
    settingsSearchHandler.setFakeResults([fakeSettingsResult('result')]);
    personalizationSearchHandler.setFakeResults([]);
    await simulateSearch('query 2');
    assertNotEquals(searchBox.searchResults_.length, 0);
    assertTrue(noResultsSection.hidden);

    // Show result list if personalization search results are returned, and hide
    // no results div.
    settingsSearchHandler.setFakeResults([]);
    personalizationSearchHandler.setFakeResults(
        [fakePersonalizationResult('personalization')]);
    await simulateSearch('query 3');
    assertNotEquals(searchBox.searchResults_.length, 0);
    assertTrue(noResultsSection.hidden);
  });

  test('Restore previous existing search results', async () => {
    setupSearchBox();
    settingsSearchHandler.setFakeResults([fakeSettingsResult('result 1')]);
    personalizationSearchHandler.setFakeResults(
        [fakePersonalizationResult('personalization')]);
    await simulateSearch('query');
    assertTrue(dropDown.opened);
    assertEquals(2, resultList.items.length);
    const [firstResult, secondResult] = resultList.items;

    // Child blur elements except field should not trigger closing of dropdown.
    resultList.blur();
    assertTrue(dropDown.opened);
    dropDown.blur();
    assertTrue(dropDown.opened);

    // User clicks outside the search box, closing the dropdown.
    searchBox.blur();
    assertFalse(dropDown.opened);

    // User clicks on input, restoring old results and opening dropdown.
    field.$.searchInput.focus();
    assertEquals('query', field.$.searchInput.value);
    assertTrue(dropDown.opened);

    // The same result rows exist.
    assertEquals(firstResult, resultList.items[0]);
    assertEquals(secondResult, resultList.items[1]);

    // Search field is blurred, closing the dropdown.
    field.$.searchInput.blur();
    assertFalse(dropDown.opened);

    // User clicks on input, restoring old results and opening dropdown.
    field.$.searchInput.focus();
    assertEquals('query', field.$.searchInput.value);
    assertTrue(dropDown.opened);

    // The same result rows exist.
    assertEquals(firstResult, resultList.items[0]);
    assertEquals(secondResult, resultList.items[1]);
  });

  test('Search result rows are selected correctly', async () => {
    setupSearchBox();
    settingsSearchHandler.setFakeResults([fakeSettingsResult('a')]);
    personalizationSearchHandler.setFakeResults(
        [fakePersonalizationResult('b')]);
    await simulateSearch('query');
    await waitForListUpdate();

    assertTrue(dropDown.opened);
    assertEquals(resultList.items.length, 2);

    // The first row should be selected when results are fetched.
    assertEquals(resultList.selectedItem, resultList.items[0]);

    // Test ArrowUp and ArrowDown interaction with selecting.
    const arrowUpEvent = new KeyboardEvent(
        'keydown', {cancelable: true, key: 'ArrowUp', keyCode: 38});
    const arrowDownEvent = new KeyboardEvent(
        'keydown', {cancelable: true, key: 'ArrowDown', keyCode: 40});

    // ArrowDown event should select next row.
    searchBox.dispatchEvent(arrowDownEvent);
    assertEquals(resultList.selectedItem, resultList.items[1]);

    // If last row selected, ArrowDown brings select back to first row.
    searchBox.dispatchEvent(arrowDownEvent);
    assertEquals(resultList.selectedItem, resultList.items[0]);

    // If first row selected, ArrowUp brings select back to last row.
    searchBox.dispatchEvent(arrowUpEvent);
    assertEquals(resultList.selectedItem, resultList.items[1]);

    // ArrowUp should bring select previous row.
    searchBox.dispatchEvent(arrowUpEvent);
    assertEquals(resultList.selectedItem, resultList.items[0]);

    // Test that ArrowLeft and ArrowRight do nothing.
    const arrowLeftEvent = new KeyboardEvent(
        'keydown', {cancelable: true, key: 'ArrowLeft', keyCode: 37});
    const arrowRightEvent = new KeyboardEvent(
        'keydown', {cancelable: true, key: 'ArrowRight', keyCode: 39});

    // No change on ArrowLeft
    searchBox.dispatchEvent(arrowLeftEvent);
    assertEquals(resultList.selectedItem, resultList.items[0]);

    // No change on ArrowRight
    searchBox.dispatchEvent(arrowRightEvent);
    assertEquals(resultList.selectedItem, resultList.items[0]);
  });

  test('Keydown Enter on search box can cause route change', async () => {
    setupSearchBox();
    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('WiFi Settings', 'networks?type=WiFi')]);
    await simulateSearch('fake query');
    await waitForListUpdate();

    const enterEvent = new KeyboardEvent(
        'keydown', {cancelable: true, key: 'Enter', keyCode: 13});

    // Keydown with Enter key on the searchBox causes navigation to selected
    // row's route.
    searchBox.dispatchEvent(enterEvent);
    flush();
    assertFalse(dropDown.opened);
    const router = Router.getInstance();
    assertEquals(router.getQueryParameters().get('search'), 'fake query');
    assertEquals(router.currentRoute.path, '/networks');
    assertEquals(router.getQueryParameters().get('type'), 'WiFi');
  });

  test(
      'Keypress Enter on personalization result opens personalization hub',
      async () => {
        setupSearchBox();
        personalizationSearchHandler.setFakeResults(
            [fakePersonalizationResult('result', 'test')]);
        settingsSearchHandler.setFakeResults([]);
        await simulateSearch('fake query 1');
        await waitForListUpdate();

        const selectedOsRow = searchBox.getSelectedOsSearchResultRow_();
        assertTrue(!!selectedOsRow);
        assertEquals('cr:open-in-new', selectedOsRow.getActionTypeIcon_());

        // Keypress with Enter key on any row specifically causes navigation to
        // selected row's route. This can't happen unless the row is focused.
        const enterEvent = new KeyboardEvent(
            'keypress', {cancelable: true, key: 'Enter', keyCode: 13});
        selectedOsRow.$.searchResultContainer.dispatchEvent(enterEvent);

        assertEquals(
            'chrome://personalization/test',
            await openWindowProxy.whenCalled('openUrl'));
      });

  test(
      'Clicking on personalization result opens personalization hub',
      async () => {
        setupSearchBox();
        personalizationSearchHandler.setFakeResults(
            [fakePersonalizationResult('Wallpaper', 'test')]);
        await simulateSearch('fake query 1');
        await waitForListUpdate();

        const selectedOsRow = searchBox.getSelectedOsSearchResultRow_();
        assertTrue(!!selectedOsRow);
        assertEquals('cr:open-in-new', selectedOsRow.getActionTypeIcon_());

        // Clicking on the searchResultContainer of the row opens a new window.
        selectedOsRow.$.searchResultContainer.click();

        assertEquals(
            'chrome://personalization/test',
            await openWindowProxy.whenCalled('openUrl'));
      });

  test('Keypress Enter on row causes route change', async () => {
    setupSearchBox();
    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('WiFi Settings', 'networks?type=WiFi')]);
    await simulateSearch('fake query 1');
    await waitForListUpdate();

    const selectedOsRow = searchBox.getSelectedOsSearchResultRow_();
    assertTrue(!!selectedOsRow);

    // Keypress with Enter key on any row specifically causes navigation to
    // selected row's route. This can't happen unless the row is focused.
    const enterEvent = new KeyboardEvent(
        'keypress', {cancelable: true, key: 'Enter', keyCode: 13});
    selectedOsRow.$.searchResultContainer.dispatchEvent(enterEvent);
    assertFalse(dropDown.opened);
    const router = Router.getInstance();
    assertEquals(router.getQueryParameters().get('search'), 'fake query 1');
    assertEquals(router.currentRoute.path, '/networks');
    assertEquals(router.getQueryParameters().get('type'), 'WiFi');
  });

  test('Route change when result row is clicked', async () => {
    setupSearchBox();
    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('WiFi Settings', 'networks?type=WiFi')]);
    await simulateSearch('fake query 2');
    await waitForListUpdate();

    const searchResultRow = searchBox.getSelectedOsSearchResultRow_();

    // Clicking on the searchResultContainer of the row correctly changes the
    // route and dropdown to close.
    searchResultRow.$.searchResultContainer.click();

    assertFalse(dropDown.opened);
    const router = Router.getInstance();
    assertEquals(router.getQueryParameters().get('search'), 'fake query 2');
    assertEquals(router.currentRoute.path, '/networks');
    assertEquals(router.getQueryParameters().get('type'), 'WiFi');
  });

  test('Selecting result a second time does not deselect it.', async () => {
    setupSearchBox();
    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('WiFi Settings', 'networks?type=WiFi')]);
    await simulateSearch('query');
    await waitForListUpdate();

    // Clicking a selected item does not deselect it.
    const searchResultRow = searchBox.getSelectedOsSearchResultRow_();
    searchResultRow.$.searchResultContainer.click();
    assertEquals(resultList.selectedItem, resultList.items[0]);
    assertFalse(dropDown.opened);

    // Open search drop down again.
    field.$.searchInput.focus();
    assertTrue(dropDown.opened);

    // Clicking again does not deslect the row.
    searchResultRow.$.searchResultContainer.click();
    assertEquals(resultList.selectedItem, resultList.items[0]);
  });

  test('Test no bolding if not generated from text match', async () => {
    setupSearchBox();
    settingsSearchHandler.setFakeResults([fakeSettingsResult(
        'Search and Assistant', undefined, undefined,
        /*wasGeneratedFromTextMatch=*/ false)]);
    await simulateSearch(`Search`);
    await waitForListUpdate();
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Search and Assistant`);
  });

  test('Tokenize and match result text to query text', async () => {
    setupSearchBox();
    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('Search and Assistant')]);
    await simulateSearch(`Assistant Search`);
    await waitForListUpdate();
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `<b>Search</b> and <b>Assistant</b>`);
  });

  test('Bold result text to matching query', async () => {
    setupSearchBox();
    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('Search and Assistant')]);
    await simulateSearch(`a`);
    await waitForListUpdate();
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Se<b>a</b>rch <b>a</b>nd <b>A</b>ssist<b>a</b>nt`);
  });

  test('Bold result including ignored characters', async () => {
    setupSearchBox();
    settingsSearchHandler.setFakeResults([fakeSettingsResult('Turn on Wi-Fi')]);
    await simulateSearch(`wif`);
    await waitForListUpdate();
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Turn on <b>Wi-F</b>i`);
    await simulateSearch(`wi f`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Turn on <b>Wi-F</b>i`);
    await simulateSearch(`wi-f`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Turn on <b>Wi-F</b>i`);

    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('Touchpad tap-to-click')]);
    await simulateSearch(`tap to cli`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Touchpad <b>tap-to-cli</b>ck`);

    await simulateSearch(`taptocli`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Touchpad <b>tap-to-cli</b>ck`);
    await simulateSearch(`tap-to-cli`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Touchpad <b>tap-to-cli</b>ck`);

    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('Touchpad tap-to-click')]);
    await simulateSearch(`tap top cli`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Touchpad <b>tap-to-cli</b>ck`);

    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('wxyz Tap-To-Click')]);
    await simulateSearch(`tap toxy cli`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `w<b>xy</b>z <b>Tap-To</b>-Click`);

    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('Tap-to-click Tips Title')]);
    await simulateSearch(`tap ti`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `<b>Tap</b>-to-click <b>Ti</b>ps <b>Ti</b>tle`);
  });

  test('Test query longer than result blocks', async () => {
    setupSearchBox();
    settingsSearchHandler.setFakeResults([fakeSettingsResult('Turn on Wi-Fi')]);
    await simulateSearch(`onwifi`);
    await waitForListUpdate();
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Turn <b>on</b> <b>Wi-Fi</b>`);
  });

  test('Test bolding of accented characters', async () => {
    setupSearchBox();
    settingsSearchHandler.setFakeResults([fakeSettingsResult('Crème Brûlée')]);
    await simulateSearch(`E U`);
    await waitForListUpdate();
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Cr<b>è</b>me Br<b>û</b>l<b>é</b>e`);
  });

  test('Test no spaces nor characters that have upper/lower case', async () => {
    setupSearchBox();
    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('キーボード設定---')]);
    await simulateSearch(`キー設`);
    await waitForListUpdate();
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `<b>キ</b><b>ー</b>ボ<b>ー</b>ド<b>設</b>定---`);
  });

  test('Test blankspace types in result maintained', async () => {
    setupSearchBox();
    const resultText = 'Turn\xa0on  \xa0Wi-Fi ';

    settingsSearchHandler.setFakeResults([fakeSettingsResult(resultText)]);
    await simulateSearch(`wif`);
    await waitForListUpdate();
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `Turn&nbsp;on  &nbsp;<b>Wi-F</b>i `);
  });

  test('Test longest common substring for mispellings', async () => {
    setupSearchBox();
    settingsSearchHandler.setFakeResults([fakeSettingsResult('Linux')]);
    await simulateSearch(`Linuux`);
    await waitForListUpdate();
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `<b>Linu</b>x`);

    settingsSearchHandler.setFakeResults([fakeSettingsResult('Linux')]);
    await simulateSearch(`Llinuc`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `<b>Linu</b>x`);

    settingsSearchHandler.setFakeResults([fakeSettingsResult('Display')]);
    await simulateSearch(`Dispplay`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `<b>Disp</b>lay`);

    settingsSearchHandler.setFakeResults(
        [fakeSettingsResult('ABCDEF GHIJK LMNO')]);
    await simulateSearch(`MCDEMMM LM EF CDEABCDEFADBCDABDCEF`);
    assertEquals(
        searchBox.getSelectedOsSearchResultRow_().$.resultText.innerHTML,
        `<b>ABCDEF</b> GHIJK <b>LM</b>NO`);
  });

  test('Focus search input behavior on attached', async () => {
    PolymerTest.clearBody();
    Router.getInstance().navigateTo(routes.BASIC);
    setupSearchBox();
    assertEquals(field.root.activeElement, field.$.searchInput);

    PolymerTest.clearBody();
    Router.getInstance().navigateTo(routes.KEYBOARD);
    assertEquals(field.root.activeElement, null);
  });

  test('search results sorted descending', async () => {
    setupSearchBox();
    personalizationSearchHandler.setFakeResults([
      fakePersonalizationResult(
          'one', /*relativeUrl=*/ '', /*relevanceScore=*/ 0.99),
      fakePersonalizationResult(
          'three', /*relativeUrl=*/ '', /*relevanceScore=*/ 0.75),
      fakePersonalizationResult(
          'cut', /*relativeUrl=*/ '', /*relevanceScore=*/ 0.2),
    ]);
    settingsSearchHandler.setFakeResults([
      fakeSettingsResult(
          'two', /*urlPathWithParameters=*/ '',
          /*icon=*/ searchResultIconMojom.SearchResultIcon.MIN_VALUE,
          /*wasGeneratedFromTextMatch=*/ true, /*relevanceScore=*/ 0.85),
      fakeSettingsResult(
          'four', /*urlPathWithParameters=*/ '',
          /*icon=*/ searchResultIconMojom.SearchResultIcon.MIN_VALUE,
          /*wasGeneratedFromTextMatch=*/ true, /*relevanceScore=*/ 0.55),
      fakeSettingsResult(
          'five', /*urlPathWithParameters=*/ '',
          /*icon=*/ searchResultIconMojom.SearchResultIcon.MIN_VALUE,
          /*wasGeneratedFromTextMatch=*/ true, /*relevanceScore=*/ 0.35),
    ]);

    await simulateSearch('fake query');
    await waitForListUpdate();

    assertEquals(5, resultList.items.length, 'results cut to show top 5');

    assertDeepEquals(
        [
          {text: 'one', relevanceScore: 0.99},
          {text: 'two', relevanceScore: 0.85},
          {text: 'three', relevanceScore: 0.75},
          {text: 'four', relevanceScore: 0.55},
          {text: 'five', relevanceScore: 0.35},
        ],
        resultList.items.map(item => {
          return {
            text: item.text.data.map(ch => String.fromCodePoint(ch)).join(''),
            relevanceScore: item.relevanceScore,
          };
        }),
        'search results sorted in expected order');
  });

  suite('SearchFeedback_OfficialBuild', () => {
    suite('when feature flag is enabled', () => {
      /** @type {?TestOsSettingsSearchBoxBrowserProxy} */
      let browserProxy = null;

      setup(() => {
        loadTimeData.overrideValues({searchFeedbackEnabled: true});

        browserProxy = new TestOsSettingsSearchBoxBrowserProxy();
        OsSettingsSearchBoxBrowserProxyImpl.setInstanceForTesting(browserProxy);

        setupSearchBox();
      });

      teardown(() => {
        PolymerTest.clearBody();
      });

      test(
          'feedback button does not appear when search result exists',
          async () => {
            settingsSearchHandler.setFakeResults(['assistant']);
            await simulateSearch('a');
            assertTrue(dropDown.opened);
            assertEquals(1, searchBox.searchResults_.length);
            assertTrue(noResultsSection.hidden);
            const feedbackReportResults =
                searchBox.shadowRoot.querySelector('#reportSearchResultButton');
            assertTrue(!!feedbackReportResults);
            assertTrue(feedbackReportResults.hidden);
          });

      test(
          'feedback button appears when search result does not exist',
          async () => {
            settingsSearchHandler.setFakeResults([]);
            await simulateSearch('query 1');
            assertTrue(dropDown.opened);
            assertEquals(0, searchBox.searchResults_.length);
            assertFalse(noResultsSection.hidden);
            // feedback button appears when no search results have been found
            const feedbackReportResults =
                searchBox.shadowRoot.querySelector('#reportSearchResultButton');
            assertTrue(!!feedbackReportResults);
            assertFalse(feedbackReportResults.hidden);
          });

      test('clicking the button opens feedback dialog', async () => {
        settingsSearchHandler.setFakeResults([]);
        const searchQuery = 'query 1';
        await simulateSearch(searchQuery);
        const feedbackReportResults =
            searchBox.shadowRoot.querySelector('#reportSearchResultButton');
        feedbackReportResults.click();
        const descriptionTemplate =
            searchBox
                .i18nAdvanced('searchFeedbackDescriptionTemplate', {
                  substitutions: [searchQuery],
                })
                .toString();
        return browserProxy.whenCalled(
            'openSearchFeedbackDialog', descriptionTemplate);
      });

      test(
          'feedback button does not appear when searching for only whitespace',
          async () => {
            settingsSearchHandler.setFakeResults(['']);
            await simulateSearch('    ');
            const noSearchResult =
                searchBox.shadowRoot.querySelector('#noSearchResultsContainer');
            assertTrue(!!noSearchResult);
            const feedbackReportResults =
                searchBox.shadowRoot.querySelector('#reportSearchResultButton');
            assertTrue(feedbackReportResults.hidden);
          });
    });

    suite('when feature flag is disabled', () => {
      setup(() => {
        loadTimeData.overrideValues({searchFeedbackEnabled: false});

        setupSearchBox();
      });

      teardown(() => {
        PolymerTest.clearBody();
      });

      test('feedback button does not render', async () => {
        settingsSearchHandler.setFakeResults([]);
        await simulateSearch('query 1');
        assertTrue(dropDown.opened);
        assertEquals(0, searchBox.searchResults_.length);
        assertFalse(noResultsSection.hidden);
        const feedbackReportResults =
            searchBox.shadowRoot.querySelector('#reportSearchResultButton');
        assertEquals(null, feedbackReportResults);
      });
    });
  });
});
