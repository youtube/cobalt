{{+bindTo:partials.standard_nacl_api}}
<h1>Functions</h1>
<div id="doxygen-ref">
{{- dummy div to appease doxygen -}}
  <div>
<!-- Generated by Doxygen 1.7.6.1 -->

</div>
<!--header-->
<div class="contents">
<h2>
Functions</h2><table class="memberdecls">

<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_p_p___completion_callback.html">PP_CompletionCallback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#ga8691f15edad9b391c3644064ac57f191">PP_MakeCompletionCallback</a> (<a class="el" href="group___typedefs.html#ga6fe12e1a41df5e10103a811036d4d8d2">PP_CompletionCallback_Func</a> func, void *user_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_p_p___completion_callback.html">PP_CompletionCallback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#gabd6bf83f4c787477631c37d44418c4db">PP_MakeOptionalCompletionCallback</a> (<a class="el" href="group___typedefs.html#ga6fe12e1a41df5e10103a811036d4d8d2">PP_CompletionCallback_Func</a> func, void *user_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#gaffce49266a735f9ee8d149b14477404f">PP_RunCompletionCallback</a> (struct <a class="el" href="struct_p_p___completion_callback.html">PP_CompletionCallback</a> *cc, int32_t result)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_p_p___completion_callback.html">PP_CompletionCallback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#ga340e452b4931d17bd44928769490e282">PP_BlockUntilComplete</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#ga8dac45aa496bbb1f97a15e2833d3ed02">PP_RunAndClearCompletionCallback</a> (struct <a class="el" href="struct_p_p___completion_callback.html">PP_CompletionCallback</a> *cc, int32_t res)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_p_p___point.html">PP_Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#ga15880e8085178758053cc521af33b250">PP_MakePoint</a> (int32_t x, int32_t y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_p_p___float_point.html">PP_FloatPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#ga0aca79088546fe91d13c97db9033e709">PP_MakeFloatPoint</a> (float x, float y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_p_p___rect.html">PP_Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#gaf868e2929269ef195241b79a015fcf61">PP_MakeRectFromXYWH</a> (int32_t x, int32_t y, int32_t w, int32_t h)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_p_p___float_rect.html">PP_FloatRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#ga0d58c0f7ab657c5cdd92afe7b5da0fce">PP_MakeFloatRectFromXYWH</a> (float x, float y, float w, float h)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_p_p___size.html">PP_Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#ga35a97e64d18402d8feff46722b98beb0">PP_MakeSize</a> (int32_t w, int32_t h)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_p_p___float_size.html">PP_FloatSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#gaa45701f5b00be4d57637165ae9382251">PP_MakeFloatSize</a> (float w, float h)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_p_p___touch_point.html">PP_TouchPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#gae7f6d41cbb173c12f474242c2a3bf5e7">PP_MakeTouchPoint</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_p_p___var.html">PP_Var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#ga0edc8314fc1a92f93dd3d0eab286cb5d">PP_MakeUndefined</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_p_p___var.html">PP_Var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#ga75f83ac65ccbf57866d52d45cd5792e7">PP_MakeNull</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_p_p___var.html">PP_Var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#ga0fba11ae90d57086064d41b0af710253">PP_MakeBool</a> (<a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_p_p___var.html">PP_Var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#gad14a59fa681d4cc532b3d49c0438f0ca">PP_MakeInt32</a> (int32_t value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_p_p___var.html">PP_Var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#gafbebaae212cb7e737efc56eea0e785b5">PP_MakeDouble</a> (double value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#ga2fc7b396531c19417d8d7171d56da8b6">PPP_InitializeModule</a> (<a class="el" href="group___typedefs.html#gab780dd451cd7f51284cb752edd88f9a0">PP_Module</a> module, <a class="el" href="group___typedefs.html#ga68ad7c927b86e0c29d890603edd33154">PPB_GetInterface</a> get_browser_interface)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#gaa3021aba7ddc17a8cecb4bc4f8374e98">PPP_ShutdownModule</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___functions.html#ga4127b148b2bd0f3bc2c078dd38cbe4cf">PPP_GetInterface</a> (const char *interface_name)</td></tr>
</table>
<hr /><h2>Function Documentation</h2>
<a class="anchor" id="ga340e452b4931d17bd44928769490e282"></a><!-- doxytag: member="pp_completion_callback.h::PP_BlockUntilComplete" ref="ga340e452b4931d17bd44928769490e282" args="(void)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">struct <a class="el" href="struct_p_p___completion_callback.html">PP_CompletionCallback</a> <a class="el" href="group___functions.html#ga340e452b4931d17bd44928769490e282">PP_BlockUntilComplete</a> </td>
<td>(</td>
<td class="paramtype">void&#160;</td>
<td class="paramname"></td><td>)</td>
<td><code> [read]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="group___functions.html#ga340e452b4931d17bd44928769490e282" title="PP_BlockUntilComplete() is used in place of an actual completion callback to request blocking behavio...">PP_BlockUntilComplete()</a> is used in place of an actual completion callback to request blocking behavior. </p>
<p>If specified, the calling thread will block until the function completes. Blocking completion callbacks are only allowed from background threads.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="struct_p_p___completion_callback.html" title="PP_CompletionCallback is a common mechanism for supporting potentially asynchronous calls in browser ...">PP_CompletionCallback</a></code> structure. </dd></dl>
</div>
</div>
<a class="anchor" id="ga0fba11ae90d57086064d41b0af710253"></a><!-- doxytag: member="pp_var.h::PP_MakeBool" ref="ga0fba11ae90d57086064d41b0af710253" args="(PP_Bool value)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">struct <a class="el" href="struct_p_p___var.html">PP_Var</a> <a class="el" href="group___functions.html#ga0fba11ae90d57086064d41b0af710253">PP_MakeBool</a> </td>
<td>(</td>
<td class="paramtype"><a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a>&#160;</td>
<td class="paramname"><em>value</em></td><td>)</td>
<td><code> [read]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="group___functions.html#ga0fba11ae90d57086064d41b0af710253" title="PP_MakeBool() is used to wrap a boolean value into a PP_Var struct for passing to the browser...">PP_MakeBool()</a> is used to wrap a boolean value into a <code><a class="el" href="struct_p_p___var.html" title="The PP_VAR struct is a variant data type and can contain any value of one of the types named in the P...">PP_Var</a></code> struct for passing to the browser. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>A <code>PP_Bool</code> enumeration to wrap.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="struct_p_p___var.html" title="The PP_VAR struct is a variant data type and can contain any value of one of the types named in the P...">PP_Var</a></code> structure. </dd></dl>
</div>
</div>
<a class="anchor" id="ga8691f15edad9b391c3644064ac57f191"></a><!-- doxytag: member="pp_completion_callback.h::PP_MakeCompletionCallback" ref="ga8691f15edad9b391c3644064ac57f191" args="(PP_CompletionCallback_Func func, void *user_data)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">struct <a class="el" href="struct_p_p___completion_callback.html">PP_CompletionCallback</a> <a class="el" href="group___functions.html#ga8691f15edad9b391c3644064ac57f191">PP_MakeCompletionCallback</a> </td>
<td>(</td>
<td class="paramtype"><a class="el" href="group___typedefs.html#ga6fe12e1a41df5e10103a811036d4d8d2">PP_CompletionCallback_Func</a>&#160;</td>
<td class="paramname"><em>func</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void *&#160;</td>
<td class="paramname"><em>user_data</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [read]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="group___functions.html#ga8691f15edad9b391c3644064ac57f191" title="PP_MakeCompletionCallback() is used to create a PP_CompletionCallback.">PP_MakeCompletionCallback()</a> is used to create a <code><a class="el" href="struct_p_p___completion_callback.html" title="PP_CompletionCallback is a common mechanism for supporting potentially asynchronous calls in browser ...">PP_CompletionCallback</a></code>. </p>
<p><b>Example, creating a Required callback:</b></p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span><a class="code" href="struct_p_p___completion_callback.html" title="PP_CompletionCallback is a common mechanism for supporting potentially asynchronous calls in browser ...">PP_CompletionCallback</a> cc = <a class="code" href="group___functions.html#ga8691f15edad9b391c3644064ac57f191" title="PP_MakeCompletionCallback() is used to create a PP_CompletionCallback.">PP_MakeCompletionCallback</a>(Foo, NULL);
</pre></div><p><b>Example, creating an Optional callback:</b></p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span><a class="code" href="struct_p_p___completion_callback.html" title="PP_CompletionCallback is a common mechanism for supporting potentially asynchronous calls in browser ...">PP_CompletionCallback</a> cc = <a class="code" href="group___functions.html#ga8691f15edad9b391c3644064ac57f191" title="PP_MakeCompletionCallback() is used to create a PP_CompletionCallback.">PP_MakeCompletionCallback</a>(Foo, NULL);
 cc.<a class="code" href="struct_p_p___completion_callback.html#a4bd2d9440bc8dc18eeeca2d464156a38" title="Flags used to control how non-NULL callbacks are scheduled by asynchronous methods.">flags</a> = cc.<a class="code" href="struct_p_p___completion_callback.html#a4bd2d9440bc8dc18eeeca2d464156a38" title="Flags used to control how non-NULL callbacks are scheduled by asynchronous methods.">flags</a> | <a class="code" href="group___enums.html#gga7610f0fba2396d46384859caa4d91798aebb176d8930b14219b7966fd93a2e967" title="This flag allows any method taking such callback to complete synchronously and not call the callback ...">PP_COMPLETIONCALLBACK_FLAG_OPTIONAL</a>;
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>A <code>PP_CompletionCallback_Func</code> that will be called. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>A pointer to user data passed to your callback function. This is optional and is typically used to help track state when you may have multiple callbacks pending.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="struct_p_p___completion_callback.html" title="PP_CompletionCallback is a common mechanism for supporting potentially asynchronous calls in browser ...">PP_CompletionCallback</a></code> structure. </dd></dl>
</div>
</div>
<a class="anchor" id="gafbebaae212cb7e737efc56eea0e785b5"></a><!-- doxytag: member="pp_var.h::PP_MakeDouble" ref="gafbebaae212cb7e737efc56eea0e785b5" args="(double value)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">struct <a class="el" href="struct_p_p___var.html">PP_Var</a> <a class="el" href="group___functions.html#gafbebaae212cb7e737efc56eea0e785b5">PP_MakeDouble</a> </td>
<td>(</td>
<td class="paramtype">double&#160;</td>
<td class="paramname"><em>value</em></td><td>)</td>
<td><code> [read]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="group___functions.html#gafbebaae212cb7e737efc56eea0e785b5" title="PP_MakeDouble() is used to wrap a double value into a PP_Var struct for passing to the browser...">PP_MakeDouble()</a> is used to wrap a double value into a <code><a class="el" href="struct_p_p___var.html" title="The PP_VAR struct is a variant data type and can contain any value of one of the types named in the P...">PP_Var</a></code> struct for passing to the browser. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>A double to wrap.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="struct_p_p___var.html" title="The PP_VAR struct is a variant data type and can contain any value of one of the types named in the P...">PP_Var</a></code> structure. </dd></dl>
</div>
</div>
<a class="anchor" id="ga0aca79088546fe91d13c97db9033e709"></a><!-- doxytag: member="pp_point.h::PP_MakeFloatPoint" ref="ga0aca79088546fe91d13c97db9033e709" args="(float x, float y)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">struct <a class="el" href="struct_p_p___float_point.html">PP_FloatPoint</a> <a class="el" href="group___functions.html#ga0aca79088546fe91d13c97db9033e709">PP_MakeFloatPoint</a> </td>
<td>(</td>
<td class="paramtype">float&#160;</td>
<td class="paramname"><em>x</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float&#160;</td>
<td class="paramname"><em>y</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [read]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
</div>
</div>
<a class="anchor" id="ga0d58c0f7ab657c5cdd92afe7b5da0fce"></a><!-- doxytag: member="pp_rect.h::PP_MakeFloatRectFromXYWH" ref="ga0d58c0f7ab657c5cdd92afe7b5da0fce" args="(float x, float y, float w, float h)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">struct <a class="el" href="struct_p_p___float_rect.html">PP_FloatRect</a> <a class="el" href="group___functions.html#ga0d58c0f7ab657c5cdd92afe7b5da0fce">PP_MakeFloatRectFromXYWH</a> </td>
<td>(</td>
<td class="paramtype">float&#160;</td>
<td class="paramname"><em>x</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float&#160;</td>
<td class="paramname"><em>y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float&#160;</td>
<td class="paramname"><em>w</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float&#160;</td>
<td class="paramname"><em>h</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [read]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="group___functions.html#ga0d58c0f7ab657c5cdd92afe7b5da0fce" title="PP_MakeFloatRectFromXYWH() creates a PP_FloatRect given x and y coordinates and width and height dime...">PP_MakeFloatRectFromXYWH()</a> creates a <code><a class="el" href="struct_p_p___float_rect.html" title="The PP_FloatRect struct contains the size and location of a 2D rectangle.">PP_FloatRect</a></code> given x and y coordinates and width and height dimensions as float values. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>An float value representing a horizontal coordinate of a point, starting with 0 as the left-most coordinate. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>An float value representing a vertical coordinate of a point, starting with 0 as the top-most coordinate. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>An float value representing a width. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>An float value representing a height.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="struct_p_p___float_rect.html" title="The PP_FloatRect struct contains the size and location of a 2D rectangle.">PP_FloatRect</a></code> structure. </dd></dl>
</div>
</div>
<a class="anchor" id="gaa45701f5b00be4d57637165ae9382251"></a><!-- doxytag: member="pp_size.h::PP_MakeFloatSize" ref="gaa45701f5b00be4d57637165ae9382251" args="(float w, float h)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">struct <a class="el" href="struct_p_p___float_size.html">PP_FloatSize</a> <a class="el" href="group___functions.html#gaa45701f5b00be4d57637165ae9382251">PP_MakeFloatSize</a> </td>
<td>(</td>
<td class="paramtype">float&#160;</td>
<td class="paramname"><em>w</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float&#160;</td>
<td class="paramname"><em>h</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [read]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="group___functions.html#gaa45701f5b00be4d57637165ae9382251" title="PP_MakeFloatSize() creates a PP_FloatSize given a width and height as float values.">PP_MakeFloatSize()</a> creates a <code><a class="el" href="struct_p_p___float_size.html" title="The PP_FloatSize struct contains the size of a 2D rectangle.">PP_FloatSize</a></code> given a width and height as float values. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>An float value representing a width. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>An float value representing a height.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="struct_p_p___float_size.html" title="The PP_FloatSize struct contains the size of a 2D rectangle.">PP_FloatSize</a></code> structure. </dd></dl>
</div>
</div>
<a class="anchor" id="gad14a59fa681d4cc532b3d49c0438f0ca"></a><!-- doxytag: member="pp_var.h::PP_MakeInt32" ref="gad14a59fa681d4cc532b3d49c0438f0ca" args="(int32_t value)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">struct <a class="el" href="struct_p_p___var.html">PP_Var</a> <a class="el" href="group___functions.html#gad14a59fa681d4cc532b3d49c0438f0ca">PP_MakeInt32</a> </td>
<td>(</td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>value</em></td><td>)</td>
<td><code> [read]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="group___functions.html#gad14a59fa681d4cc532b3d49c0438f0ca" title="PP_MakeInt32() is used to wrap a 32 bit integer value into a PP_Var struct for passing to the browser...">PP_MakeInt32()</a> is used to wrap a 32 bit integer value into a <code><a class="el" href="struct_p_p___var.html" title="The PP_VAR struct is a variant data type and can contain any value of one of the types named in the P...">PP_Var</a></code> struct for passing to the browser. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>An int32 to wrap.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="struct_p_p___var.html" title="The PP_VAR struct is a variant data type and can contain any value of one of the types named in the P...">PP_Var</a></code> structure. </dd></dl>
</div>
</div>
<a class="anchor" id="ga75f83ac65ccbf57866d52d45cd5792e7"></a><!-- doxytag: member="pp_var.h::PP_MakeNull" ref="ga75f83ac65ccbf57866d52d45cd5792e7" args="(void)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">struct <a class="el" href="struct_p_p___var.html">PP_Var</a> <a class="el" href="group___functions.html#ga75f83ac65ccbf57866d52d45cd5792e7">PP_MakeNull</a> </td>
<td>(</td>
<td class="paramtype">void&#160;</td>
<td class="paramname"></td><td>)</td>
<td><code> [read]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="group___functions.html#ga75f83ac65ccbf57866d52d45cd5792e7" title="PP_MakeNull() is used to wrap a null value into a PP_Var struct for passing to the browser...">PP_MakeNull()</a> is used to wrap a null value into a <code><a class="el" href="struct_p_p___var.html" title="The PP_VAR struct is a variant data type and can contain any value of one of the types named in the P...">PP_Var</a></code> struct for passing to the browser. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="struct_p_p___var.html" title="The PP_VAR struct is a variant data type and can contain any value of one of the types named in the P...">PP_Var</a></code> structure, </dd></dl>
</div>
</div>
<a class="anchor" id="gabd6bf83f4c787477631c37d44418c4db"></a><!-- doxytag: member="pp_completion_callback.h::PP_MakeOptionalCompletionCallback" ref="gabd6bf83f4c787477631c37d44418c4db" args="(PP_CompletionCallback_Func func, void *user_data)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">struct <a class="el" href="struct_p_p___completion_callback.html">PP_CompletionCallback</a> <a class="el" href="group___functions.html#gabd6bf83f4c787477631c37d44418c4db">PP_MakeOptionalCompletionCallback</a> </td>
<td>(</td>
<td class="paramtype"><a class="el" href="group___typedefs.html#ga6fe12e1a41df5e10103a811036d4d8d2">PP_CompletionCallback_Func</a>&#160;</td>
<td class="paramname"><em>func</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void *&#160;</td>
<td class="paramname"><em>user_data</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [read]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="group___functions.html#gabd6bf83f4c787477631c37d44418c4db" title="PP_MakeOptionalCompletionCallback() is used to create a PP_CompletionCallback with PP_COMPLETIONCALLB...">PP_MakeOptionalCompletionCallback()</a> is used to create a <a class="el" href="struct_p_p___completion_callback.html" title="PP_CompletionCallback is a common mechanism for supporting potentially asynchronous calls in browser ...">PP_CompletionCallback</a> with PP_COMPLETIONCALLBACK_FLAG_OPTIONAL set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>A PP_CompletionCallback_Func to be called on completion. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>A pointer to user data passed to be passed to the callback function. This is optional and is typically used to help track state in case of multiple pending callbacks.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="struct_p_p___completion_callback.html" title="PP_CompletionCallback is a common mechanism for supporting potentially asynchronous calls in browser ...">PP_CompletionCallback</a> structure. </dd></dl>
</div>
</div>
<a class="anchor" id="ga15880e8085178758053cc521af33b250"></a><!-- doxytag: member="pp_point.h::PP_MakePoint" ref="ga15880e8085178758053cc521af33b250" args="(int32_t x, int32_t y)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">struct <a class="el" href="struct_p_p___point.html">PP_Point</a> <a class="el" href="group___functions.html#ga15880e8085178758053cc521af33b250">PP_MakePoint</a> </td>
<td>(</td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>x</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>y</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [read]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="group___functions.html#ga15880e8085178758053cc521af33b250" title="PP_MakePoint() creates a PP_Point given the x and y coordinates as int32_t values.">PP_MakePoint()</a> creates a <code><a class="el" href="struct_p_p___point.html" title="The PP_Point structure defines the integer x and y coordinates of a point.">PP_Point</a></code> given the x and y coordinates as int32_t values. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>An int32_t value representing a horizontal coordinate of a point, starting with 0 as the left-most coordinate. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>An int32_t value representing a vertical coordinate of a point, starting with 0 as the top-most coordinate.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="struct_p_p___point.html" title="The PP_Point structure defines the integer x and y coordinates of a point.">PP_Point</a></code> structure. </dd></dl>
</div>
</div>
<a class="anchor" id="gaf868e2929269ef195241b79a015fcf61"></a><!-- doxytag: member="pp_rect.h::PP_MakeRectFromXYWH" ref="gaf868e2929269ef195241b79a015fcf61" args="(int32_t x, int32_t y, int32_t w, int32_t h)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">struct <a class="el" href="struct_p_p___rect.html">PP_Rect</a> <a class="el" href="group___functions.html#gaf868e2929269ef195241b79a015fcf61">PP_MakeRectFromXYWH</a> </td>
<td>(</td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>x</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>w</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>h</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [read]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="group___functions.html#gaf868e2929269ef195241b79a015fcf61" title="PP_MakeRectFromXYWH() creates a PP_Rect given x and y coordinates and width and height dimensions as ...">PP_MakeRectFromXYWH()</a> creates a <code><a class="el" href="struct_p_p___rect.html" title="The PP_Rect struct contains the size and location of a 2D rectangle.">PP_Rect</a></code> given x and y coordinates and width and height dimensions as int32_t values. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>An int32_t value representing a horizontal coordinate of a point, starting with 0 as the left-most coordinate. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>An int32_t value representing a vertical coordinate of a point, starting with 0 as the top-most coordinate. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>An int32_t value representing a width. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>An int32_t value representing a height.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="struct_p_p___rect.html" title="The PP_Rect struct contains the size and location of a 2D rectangle.">PP_Rect</a></code> structure. </dd></dl>
</div>
</div>
<a class="anchor" id="ga35a97e64d18402d8feff46722b98beb0"></a><!-- doxytag: member="pp_size.h::PP_MakeSize" ref="ga35a97e64d18402d8feff46722b98beb0" args="(int32_t w, int32_t h)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">struct <a class="el" href="struct_p_p___size.html">PP_Size</a> <a class="el" href="group___functions.html#ga35a97e64d18402d8feff46722b98beb0">PP_MakeSize</a> </td>
<td>(</td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>w</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>h</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [read]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="group___functions.html#ga35a97e64d18402d8feff46722b98beb0" title="PP_MakeSize() creates a PP_Size given a width and height as int32_t values.">PP_MakeSize()</a> creates a <code><a class="el" href="struct_p_p___size.html" title="The PP_Size struct contains the size of a 2D rectangle.">PP_Size</a></code> given a width and height as int32_t values. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>An int32_t value representing a width. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>An int32_t value representing a height.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="struct_p_p___size.html" title="The PP_Size struct contains the size of a 2D rectangle.">PP_Size</a></code> structure. </dd></dl>
</div>
</div>
<a class="anchor" id="gae7f6d41cbb173c12f474242c2a3bf5e7"></a><!-- doxytag: member="pp_touch_point.h::PP_MakeTouchPoint" ref="gae7f6d41cbb173c12f474242c2a3bf5e7" args="(void)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">struct <a class="el" href="struct_p_p___touch_point.html">PP_TouchPoint</a> <a class="el" href="group___functions.html#gae7f6d41cbb173c12f474242c2a3bf5e7">PP_MakeTouchPoint</a> </td>
<td>(</td>
<td class="paramtype">void&#160;</td>
<td class="paramname"></td><td>)</td>
<td><code> [read]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="group___functions.html#gae7f6d41cbb173c12f474242c2a3bf5e7" title="PP_MakeTouchPoint() creates a PP_TouchPoint.">PP_MakeTouchPoint()</a> creates a <code><a class="el" href="struct_p_p___touch_point.html" title="The PP_TouchPoint struct represents all information about a single touch point, such as position...">PP_TouchPoint</a></code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="struct_p_p___touch_point.html" title="The PP_TouchPoint struct represents all information about a single touch point, such as position...">PP_TouchPoint</a></code> structure. </dd></dl>
</div>
</div>
<a class="anchor" id="ga0edc8314fc1a92f93dd3d0eab286cb5d"></a><!-- doxytag: member="pp_var.h::PP_MakeUndefined" ref="ga0edc8314fc1a92f93dd3d0eab286cb5d" args="(void)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">struct <a class="el" href="struct_p_p___var.html">PP_Var</a> <a class="el" href="group___functions.html#ga0edc8314fc1a92f93dd3d0eab286cb5d">PP_MakeUndefined</a> </td>
<td>(</td>
<td class="paramtype">void&#160;</td>
<td class="paramname"></td><td>)</td>
<td><code> [read]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="group___functions.html#ga0edc8314fc1a92f93dd3d0eab286cb5d" title="PP_MakeUndefined() is used to wrap an undefined value into a PP_Var struct for passing to the browser...">PP_MakeUndefined()</a> is used to wrap an undefined value into a <code><a class="el" href="struct_p_p___var.html" title="The PP_VAR struct is a variant data type and can contain any value of one of the types named in the P...">PP_Var</a></code> struct for passing to the browser. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="struct_p_p___var.html" title="The PP_VAR struct is a variant data type and can contain any value of one of the types named in the P...">PP_Var</a></code> structure. </dd></dl>
</div>
</div>
<a class="anchor" id="ga8dac45aa496bbb1f97a15e2833d3ed02"></a><!-- doxytag: member="pp_completion_callback.h::PP_RunAndClearCompletionCallback" ref="ga8dac45aa496bbb1f97a15e2833d3ed02" args="(struct PP_CompletionCallback *cc, int32_t res)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void <a class="el" href="group___functions.html#ga8dac45aa496bbb1f97a15e2833d3ed02">PP_RunAndClearCompletionCallback</a> </td>
<td>(</td>
<td class="paramtype">struct <a class="el" href="struct_p_p___completion_callback.html">PP_CompletionCallback</a> *&#160;</td>
<td class="paramname"><em>cc</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>res</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="group___functions.html#ga8dac45aa496bbb1f97a15e2833d3ed02" title="PP_RunAndClearCompletionCallback() runs a callback and clears the reference to that callback...">PP_RunAndClearCompletionCallback()</a> runs a callback and clears the reference to that callback. </p>
<p>This function is used when the null-ness of a completion callback is used as a signal for whether a completion callback has been registered. In this case, after the execution of the callback, it should be cleared. However, this introduces a conflict if the completion callback wants to schedule more work that involves the same completion callback again (for example, when reading data from an URLLoader, one would typically queue up another read callback). As a result, this function clears the pointer before the provided callback is executed. </p>
</div>
</div>
<a class="anchor" id="gaffce49266a735f9ee8d149b14477404f"></a><!-- doxytag: member="pp_completion_callback.h::PP_RunCompletionCallback" ref="gaffce49266a735f9ee8d149b14477404f" args="(struct PP_CompletionCallback *cc, int32_t result)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void <a class="el" href="group___functions.html#gaffce49266a735f9ee8d149b14477404f">PP_RunCompletionCallback</a> </td>
<td>(</td>
<td class="paramtype">struct <a class="el" href="struct_p_p___completion_callback.html">PP_CompletionCallback</a> *&#160;</td>
<td class="paramname"><em>cc</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>result</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="group___functions.html#gaffce49266a735f9ee8d149b14477404f" title="PP_RunCompletionCallback() is used to run a callback.">PP_RunCompletionCallback()</a> is used to run a callback. </p>
<p>It invokes the callback function passing it user data specified on creation and completion |result|.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">cc</td><td>A pointer to a <code><a class="el" href="struct_p_p___completion_callback.html" title="PP_CompletionCallback is a common mechanism for supporting potentially asynchronous calls in browser ...">PP_CompletionCallback</a></code> that will be run. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>The result of the operation. Non-positive values correspond to the error codes from <a class="el" href="pp__errors_8h.html" title="This file defines an enumeration of all PPAPI error codes.">pp_errors.h</a> (excluding PP_OK_COMPLETIONPENDING). Positive values indicate additional information such as bytes read. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga4127b148b2bd0f3bc2c078dd38cbe4cf"></a><!-- doxytag: member="ppp.h::PPP_GetInterface" ref="ga4127b148b2bd0f3bc2c078dd38cbe4cf" args="(const char *interface_name)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">const void* <a class="el" href="group___functions.html#ga4127b148b2bd0f3bc2c078dd38cbe4cf">PPP_GetInterface</a> </td>
<td>(</td>
<td class="paramtype">const char *&#160;</td>
<td class="paramname"><em>interface_name</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="group___functions.html#ga4127b148b2bd0f3bc2c078dd38cbe4cf" title="PPP_GetInterface() is called by the browser to query the module for interfaces it supports...">PPP_GetInterface()</a> is called by the browser to query the module for interfaces it supports. </p>
<p>Your module must implement the <code>PPP_Instance</code> interface or it will be unloaded. Other interfaces are optional.</p>
<p>This function is called from within browser code whenever an interface is needed. This means your plugin could be reentered via this function if you make a browser call and it needs an interface. Furthermore, you should not make any other browser calls from within your implementation to avoid reentering the browser.</p>
<p>As a result, your implementation of this should merely provide a lookup from the requested name to an interface pointer, via something like a big if/else block or a map, and not do any other work.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">interface_name</td><td>A pointer to a "PPP" (plugin) interface name. Interface names are null-terminated ASCII strings.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer for the interface or <code>NULL</code> if the interface is not supported. </dd></dl>
</div>
</div>
<a class="anchor" id="ga2fc7b396531c19417d8d7171d56da8b6"></a><!-- doxytag: member="ppp.h::PPP_InitializeModule" ref="ga2fc7b396531c19417d8d7171d56da8b6" args="(PP_Module module, PPB_GetInterface get_browser_interface)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="group___functions.html#ga2fc7b396531c19417d8d7171d56da8b6">PPP_InitializeModule</a> </td>
<td>(</td>
<td class="paramtype"><a class="el" href="group___typedefs.html#gab780dd451cd7f51284cb752edd88f9a0">PP_Module</a>&#160;</td>
<td class="paramname"><em>module</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="group___typedefs.html#ga68ad7c927b86e0c29d890603edd33154">PPB_GetInterface</a>&#160;</td>
<td class="paramname"><em>get_browser_interface</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="group___functions.html#ga2fc7b396531c19417d8d7171d56da8b6" title="PPP_InitializeModule() is the entry point for a module and is called by the browser when your module ...">PPP_InitializeModule()</a> is the entry point for a module and is called by the browser when your module loads. </p>
<p>Your code must implement this function.</p>
<p>Failure indicates to the browser that this module can not be used. In this case, the module will be unloaded and ShutdownModule will NOT be called.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>A handle to your module. Generally you should store this value since it will be required for other API calls. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">get_browser_interface</td><td>A pointer to the function that you can use to query for browser interfaces. Generally you should store this value for future use.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>PP_OK</code> on success. Any other value on failure. </dd></dl>
</div>
</div>
<a class="anchor" id="gaa3021aba7ddc17a8cecb4bc4f8374e98"></a><!-- doxytag: member="ppp.h::PPP_ShutdownModule" ref="gaa3021aba7ddc17a8cecb4bc4f8374e98" args="(void)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void <a class="el" href="group___functions.html#gaa3021aba7ddc17a8cecb4bc4f8374e98">PPP_ShutdownModule</a> </td>
<td>(</td>
<td class="paramtype">void&#160;</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="group___functions.html#gaa3021aba7ddc17a8cecb4bc4f8374e98" title="PPP_ShutdownModule() is sometimes called before the module is unloaded.">PPP_ShutdownModule()</a> is <b>sometimes</b> called before the module is unloaded. </p>
<p>It is not recommended that you implement this function.</p>
<p>There is no practical use of this function for third party modules. Its existence is because of some internal use cases inside Chrome.</p>
<p>Since your module runs in a separate process, there's no need to free allocated memory. There is also no need to free any resources since all of resources associated with an instance will be force-freed when that instance is deleted.</p>
<p><b>Note:</b> This function will always be skipped on untrusted (Native Client) implementations. This function may be skipped on trusted implementations in certain circumstances when Chrome does "fast shutdown" of a web page. </p>
</div>
</div>
</div><!-- contents -->
</div>
{{/partials.standard_nacl_api}}
