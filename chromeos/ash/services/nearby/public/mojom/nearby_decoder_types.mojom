// Copyright 2020 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module sharing.mojom;

import "chromeos/ash/services/nearby/public/mojom/nearby_share_target_types.mojom";
import "mojo/public/mojom/base/time.mojom";

// An advertisement send by a device in receiving mode.
struct Advertisement {
  // Random bytes that were used as salt during encryption of public
  // certificate metadata.
  array<uint8, 2> salt;

  // An encrypted symmetric key that was used to encrypt public certificate
  // metadata. The key can be decrypted using |salt| and the corresponding
  // public certificate's secret/authenticity key.
  array<uint8, 14> encrypted_metadata_key;

  // Type of the device.
  nearby_share.mojom.ShareTargetType device_type;

  // If present, the device is visible to everyone rather than contacts only.
  string? device_name;
};

// A frame used when sending messages over the wire.
union Frame {
  // A frame of one possible type.
  V1Frame v1;
};

// The possible types of a frame.
union V1Frame {
  IntroductionFrame introduction;

  ConnectionResponseFrame connection_response;

  PairedKeyEncryptionFrame paired_key_encryption;

  PairedKeyResultFrame paired_key_result;

  CertificateInfoFrame certificate_info;

  CancelFrame cancel_frame;
};

// An introduction packet sent by the sending side. Contains a list of files
// they'd like to share.
struct IntroductionFrame {
  // Description of a file to be sent.
  array<FileMetadata> file_metadata;

  // Description of text to be sent.
  array<TextMetadata> text_metadata;

  // The required app package to open the content. May be null.
  string? required_package;

  // Credentials of the wifi network.
  array<WifiCredentialsMetadata> wifi_credentials_metadata;
};

// File metadata. Does not include the actual bytes of the shared file
// in transit.
struct FileMetadata {
  enum Type {
    kUnknown = 0,
    kImage = 1,
    kVideo = 2,
    kApp = 3,
    kAudio = 4
  };

  // The human readable name of this file (eg. 'Cookbook.pdf').
  string name;

  // The type of file (eg. 'kImage' from 'dog.jpg'). Specifying a type helps
  // provide a richer experience on the receiving side.
  Type type = kUnknown;

  // The FILE payload id that will be sent as a follow up containing the actual
  // bytes of the file.
  int64 payload_id;

  // The total size of the file.
  uint64 size;

  // The mimeType of file (eg. 'image/jpeg' from 'dog.jpg'). Specifying a
  // mimeType helps provide a richer experience on receiving side.
  string mime_type = "application/octet-stream";

  // A uuid for the attachment. Should be unique across all attachments.
  int64 id;
};

// Text metadata. Does not include the actual bytes of the text in transit.
struct TextMetadata {
  enum Type {
    kUnknown = 0,
    kText = 1,
    // Open with browsers.
    kUrl = 2,
    // Open with map apps.
    kAddress = 3,
    // Dial.
    kPhoneNumber = 4
  };

  // The title of the text content.
  string text_title;

  // The type of text (phone number, url, address, or plain text).
  Type type = kUnknown;

  // The BYTE payload id that will be sent as a follow up containing the actual
  // bytes of the text.
  int64 payload_id;

  // The size of the text content.
  uint64 size;

  // A uuid for the attachment. Should be unique across all attachments.
  int64 id;
};

// Wifi credentails metadata. Describes the wifi network to be used by the
// connection.
struct WifiCredentialsMetadata {
  enum SecurityType {
    kUnknownSecurityType = 0,
    kOpen = 1,
    kWpaPsk = 2,
    kWep = 3
  };

  // The Wifi network name. This will be sent in introduction.
  string ssid;

  // The security type of network (OPEN, WPA_PSK, WEP).
  SecurityType security_type = kUnknownSecurityType;

  // The BYTE payload id that will be sent as a follow up containing the
  // password.
  int64 payload_id;

  // A uuid for the attachment. Should be unique across all attachments.
  int64 id;
};

// A response packet sent by the receiving side. Accepts or rejects the list of
// files.
struct ConnectionResponseFrame {
  enum Status {
    kUnknown = 0,
    kAccept = 1,
    kReject = 2,
    kNotEnoughSpace = 3,
    kUnsupportedAttachmentType = 4,
    kTimedOut = 5
  };

  // The receiving side's response.
  Status status;
};

// A paired key encryption packet sent between devices, contains signed data.
struct PairedKeyEncryptionFrame {
  // The encrypted data in byte array format.
  // The size of byte array generated by signing should be 72.
  array<uint8> signed_data;

  // The HMAC 256 based HKDF of UKEY2 authentication key with
  // authenticity_key salt.
  // The size of bytes of secret id after hash should be 6.
  array<uint8> secret_id_hash;

  // An optional encrypted data in byte array format.
  // The size of byte array generated by signing should be 72.
  array<uint8>? optional_signed_data;
};

// A paired key verification result packet sent between devices.
struct PairedKeyResultFrame {
  enum Status {
    kUnknown = 0,
    kSuccess = 1,
    kFail = 2,
    kUnable = 3
  };

  // The verification result.
  Status status;
};

// A package containing certificate info to be shared to remote device offline.
struct CertificateInfoFrame {
  // The public certificates to be shared with remote devices.
  array<PublicCertificate> public_certificate;
};

// A public certificate from the local device.
struct PublicCertificate {
  // The unique id of the public certificate.
  array<uint8> secret_id;

  // A bytes representation of a Secret Key owned by contact, to decrypt the
  // metadata_key stored within the advertisement.
  // The size should be 32.
  array<uint8> authenticity_key;

  // A bytes representation a public key of X509Certificate, owned by contact,
  // to decrypt UKEY2 (from Nearby Connections API) as a hand shake in
  // contact verification phase.
  array<uint8> public_key;

  // Time from epoch when this certificate becomes effective.
  mojo_base.mojom.Time start_time;

  // Time from epoch when this certificate expires.
  mojo_base.mojom.Time end_time;

  // The encrypted metadata in bytes, contains personal information of the
  // device/user who created this certificate. Needs to be decrypted into bytes,
  // and converted back to EncryptedMetadata object to access fields.
  array<uint8> encrypted_metadata_bytes;

  // The tag for verifying metadata_encryption_key.
  // The size should be 32.
  array<uint8> metadata_encryption_key_tag;
};

// Frame sent by remote device to cancel the share action.
struct CancelFrame {
};
