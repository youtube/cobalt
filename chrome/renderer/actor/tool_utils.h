// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_RENDERER_ACTOR_TOOL_UTILS_H_
#define CHROME_RENDERER_ACTOR_TOOL_UTILS_H_

#include <cstdint>
#include <optional>
#include <string>

#include "base/functional/callback_forward.h"
#include "base/memory/weak_ptr.h"
#include "chrome/common/actor.mojom-forward.h"
#include "chrome/renderer/actor/tool_base.h"
#include "third_party/blink/public/common/input/web_input_event.h"
#include "third_party/blink/public/common/input/web_mouse_event.h"

namespace blink {
class WebNode;
class WebWidget;
}  // namespace blink

namespace content {
class RenderFrame;
}  // namespace content

namespace gfx {
class Rect;
class PointF;
}  // namespace gfx

namespace actor {

struct ResolvedTarget;
class ToolBase;

// Class to help with iteratively refining interaction points. When created,
// it grabs the client rects for the provided web node. Then if you perform a
// hit test that hits another element you can add that element's visible bounds
// as a new exclusion.
class InteractionPointRefiner {
 public:
  // Limit the number of rects that we try to handle to avoid performance hits
  // on bad pages.
  static constexpr size_t kMaxRects = 100;

  explicit InteractionPointRefiner(const blink::WebNode& node);
  explicit InteractionPointRefiner(std::vector<gfx::Rect> rects);
  ~InteractionPointRefiner();
  InteractionPointRefiner(InteractionPointRefiner&&);
  InteractionPointRefiner& operator=(InteractionPointRefiner&&);

  // Samples a point from the hit_boxes_. Currently just uses the middle of the
  // first non-empty box.
  std::optional<gfx::PointF> GetPoint() const;

  // Updates the `hit_boxes_` based on the exclusions generated by this element.
  // After this call the `hit_boxes_` will not intersect the hit boxes
  // calculated for this `element`.
  void ExcludeElement(blink::WebElement& element);

  // Updates the hit_boxes based on the new exclusion. After this is called the
  // new hit_boxes_ will not intersect with new_exclusion.
  void AddExclusion(const gfx::Rect& exclusion);

 private:
  std::vector<gfx::Rect> hit_boxes_;
};

// Returns the Blink node for the given DOMNodeId if one exists and its document
// has the given frame as a local root. Returns a null WebNode otherwise.
blink::WebNode GetNodeFromId(const content::RenderFrame& local_root_frame,
                             int32_t node_id);

// Returns the center coordinates of the node's bounding box in widget space.
// Returns nullopt if the node is not a visible element or has no bounds.
std::optional<gfx::PointF> InteractionPointFromWebNode(
    blink::WebWidget* widget,
    const blink::WebNode& node);

// Returns whether the Node is focusable and in focus.
bool IsNodeFocused(const content::RenderFrame& frame,
                   const blink::WebNode& node);

// `point` is relative to the viewport origin.
// Note: this doesn't account for pinch-zoom.
bool IsPointWithinViewport(const gfx::PointF& point,
                           const content::RenderFrame& frame);

// Returns true if node appears (even partially) in the viewport.
bool IsNodeWithinViewport(const blink::WebNode& node);

std::string ToDebugString(const mojom::ToolTargetPtr& target);

// Create and dispatch the mouse down event and corresponding mouse up, click
// event to the widget.
void CreateAndDispatchClick(
    blink::WebMouseEvent::Button button,
    int count,
    const ResolvedTarget& click_point,
    base::WeakPtr<ToolBase> tool,
    base::OnceCallback<void(mojom::ActionResultPtr)> on_complete);

// Converts Node to a debug string of tag name, id and class.
std::string NodeToDebugString(const blink::WebNode& node);

}  // namespace actor

#endif  // CHROME_RENDERER_ACTOR_TOOL_UTILS_H_
