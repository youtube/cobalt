// This file was GENERATED by command:
//     pump.py optional_internal.h.pump
// DO NOT EDIT BY HAND!!!

//
// Copyright 2016 The Cobalt Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// clang-format off
// Begin forwarding constructor definitions ////////////////////////////////////
  explicit optional(in_place_t) {
    InitializeAsDisengaged();
    new (void_value()) T();
    engaged_ = true;
#if !defined(NDEBUG)
    value_ptr_ = static_cast<const T*>(void_value());
#endif
  }
  template <typename P1>
  explicit optional(in_place_t, const P1& p1) {
    InitializeAsDisengaged();
    new (void_value()) T(p1);
    engaged_ = true;
#if !defined(NDEBUG)
    value_ptr_ = static_cast<const T*>(void_value());
#endif
  }
  template <typename P1, typename P2>
  explicit optional(in_place_t, const P1& p1, const P2& p2) {
    InitializeAsDisengaged();
    new (void_value()) T(p1, p2);
    engaged_ = true;
#if !defined(NDEBUG)
    value_ptr_ = static_cast<const T*>(void_value());
#endif
  }
  template <typename P1, typename P2, typename P3>
  explicit optional(in_place_t, const P1& p1, const P2& p2, const P3& p3) {
    InitializeAsDisengaged();
    new (void_value()) T(p1, p2, p3);
    engaged_ = true;
#if !defined(NDEBUG)
    value_ptr_ = static_cast<const T*>(void_value());
#endif
  }
  template <typename P1, typename P2, typename P3, typename P4>
  explicit optional(in_place_t, const P1& p1, const P2& p2, const P3& p3,
      const P4& p4) {
    InitializeAsDisengaged();
    new (void_value()) T(p1, p2, p3, p4);
    engaged_ = true;
#if !defined(NDEBUG)
    value_ptr_ = static_cast<const T*>(void_value());
#endif
  }
  template <typename P1, typename P2, typename P3, typename P4, typename P5>
  explicit optional(in_place_t, const P1& p1, const P2& p2, const P3& p3,
      const P4& p4, const P5& p5) {
    InitializeAsDisengaged();
    new (void_value()) T(p1, p2, p3, p4, p5);
    engaged_ = true;
#if !defined(NDEBUG)
    value_ptr_ = static_cast<const T*>(void_value());
#endif
  }
  template <typename P1, typename P2, typename P3, typename P4, typename P5,
      typename P6>
  explicit optional(in_place_t, const P1& p1, const P2& p2, const P3& p3,
      const P4& p4, const P5& p5, const P6& p6) {
    InitializeAsDisengaged();
    new (void_value()) T(p1, p2, p3, p4, p5, p6);
    engaged_ = true;
#if !defined(NDEBUG)
    value_ptr_ = static_cast<const T*>(void_value());
#endif
  }
  template <typename P1, typename P2, typename P3, typename P4, typename P5,
      typename P6, typename P7>
  explicit optional(in_place_t, const P1& p1, const P2& p2, const P3& p3,
      const P4& p4, const P5& p5, const P6& p6, const P7& p7) {
    InitializeAsDisengaged();
    new (void_value()) T(p1, p2, p3, p4, p5, p6, p7);
    engaged_ = true;
#if !defined(NDEBUG)
    value_ptr_ = static_cast<const T*>(void_value());
#endif
  }
// End forwarding constructor definitions //////////////////////////////////////

// Begin emplace(...) definitions //////////////////////////////////////////////
  void emplace() {
    EnsureDisengaged();
    new (void_value()) T();
    engaged_ = true;
#if !defined(NDEBUG)
    value_ptr_ = static_cast<const T*>(void_value());
#endif
  }
  template <typename P1>
  void emplace(const P1& p1) {
    EnsureDisengaged();
    new (void_value()) T(p1);
    engaged_ = true;
#if !defined(NDEBUG)
    value_ptr_ = static_cast<const T*>(void_value());
#endif
  }
  template <typename P1, typename P2>
  void emplace(const P1& p1, const P2& p2) {
    EnsureDisengaged();
    new (void_value()) T(p1, p2);
    engaged_ = true;
#if !defined(NDEBUG)
    value_ptr_ = static_cast<const T*>(void_value());
#endif
  }
  template <typename P1, typename P2, typename P3>
  void emplace(const P1& p1, const P2& p2, const P3& p3) {
    EnsureDisengaged();
    new (void_value()) T(p1, p2, p3);
    engaged_ = true;
#if !defined(NDEBUG)
    value_ptr_ = static_cast<const T*>(void_value());
#endif
  }
  template <typename P1, typename P2, typename P3, typename P4>
  void emplace(const P1& p1, const P2& p2, const P3& p3, const P4& p4) {
    EnsureDisengaged();
    new (void_value()) T(p1, p2, p3, p4);
    engaged_ = true;
#if !defined(NDEBUG)
    value_ptr_ = static_cast<const T*>(void_value());
#endif
  }
  template <typename P1, typename P2, typename P3, typename P4, typename P5>
  void emplace(const P1& p1, const P2& p2, const P3& p3, const P4& p4,
      const P5& p5) {
    EnsureDisengaged();
    new (void_value()) T(p1, p2, p3, p4, p5);
    engaged_ = true;
#if !defined(NDEBUG)
    value_ptr_ = static_cast<const T*>(void_value());
#endif
  }
  template <typename P1, typename P2, typename P3, typename P4, typename P5,
      typename P6>
  void emplace(const P1& p1, const P2& p2, const P3& p3, const P4& p4,
      const P5& p5, const P6& p6) {
    EnsureDisengaged();
    new (void_value()) T(p1, p2, p3, p4, p5, p6);
    engaged_ = true;
#if !defined(NDEBUG)
    value_ptr_ = static_cast<const T*>(void_value());
#endif
  }
  template <typename P1, typename P2, typename P3, typename P4, typename P5,
      typename P6, typename P7>
  void emplace(const P1& p1, const P2& p2, const P3& p3, const P4& p4,
      const P5& p5, const P6& p6, const P7& p7) {
    EnsureDisengaged();
    new (void_value()) T(p1, p2, p3, p4, p5, p6, p7);
    engaged_ = true;
#if !defined(NDEBUG)
    value_ptr_ = static_cast<const T*>(void_value());
#endif
  }
// End emplace(...) definitions ////////////////////////////////////////////////
// clang-format on
