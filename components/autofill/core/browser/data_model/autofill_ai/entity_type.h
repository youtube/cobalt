// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_AUTOFILL_CORE_BROWSER_DATA_MODEL_AUTOFILL_AI_ENTITY_TYPE_H_
#define COMPONENTS_AUTOFILL_CORE_BROWSER_DATA_MODEL_AUTOFILL_AI_ENTITY_TYPE_H_

#include <ostream>
#include <string_view>
#include <type_traits>

#include "base/containers/span.h"
#include "base/notreached.h"
#include "components/autofill/core/browser/data_model/autofill_ai/entity_type_names.h"
#include "components/autofill/core/browser/field_types.h"
#include "components/autofill/core/common/dense_set.h"

namespace autofill {

// Entity and attribute types are blueprints for entity and attribute instances.
//
// For example, "passport" is an entity type and its attribute types include
// "name", "country", "issue date", "expiry date", etc.
//
// A specific passport is an entity instance, which has attribute instances with
// values such "John Doe", "USA", "05/2019", "04/2029", etc.
//
// Entity types are generated at compile time from the schema definition in
// entity_schema.json.
class EntityType;
class AttributeType;

// An attribute type is the blueprint for an attribute instance, which in turn
// represents a string value with additional metadata.
//
// An AttributeType is uniquely identified by its AttributeTypeName from
// entity_type_names.h generated by transpile_entity_schema.py. AttributeType is
// merely a thin wrapper with member functions.
class AttributeType final {
 public:
  // The underlying representation of the data stored in this attribute.
  enum class DataType {
    kCountry,
    kDate,
    kName,
    kState,
    kString,
    kMaxValue = kString,
  };

  // Comparator that ranks types by their priority for disambiguating different
  // instances of the same entity type, as specified in the schema.
  // `DisambiguationOrder(x, y) == true` means `x` has higher priority than `y`.
  //
  // For example, when disambiguating different passport instances, the name and
  // country should likely take precedence over the passport number.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  static bool DisambiguationOrder(const AttributeType& lhs,
                                  const AttributeType& rhs);

  // Maps each Autofill AI `FieldType` to the corresponding AttributeType.
  static std::optional<AttributeType> FromFieldType(FieldType type);

  constexpr explicit AttributeType(AttributeTypeName n) : name_(n) {}

  constexpr AttributeType(const AttributeType&) = default;
  constexpr AttributeType& operator=(const AttributeType&) = default;
  constexpr AttributeType(AttributeType&&) = default;
  constexpr AttributeType& operator=(AttributeType&&) = default;

  constexpr AttributeTypeName name() const { return name_; }

  EntityType entity_type() const;

  constexpr DataType data_type() const;

  // Maps this AttributeType to the corresponding Autofill AI `FieldType`.
  constexpr FieldType field_type() const;

  // Returns whether the attribute should be obfuscated in preview and
  // suggestion labels.
  bool is_obfuscated() const;

  // Whether this attribute type is part of the entity's disambiguating fields
  // list.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  bool is_disambiguation_type() const;

  // The string representation of the name. This is unique among all attribute
  // types of the associated entity type. (It is not globally unique!)
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  std::string_view name_as_string() const;

  // The i18n string representation of the name.
  std::u16string GetNameForI18n() const;

  friend constexpr bool operator==(const AttributeType& lhs,
                                   const AttributeType& rhs) = default;

  friend constexpr auto operator<=>(const AttributeType& lhs,
                                    const AttributeType& rhs) = default;

 private:
  AttributeTypeName name_{};
};

constexpr AttributeType::DataType AttributeType::data_type() const {
  switch (name_) {
    case AttributeTypeName::kPassportName:
    case AttributeTypeName::kDriversLicenseName:
    case AttributeTypeName::kVehicleOwner:
      return DataType::kName;
    case AttributeTypeName::kPassportCountry:
      return DataType::kCountry;
    case AttributeTypeName::kPassportExpirationDate:
    case AttributeTypeName::kPassportIssueDate:
    case AttributeTypeName::kDriversLicenseExpirationDate:
    case AttributeTypeName::kDriversLicenseIssueDate:
      return DataType::kDate;
    case AttributeTypeName::kVehiclePlateState:
    case AttributeTypeName::kDriversLicenseState:
      return DataType::kState;
    case AttributeTypeName::kPassportNumber:
    case AttributeTypeName::kVehiclePlateNumber:
    case AttributeTypeName::kVehicleVin:
    case AttributeTypeName::kVehicleMake:
    case AttributeTypeName::kVehicleModel:
    case AttributeTypeName::kVehicleYear:
    case AttributeTypeName::kDriversLicenseNumber:
      return DataType::kString;
  }
  NOTREACHED();
}

constexpr FieldType AttributeType::field_type() const {
  switch (name_) {
    case AttributeTypeName::kPassportName:
      return PASSPORT_NAME_TAG;
    case AttributeTypeName::kPassportNumber:
      return PASSPORT_NUMBER;
    case AttributeTypeName::kPassportCountry:
      return PASSPORT_ISSUING_COUNTRY;
    case AttributeTypeName::kPassportExpirationDate:
      return PASSPORT_EXPIRATION_DATE;
    case AttributeTypeName::kPassportIssueDate:
      return PASSPORT_ISSUE_DATE;

    case AttributeTypeName::kVehicleOwner:
      return VEHICLE_OWNER_TAG;
    case AttributeTypeName::kVehiclePlateNumber:
      return VEHICLE_LICENSE_PLATE;
    case AttributeTypeName::kVehicleVin:
      return VEHICLE_VIN;
    case AttributeTypeName::kVehicleMake:
      return VEHICLE_MAKE;
    case AttributeTypeName::kVehicleModel:
      return VEHICLE_MODEL;
    case AttributeTypeName::kVehicleYear:
      return VEHICLE_YEAR;
    case AttributeTypeName::kVehiclePlateState:
      return VEHICLE_PLATE_STATE;

    case AttributeTypeName::kDriversLicenseName:
      return DRIVERS_LICENSE_NAME_TAG;
    case AttributeTypeName::kDriversLicenseState:
      return DRIVERS_LICENSE_REGION;
    case AttributeTypeName::kDriversLicenseNumber:
      return DRIVERS_LICENSE_NUMBER;
    case AttributeTypeName::kDriversLicenseExpirationDate:
      return DRIVERS_LICENSE_EXPIRATION_DATE;
    case AttributeTypeName::kDriversLicenseIssueDate:
      return DRIVERS_LICENSE_ISSUE_DATE;
  }
  NOTREACHED();
}

template <>
struct DenseSetTraits<AttributeType> {
  using T = AttributeType;
  using N = AttributeTypeName;
  using UnderlyingType = std::underlying_type_t<N>;

  static constexpr T from_underlying(UnderlyingType x) {
    return T(static_cast<N>(x));
  }
  static constexpr UnderlyingType to_underlying(T x) {
    return base::to_underlying(x.name());
  }

  static constexpr auto kMinValue = T(static_cast<N>(0));
  static constexpr auto kMaxValue = T(N::kMaxValue);
  static constexpr bool kPacked = false;
};

// An entity type is the blueprint for an entity instance. It defines the
// available attributes and additional metadata.
//
// An EntityType is uniquely identified by its EntityTypeName from
// entity_type_names.h generated by transpile_entity_schema.py. EntityType is
// merely a thin wrapper with member functions.
class EntityType final {
 public:
  constexpr explicit EntityType(EntityTypeName n) : name_(n) {}

  constexpr EntityType(const EntityType&) = default;
  constexpr EntityType& operator=(const EntityType&) = default;
  constexpr EntityType(EntityType&&) = default;
  constexpr EntityType& operator=(EntityType&&) = default;

  // Comparator that ranks types by their priority for import on form
  // submission.
  // `ImportOrder(x, y) == true` means `x` has higher priority than `y`.
  static bool ImportOrder(const EntityType& lhs, const EntityType& rhs);

  constexpr EntityTypeName name() const { return name_; }

  // The string representation of the name. This is unique among all entity
  // types.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  std::string_view name_as_string() const;

  // The i18n string representation of the name.
  std::u16string GetNameForI18n() const;

  // The attributes supported by this entity type, as specified in the schema.
  // An instance of this entity may define values for some or all of these
  // attributes.
  //
  // For example, for a passport entity this may be the number, the name, the
  // country etc.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  DenseSet<AttributeType> attributes() const;

  // An import constraint is a precondition for importing an EntityInstance on
  // form submission: it is a set of attributes all of which the instance must
  // set.
  // At least one of the import constraints must be satisfied.
  //
  // For example, for a passport the import constraints may be {number} and
  // {name, country}. Then it suffices for an instances to define either the
  // number or both the name and country.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  base::span<const DenseSet<AttributeType>> import_constraints() const;

  // A merge constraint is a precondition for merging two EntityInstances: it is
  // a set of attributes which both instances must agree on, i.e., they must set
  // it to the same value.
  // At least one of the merge constraints must be satisfied.
  //
  // Intuitively, the attributes of a merge constraint uniquely identify an
  // entity instances.
  //
  // For example, for a passport the two alternative constraints may be {number}
  // and {name, country, issue date} because passport numbers generally serve
  // as unique identifiers and also a single user usually only has one passport
  // per name, country, and date.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  base::span<const DenseSet<AttributeType>> merge_constraints() const;

  // A strike key is a tuple of attributes whose values are used as a key in the
  // strike database for save prompts.
  //
  // For example, a passport may have {number} and {name, country} as strike
  // keys. In that case we will stop showing save prompts for a given passport
  // number if save prompts with the same number have been ignored or declined
  // enough consecutive times. Similarly, we will stop showing save prompts for
  // a given (passport name, passport country) combination if the save prompts
  // with the same attribute values have been ignored or declined enough times
  // in a row.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  base::span<const DenseSet<AttributeType>> strike_keys() const;

  // Indicates if instances of this type may be synced, as specified in the
  // schema.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  bool syncable() const;

  friend constexpr bool operator==(const EntityType& lhs,
                                   const EntityType& rhs) = default;

  friend constexpr auto operator<=>(const EntityType& lhs,
                                    const EntityType& rhs) = default;

 private:
  EntityTypeName name_{};
};

// Validates a raw value corresponding to an `EntityTypeName` object. Returns
// the corresponding enum value if valid, or `std::nullopt` otherwise.
std::optional<EntityTypeName> ToSafeEntityTypeName(
    std::underlying_type_t<EntityTypeName> raw_value);

template <>
struct DenseSetTraits<EntityType> {
  using T = EntityType;
  using N = EntityTypeName;
  using UnderlyingType = std::underlying_type_t<N>;

  static constexpr T from_underlying(UnderlyingType x) {
    return T(static_cast<N>(x));
  }
  static constexpr UnderlyingType to_underlying(T x) {
    return base::to_underlying(x.name());
  }

  static constexpr auto kMinValue = T(static_cast<N>(0));
  static constexpr auto kMaxValue = T(N::kMaxValue);
  static constexpr bool kPacked = false;
};

class EntityTable;

// Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
std::optional<EntityType> StringToEntityType(
    base::PassKey<EntityTable> pass_key,
    std::string_view entity_type_name);
std::optional<AttributeType> StringToAttributeType(
    base::PassKey<EntityTable> pass_key,
    EntityType entity_type,
    std::string_view attribute_type_name);

std::ostream& operator<<(std::ostream& os, AttributeType a);
std::ostream& operator<<(std::ostream& os, EntityType t);

}  // namespace autofill

#endif  // COMPONENTS_AUTOFILL_CORE_BROWSER_DATA_MODEL_AUTOFILL_AI_ENTITY_TYPE_H_
