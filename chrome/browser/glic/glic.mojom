// Copyright 2024 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module glic.mojom;

import "mojo/public/mojom/base/proto_wrapper.mojom";
import "mojo/public/mojom/base/version.mojom";
import "skia/public/mojom/bitmap.mojom";
import "ui/gfx/geometry/mojom/geometry.mojom";
import "url/mojom/origin.mojom";
import "url/mojom/url.mojom";
import "mojo/public/mojom/base/time.mojom";

// Functions provided by the WebUI page.
interface Page {
  // Called before the page is shown.
  IntentToShow();
};

// Factory for PageHandler used in chrome://glic.
interface PageHandlerFactory {
  // Creates the PageHandler for chrome://glic.
  CreatePageHandler(pending_receiver<PageHandler> receiver,
      pending_remote<Page> page);
  // Creates the handler for chrome://glic/glic_fre.
  CreateFrePageHandler(pending_receiver<FrePageHandler> receiver);
};

// It is used in the Glic.PanelWebUiState.FinishState histogram.
// This must match enums.xml.
// LINT.IfChange(WebUiState)
enum WebUiState {
  // Glic app controller not started.
  kUninitialized,
  // Web client begins loading; no visible UI.
  kBeginLoad,
  // Loading panel is displayed. This state, combined with the `hold-loading`
  // state, will be held for `kMinHoldLoadingTimeMs` if entered.
  kShowLoading,
  // Loading panel is still displayed, but the web client is ready. This
  // state will be held for the remainder of `kMinHoldLoadingTimeMs`.
  kHoldLoading,
  // Loading panel is displayed until web client is ready, or until
  // `kMaxWaitTimeMs` timeout is reached.
  kFinishLoading,
  // "Something went wrong" error panel is displayed.
  kError,
  // Connection offline panel is displayed.
  kOffline,
  // Glic is not available for profile; "Unavailable" panel is displayed.
  kUnavailable,
  // Web view is displayed.
  kReady,
  // Glic is unresponsive. Currently this will show the same UI as kError.
  // TODO(crbug.com/394162784): create an unresponsive UI.
  kUnresponsive,
};
// LINT.ThenChange(//tools/metrics/histograms/metadata/glic/enums.xml:WebUiState)

// Page handler for the glic WebUI.
interface PageHandler {
  // Creates a WebClientHandler, for use by a single web client instance.
  CreateWebClient(pending_receiver<WebClientHandler> web_client_receiver);

  // Prepare the webview for loading the client. Sync Google account sign-in
  // cookies to the webview, if necessary, so that it can sign-in automatically.
  // If this returns false, the web client cannot be created due to an error.
  PrepareForClient() => (bool success);

  // Called whenever the webview mainframe commits.
  WebviewCommitted(url.mojom.Url url);

  // Closes the Glic panel.
  ClosePanel();

  // Resize the widget hosting the WebUI to the given size.
  // If `duration` is 0 or less, instantly resize, otherwise run an animation.
  ResizeWidget(gfx.mojom.Size size, mojo_base.mojom.TimeDelta duration) => ();

  // Returns true if the profile associated with this Glic page is enabled by
  // policy.
  IsProfileEnabled() => (bool enabled);

  // Notifies the PageHandler that the state of the WebUI has changed.
  WebUiStateChanged(WebUiState new_state);
};

// Handler for the glic FRE WebUI.
// TODO(crbug.com/393399675): The FRE should be handled in a separate WebUI
// and mojom.
interface FrePageHandler {
  // Closes the glic FRE modal dialog and opens the widget hosting the main
  // glic WebUI.
  AcceptFre();
  // Closes the glic FRE modal dialog.
  DismissFre();
  // Opens `url` in a new backgrounded tab when a link is clicked in the FRE
  // modal dialog if `url` uses the Google domain.
  ValidateAndOpenLinkInNewTab(url.mojom.Url url);
};

// Reason for failure while extracting tab context. This MUST be kept in sync
// with the glic_api.ts enum.
[Stable, Extensible]
enum GetTabContextErrorReason {
  [ Default] kUnknown = 0 ,
  // The web contents was navigated or closed during context gathering.
  [ MinVersion=1 ] kWebContentsChanged = 1,
  // Permission to capture page context is denied.
  [ MinVersion=1 ] kPermissionDenied = 2,
  // The URL in the tab data is not supported.
  [ MinVersion=1 ] kUnsupportedUrl = 3,
  // There are no Chrome tabs available to be focused.
  [ MinVersion=1 ] kNoFocusableTabs = 4,
};

// Reason why a focused tab candidate is not valid for focus.
[Stable, Extensible]
enum InvalidCandidateError {
  // Candidate was deemed invalid for focus for an unknown reason.
  [Default] kUnknown = 0,
  // The URL in the candidate's tab data is not supported.
  kUnsupportedUrl = 1,
};

// Reason why a focused tab is not available.
[Stable, Extensible]
enum NoCandidateTabError {
  // An unknown error occurred while getting the tab data.
  [Default] kUnknown = 0,
  // There are no Chrome tabs available to be focused.
  kNoFocusableTabs = 1,
};

// Reason why capturing desktop screenshot failed. This MUST be kept in sync
// with the glic_api.ts enum.
[Stable, Extensible]
enum CaptureScreenshotErrorReason {
  // Screen capture or frame encoding failure.
  [Default] kUnknown = 0,
  // Screen capture requested but already in progress of serving another request
  kScreenCaptureRequestThrottled = 1,
  // User declined screen capture dialog before taking a screenshot.
  kUserCancelledScreenPickerDialog = 2,
};

union GetContextResult {
  GetTabContextErrorReason error_reason;
  TabContext tab_context;
};

union CaptureScreenshotResult {
  CaptureScreenshotErrorReason error_reason;
  Screenshot screenshot;
};

// Information about the user profile.
struct UserProfileInfo {
  // Profile avatar image bitmap.
  skia.mojom.BitmapN32? avatar_icon;
  // The user's name for display purposes.
  string display_name;
  // The user's email.
  string email;
};

// The result of `WebClientCreated()`. Contains information that needs to be
// available before the web client is initialized.
struct WebClientInitialState {
  PanelState panel_state;
  // Initially focused tab data.
  FocusedTabData focused_tab_data;
  bool microphone_permission_enabled;
  bool location_permission_enabled;
  bool tab_context_permission_enabled;
  mojo_base.mojom.Version chrome_version;
  // Whether the glic panel can currently be attached to a browser window.
  bool can_attach;
};

// Options for getting tab context.
struct GetTabContextOptions {
  // Whether to include inner text in the response.
  bool include_inner_text;
  // Whether to include a viewport screenshot in the response.
  bool include_viewport_screenshot;
    // Whether to include annotated page content in the response.
  bool include_annotated_page_content;
  // Whether to include PDF data in the response.
  bool include_pdf;
  // Maximum size of PDF data returned. If PDF data exceeds this size, no PDF
  // data is returned.
  uint32 pdf_size_limit;
};

// Parameters for ScrollTo.
struct ScrollToParams {
  // Used to specify content to scroll to (and optionally highlight).
  ScrollToSelector selector;

  // Whether to highlight the selected content.
  bool highlight;
};

// Used to select content in a page to scroll to and highlight.
union ScrollToSelector {
  ScrollToTextSelector exact_text_selector;
  ScrollToTextFragmentSelector text_fragment_selector;
};

// Used to specify exact text to scroll to and highlight.
struct ScrollToTextSelector {
  // Exact text to select.
  string text;
};

// Used to specify a text fragment to scroll to and highlight. Text selected
// will match text block that starts with `text_start` and ends with `text_end`
// (and can have any text in the middle).
struct ScrollToTextFragmentSelector {
  // Start of text to select.
  string text_start;
  // End of text to select.
  string text_end;
};

// Note: This must be kept in sync with the corresponding enum (same name) in
// glic_api.ts
[Stable, Extensible]
enum ScrollToErrorReason {
  // The browser doesn't support ScrollTo.
  [Default] kNotSupported = 0
};

// Access to the browser from the web client by proxy through the WebUI.
// A single WebClientHandler will provide access to the browser for only
// a single web client. If the webview navigates or refreshes, a new
// WebClientHandler is created.
interface WebClientHandler {
  // Called just before the web client initialize() call. Provides the initial
  // state of any values that can be queried.
  WebClientCreated(pending_remote<WebClient> web_client)
      => (WebClientInitialState initial_state);

  // Called when the web client loads and successfully returns from
  // initialize(), indicating that it will support Chrome. `web_client` may
  // be used to communicate with the client.
  WebClientInitialized();

  // Called when the web client loads, but throws an exception in initialize().
  WebClientInitializeFailed();

  // Creates a new tab. `url` must have a http or https protocol.
  // `tab_data` is null if the tab could not be created, which may happen if the
  // url or window_id is invalid.
  CreateTab(url.mojom.Url url, bool open_in_background, int32? window_id)
      => (TabData? tab_data);

  // Opens the glic settings page.
  OpenGlicSettingsPage();

  // Closes the Glic panel.
  ClosePanel();

  // Requests that the web client's panel be attached to a browser
  // window.
  AttachPanel();

  // Requests that the web client's panel be detached from a browser
  // window (floats free).
  DetachPanel();

  // Triggers the change profile flow, which allows the user to switch which
  // profile is used. If a new profile is chosen, this WebUI will be closed in
  // favor of a new one.
  ShowProfilePicker();

  // Returns the context from the currently active tab.
  // `tab_context_result` is null if tab content could not be captured.
  // This may fail if the tab is navigated while collecting data, or closed
  // before data is collected.
  GetContextFromFocusedTab(GetTabContextOptions options)
      => (GetContextResult result);

  // Resize the widget hosting the WebUI to the given size.
  // If `duration` is 0 or less, instantly resize, otherwise run an animation.
  // If the widget doesn't exist yet, `size` will be used as its initial size
  // when it's created later.
  ResizeWidget(gfx.mojom.Size size, mojo_base.mojom.TimeDelta duration) => ();

  // Returns the screenshot result or error reason. 'screenshot' is null when an
  // error occurs during capture. This can also fail if the user cancels the
  // screen picker dialog.
  CaptureScreenshot() => (CaptureScreenshotResult result);

  // Requests that audio ducking be enabled or disabled.
  // If enabled, audio from other sources will be attenuated.
  // If disabled, normal audio playout resumes.
  // Returns `true` if the ducking state was actually changed.
  SetAudioDucking(bool enable) => (bool result);

  // Set the areas of the Glic panel from which it should be draggable. If
  // `draggable_areas` is empty, the panel will use the top bar area by default.
  // Returns when the browser has updated the draggable area.
  // Any web elements that are in the draggable area must set "draggable=false"
  // to avoid conflicting with dragging the Glic panel. Also, elements with text
  // like <h1> should have style 'user-select: none'.
  SetPanelDraggableAreas(array<gfx.mojom.Rect> draggable_areas) => ();

  // Set the state of the Microphone permission pref:
  // prefs::kGlicMicrophoneEnabled. Returns when the browser has stored the new
  // pref value.
  SetMicrophonePermissionState(bool enabled) => ();

  // Set the state of the Location permission pref:
  // prefs::kGlicGeolocationEnabled. Returns when the browser has stored the new
  // pref value.
  SetLocationPermissionState(bool enabled) => ();

  // Set the state of the TabContext permission pref:
  // prefs::kGlicTabContextEnabled. Returns when the browser has stored the new
  // pref value.
  SetTabContextPermissionState(bool enabled) => ();

  // Set the state of the context access indicator UI effect on the focused tab.
  SetContextAccessIndicator(bool enabled);

  // Returns the user profile information. This should only return null if
  // the profile associated with this webui is invalid, which should only
  // possibly happen during teardown.
  GetUserProfileInfo() => (UserProfileInfo? profile_info);

  // Sync signin cookies to webview. This is the same as
  // `PageHandler.SyncWebviewCookies()`, except this call originates from the
  // webview.
  SyncCookies() => (bool success);

  // Called when the user submits input.
  OnUserInputSubmitted(WebClientMode mode);

  // Called when the web client starts to respond.
  OnResponseStarted();

  // Called when the web client stops responding.
  OnResponseStopped();

  // Called when the session is terminated.
  OnSessionTerminated();

  // Called when the user rates a response.
  OnResponseRated(bool positive);

  // Scrolls to and (optionally) highlights content specified by `params`.
  // Returns an error reason if the scroll fails, or null otherwise.
  ScrollTo(ScrollToParams params) => (ScrollToErrorReason? error_reason);
};

// State of the glic panel.
struct PanelState {
  // The panel can be in one of these three states.
  // WARNING: These enum values should match
  // chrome/browser/resources/glic/glic_api/glic_api.ts.
  enum Kind {
    // The panel is hidden.
    kHidden = 0,
    // The panel is floating free and detached from any browser window.
    kDetached = 1,
    // The panel is attached to a browser window.
    kAttached = 2,
  };

  Kind kind;
  // Present when attached, indicates to which window the panel is attached.
  int32? window_id;
};


// Web client's operation modes.
// WARNING: These enum values should match
// chrome/browser/resources/glic/glic_api/glic_api.ts
// Warning: this is used for UMA histograms, so values should not be
// renumbered. See GlicWebClientMode in
// tools/metrics/histograms/metadata/glic/enums.xml
[Stable, Extensible]
enum WebClientMode {
  [Default] kUnknown = 2,
  // Text operation mode.
  kText = 0,
  // Audio operation mode.
  kAudio = 1,
};

// Carries back to the browser information on how to configure the panel being
// opened.
struct OpenPanelInfo {
  // Informs Chrome of the current web client mode, which may be kUnknown for
  // clients that do not support it.
  WebClientMode web_client_mode;
  // The size of the panel upon opening. Temporarily, it may not be provided by
  // the web client.
  gfx.mojom.Size? panelSize;
  // Resize animation duration.
  mojo_base.mojom.TimeDelta resizeDuration;
};

// Access from the browser to the Glic web client by proxy of the WebUI page.
interface WebClient {
  // Informs the web client that the panel will open. Chrome will wait to open
  // the panel until after this returns, and will use the data in the returned
  // `OpenPanelInfo` to setup the opening panel.
  NotifyPanelWillOpen(PanelState panel_state) => (OpenPanelInfo openPanelInfo);

  // Informs the web client that the panel was closed. Chrome will try to keep
  // the web client alive until this function returns.
  NotifyPanelWasClosed() => ();

  // The user has requested activation of the web client.
  // `attached_to_window_id` identifies the browser window to which the
  // panel is attached to. It is undefined if it is detached.
  // DEPRECATED: will be removed soon.
  NotifyPanelOpened(int32? attached_to_window_id);

  // The user has closed the web client window. The window may be activated
  // again later. Returns when the web client has stored any needed
  // information and stopped accepting the user's input.
  // DEPRECATED: will be removed soon.
  NotifyPanelClosed() => ();

  // Informs the client that the state of the glic panel has changed.
  NotifyPanelStateChange(PanelState panel_state);

  // Informs the client that whether the panel can be attached right now.
  NotifyPanelCanAttachChange(bool can_attach);

  // The Microphone permission has changed either by action within the web
  // client or by user action in the glic settings.
  NotifyMicrophonePermissionStateChanged(bool enabled);

  // The Location permission has changed either by action within the web client
  // or by user action in the glic settings.
  NotifyLocationPermissionStateChanged(bool enabled);

  // The Tab Context permission has changed either by action within the web
  // client or by user action in the glic settings.
  NotifyTabContextPermissionStateChanged(bool enabled);

  // The focused tab has changed.
  NotifyFocusedTabChanged(FocusedTabData focused_tab_data);
};

// Information extracted from a tab.
struct TabContext {
  // Metadata about the tab that holds the page. Always provided.
  TabData tab_data;
  // Web page data, if requested.
  WebPageData? web_page_data;
  // A screenshot of the user-visible portion of the tab. Provided only if
  // requested.
  Screenshot? viewport_screenshot;
  // Information about a PDF document. Provided if the document is a PDF or
  // contains a PDF, and PDF data was requested. Note that it is possible for
  // a document to contain multiple PDFs using iframes. Only the first PDF
  // document found while traversing the frame tree will be provided here.
  PdfDocumentData? pdf_document_data;
  // Information about the annotated page content. Provided if the document is
  // a web page and annotated page content was requested.
  AnnotatedPageData? annotated_page_data;
};

// Information about a web page being rendered in a tab.
struct WebPageData {
  // Main document of the page.
  DocumentData main_document;
};

// Text information about a web document.
struct DocumentData {
  // Origin of the document.
  url.mojom.Origin origin;
  // The innerText of the document at its current state.
  // Currently includes embedded same-origin iframes.
  string inner_text;
};

// Information about a PDF document.
struct PdfDocumentData {
  // Origin of the PDF document. This may not match the origin of the tab.
  url.mojom.Origin origin;
  // Raw PDF bytes.
  array<uint8>? pdf_data;
  // Whether the the PDF size exceeds the requested limit. If true, pdf data is
  // not returned.
  bool size_limit_exceeded;
};

// Data about a browser tab.
struct TabData {
  // Unique ID of the tab that owns the page.
  int32 tab_id;
  // Unique ID of the browser window holding the tab.
  int32 window_id;
  // URL of the page.
  url.mojom.Url url;
  // The title of the loaded page. Returned if the page is loaded enough for it
  // to be available. It may be empty if the page did not define a title.
  string? title;
  // The favicon for the tab. Null when not available.
  skia.mojom.BitmapN32? favicon;
  // MIME type of the main document in this tab.
  string document_mime_type;
};

// Data about the focused tab state.
union FocusedTabData {
  // Stores the focused tab data if one exists.
  TabData focused_tab;
  // If a focus candidate exists but cannot be focused then
  // `focused_tab_candidate` will hold its `TabData` and an
  // `InvalidCandidateError` specifying why it is not focusable.
  FocusedTabCandidate focused_tab_candidate;
  // If no candidate exists then the `no_candidate_tab_error` will indicate why.
  NoCandidateTabError no_candidate_tab_error;
};

// Data about the focused tab candidate.
struct FocusedTabCandidate {
  // Stores the focused tab candidate data when the browser has valid TabData
  // that cannot be used for context extraction.
  TabData focused_tab_candidate_data;
  // Specifies why the candidate was invalid for focus.
  InvalidCandidateError invalid_candidate_error;
};

// Information about the annotated page content.
struct AnnotatedPageData {
  // Proto for AnnotatedPageContent.
  // See components/optimization_guide/proto/features/common_quality_data.proto
  // Provided only if requested.
  mojo_base.mojom.ProtoWrapper? annotated_page_content;
};

// Annotates an image, providing security relevant information about the origins
// from which image is composed.
// TODO(crbug.com/380495633): Finalize and implement image annotations.
struct ImageOriginAnnotations {};

// An encoded screenshot image and associated metadata.
struct Screenshot {
  // Width and height of the image in pixels.
  uint32 width_pixels;
  uint32 height_pixels;
  // Encoded image data.
  array<uint8> data;
  // The image encoding format represented as a MIME type.
  string mime_type;
  // Image annotations for this screenshot.
  ImageOriginAnnotations origin_annotations;
};
