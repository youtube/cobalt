// Copyright 2011 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "base/test/scoped_feature_list.h"
#include "build/build_config.h"
#include "chrome/browser/sync/test/integration/fake_server_match_status_checker.h"
#include "chrome/browser/sync/test/integration/preferences_helper.h"
#include "chrome/browser/sync/test/integration/sync_service_impl_harness.h"
#include "chrome/browser/sync/test/integration/sync_test.h"
#include "chrome/browser/sync/test/integration/themes_helper.h"
#include "chrome/browser/sync/test/integration/updated_progress_marker_checker.h"
#include "chrome/browser/themes/theme_service.h"
#include "chrome/browser/themes/theme_service_factory.h"
#include "chrome/browser/themes/theme_service_utils.h"
#include "chrome/browser/themes/theme_syncable_service.h"
#include "chrome/common/pref_names.h"
#include "components/prefs/pref_service.h"
#include "components/sync/base/data_type.h"
#include "components/sync/base/features.h"
#include "components/sync/engine/loopback_server/persistent_unique_client_entity.h"
#include "components/sync/protocol/theme_specifics.pb.h"
#include "components/sync/test/fake_server.h"
#include "content/public/test/browser_test.h"
#include "testing/gmock/include/gmock/gmock.h"

namespace {

using themes_helper::GetCustomTheme;
using themes_helper::IsSystemThemeDistinctFromDefaultTheme;
using themes_helper::UseCustomTheme;
using themes_helper::UseDefaultTheme;
using themes_helper::UseSystemTheme;
using themes_helper::UsingCustomTheme;
using themes_helper::UsingDefaultTheme;
using themes_helper::UsingGrayscaleTheme;
using themes_helper::UsingSystemTheme;

// Note: All of these matchers take a sync_pb::ThemeSpecifics.

MATCHER(HasDefaultTheme, "") {
  return !arg.use_custom_theme() && !arg.use_system_theme_by_default() &&
         !arg.has_custom_theme_id();
}

MATCHER(HasSystemTheme, "") {
  return !arg.use_custom_theme() && arg.use_system_theme_by_default() &&
         !arg.has_custom_theme_id();
}

MATCHER_P(HasCustomThemeWithId, theme_id, "") {
  return arg.use_custom_theme() && arg.custom_theme_id() == theme_id;
}

MATCHER_P(HasBrowserColorScheme, color_scheme, "") {
  return arg.browser_color_scheme() == color_scheme;
}

MATCHER_P(HasAutogeneratedThemeColor, color, "") {
  return arg.has_autogenerated_color_theme() &&
         arg.autogenerated_color_theme().color() == color;
}

MATCHER_P(HasUserColor, color, "") {
  return arg.has_user_color_theme() && arg.user_color_theme().color() == color;
}

std::unique_ptr<syncer::LoopbackServerEntity> CreateDefaultThemeEntity() {
  sync_pb::EntitySpecifics specifics;
  // Clients always write `browser_color_scheme` field.
  specifics.mutable_theme()->set_browser_color_scheme(
      sync_pb::ThemeSpecifics_BrowserColorScheme_SYSTEM);
  return syncer::PersistentUniqueClientEntity::CreateFromSpecificsForTesting(
      ThemeSyncableService::kSyncEntityClientTag,
      ThemeSyncableService::kSyncEntityClientTag, specifics,
      /*creation_time=*/0, /*last_modified_time=*/0);
}

std::unique_ptr<syncer::LoopbackServerEntity> CreateSystemThemeEntity() {
  sync_pb::EntitySpecifics specifics;
  // Clients always write `browser_color_scheme` field.
  specifics.mutable_theme()->set_browser_color_scheme(
      sync_pb::ThemeSpecifics_BrowserColorScheme_SYSTEM);
  specifics.mutable_theme()->set_use_system_theme_by_default(true);
  return syncer::PersistentUniqueClientEntity::CreateFromSpecificsForTesting(
      ThemeSyncableService::kSyncEntityTitle,
      ThemeSyncableService::kSyncEntityClientTag, specifics,
      /*creation_time=*/0, /*last_modified_time=*/0);
}

std::unique_ptr<syncer::LoopbackServerEntity> CreateCustomThemeEntity(
    const std::string& theme_id) {
  sync_pb::EntitySpecifics specifics;
  specifics.mutable_theme()->set_use_custom_theme(true);
  specifics.mutable_theme()->set_custom_theme_id(theme_id);
  specifics.mutable_theme()->set_custom_theme_name("custom theme");
  return syncer::PersistentUniqueClientEntity::CreateFromSpecificsForTesting(
      ThemeSyncableService::kSyncEntityTitle,
      ThemeSyncableService::kSyncEntityClientTag, specifics,
      /*creation_time=*/0, /*last_modified_time=*/0);
}

std::unique_ptr<syncer::LoopbackServerEntity> CreateGrayscaleThemeEntity() {
  sync_pb::EntitySpecifics specifics;
  specifics.mutable_theme()->set_use_custom_theme(false);
  specifics.mutable_theme()->mutable_grayscale_theme_enabled();
  return syncer::PersistentUniqueClientEntity::CreateFromSpecificsForTesting(
      ThemeSyncableService::kSyncEntityTitle,
      ThemeSyncableService::kSyncEntityClientTag, specifics,
      /*creation_time=*/0, /*last_modified_time=*/0);
}

// A helper class that waits for the (single) THEME entity on the FakeServer to
// match a given matcher.
class ServerThemeMatchChecker
    : public fake_server::FakeServerMatchStatusChecker {
 public:
  using Matcher = testing::Matcher<sync_pb::ThemeSpecifics>;

  explicit ServerThemeMatchChecker(const Matcher& matcher);
  ~ServerThemeMatchChecker() override;
  ServerThemeMatchChecker(const ServerThemeMatchChecker&) = delete;
  ServerThemeMatchChecker& operator=(const ServerThemeMatchChecker&) = delete;

  // FakeServer::Observer overrides.
  void OnCommit(syncer::DataTypeSet committed_data_types) override;

  // StatusChangeChecker overrides.
  bool IsExitConditionSatisfied(std::ostream* os) override;

 private:
  const Matcher matcher_;
};

ServerThemeMatchChecker::ServerThemeMatchChecker(const Matcher& matcher)
    : matcher_(matcher) {}

ServerThemeMatchChecker::~ServerThemeMatchChecker() = default;

void ServerThemeMatchChecker::OnCommit(
    syncer::DataTypeSet committed_data_types) {
  if (committed_data_types.Has(syncer::THEMES)) {
    CheckExitCondition();
  }
}

bool ServerThemeMatchChecker::IsExitConditionSatisfied(std::ostream* os) {
  std::vector<sync_pb::SyncEntity> entities =
      fake_server()->GetSyncEntitiesByDataType(syncer::THEMES);

  if (entities.empty()) {
    return false;
  }
  DCHECK_EQ(entities.size(), 1u);
  DCHECK(entities[0].specifics().has_theme());

  testing::StringMatchResultListener result_listener;
  const bool matches = testing::ExplainMatchResult(
      matcher_, entities[0].specifics().theme(), &result_listener);
  *os << result_listener.str();
  return matches;
}

class SingleClientThemesSyncTest : public SyncTest {
 public:
  SingleClientThemesSyncTest() : SyncTest(SINGLE_CLIENT) {}
  ~SingleClientThemesSyncTest() override = default;

  bool TestUsesSelfNotifications() override { return false; }
};

IN_PROC_BROWSER_TEST_F(SingleClientThemesSyncTest, UploadsThemesOnInstall) {
  ASSERT_TRUE(SetupSync()) << "SetupSync() failed.";

  ASSERT_FALSE(UsingCustomTheme(GetProfile(0)));
  UseCustomTheme(GetProfile(0), 0);
  EXPECT_TRUE(
      ServerThemeMatchChecker(HasCustomThemeWithId(GetCustomTheme(0))).Wait());

  if (IsSystemThemeDistinctFromDefaultTheme(GetProfile(0))) {
    ASSERT_FALSE(UsingSystemTheme(GetProfile(0)));
    UseSystemTheme(GetProfile(0));
    EXPECT_TRUE(ServerThemeMatchChecker(HasSystemTheme()).Wait());
  }

  ASSERT_FALSE(UsingDefaultTheme(GetProfile(0)));
  UseDefaultTheme(GetProfile(0));
  EXPECT_TRUE(ServerThemeMatchChecker(HasDefaultTheme()).Wait());
}

IN_PROC_BROWSER_TEST_F(SingleClientThemesSyncTest, DownloadsCustomTheme) {
  ASSERT_TRUE(SetupSync()) << "SetupSync() failed.";

  GetFakeServer()->InjectEntity(CreateCustomThemeEntity(GetCustomTheme(0)));
  // Note: The custom theme won't actually get installed; just check that it's
  // pending for installation.
  EXPECT_TRUE(
      ThemePendingInstallChecker(GetProfile(0), GetCustomTheme(0)).Wait());
}

IN_PROC_BROWSER_TEST_F(SingleClientThemesSyncTest, DownloadsSystemTheme) {
  // Skip if this platform doesn't distinguish between system and default theme.
  ASSERT_TRUE(SetupClients());
  if (!IsSystemThemeDistinctFromDefaultTheme(GetProfile(0))) {
    return;
  }

  ASSERT_TRUE(SetupSync()) << "SetupSync() failed.";

  // Set up a custom theme first, so we can then switch back to system.
  UseCustomTheme(GetProfile(0), 0);
  ASSERT_TRUE(
      ServerThemeMatchChecker(HasCustomThemeWithId(GetCustomTheme(0))).Wait());
  ASSERT_TRUE(UsingCustomTheme(GetProfile(0)));

  ASSERT_FALSE(UsingSystemTheme(GetProfile(0)));
  GetFakeServer()->InjectEntity(CreateSystemThemeEntity());
  EXPECT_TRUE(SystemThemeChecker(GetProfile(0)).Wait());
}

IN_PROC_BROWSER_TEST_F(SingleClientThemesSyncTest, DownloadsDefaultTheme) {
  ASSERT_TRUE(SetupSync()) << "SetupSync() failed.";

  // Set up a custom theme first, so we can then switch back to default.
  UseCustomTheme(GetProfile(0), 0);
  ASSERT_TRUE(
      ServerThemeMatchChecker(HasCustomThemeWithId(GetCustomTheme(0))).Wait());
  ASSERT_TRUE(UsingCustomTheme(GetProfile(0)));

  ASSERT_FALSE(UsingDefaultTheme(GetProfile(0)));
  GetFakeServer()->InjectEntity(CreateDefaultThemeEntity());
  EXPECT_TRUE(DefaultThemeChecker(GetProfile(0)).Wait());
}

class SingleClientThemesWithMoveThemePrefsToSpecficsiEnabledSyncTest
    : public SingleClientThemesSyncTest {
 private:
  bool TestUsesSelfNotifications() override { return true; }

  base::test::ScopedFeatureList feature_list_{
      syncer::kMoveThemePrefsToSpecifics};
};

// Verifies that theme from syncing theme prefs get applied if the migration is
// unset. After this, the migration flag should get set to disallow future reads
// from the syncing theme prefs. The incoming theme is committed to the server
// with the new fields in the ThemeSpecifics.
IN_PROC_BROWSER_TEST_F(
    SingleClientThemesWithMoveThemePrefsToSpecficsiEnabledSyncTest,
    ShouldApplyThemeFromSyncingPrefsIfFlagUnmarked) {
  ASSERT_TRUE(SetupClients());
  // Migration flag is unset.
  ASSERT_TRUE(preferences_helper::GetPrefs(/*index=*/0)
                  ->GetBoolean(prefs::kShouldReadIncomingSyncingThemePrefs));

  {
    sync_pb::EntitySpecifics specifics;
    sync_pb::PreferenceSpecifics* preference_specifics =
        specifics.mutable_preference();
    preference_specifics->set_name(prefs::kBrowserColorSchemeDoNotUse);
    preference_specifics->set_value(
        preferences_helper::ConvertPrefValueToValueInSpecifics(base::Value(
            static_cast<int>(ThemeService::BrowserColorScheme::kLight))));

    GetFakeServer()->InjectEntity(
        syncer::PersistentUniqueClientEntity::CreateFromSpecificsForTesting(
            /*non_unique_name=*/prefs::kBrowserColorSchemeDoNotUse,
            /*client_tag=*/prefs::kBrowserColorSchemeDoNotUse, specifics,
            /*creation_time=*/0, /*last_modified_time=*/0));
  }
  {
    sync_pb::EntitySpecifics specifics;
    sync_pb::PreferenceSpecifics* preference_specifics =
        specifics.mutable_preference();
    preference_specifics->set_name(prefs::kUserColorDoNotUse);
    preference_specifics->set_value(
        preferences_helper::ConvertPrefValueToValueInSpecifics(
            base::Value(static_cast<int>(SK_ColorRED))));

    GetFakeServer()->InjectEntity(
        syncer::PersistentUniqueClientEntity::CreateFromSpecificsForTesting(
            /*non_unique_name=*/prefs::kUserColorDoNotUse,
            /*client_tag=*/prefs::kUserColorDoNotUse, specifics,
            /*creation_time=*/0, /*last_modified_time=*/0));
  }

  ASSERT_TRUE(SetupSync());
  // Themes was applied from the syncing theme prefs.
  EXPECT_EQ(ThemeServiceFactory::GetForProfile(GetProfile(0))
                ->GetBrowserColorScheme(),
            ThemeService::BrowserColorScheme::kLight);
  EXPECT_EQ(ThemeServiceFactory::GetForProfile(GetProfile(0))->GetUserColor(),
            SK_ColorRED);
  // Migration flag is set.
  EXPECT_FALSE(preferences_helper::GetPrefs(/*index=*/0)
                   ->GetBoolean(prefs::kShouldReadIncomingSyncingThemePrefs));

  // The theme should get committed to the server with the new fields in
  // ThemeSpecifics.
  EXPECT_TRUE(ServerThemeMatchChecker(HasUserColor(SK_ColorRED)).Wait());
  EXPECT_TRUE(ServerThemeMatchChecker(
                  HasBrowserColorScheme(
                      sync_pb::ThemeSpecifics_BrowserColorScheme_LIGHT))
                  .Wait());
}

// Simulate pref migration being run in the previous browser session by setting
// the migration flag.
IN_PROC_BROWSER_TEST_F(
    SingleClientThemesWithMoveThemePrefsToSpecficsiEnabledSyncTest,
    PRE_ShouldNotApplyThemeFromSyncingPrefsIfFlagMarked) {
  ASSERT_TRUE(SetupClients());

  // Set the flag to not read incoming prefs.
  preferences_helper::GetPrefs(/*index=*/0)
      ->SetBoolean(prefs::kShouldReadIncomingSyncingThemePrefs, false);
}

// Verifies that the syncing theme prefs are not read if the migration is set.
IN_PROC_BROWSER_TEST_F(
    SingleClientThemesWithMoveThemePrefsToSpecficsiEnabledSyncTest,
    ShouldNotApplyThemeFromSyncingPrefsIfFlagMarked) {
  ASSERT_TRUE(SetupClients());

  // Migration flag is already set.
  ASSERT_FALSE(preferences_helper::GetPrefs(/*index=*/0)
                   ->GetBoolean(prefs::kShouldReadIncomingSyncingThemePrefs));

  {
    sync_pb::EntitySpecifics specifics;
    sync_pb::PreferenceSpecifics* preference_specifics =
        specifics.mutable_preference();
    preference_specifics->set_name(prefs::kBrowserColorSchemeDoNotUse);
    preference_specifics->set_value(
        preferences_helper::ConvertPrefValueToValueInSpecifics(base::Value(
            static_cast<int>(ThemeService::BrowserColorScheme::kDark))));

    GetFakeServer()->InjectEntity(
        syncer::PersistentUniqueClientEntity::CreateFromSpecificsForTesting(
            /*non_unique_name=*/prefs::kBrowserColorSchemeDoNotUse,
            /*client_tag=*/prefs::kBrowserColorSchemeDoNotUse, specifics,
            /*creation_time=*/0, /*last_modified_time=*/0));
  }
  {
    sync_pb::EntitySpecifics specifics;
    sync_pb::PreferenceSpecifics* preference_specifics =
        specifics.mutable_preference();
    preference_specifics->set_name(prefs::kUserColorDoNotUse);
    preference_specifics->set_value(
        preferences_helper::ConvertPrefValueToValueInSpecifics(
            base::Value(static_cast<int>(SK_ColorBLUE))));

    GetFakeServer()->InjectEntity(
        syncer::PersistentUniqueClientEntity::CreateFromSpecificsForTesting(
            /*non_unique_name=*/prefs::kUserColorDoNotUse,
            /*client_tag=*/prefs::kUserColorDoNotUse, specifics,
            /*creation_time=*/0, /*last_modified_time=*/0));
  }

  ASSERT_TRUE(SetupSync());

  // Themes was not applied from the syncing theme prefs.
  EXPECT_EQ(ThemeServiceFactory::GetForProfile(GetProfile(0))
                ->GetBrowserColorScheme(),
            ThemeService::BrowserColorScheme::kSystem);
  EXPECT_EQ(ThemeServiceFactory::GetForProfile(GetProfile(0))->GetUserColor(),
            std::nullopt);
}

// Verifies that syncing theme prefs are not read with the incremental updates.
// They can only be applied when the prefs sync starts (which will set the
// migration flag to disallow future reads).
IN_PROC_BROWSER_TEST_F(
    SingleClientThemesWithMoveThemePrefsToSpecficsiEnabledSyncTest,
    ShouldNotApplyThemeFromSyncingPrefsAfterSyncHasStarted) {
  ASSERT_TRUE(SetupClients());
  ASSERT_TRUE(preferences_helper::GetPrefs(/*index=*/0)
                  ->GetBoolean(prefs::kShouldReadIncomingSyncingThemePrefs));

  ASSERT_TRUE(SetupSync());

  // The migration flag gets set upon sync start.
  EXPECT_FALSE(preferences_helper::GetPrefs(/*index=*/0)
                   ->GetBoolean(prefs::kShouldReadIncomingSyncingThemePrefs));

  ASSERT_EQ(ThemeServiceFactory::GetForProfile(GetProfile(0))
                ->GetBrowserColorScheme(),
            ThemeService::BrowserColorScheme::kSystem);

  {
    sync_pb::EntitySpecifics specifics;
    sync_pb::PreferenceSpecifics* preference_specifics =
        specifics.mutable_preference();
    preference_specifics->set_name(prefs::kBrowserColorSchemeDoNotUse);
    preference_specifics->set_value(
        preferences_helper::ConvertPrefValueToValueInSpecifics(base::Value(
            static_cast<int>(ThemeService::BrowserColorScheme::kLight))));

    GetFakeServer()->InjectEntity(
        syncer::PersistentUniqueClientEntity::CreateFromSpecificsForTesting(
            /*non_unique_name=*/prefs::kBrowserColorSchemeDoNotUse,
            /*client_tag=*/prefs::kBrowserColorSchemeDoNotUse, specifics,
            /*creation_time=*/0, /*last_modified_time=*/0));
  }

  ASSERT_TRUE(PrefValueChecker(preferences_helper::GetPrefs(/*index=*/0),
                               prefs::kBrowserColorSchemeDoNotUse,
                               base::Value(static_cast<int>(
                                   ThemeService::BrowserColorScheme::kLight)))
                  .Wait());

  // The incoming theme pref is not applied.
  EXPECT_EQ(ThemeServiceFactory::GetForProfile(GetProfile(0))
                ->GetBrowserColorScheme(),
            ThemeService::BrowserColorScheme::kSystem);
}

// Verifies that the syncing theme prefs are not applied if the incoming
// ThemeSpecifics has the new fields, which implies another client has already
// updated the ThemeSpecifics using the prefs.
IN_PROC_BROWSER_TEST_F(
    SingleClientThemesWithMoveThemePrefsToSpecficsiEnabledSyncTest,
    ShouldNotApplyThemeFromSyncingPrefsIfReceivedViaSpecifics) {
  ASSERT_TRUE(SetupClients());
  ASSERT_TRUE(preferences_helper::GetPrefs(/*index=*/0)
                  ->GetBoolean(prefs::kShouldReadIncomingSyncingThemePrefs));
  {
    sync_pb::EntitySpecifics specifics;
    sync_pb::PreferenceSpecifics* preference_specifics =
        specifics.mutable_preference();
    preference_specifics->set_name(prefs::kBrowserColorSchemeDoNotUse);
    preference_specifics->set_value(
        preferences_helper::ConvertPrefValueToValueInSpecifics(base::Value(
            static_cast<int>(ThemeService::BrowserColorScheme::kLight))));
    GetFakeServer()->InjectEntity(
        syncer::PersistentUniqueClientEntity::CreateFromSpecificsForTesting(
            /*non_unique_name=*/prefs::kBrowserColorSchemeDoNotUse,
            /*client_tag=*/prefs::kBrowserColorSchemeDoNotUse, specifics,
            /*creation_time=*/0, /*last_modified_time=*/0));
  }
  {
    sync_pb::EntitySpecifics specifics;
    sync_pb::PreferenceSpecifics* preference_specifics =
        specifics.mutable_preference();
    preference_specifics->set_name(prefs::kUserColorDoNotUse);
    preference_specifics->set_value(
        preferences_helper::ConvertPrefValueToValueInSpecifics(
            base::Value(static_cast<int>(SK_ColorBLUE))));

    GetFakeServer()->InjectEntity(
        syncer::PersistentUniqueClientEntity::CreateFromSpecificsForTesting(
            /*non_unique_name=*/prefs::kUserColorDoNotUse,
            /*client_tag=*/prefs::kUserColorDoNotUse, specifics,
            /*creation_time=*/0, /*last_modified_time=*/0));
  }
  {
    sync_pb::EntitySpecifics specifics;
    sync_pb::ThemeSpecifics* theme_specifics = specifics.mutable_theme();
    theme_specifics->set_browser_color_scheme(
        sync_pb::ThemeSpecifics_BrowserColorScheme_DARK);

    GetFakeServer()->InjectEntity(
        syncer::PersistentUniqueClientEntity::CreateFromSpecificsForTesting(
            ThemeSyncableService::kSyncEntityTitle,
            ThemeSyncableService::kSyncEntityClientTag, specifics,
            /*creation_time=*/0, /*last_modified_time=*/0));
  }

  ASSERT_TRUE(SetupSync()) << "SetupSync() failed.";

  EXPECT_FALSE(preferences_helper::GetPrefs(/*index=*/0)
                   ->GetBoolean(prefs::kShouldReadIncomingSyncingThemePrefs));
  // Theme from prefs is not applied.
  EXPECT_EQ(ThemeServiceFactory::GetForProfile(GetProfile(0))
                ->GetBrowserColorScheme(),
            ThemeService::BrowserColorScheme::kDark);
  EXPECT_EQ(ThemeServiceFactory::GetForProfile(GetProfile(0))->GetUserColor(),
            std::nullopt);
}

// Verifies that the syncing theme prefs are applied if the incoming
// ThemeSpecifics does not have the new fields.
IN_PROC_BROWSER_TEST_F(
    SingleClientThemesWithMoveThemePrefsToSpecficsiEnabledSyncTest,
    ShouldApplyThemeFromSyncingPrefsIfNotReceivedViaSpecifics) {
  ASSERT_TRUE(SetupClients());
  ASSERT_TRUE(preferences_helper::GetPrefs(/*index=*/0)
                  ->GetBoolean(prefs::kShouldReadIncomingSyncingThemePrefs));
  {
    sync_pb::EntitySpecifics specifics;
    sync_pb::PreferenceSpecifics* preference_specifics =
        specifics.mutable_preference();
    preference_specifics->set_name(prefs::kBrowserColorSchemeDoNotUse);
    preference_specifics->set_value(
        preferences_helper::ConvertPrefValueToValueInSpecifics(base::Value(
            static_cast<int>(ThemeService::BrowserColorScheme::kLight))));
    GetFakeServer()->InjectEntity(
        syncer::PersistentUniqueClientEntity::CreateFromSpecificsForTesting(
            /*non_unique_name=*/prefs::kBrowserColorSchemeDoNotUse,
            /*client_tag=*/prefs::kBrowserColorSchemeDoNotUse, specifics,
            /*creation_time=*/0, /*last_modified_time=*/0));
  }
  {
    sync_pb::EntitySpecifics specifics;
    sync_pb::ThemeSpecifics* theme_specifics = specifics.mutable_theme();
    theme_specifics->mutable_autogenerated_color_theme()->set_color(
        SK_ColorRED);

    GetFakeServer()->InjectEntity(
        syncer::PersistentUniqueClientEntity::CreateFromSpecificsForTesting(
            ThemeSyncableService::kSyncEntityTitle,
            ThemeSyncableService::kSyncEntityClientTag, specifics,
            /*creation_time=*/0, /*last_modified_time=*/0));
  }

  ASSERT_TRUE(SetupSync()) << "SetupSync() failed.";

  EXPECT_FALSE(preferences_helper::GetPrefs(/*index=*/0)
                   ->GetBoolean(prefs::kShouldReadIncomingSyncingThemePrefs));

  // Theme from prefs is applied.
  EXPECT_EQ(ThemeServiceFactory::GetForProfile(GetProfile(0))
                ->GetBrowserColorScheme(),
            ThemeService::BrowserColorScheme::kLight);
  EXPECT_EQ(ThemeServiceFactory::GetForProfile(GetProfile(0))
                ->GetAutogeneratedThemeColor(),
            SK_ColorRED);
  // The theme is also committed to the server using the new fields in
  // ThemeSpecifics.
  EXPECT_TRUE(ServerThemeMatchChecker(
                  HasBrowserColorScheme(
                      sync_pb::ThemeSpecifics_BrowserColorScheme_LIGHT))
                  .Wait());
}

class SingleClientThemesSyncTestWithoutAccountThemesSeparation
    : public SingleClientThemesWithMoveThemePrefsToSpecficsiEnabledSyncTest {
 public:
  SingleClientThemesSyncTestWithoutAccountThemesSeparation() {
    feature_list_.InitAndDisableFeature(syncer::kSeparateLocalAndAccountThemes);
  }

 private:
  base::test::ScopedFeatureList feature_list_;
};

IN_PROC_BROWSER_TEST_F(SingleClientThemesSyncTestWithoutAccountThemesSeparation,
                       UploadsPreexistingTheme) {
  ASSERT_TRUE(SetupClients());

  UseCustomTheme(GetProfile(0), 0);

  ASSERT_TRUE(SetupSync()) << "SetupSync() failed.";

  EXPECT_TRUE(
      ServerThemeMatchChecker(HasCustomThemeWithId(GetCustomTheme(0))).Wait());
}

class SingleClientThemesSyncTestWithAccountThemesSeparation
    : public SingleClientThemesWithMoveThemePrefsToSpecficsiEnabledSyncTest {
 public:
  SingleClientThemesSyncTestWithAccountThemesSeparation()
      : feature_list_(syncer::kSeparateLocalAndAccountThemes) {}

 private:
  base::test::ScopedFeatureList feature_list_;
};

IN_PROC_BROWSER_TEST_F(SingleClientThemesSyncTestWithAccountThemesSeparation,
                       ShouldNotUploadPreexistingTheme) {
  ASSERT_TRUE(SetupClients()) << "SetupClients() failed.";

  // Use custom theme locally.
  UseCustomTheme(GetProfile(0), 0);
  ASSERT_TRUE(CustomThemeChecker(GetProfile(0)).Wait());

  // Default theme on the server.
  ASSERT_FALSE(UsingDefaultTheme(GetProfile(0)));
  GetFakeServer()->InjectEntity(CreateDefaultThemeEntity());

  // Enable sync.
  ASSERT_TRUE(SetupSync()) << "SetupSync() failed.";
  ASSERT_TRUE(GetSyncService(0)->GetActiveDataTypes().Has(syncer::THEMES));

  // Local custom theme is not uploaded to the account.
  EXPECT_TRUE(ServerThemeMatchChecker(HasDefaultTheme()).Wait());
  EXPECT_TRUE(UsingCustomTheme(GetProfile(0)));
}

IN_PROC_BROWSER_TEST_F(SingleClientThemesSyncTestWithAccountThemesSeparation,
                       ShouldRestoreLocalThemeUponSyncStop) {
  ASSERT_TRUE(SetupClients());

  UseCustomTheme(GetProfile(0), 0);
  ASSERT_TRUE(CustomThemeChecker(GetProfile(0)).Wait());

  GetFakeServer()->InjectEntity(CreateGrayscaleThemeEntity());

  ASSERT_TRUE(SetupSync());
  EXPECT_TRUE(GrayscaleThemeChecker(GetProfile(0)).Wait());

  // Disable sync.
  ASSERT_TRUE(
      GetClient(0)->DisableSyncForType(syncer::UserSelectableType::kThemes));

  // Original local theme should get re-applied.
  EXPECT_TRUE(CustomThemeChecker(GetProfile(0)).Wait());
  EXPECT_FALSE(UsingGrayscaleTheme(GetProfile(0)));
}

IN_PROC_BROWSER_TEST_F(SingleClientThemesSyncTestWithAccountThemesSeparation,
                       PRE_ShouldPersistSavedLocalThemeOverBrowserRestart) {
  ASSERT_TRUE(SetupClients());

  UseCustomTheme(GetProfile(0), 0);
  ASSERT_TRUE(CustomThemeChecker(GetProfile(0)).Wait());

  GetFakeServer()->InjectEntity(CreateGrayscaleThemeEntity());

  ASSERT_TRUE(SetupSync());
  EXPECT_TRUE(GrayscaleThemeChecker(GetProfile(0)).Wait());
}

IN_PROC_BROWSER_TEST_F(SingleClientThemesSyncTestWithAccountThemesSeparation,
                       ShouldPersistSavedLocalThemeOverBrowserRestart) {
  ASSERT_TRUE(SetupClients());
  ASSERT_TRUE(GetClient(0)->AwaitSyncSetupCompletion());
  ASSERT_TRUE(GetSyncService(0)->GetActiveDataTypes().Has(syncer::THEMES));

  // Disable sync.
  ASSERT_TRUE(
      GetClient(0)->DisableSyncForType(syncer::UserSelectableType::kThemes));

  // Original local theme should get re-applied.
  EXPECT_TRUE(CustomThemeChecker(GetProfile(0)).Wait());
  EXPECT_FALSE(UsingGrayscaleTheme(GetProfile(0)));
}

IN_PROC_BROWSER_TEST_F(SingleClientThemesSyncTestWithAccountThemesSeparation,
                       ShouldNotApplyLocalUpdateOnLocalThemeWhenSignedIn) {
  ASSERT_TRUE(SetupSync());

  // Change to a custom theme.
  UseCustomTheme(GetProfile(0), 0);
  // Custom theme is uploaded to account.
  EXPECT_TRUE(
      ServerThemeMatchChecker(HasCustomThemeWithId(GetCustomTheme(0))).Wait());

  // Disable syncing of themes.
  ASSERT_TRUE(
      GetClient(0)->DisableSyncForType(syncer::UserSelectableType::kThemes));

  // Original local theme is restored.
  EXPECT_TRUE(DefaultThemeChecker(GetProfile(0)).Wait());
}

IN_PROC_BROWSER_TEST_F(SingleClientThemesSyncTestWithAccountThemesSeparation,
                       ShouldNotApplyRemoteUpdateOnLocalTheme) {
  ASSERT_TRUE(SetupClients());

  // Set up a custom theme first, so we can then switch back to default.
  UseCustomTheme(GetProfile(0), 0);
  ASSERT_TRUE(CustomThemeChecker(GetProfile(0)).Wait());

  ASSERT_TRUE(SetupSync());

  // Remote update.
  GetFakeServer()->InjectEntity(CreateDefaultThemeEntity());
  EXPECT_TRUE(DefaultThemeChecker(GetProfile(0)).Wait());

  // Disable sync.
  ASSERT_TRUE(
      GetClient(0)->DisableSyncForType(syncer::UserSelectableType::kThemes));

  // Original local theme should get re-applied.
  EXPECT_TRUE(CustomThemeChecker(GetProfile(0)).Wait());
  EXPECT_FALSE(UsingGrayscaleTheme(GetProfile(0)));
}

}  // namespace
