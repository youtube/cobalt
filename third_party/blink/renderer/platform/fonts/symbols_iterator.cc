// Copyright 2015 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/renderer/platform/fonts/symbols_iterator.h"

#include <unicode/uchar.h>
#include <unicode/uniset.h>

#include <memory>

#include "third_party/blink/renderer/platform/fonts/utf16_ragel_iterator.h"
#include "third_party/blink/renderer/platform/runtime_enabled_features.h"
#include "third_party/blink/renderer/platform/text/character.h"

namespace blink {

namespace {
using emoji_text_iter_t = UTF16RagelIterator;
// Scanner code generated by Ragel and imported from third_party.
#include "third_party/emoji-segmenter/src/emoji_presentation_scanner.c"
}  // namespace

SymbolsIterator::SymbolsIterator(const UChar* buffer, unsigned buffer_size)
    : cursor_(0), next_token_end_(0), next_token_emoji_(false) {
  if (buffer_size) {
    buffer_iterator_ = UTF16RagelIterator(buffer, buffer_size);

    next_token_end_ = cursor_ + (scan_emoji_presentation(
                                     buffer_iterator_, buffer_iterator_.end(),
                                     &next_token_emoji_, &next_token_has_vs_) -
                                 buffer_iterator_);
  }
}

bool SymbolsIterator::Consume(unsigned* symbols_limit,
                              FontFallbackPriority* font_fallback_priority) {
  if (cursor_ >= buffer_iterator_.size()) {
    return false;
  }

  bool current_token_emoji = false;
  bool curr_has_vs = false;
  do {
    cursor_ = next_token_end_;
    current_token_emoji = next_token_emoji_;
    curr_has_vs = next_token_has_vs_;

    if (cursor_ >= buffer_iterator_.end().Cursor())
      break;

    if (!current_token_emoji &&
        !Character::MaybeEmojiPresentation(buffer_iterator_.PeekCodepoint())) {
      ++buffer_iterator_;
      next_token_end_ = buffer_iterator_.Cursor();
      next_token_has_vs_ = false;
      continue;
    }

    buffer_iterator_.SetCursor(cursor_);

    next_token_end_ = cursor_ + (scan_emoji_presentation(
                                     buffer_iterator_, buffer_iterator_.end(),
                                     &next_token_emoji_, &next_token_has_vs_) -
                                 buffer_iterator_);
  } while (current_token_emoji == next_token_emoji_ &&
           (!RuntimeEnabledFeatures::FontVariantEmojiEnabled() ||
            curr_has_vs == next_token_has_vs_));

  if (RuntimeEnabledFeatures::FontVariantEmojiEnabled() && curr_has_vs) {
    *font_fallback_priority = current_token_emoji
                                  ? FontFallbackPriority::kEmojiEmojiWithVS
                                  : FontFallbackPriority::kEmojiTextWithVS;
  } else {
    *font_fallback_priority = current_token_emoji
                                  ? FontFallbackPriority::kEmojiEmoji
                                  : FontFallbackPriority::kText;
  }
  *symbols_limit = cursor_;

  return true;
}

}  // namespace blink
