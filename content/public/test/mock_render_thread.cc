// Copyright 2012 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "content/public/test/mock_render_thread.h"

#include <memory>
#include <tuple>

#include "base/logging.h"
#include "base/task/single_thread_task_runner.h"
#include "base/unguessable_token.h"
#include "build/build_config.h"
#include "content/common/associated_interfaces.mojom.h"
#include "content/common/frame.mojom.h"
#include "content/public/renderer/render_thread_observer.h"
#include "content/renderer/render_thread_impl.h"
#include "content/test/test_render_frame.h"
#include "ipc/param_traits_utils.h"
#include "mojo/public/cpp/bindings/pending_remote.h"
#include "testing/gtest/include/gtest/gtest.h"
#include "third_party/blink/public/common/dom_storage/session_storage_namespace_id.h"
#include "third_party/blink/public/common/user_agent/user_agent_metadata.h"
#include "third_party/blink/public/mojom/page/widget.mojom.h"
#include "third_party/blink/public/mojom/widget/platform_widget.mojom.h"

namespace content {

namespace {

// Some tests hard-code small numbers for routing IDs, so make reasonably sure
// that the IDs generated by MockRenderThread will not clash.
constexpr int32_t kFirstGeneratedRoutingId = 313337000;

static const blink::UserAgentMetadata kUserAgentMetadata;

}  // namespace

MockRenderThread::MockRenderThread()
    : next_routing_id_(kFirstGeneratedRoutingId) {}

MockRenderThread::~MockRenderThread() = default;

IPC::SyncChannel* MockRenderThread::GetChannel() {
  return nullptr;
}

std::string MockRenderThread::GetLocale() {
  return "en-US";
}

scoped_refptr<base::SingleThreadTaskRunner>
MockRenderThread::GetIOTaskRunner() {
  return io_task_runner_;
}

void MockRenderThread::BindHostReceiver(mojo::GenericPendingReceiver receiver) {
}

bool MockRenderThread::GenerateFrameRoutingID(
    int32_t& routing_id,
    blink::LocalFrameToken& frame_token,
    base::UnguessableToken& devtools_frame_token,
    blink::DocumentToken& document_token) {
  routing_id = GetNextRoutingID();
  frame_token = blink::LocalFrameToken();
  devtools_frame_token = base::UnguessableToken::Create();
  document_token = blink::DocumentToken();
  return true;
}

void MockRenderThread::AddObserver(RenderThreadObserver* observer) {
  observers_.AddObserver(observer);
}

void MockRenderThread::RemoveObserver(RenderThreadObserver* observer) {
  observers_.RemoveObserver(observer);
}

void MockRenderThread::RecordAction(const base::UserMetricsAction& action) {
}

void MockRenderThread::RecordComputedAction(const std::string& action) {
}

int MockRenderThread::PostTaskToAllWebWorkers(base::RepeatingClosure closure) {
  return 0;
}

base::WaitableEvent* MockRenderThread::GetShutdownEvent() {
  return nullptr;
}

int32_t MockRenderThread::GetClientId() {
  return 1;
}

blink::WebString MockRenderThread::GetUserAgent() {
  return blink::WebString();
}

const blink::UserAgentMetadata& MockRenderThread::GetUserAgentMetadata() {
  return kUserAgentMetadata;
}

#if BUILDFLAG(IS_WIN)
void MockRenderThread::PreCacheFont(const LOGFONT& log_font) {
}

void MockRenderThread::ReleaseCachedFonts() {
}
#endif

void MockRenderThread::SetFieldTrialGroup(const std::string& trial_name,
                                          const std::string& group_name) {}

void MockRenderThread::WriteIntoTrace(
    perfetto::TracedProto<perfetto::protos::pbzero::RenderProcessHost> proto) {
  // Unlike RenderThreadImpl, MockRenderThread is not aware of its render
  // process ID.
}

int32_t MockRenderThread::GetNextRoutingID() {
  return next_routing_id_++;
}

mojo::PendingReceiver<blink::mojom::BrowserInterfaceBroker>
MockRenderThread::TakeInitialBrowserInterfaceBrokerReceiverForFrame(
    const blink::LocalFrameToken& frame_token) {
  mojo::PendingReceiver<blink::mojom::BrowserInterfaceBroker>
      broker_from_create_child_frame_request;
  auto it = frame_token_to_initial_browser_brokers_.find(frame_token);
  if (it != frame_token_to_initial_browser_brokers_.end()) {
    broker_from_create_child_frame_request = std::move(it->second);
    frame_token_to_initial_browser_brokers_.erase(it);
  }
  return broker_from_create_child_frame_request;
}

void MockRenderThread::OnCreateChildFrame(
    const blink::LocalFrameToken& child_frame_token,
    mojo::PendingAssociatedRemote<mojom::Frame> frame_remote,
    mojo::PendingReceiver<blink::mojom::BrowserInterfaceBroker>
        browser_interface_broker) {
  frame_token_to_initial_browser_brokers_.emplace(
      child_frame_token, std::move(browser_interface_broker));
}

// The View expects to be returned a valid route_id different from its own.
void MockRenderThread::OnCreateWindow(mojom::CreateNewWindowParams& params,
                                      mojom::CreateNewWindowReply* reply) {
  params.associated_interface_provider.EnableUnassociatedUsage();
  params.widget_host.EnableUnassociatedUsage();
  params.frame_widget_host.EnableUnassociatedUsage();
  reply->main_frame_route_id = GetNextRoutingID();
  frame_token_to_initial_browser_brokers_.emplace(
      reply->main_frame_token, std::move(params.main_frame_interface_broker));
  reply->cloned_session_storage_namespace_id =
      blink::AllocateSessionStorageNamespaceId();

  reply->widget_routing_id = GetNextRoutingID();
  reply->visual_properties.screen_infos =
      display::ScreenInfos(display::ScreenInfo());

  mojo::AssociatedRemote<blink::mojom::PageBroadcast> page_broadcast;
  page_broadcast.Bind(std::move(params.page_broadcast_remote));
  page_broadcasts_.push_back(std::move(page_broadcast));
}

void MockRenderThread::ReleaseAllWebViews() {
  page_broadcasts_.clear();
}

}  // namespace content
