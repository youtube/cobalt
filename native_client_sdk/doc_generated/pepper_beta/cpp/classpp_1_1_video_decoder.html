{{+bindTo:partials.standard_nacl_api}}
<h1>pp::VideoDecoder Class Reference</h1>
<div id="doxygen-ref">
{{- dummy div to appease doxygen -}}
  <div>
<!-- Generated by Doxygen 1.7.6.1 -->



</div>
<!--header-->
<div class="contents">
<!-- doxytag: class="pp::VideoDecoder" --><!-- doxytag: inherits="pp::Resource" --><div class="dynheader">
Inheritance diagram for pp::VideoDecoder:</div>
<div class="dyncontent">
<div class="center"><img src="classpp_1_1_video_decoder__inherit__graph.png" border="0" usemap="#pp_1_1_video_decoder_inherit__map" alt="Inheritance graph" /></div>
<map name="pp_1_1_video_decoder_inherit__map" id="pp_1_1_video_decoder_inherit__map">
<area shape="rect" id="node2" href="classpp_1_1_resource.html" title="A reference counted module resource." alt="" coords="20,5,124,32"></area></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<p><a href="classpp_1_1_video_decoder-members.html">List of all members.</a></p>
<h2>
Public Member Functions</h2><table class="memberdecls">

<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_decoder.html#afc9613c960f58ff4c97804da4645cd64">VideoDecoder</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_decoder.html#a5c7b1010b42e179cf51e55266eb1491a">VideoDecoder</a> (const <a class="el" href="classpp_1_1_instance_handle.html">InstanceHandle</a> &amp;instance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_decoder.html#a0eec2949dd73ef6d52b6782cee3b427d">VideoDecoder</a> (const <a class="el" href="classpp_1_1_video_decoder.html">VideoDecoder</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_decoder.html#a284c6a99f5c3ea83465f7eab81ca4ba8">Initialize</a> (const <a class="el" href="classpp_1_1_graphics3_d.html">Graphics3D</a> &amp;graphics3d_context, PP_VideoProfile profile, PP_HardwareAcceleration acceleration, uint32_t min_picture_count, const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_decoder.html#a2f1a48cf6d2f1854b20e6a747c9b03e3">Decode</a> (uint32_t decode_id, uint32_t size, const void *buffer, const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_decoder.html#aec1a1bc95b8d3eea64b942af48dff02a">GetPicture</a> (const <a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a>&lt; PP_VideoPicture &gt; &amp;callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_decoder.html#a7b9c4917ebd205572a0fe69a34f1bfd9">RecyclePicture</a> (const PP_VideoPicture &amp;picture)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_decoder.html#adb59ebce58f83b1c27e9c427596fb366">Flush</a> (const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_decoder.html#aa05481906b07e929c9567bc22a48917a">Reset</a> (const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;callback)</td></tr>
</table>
<hr /><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Video decoder interface. </p>
<p>Typical usage:</p>
<ul>
<li>Call Create() to create a new video decoder resource.</li>
<li>Call <a class="el" href="classpp_1_1_video_decoder.html#a284c6a99f5c3ea83465f7eab81ca4ba8" title="Initializes a video decoder resource.">Initialize()</a> to initialize it with a 3d graphics context and the desired codec profile.</li>
<li>Call <a class="el" href="classpp_1_1_video_decoder.html#a2f1a48cf6d2f1854b20e6a747c9b03e3" title="Decodes a bitstream buffer.">Decode()</a> continuously (waiting for each previous call to complete) to push bitstream buffers to the decoder.</li>
<li>Call <a class="el" href="classpp_1_1_video_decoder.html#aec1a1bc95b8d3eea64b942af48dff02a" title="Gets the next picture from the decoder.">GetPicture()</a> continuously (waiting for each previous call to complete) to pull decoded pictures from the decoder.</li>
<li>Call <a class="el" href="classpp_1_1_video_decoder.html#adb59ebce58f83b1c27e9c427596fb366" title="Flushes the decoder.">Flush()</a> to signal end of stream to the decoder and perform shutdown when it completes.</li>
<li>Call <a class="el" href="classpp_1_1_video_decoder.html#aa05481906b07e929c9567bc22a48917a" title="Resets the decoder as quickly as possible.">Reset()</a> to quickly stop the decoder (e.g. to implement Seek) and wait for the callback before restarting decoding at another point.</li>
<li>To destroy the decoder, the plugin should release all of its references to it. Any pending callbacks will abort before the decoder is destroyed.</li>
</ul>
<p>Available video codecs vary by platform. All: theora, vorbis, vp8. Chrome and ChromeOS: aac, h264. ChromeOS: mpeg4. </p>
</div><hr /><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afc9613c960f58ff4c97804da4645cd64"></a><!-- doxytag: member="pp::VideoDecoder::VideoDecoder" ref="afc9613c960f58ff4c97804da4645cd64" args="()" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_video_decoder.html#afc9613c960f58ff4c97804da4645cd64">pp::VideoDecoder::VideoDecoder</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Default constructor for creating an <a class="el" href="classpp_1_1_resource.html#a859068e34cdc2dc0b78754c255323aa9" title="This functions determines if this resource is invalid or uninitialized.">is_null()</a> <code><a class="el" href="classpp_1_1_video_decoder.html" title="Video decoder interface.">VideoDecoder</a></code> object. </p>
</div>
</div>
<a class="anchor" id="a5c7b1010b42e179cf51e55266eb1491a"></a><!-- doxytag: member="pp::VideoDecoder::VideoDecoder" ref="a5c7b1010b42e179cf51e55266eb1491a" args="(const InstanceHandle &amp;instance)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_video_decoder.html#afc9613c960f58ff4c97804da4645cd64">pp::VideoDecoder::VideoDecoder</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_instance_handle.html">InstanceHandle</a> &amp;&#160;</td>
<td class="paramname"><em>instance</em></td><td>)</td>
<td><code> [explicit]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>A constructor used to create a <code><a class="el" href="classpp_1_1_video_decoder.html" title="Video decoder interface.">VideoDecoder</a></code> and associate it with the provided <code><a class="el" href="classpp_1_1_instance.html">Instance</a></code>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>The instance with which this resource will be associated. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a0eec2949dd73ef6d52b6782cee3b427d"></a><!-- doxytag: member="pp::VideoDecoder::VideoDecoder" ref="a0eec2949dd73ef6d52b6782cee3b427d" args="(const VideoDecoder &amp;other)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_video_decoder.html#afc9613c960f58ff4c97804da4645cd64">pp::VideoDecoder::VideoDecoder</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_video_decoder.html">VideoDecoder</a> &amp;&#160;</td>
<td class="paramname"><em>other</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>The copy constructor for <code><a class="el" href="classpp_1_1_video_decoder.html" title="Video decoder interface.">VideoDecoder</a></code>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>A reference to a <code><a class="el" href="classpp_1_1_video_decoder.html" title="Video decoder interface.">VideoDecoder</a></code>. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<hr /><h2>Member Function Documentation</h2>
<a class="anchor" id="a2f1a48cf6d2f1854b20e6a747c9b03e3"></a><!-- doxytag: member="pp::VideoDecoder::Decode" ref="a2f1a48cf6d2f1854b20e6a747c9b03e3" args="(uint32_t decode_id, uint32_t size, const void *buffer, const CompletionCallback &amp;callback)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_video_decoder.html#a2f1a48cf6d2f1854b20e6a747c9b03e3">pp::VideoDecoder::Decode</a> </td>
<td>(</td>
<td class="paramtype">uint32_t&#160;</td>
<td class="paramname"><em>decode_id</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t&#160;</td>
<td class="paramname"><em>size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const void *&#160;</td>
<td class="paramname"><em>buffer</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;&#160;</td>
<td class="paramname"><em>callback</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Decodes a bitstream buffer. </p>
<p>Copies |size| bytes of data from the plugin's |buffer|. The plugin should wait until the decoder signals completion by returning PP_OK or by running |callback| before calling <a class="el" href="classpp_1_1_video_decoder.html#a2f1a48cf6d2f1854b20e6a747c9b03e3" title="Decodes a bitstream buffer.">Decode()</a> again.</p>
<p>In general, each bitstream buffer should contain a demuxed bitstream frame for the selected video codec. For example, H264 decoders expect to receive one AnnexB NAL unit, including the 4 byte start code prefix, while VP8 decoders expect to receive a bitstream frame without the IVF frame header.</p>
<p>If the call to <a class="el" href="classpp_1_1_video_decoder.html#a2f1a48cf6d2f1854b20e6a747c9b03e3" title="Decodes a bitstream buffer.">Decode()</a> eventually results in a picture, the |decode_id| parameter is copied into the returned picture. The plugin can use this to associate decoded pictures with <a class="el" href="classpp_1_1_video_decoder.html#a2f1a48cf6d2f1854b20e6a747c9b03e3" title="Decodes a bitstream buffer.">Decode()</a> calls (e.g. to assign timestamps or frame numbers to pictures.) This value is opaque to the API so the plugin is free to pass any value.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">decode_id</td><td>An optional value, chosen by the plugin, that can be used to associate calls to <a class="el" href="classpp_1_1_video_decoder.html#a2f1a48cf6d2f1854b20e6a747c9b03e3" title="Decodes a bitstream buffer.">Decode()</a> with decoded pictures returned by <a class="el" href="classpp_1_1_video_decoder.html#aec1a1bc95b8d3eea64b942af48dff02a" title="Gets the next picture from the decoder.">GetPicture()</a>. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Buffer size in bytes. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Starting address of buffer. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> to be called on completion.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing an error code from <code>pp_errors.h</code>. Returns PP_ERROR_FAILED if the decoder isn't initialized or if a <a class="el" href="classpp_1_1_video_decoder.html#adb59ebce58f83b1c27e9c427596fb366" title="Flushes the decoder.">Flush()</a> or <a class="el" href="classpp_1_1_video_decoder.html#aa05481906b07e929c9567bc22a48917a" title="Resets the decoder as quickly as possible.">Reset()</a> call is pending. Returns PP_ERROR_INPROGRESS if there is another <a class="el" href="classpp_1_1_video_decoder.html#a2f1a48cf6d2f1854b20e6a747c9b03e3" title="Decodes a bitstream buffer.">Decode()</a> call pending. Returns PP_ERROR_NOMEMORY if a bitstream buffer can't be created. Returns PP_ERROR_ABORTED when <a class="el" href="classpp_1_1_video_decoder.html#aa05481906b07e929c9567bc22a48917a" title="Resets the decoder as quickly as possible.">Reset()</a> is called while <a class="el" href="classpp_1_1_video_decoder.html#a2f1a48cf6d2f1854b20e6a747c9b03e3" title="Decodes a bitstream buffer.">Decode()</a> is pending. </dd></dl>
</div>
</div>
<a class="anchor" id="adb59ebce58f83b1c27e9c427596fb366"></a><!-- doxytag: member="pp::VideoDecoder::Flush" ref="adb59ebce58f83b1c27e9c427596fb366" args="(const CompletionCallback &amp;callback)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_video_decoder.html#adb59ebce58f83b1c27e9c427596fb366">pp::VideoDecoder::Flush</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;&#160;</td>
<td class="paramname"><em>callback</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Flushes the decoder. </p>
<p>The plugin should call <a class="el" href="classpp_1_1_video_decoder.html#adb59ebce58f83b1c27e9c427596fb366" title="Flushes the decoder.">Flush()</a> when it reaches the end of its video stream in order to stop cleanly. The decoder will run any pending <a class="el" href="classpp_1_1_video_decoder.html#a2f1a48cf6d2f1854b20e6a747c9b03e3" title="Decodes a bitstream buffer.">Decode()</a> call to completion. The plugin should make no further calls to the decoder other than <a class="el" href="classpp_1_1_video_decoder.html#aec1a1bc95b8d3eea64b942af48dff02a" title="Gets the next picture from the decoder.">GetPicture()</a> and <a class="el" href="classpp_1_1_video_decoder.html#a7b9c4917ebd205572a0fe69a34f1bfd9" title="Recycles a picture that the plugin has received from the decoder.">RecyclePicture()</a> until the decoder signals completion by running |callback|. Just before completion, any pending <a class="el" href="classpp_1_1_video_decoder.html#aec1a1bc95b8d3eea64b942af48dff02a" title="Gets the next picture from the decoder.">GetPicture()</a> call will complete by running its callback with result PP_ERROR_ABORTED to signal that no more pictures are available. Any pictures held by the plugin remain valid during and after the flush and should be recycled back to the decoder.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> to be called on completion.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing an error code from <code>pp_errors.h</code>. Returns PP_ERROR_FAILED if the decoder isn't initialized. </dd></dl>
</div>
</div>
<a class="anchor" id="aec1a1bc95b8d3eea64b942af48dff02a"></a><!-- doxytag: member="pp::VideoDecoder::GetPicture" ref="aec1a1bc95b8d3eea64b942af48dff02a" args="(const CompletionCallbackWithOutput&lt; PP_VideoPicture &gt; &amp;callback)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_video_decoder.html#aec1a1bc95b8d3eea64b942af48dff02a">pp::VideoDecoder::GetPicture</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a>&lt; PP_VideoPicture &gt; &amp;&#160;</td>
<td class="paramname"><em>callback</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Gets the next picture from the decoder. </p>
<p>The picture is valid after the decoder signals completion by returning PP_OK or running |callback|. The plugin can call <a class="el" href="classpp_1_1_video_decoder.html#aec1a1bc95b8d3eea64b942af48dff02a" title="Gets the next picture from the decoder.">GetPicture()</a> again after the decoder signals completion. When the plugin is finished using the picture, it should return it to the system by calling <a class="el" href="classpp_1_1_video_decoder.html#a7b9c4917ebd205572a0fe69a34f1bfd9" title="Recycles a picture that the plugin has received from the decoder.">RecyclePicture()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A <code><a class="el" href="classpp_1_1_completion_callback_with_output.html" title="A CompletionCallbackWithOutput defines a completion callback that additionally stores a pointer to so...">CompletionCallbackWithOutput</a></code> to be called on completion, and on success, to hold the picture descriptor.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing an error code from <code>pp_errors.h</code>. Returns PP_ERROR_FAILED if the decoder isn't initialized or if a <a class="el" href="classpp_1_1_video_decoder.html#aa05481906b07e929c9567bc22a48917a" title="Resets the decoder as quickly as possible.">Reset()</a> call is pending. Returns PP_ERROR_INPROGRESS if there is another <a class="el" href="classpp_1_1_video_decoder.html#aec1a1bc95b8d3eea64b942af48dff02a" title="Gets the next picture from the decoder.">GetPicture()</a> call pending. Returns PP_ERROR_ABORTED when <a class="el" href="classpp_1_1_video_decoder.html#aa05481906b07e929c9567bc22a48917a" title="Resets the decoder as quickly as possible.">Reset()</a> is called, or if a call to <a class="el" href="classpp_1_1_video_decoder.html#adb59ebce58f83b1c27e9c427596fb366" title="Flushes the decoder.">Flush()</a> completes while <a class="el" href="classpp_1_1_video_decoder.html#aec1a1bc95b8d3eea64b942af48dff02a" title="Gets the next picture from the decoder.">GetPicture()</a> is pending. </dd></dl>
</div>
</div>
<a class="anchor" id="a284c6a99f5c3ea83465f7eab81ca4ba8"></a><!-- doxytag: member="pp::VideoDecoder::Initialize" ref="a284c6a99f5c3ea83465f7eab81ca4ba8" args="(const Graphics3D &amp;graphics3d_context, PP_VideoProfile profile, PP_HardwareAcceleration acceleration, uint32_t min_picture_count, const CompletionCallback &amp;callback)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_video_decoder.html#a284c6a99f5c3ea83465f7eab81ca4ba8">pp::VideoDecoder::Initialize</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_graphics3_d.html">Graphics3D</a> &amp;&#160;</td>
<td class="paramname"><em>graphics3d_context</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">PP_VideoProfile&#160;</td>
<td class="paramname"><em>profile</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">PP_HardwareAcceleration&#160;</td>
<td class="paramname"><em>acceleration</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t&#160;</td>
<td class="paramname"><em>min_picture_count</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;&#160;</td>
<td class="paramname"><em>callback</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Initializes a video decoder resource. </p>
<p>This should be called after Create() and before any other functions.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graphics3d_context</td><td>A <code>PPB_Graphics3D</code> resource to use during decoding. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">profile</td><td>A <code>PP_VideoProfile</code> specifying the video codec profile. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">acceleration</td><td>A <code>PP_HardwareAcceleration</code> specifying whether to use a hardware accelerated or a software implementation. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">min_picture_count</td><td>A count of pictures the plugin would like to have in flight. This is effectively the number of times the plugin can call <a class="el" href="classpp_1_1_video_decoder.html#aec1a1bc95b8d3eea64b942af48dff02a" title="Gets the next picture from the decoder.">GetPicture()</a> and get a decoded frame without calling <a class="el" href="classpp_1_1_video_decoder.html#a7b9c4917ebd205572a0fe69a34f1bfd9" title="Recycles a picture that the plugin has received from the decoder.">RecyclePicture()</a>. The decoder has its own internal minimum count, and will take the larger of its internal and this value. A client that doesn't care can therefore just pass in zero for this argument. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A <code>PP_CompletionCallback</code> to be called upon completion.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing an error code from <code>pp_errors.h</code>. Returns PP_ERROR_NOTSUPPORTED if video decoding is not available, or the requested profile is not supported. In this case, the client may call <a class="el" href="classpp_1_1_video_decoder.html#a284c6a99f5c3ea83465f7eab81ca4ba8" title="Initializes a video decoder resource.">Initialize()</a> again with different parameters to find a good configuration. </dd></dl>
</div>
</div>
<a class="anchor" id="a7b9c4917ebd205572a0fe69a34f1bfd9"></a><!-- doxytag: member="pp::VideoDecoder::RecyclePicture" ref="a7b9c4917ebd205572a0fe69a34f1bfd9" args="(const PP_VideoPicture &amp;picture)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void <a class="el" href="classpp_1_1_video_decoder.html#a7b9c4917ebd205572a0fe69a34f1bfd9">pp::VideoDecoder::RecyclePicture</a> </td>
<td>(</td>
<td class="paramtype">const PP_VideoPicture &amp;&#160;</td>
<td class="paramname"><em>picture</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Recycles a picture that the plugin has received from the decoder. </p>
<p>The plugin should call this as soon as it has finished using the texture so the decoder can decode more pictures.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">picture</td><td>A <code>PP_VideoPicture</code> to return to the decoder. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa05481906b07e929c9567bc22a48917a"></a><!-- doxytag: member="pp::VideoDecoder::Reset" ref="aa05481906b07e929c9567bc22a48917a" args="(const CompletionCallback &amp;callback)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_video_decoder.html#aa05481906b07e929c9567bc22a48917a">pp::VideoDecoder::Reset</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;&#160;</td>
<td class="paramname"><em>callback</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Resets the decoder as quickly as possible. </p>
<p>The plugin can call <a class="el" href="classpp_1_1_video_decoder.html#aa05481906b07e929c9567bc22a48917a" title="Resets the decoder as quickly as possible.">Reset()</a> to skip to another position in the video stream. After <a class="el" href="classpp_1_1_video_decoder.html#aa05481906b07e929c9567bc22a48917a" title="Resets the decoder as quickly as possible.">Reset()</a> returns, any pending calls to <a class="el" href="classpp_1_1_video_decoder.html#a2f1a48cf6d2f1854b20e6a747c9b03e3" title="Decodes a bitstream buffer.">Decode()</a> and <a class="el" href="classpp_1_1_video_decoder.html#aec1a1bc95b8d3eea64b942af48dff02a" title="Gets the next picture from the decoder.">GetPicture()</a>) abort, causing their callbacks to run with PP_ERROR_ABORTED. The plugin should not make further calls to the decoder other than <a class="el" href="classpp_1_1_video_decoder.html#a7b9c4917ebd205572a0fe69a34f1bfd9" title="Recycles a picture that the plugin has received from the decoder.">RecyclePicture()</a> until the decoder signals completion by running |callback|. Any pictures held by the plugin remain valid during and after the reset and should be recycled back to the decoder.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> to be called on completion.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing an error code from <code>pp_errors.h</code>. Returns PP_ERROR_FAILED if the decoder isn't initialized. </dd></dl>
</div>
</div>
<hr />The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="video__decoder_8h.html">video_decoder.h</a></li>
</ul>
</div><!-- contents -->
</div>
{{/partials.standard_nacl_api}}
