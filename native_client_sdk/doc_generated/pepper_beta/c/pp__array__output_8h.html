{{+bindTo:partials.standard_nacl_api}}
<h1>pp_array_output.h File Reference</h1>
<div id="doxygen-ref">
{{- dummy div to appease doxygen -}}
  <div>
<!-- Generated by Doxygen 1.7.6.1 -->


</div>
<!--header-->
<div class="contents">
<div class="textblock"><div class="dynheader">
Include dependency graph for pp_array_output.h:</div>
<div class="dyncontent">
<div class="center"><img src="pp__array__output_8h__incl.png" border="0" usemap="#pp__array__output_8h" alt="" /></div>
<map name="pp__array__output_8h" id="pp__array__output_8h">
</map>
</div>
</div><h2>
Data Structures</h2><table class="memberdecls">

<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p___array_output.html">PP_ArrayOutput</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure that defines a way for the browser to return arrays of data to the plugin.  <a href="struct_p_p___array_output.html#details">More...</a><br /></td></tr>
</table><h2>
Typedefs</h2><table class="memberdecls">
<tr><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___typedefs.html#gaa363de651fad7342a37ec58375276af7">PP_ArrayOutput_GetDataBuffer</a> )(void *user_data, uint32_t element_count, uint32_t element_size)</td></tr>
</table>
<hr /><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>PP_ArrayOutput_GetDataBuffer is a callback function to allocate plugin memory for an array. </p>
<p>It returns the allocated memory or null on failure.</p>
<p>This function will be called reentrantly. This means that if you call a function PPB_Foo.GetData(&amp;array_output), GetData will call your GetDataBuffer function before it returns.</p>
<p>This function will be called even when returning 0-length arrays, so be sure your implementation can support that. You can return NULL for 0 length arrays and it will not be treated as a failure.</p>
<p>You should not perform any processing in this callback, including calling other PPAPI functions, outside of allocating memory. You should not throw any exceptions. In C++, this means using "new (nothrow)" or being sure to catch any exceptions before returning.</p>
<p>The C++ wrapper provides a convenient templatized implementation around std::vector which you should generally use instead of coding this specifically.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramname">user_data</td><td>The pointer provided in the <a class="el" href="struct_p_p___array_output.html" title="A structure that defines a way for the browser to return arrays of data to the plugin.">PP_ArrayOutput</a> structure. This has no meaning to the browser, it is intended to be used by the implementation to figure out where to put the data.</td></tr>
<tr><td class="paramname">element_count</td><td>The number of elements in the array. This will be 0 if there is no data to return.</td></tr>
<tr><td class="paramname">element_size</td><td>The size of each element in bytes.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a pointer to the allocated memory. On failure, returns null. You can also return null if the element_count is 0. When a non-null value is returned, the buffer must remain valid until after the callback runs. If used with a blocking callback, the buffer must remain valid until after the function returns. The plugin can then free any memory that it allocated. </dd></dl>
</div></div><!-- contents -->
</div>
{{/partials.standard_nacl_api}}
