#!/usr/bin/env vpython3
# Copyright 2025 The Cobalt Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""A command-line client for the Cobalt builds MCP server.

Run `do --help` to get a list of available commands.
"""

# [VPYTHON:BEGIN]
# python_version: "3.11"
# wheel: <
#   name: "infra/python/wheels/mcp-py3"
#   version: "version:1.9.4"
# >
# wheel: <
#   name: "infra/python/wheels/pydantic-py3"
#   version: "version:2.11.7"
# >
# wheel: <
#   name: "infra/python/wheels/starlette-py3"
#   version: "version:0.47.1"
# >
# wheel: <
#   name: "infra/python/wheels/anyio-py3"
#   version: "version:4.9.0"
# >
# wheel: <
#   name: "infra/python/wheels/sniffio-py3"
#   version: "version:1.3.0"
# >
# wheel: <
#   name: "infra/python/wheels/idna-py3"
#   version: "version:3.4"
# >
# wheel: <
#   name: "infra/python/wheels/typing-extensions-py3"
#   version: "version:4.13.2"
# >
# wheel: <
#   name: "infra/python/wheels/httpx_sse-py3"
#   version: "version:0.4.1"
# >
# wheel: <
#   name: "infra/python/wheels/httpx-py3"
#   version: "version:0.28.1"
# >
# wheel: <
#   name: "infra/python/wheels/certifi-py3"
#   version: "version:2025.4.26"
# >
# wheel: <
#   name: "infra/python/wheels/httpcore-py3"
#   version: "version:1.0.9"
# >
# wheel: <
#   name: "infra/python/wheels/h11-py3"
#   version: "version:0.16.0"
# >
# wheel: <
#   name: "infra/python/wheels/pydantic-settings-py3"
#   version: "version:2.10.1"
# >
# wheel: <
#   name: "infra/python/wheels/python-multipart-py3"
#   version: "version:0.0.20"
# >
# wheel: <
#   name: "infra/python/wheels/sse-starlette-py3"
#   version: "version:2.4.1"
# >
# wheel: <
#   name: "infra/python/wheels/uvicorn-py3"
#   version: "version:0.35.0"
# >
# wheel: <
#   name: "infra/python/wheels/annotated-types-py3"
#   version: "version:0.7.0"
# >
# wheel: <
#   name: "infra/python/wheels/pydantic_core/${vpython_platform}"
#   version: "version:2.33.2"
# >
# wheel: <
#   name: "infra/python/wheels/typing-inspection-py3"
#   version: "version:0.4.1"
# >
# wheel: <
#   name: "infra/python/wheels/python-dotenv-py3"
#   version: "version:1.1.1"
# >
# wheel: <
#   name: "infra/python/wheels/click-py3"
#   version: "version:8.0.3"
# >
# [VPYTHON:END]

import argparse
import asyncio
import json
import logging
import os
import shlex
import signal
import subprocess
import sys
import traceback
from datetime import datetime

# Suppress informational logs from the MCP client
logging.getLogger('mcp').setLevel(logging.WARNING)

from mcp.client.session import ClientSession
from mcp.client.stdio import StdioServerParameters, stdio_client

from analysis import analyze_log


def format_output(data):
  """Formats the JSON output for human readability."""
  if not data.get('content'):
    return json.dumps(data, indent=2)

  content = data['content']
  # Handle simple list of strings
  if isinstance(content, list) and all(
      isinstance(item, dict) and 'text' in item for item in content):
    return '\n'.join(item['text'] for item in content)

  # Handle single string response
  if isinstance(content, dict) and 'text' in content:
    return content['text']

  # Fallback to pretty-printed JSON for other structures
  return json.dumps(data, indent=2)


async def process_command(session, args):
  """Processes a single command."""
  tool_name = args.command
  params = vars(args).copy()

  # Remove parser-specific keys
  params.pop('command', None)
  params.pop('worker', None)

  if tool_name == 'run' and 'main_arg' in params:
    if params.get('variant') and params.get('binary_name'):
      params['platform'] = params.pop('main_arg')
    else:
      params['build_id_or_log_file'] = params.pop('main_arg')
      params.pop('variant', None)
      params.pop('binary_name', None)

  if 'binary_args' in params:
    params['args'] = [arg for arg in params.pop('binary_args') if arg != '--']

  if 'debug' in params:
    params['debug'] = True

  should_wait = tool_name in ['build', 'run']

  result = await session.call_tool(tool_name, arguments=params)

  # The raw text content from the server
  response_text = result.model_dump()['content'][0]['text']

  if not should_wait:
    print(response_text)
    return

  # If the command was run with --background, we just print the response and exit.
  if hasattr(args, 'background') and args.background:
      print(response_text)
      return

  task_id = None
  tail_process = None
  try:
    response_data = json.loads(response_text)
    task_id = response_data.get('build_id') or response_data.get('run_id')
    status = response_data.get('status')

    if status == 'in_progress':
      # Server started a background task, we need to tail the log.
      log_path = response_data.get('output_log')

      if not log_path:
        print("Error: Could not determine log path from server response.")
        return

      # Wait a moment for the log file to be created
      await asyncio.sleep(0.2)
      if not os.path.exists(log_path):
          print(f"Error: Log file not found: {log_path}")
          return

      print(f"\n--- Tailing log file: {log_path} (Ctrl+C to stop) ---", flush=True)
      tail_process = await asyncio.create_subprocess_exec(
          'tail', '-f', log_path, stdout=sys.stdout, stderr=sys.stderr)

      try:
        while True:
          # Check for completion marker in the log file
          with open(log_path, 'r') as f:
            if 'RETURN_CODE:' in f.read():
              await asyncio.sleep(0.1) # Give tail a moment to flush
              break
          await asyncio.sleep(0.5) # Poll every half second
      finally:
        if tail_process.returncode is None:
          tail_process.terminate()
        await tail_process.wait()
        print("\n--- Task finished. ---", flush=True)

    else:
      # Server ran synchronously and this is the final result.
      if 'analysis' in response_data:
          print(response_data.get('message', 'Task failed. Analysis:'))
          print(response_data['analysis'])
      elif 'log_snippet' in response_data:
          print(response_data.get('message', 'Task succeeded.'))
          print("--- Log Snippet ---")
          print(response_data['log_snippet'])
      else:
          # Fallback for other JSON responses
          print(json.dumps(response_data, indent=2))

  except KeyboardInterrupt:
    print(f"\n--- Interrupted by user. ---")
    if task_id:
        print(f"Stopping task {task_id}...")
        if tail_process and tail_process.returncode is None:
            tail_process.terminate()
            await tail_process.wait()
        await session.call_tool('stop', arguments={'task_id': task_id})
        print("Task stopped.")
  except json.JSONDecodeError:
    print("Could not parse server response. Raw output:")
    print(response_text)
  except Exception as e:
    print(f"\nAn error occurred: {e}")
    traceback.print_exc()


class NonExitingArgumentParser(argparse.ArgumentParser):
  """An ArgumentParser that raises an exception instead of exiting."""

  def error(self, message):
    """Override to raise an exception instead of calling sys.exit()."""
    raise argparse.ArgumentError(None, message)


class SinglePageHelpFormatter(argparse.RawTextHelpFormatter):
  """A help formatter that shows the full help for each subcommand."""

  def __init__(self, *args, **kwargs):
    super().__init__(*args, **kwargs)
    self._parser = None

  def format_help(self):
    # Get the default help message
    help_text = super().format_help()

    # Find and remove the 'positional arguments' section
    positional_args_header = 'positional arguments:'
    start_index = help_text.find(positional_args_header)
    if start_index != -1:
      options_header = 'options:'
      end_index = help_text.find(options_header, start_index)
      if end_index != -1:
        help_text = help_text[:start_index] + help_text[end_index:]

    # Add the custom formatted subcommand help
    subparser_action = next(
        (action
         for action in self._parser._actions
         if isinstance(action, argparse._SubParsersAction)), None)
    if subparser_action:
      for subparser in subparser_action.choices.values():
        help_text += f'\n {subparser.prog}\n'
        if subparser.description:
          help_text += f'    {subparser.description}\n'

        positional_actions = [
            act for act in subparser._actions if not act.option_strings
        ]
        optional_actions = [act for act in subparser._actions if act.option_strings]

        if positional_actions or optional_actions:
          usage = f'    Usage: {subparser.prog}'
          for act in positional_actions:
            usage += f' <{act.dest}>'
          for act in optional_actions:
            usage += f' [{act.option_strings[0]}]'
          help_text += usage + '\n'

        for act in subparser._actions:
          dest_str = act.dest.replace('_', '').lower().strip()
          help_str = (act.help or '').replace(' ', '').lower().strip()
          if dest_str != help_str and act.help is not None:
            if act.option_strings:
              help_text += f'        {act.option_strings[0]}: {act.help}\n'
            else:
              help_text += f'        <{act.dest}>: {act.help}\n'
    return help_text


def build_parser(tool_schemas, exit_on_error=True):
  """Builds the argparse parser from tool schemas."""
  formatter = SinglePageHelpFormatter('do', max_help_position=30)
  parser_class = argparse.ArgumentParser if exit_on_error else NonExitingArgumentParser
  parser = parser_class(
      description='A command-line client for the Cobalt builds MCP server.',
      formatter_class=lambda prog: formatter,
      add_help=False)
  formatter._parser = parser
  parser.add_argument(
      '-h',
      '--help',
      action='help',
      default=argparse.SUPPRESS,
      help='Show this help message and exit.')
  # Add the worker flag for internal use
  parser.add_argument('--worker', action='store_true', help=argparse.SUPPRESS)
  subparsers = parser.add_subparsers(dest='command', help='Available MCP tools')

  for tool in tool_schemas.tools:
    subparser = subparsers.add_parser(
        tool.name, help=tool.description, add_help=False)
    subparser.description = tool.description

    # Manually add the client-side --wait flag for build and run
    if tool.name in ['build', 'run']:
        subparser.add_argument(
            '--background',
            action='store_true',
            help='Run the command in the background and exit immediately.')

    for prop_name, prop_schema in tool.inputSchema.get('properties', {}).items():
      # Skip properties that are manually handled
      if tool.name in ['build', 'run'] and prop_name in ['background', 'dry_run', 'debug', 'wait']:
          continue
      if tool.name == 'build' and prop_name == 'extra_args':
          continue
      if tool.name == 'run' and prop_name == 'args':
          continue

      if prop_name == 'args':
        subparser.add_argument('binary_args', nargs=argparse.REMAINDER)
      elif prop_name == 'extra_args' and tool.name == 'build':
        subparser.add_argument('--extra_args', nargs=argparse.REMAINDER)
      elif prop_name == 'dry_run' and tool.name in ['build', 'run']:
        subparser.add_argument(
            '--dry-run',
            action='store_true',
            help='Print the command without executing it.')

      elif tool.name == 'analyze' and prop_name == 'task_id_or_log_file':
        subparser.add_argument(
            'task_id_or_log_file',
            help='The ID of the task or the path to the log file.')
      elif tool.name == 'analyze' and prop_name == 'log_type':
        subparser.add_argument(
            'log_type',
            nargs='?',
            help='The type of log file (e.g., build, test). Defaults to auto.')

      elif prop_name == 'debug' and tool.name == 'run':
        subparser.add_argument(
            '--debug',
            action='store_true',
            help='Run the binary under GDB to get a symbolized stack trace on crash.')
      elif tool.name == 'run' and prop_name in [
          'platform', 'variant', 'binary_name', 'build_id_or_log_file'
      ]:
        # Special handling for the 'run' command's flexible arguments
        if prop_name == 'platform':
          subparser.add_argument(
              'main_arg',
              help='Build ID, log file path, or platform.')
        elif prop_name == 'variant':
          subparser.add_argument(
              'variant', nargs='?', help='Variant (if platform is provided).')
        elif prop_name == 'binary_name':
          subparser.add_argument(
              'binary_name',
              nargs='?',
              help='Binary name (if platform is provided).')
      else:
        subparser.add_argument(prop_name, help=prop_schema.get('title'))

  return parser


async def interactive_launcher(parser):
    """Runs the interactive launcher."""
    print("Type 'help' for a list of commands.")
    while True:
        try:
            line = await asyncio.to_thread(input, 'cobalt> ')
            line = line.strip()
            if line.lower() in ['exit', 'quit']:
                break
            if line.lower() in ['help', '?']:
                parser.print_help()
                continue
            if not line:
                continue

            # Launch a worker process to handle the command
            worker_cmd = [sys.executable, __file__, '--worker'] + shlex.split(line)
            process = await asyncio.create_subprocess_exec(
                *worker_cmd,
                stdout=sys.stdout,
                stderr=sys.stderr
            )
            await process.wait()

        except (EOFError, KeyboardInterrupt):
            print()
            break
        except Exception as e:
            print(f'An error occurred: {e}')


async def get_tool_schemas(server_params):
  """Gets the tool schemas from the server."""
  server_process = await asyncio.create_subprocess_exec(
      server_params.command, *server_params.args)
  try:
    async with stdio_client(server_params) as (read, write):
      async with ClientSession(read, write) as session:
        await session.initialize()
        return await session.list_tools()
  finally:
    try:
      server_process.terminate()
    except ProcessLookupError:
      pass


async def run_worker(server_params, parser, is_background=False):
  """Runs a worker process to handle a single command."""
  worker_args = [arg for arg in sys.argv[1:] if arg != '--worker']
  args = parser.parse_args(worker_args)

  # Launch the server in a new process group to allow detachment.
  server_process = await asyncio.create_subprocess_exec(
      server_params.command, *server_params.args,
      preexec_fn=os.setpgrp)
  try:
    async with stdio_client(server_params) as (read, write):
      async with ClientSession(read, write) as session:
        await session.initialize()
        await process_command(session, args)
  finally:
    # If we are not in background mode, clean up the server process group.
    if not is_background:
      try:
        os.killpg(server_process.pid, signal.SIGTERM)
      except ProcessLookupError:
        pass


async def main_async():
  """The async main entry point."""
  # Special case for local analysis to avoid server overhead
  if len(sys.argv) > 1 and sys.argv[1] == 'analyze':
    log_file = sys.argv[2] if len(sys.argv) > 2 else None
    log_type = sys.argv[3] if len(sys.argv) > 3 else None
    if not log_file:
      print("Usage: do analyze <log_file> [log_type]")
      sys.exit(1)
    result = analyze_log(log_file, log_type)
    print(result)
    return

  is_worker = '--worker' in sys.argv
  is_interactive = len(sys.argv) == 1 and not is_worker

  script_dir = os.path.dirname(os.path.abspath(__file__))
  server_path = os.path.join(script_dir, 'server.py')
  server_params = StdioServerParameters(
      command='vpython3',
      args=[server_path, '--serve'])

  tool_schemas = await get_tool_schemas(server_params)
  parser = build_parser(tool_schemas, exit_on_error=not is_interactive)

  if is_worker:
    is_background = '--background' in sys.argv
    await run_worker(server_params, parser, is_background)
  elif is_interactive:
    await interactive_launcher(parser)
  else:
    # Single command mode
    if '--background' in sys.argv:
      # Re-launch the worker detached
      worker_cmd = [sys.executable, __file__, '--worker'] + sys.argv[1:]
      subprocess.Popen(worker_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
      print("Task started in background.")
    else:
      # Launch the worker and wait for it
      worker_cmd = [sys.executable, __file__, '--worker'] + sys.argv[1:]
      process = await asyncio.create_subprocess_exec(
          *worker_cmd,
          stdout=sys.stdout,
          stderr=sys.stderr
      )
      await process.wait()


def main():
  """Main entry point."""
  try:
    asyncio.run(main_async())
  except KeyboardInterrupt:
    print()
    sys.exit(0)


if __name__ == '__main__':
  main()
