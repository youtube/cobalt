{{+bindTo:partials.standard_nacl_api}}
<h1>PPB_VarArrayBuffer Struct Reference</h1>
<div id="doxygen-ref">
{{- dummy div to appease doxygen -}}
  <div>
<!-- Generated by Doxygen 1.7.6.1 -->


</div>
<!--header-->
<div class="contents">
<!-- doxytag: class="PPB_VarArrayBuffer" --><h2>
Data Fields</h2><table class="memberdecls">

<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_p_p___var.html">PP_Var</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___var_array_buffer__1__0.html#a348f1470a2fc6cba9d430d0544e84225">Create</a> )(uint32_t size_in_bytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___var_array_buffer__1__0.html#a0ad6305942f991daa6dfe3b579931ea1">ByteLength</a> )(struct <a class="el" href="struct_p_p___var.html">PP_Var</a> array, uint32_t *byte_length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___var_array_buffer__1__0.html#a4c7c25b939f56de64fa3f6f906a7da8c">Map</a> )(struct <a class="el" href="struct_p_p___var.html">PP_Var</a> array)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___var_array_buffer__1__0.html#ac841a12b7eb93dd05bd2b864920e22a7">Unmap</a> )(struct <a class="el" href="struct_p_p___var.html">PP_Var</a> array)</td></tr>
</table>
<hr /><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The <code>PPB_VarArrayBuffer</code> interface provides a way to interact with JavaScript ArrayBuffers, which represent a contiguous sequence of bytes. </p>
<p>Use <code>PPB_Var</code> to manage the reference count for a <code>VarArrayBuffer</code>. Note that these Vars are not part of the embedding page's DOM, and can only be shared with JavaScript using the <code>PostMessage</code> and <code>HandleMessage</code> functions of <code>pp::Instance</code>. </p>
</div><hr /><h2>Field Documentation</h2>
<a class="anchor" id="a0ad6305942f991daa6dfe3b579931ea1"></a><!-- doxytag: member="PPB_VarArrayBuffer::ByteLength" ref="a0ad6305942f991daa6dfe3b579931ea1" args=")(struct PP_Var array, uint32_t *byte_length)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a>(* <a class="el" href="struct_p_p_b___var_array_buffer__1__0.html#a0ad6305942f991daa6dfe3b579931ea1">PPB_VarArrayBuffer::ByteLength</a>)(struct <a class="el" href="struct_p_p___var.html">PP_Var</a> array, uint32_t *byte_length)</td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="struct_p_p_b___var_array_buffer__1__0.html#a0ad6305942f991daa6dfe3b579931ea1" title="ByteLength() retrieves the length of the VarArrayBuffer in bytes.">ByteLength()</a> retrieves the length of the <code>VarArrayBuffer</code> in bytes. </p>
<p>On success, <code>byte_length</code> is set to the length of the given <code>ArrayBuffer</code> var. On failure, <code>byte_length</code> is unchanged (this could happen, for instance, if the given <code><a class="el" href="struct_p_p___var.html" title="The PP_VAR struct is a variant data type and can contain any value of one of the types named in the P...">PP_Var</a></code> is not of type <code>PP_VARTYPE_ARRAY_BUFFER</code>). Note that <a class="el" href="struct_p_p_b___var_array_buffer__1__0.html#a0ad6305942f991daa6dfe3b579931ea1" title="ByteLength() retrieves the length of the VarArrayBuffer in bytes.">ByteLength()</a> will successfully retrieve the size of an <code>ArrayBuffer</code> even if the <code>ArrayBuffer</code> is not currently mapped.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The <code>ArrayBuffer</code> whose length should be returned.</td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">byte_length</td><td>A variable which is set to the length of the given <code>ArrayBuffer</code> on success.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>PP_TRUE</code> on success, <code>PP_FALSE</code> on failure. </dd></dl>
</div>
</div>
<a class="anchor" id="a348f1470a2fc6cba9d430d0544e84225"></a><!-- doxytag: member="PPB_VarArrayBuffer::Create" ref="a348f1470a2fc6cba9d430d0544e84225" args=")(uint32_t size_in_bytes)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">struct <a class="el" href="struct_p_p___var.html">PP_Var</a>(* <a class="el" href="struct_p_p_b___var_array_buffer__1__0.html#a348f1470a2fc6cba9d430d0544e84225">PPB_VarArrayBuffer::Create</a>)(uint32_t size_in_bytes)<code> [read]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="struct_p_p_b___var_array_buffer__1__0.html#a348f1470a2fc6cba9d430d0544e84225" title="Create() creates a zero-initialized VarArrayBuffer.">Create()</a> creates a zero-initialized <code>VarArrayBuffer</code>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">size_in_bytes</td><td>The size of the <code>ArrayBuffer</code> to be created.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="struct_p_p___var.html" title="The PP_VAR struct is a variant data type and can contain any value of one of the types named in the P...">PP_Var</a></code> representing a <code>VarArrayBuffer</code> of the requested size and with a reference count of 1. </dd></dl>
</div>
</div>
<a class="anchor" id="a4c7c25b939f56de64fa3f6f906a7da8c"></a><!-- doxytag: member="PPB_VarArrayBuffer::Map" ref="a4c7c25b939f56de64fa3f6f906a7da8c" args=")(struct PP_Var array)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void*(* <a class="el" href="struct_p_p_b___var_array_buffer__1__0.html#a4c7c25b939f56de64fa3f6f906a7da8c">PPB_VarArrayBuffer::Map</a>)(struct <a class="el" href="struct_p_p___var.html">PP_Var</a> array)</td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="struct_p_p_b___var_array_buffer__1__0.html#a4c7c25b939f56de64fa3f6f906a7da8c" title="Map() maps the ArrayBuffer in to the module's address space and returns a pointer to the beginning of...">Map()</a> maps the <code>ArrayBuffer</code> in to the module's address space and returns a pointer to the beginning of the buffer for the given <code>ArrayBuffer <a class="el" href="struct_p_p___var.html" title="The PP_VAR struct is a variant data type and can contain any value of one of the types named in the P...">PP_Var</a></code>. </p>
<p>ArrayBuffers are copied when transmitted, so changes to the underlying memory are not automatically available to the embedding page.</p>
<p>Note that calling <a class="el" href="struct_p_p_b___var_array_buffer__1__0.html#a4c7c25b939f56de64fa3f6f906a7da8c" title="Map() maps the ArrayBuffer in to the module's address space and returns a pointer to the beginning of...">Map()</a> can be a relatively expensive operation. Use care when calling it in performance-critical code. For example, you should call it only once when looping over an <code>ArrayBuffer</code>.</p>
<p><b>Example:</b></p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">char</span>* data = (<span class="keywordtype">char</span>*)(array_buffer_if.Map(array_buffer_var));
 uint32_t byte_length = 0;
 <a class="code" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918" title="The PP_Bool enum is a boolean value for use in PPAPI C headers.">PP_Bool</a> ok = array_buffer_if.ByteLength(array_buffer_var, &amp;byte_length);
 <span class="keywordflow">if</span> (!ok)
   <span class="keywordflow">return</span> DoSomethingBecauseMyVarIsNotAnArrayBuffer();
 <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; byte_length; ++i)
   data[i] = <span class="charliteral">&#39;A&#39;</span>;
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The <code>ArrayBuffer</code> whose internal buffer should be returned.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the internal buffer for this <code>ArrayBuffer</code>. Returns <code>NULL</code> if the given <code><a class="el" href="struct_p_p___var.html" title="The PP_VAR struct is a variant data type and can contain any value of one of the types named in the P...">PP_Var</a></code> is not of type <code>PP_VARTYPE_ARRAY_BUFFER</code>. </dd></dl>
</div>
</div>
<a class="anchor" id="ac841a12b7eb93dd05bd2b864920e22a7"></a><!-- doxytag: member="PPB_VarArrayBuffer::Unmap" ref="ac841a12b7eb93dd05bd2b864920e22a7" args=")(struct PP_Var array)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void(* <a class="el" href="struct_p_p_b___var_array_buffer__1__0.html#ac841a12b7eb93dd05bd2b864920e22a7">PPB_VarArrayBuffer::Unmap</a>)(struct <a class="el" href="struct_p_p___var.html">PP_Var</a> array)</td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="struct_p_p_b___var_array_buffer__1__0.html#ac841a12b7eb93dd05bd2b864920e22a7" title="Unmap() unmaps the given ArrayBuffer var from the module address space.">Unmap()</a> unmaps the given <code>ArrayBuffer</code> var from the module address space. </p>
<p>Use this if you want to save memory but might want to call <a class="el" href="struct_p_p_b___var_array_buffer__1__0.html#a4c7c25b939f56de64fa3f6f906a7da8c" title="Map() maps the ArrayBuffer in to the module's address space and returns a pointer to the beginning of...">Map()</a> to map the buffer again later. The <code><a class="el" href="struct_p_p___var.html" title="The PP_VAR struct is a variant data type and can contain any value of one of the types named in the P...">PP_Var</a></code> remains valid and should still be released using <code>PPB_Var</code> when you are done with the <code>ArrayBuffer</code>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The <code>ArrayBuffer</code> to be released. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<hr />The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="ppb__var__array__buffer_8h.html">ppb_var_array_buffer.h</a></li>
</ul>
</div><!-- contents -->
</div>
{{/partials.standard_nacl_api}}
