{{+bindTo:partials.standard_nacl_api}}
<h1>pp::CompletionCallbackFactory&lt; T, ThreadTraits &gt; Class Template Reference</h1>
<div id="doxygen-ref">
{{- dummy div to appease doxygen -}}
  <div>
<!-- Generated by Doxygen 1.7.6.1 -->



</div>
<!--header-->
<div class="contents">
<!-- doxytag: class="pp::CompletionCallbackFactory" -->
<p><a href="classpp_1_1_completion_callback_factory-members.html">List of all members.</a></p>
<h2>
Classes</h2><table class="memberdecls">

<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>BackPointer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>CallbackData</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Dispatcher0</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Dispatcher1</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Dispatcher2</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Dispatcher3</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>DispatcherWithOutput0</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>DispatcherWithOutput1</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>DispatcherWithOutput2</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>DispatcherWithOutput3</b></td></tr>
</table><h2>
Public Member Functions</h2><table class="memberdecls">
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_factory.html#ab870c8d37638facb949a86226c5138dc">CompletionCallbackFactory</a> (T *object=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_factory.html#a8341b9bfa1660d5f3f38d2530a0a9d42">~CompletionCallbackFactory</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_factory.html#ad43328a7d8c19233e3fa0b762f357088">CancelAll</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_factory.html#a6289f165e3ce15a07061f8be411e186c">Initialize</a> (T *object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_factory.html#a5cd104c9185333647e1a752860ca0336">GetObject</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Method &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_factory.html#ab25d7ebdcdcd28f06ab767fdbbd4868f">NewCallback</a> (Method method)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Method &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_factory.html#adacce232874e0d5ab52ffa4bd8af9ef7">NewOptionalCallback</a> (Method method)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Output &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a><br class="typebreak" />
&lt; typename <br class="typebreak" />
<a class="el" href="structpp_1_1internal_1_1_type_unwrapper.html">internal::TypeUnwrapper</a><br class="typebreak" />
&lt; Output &gt;::StorageType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_factory.html#a8c550ff8d18548ba962af29309880eeb">NewCallbackWithOutput</a> (void(T::*method)(int32_t, Output))</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Method , typename A &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_factory.html#aaa341cc4aa04c12dfe58a4452467b225">NewCallback</a> (Method method, const A &amp;a)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Method , typename A &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_factory.html#a221758746a8b10563148990cf63d085d">NewOptionalCallback</a> (Method method, const A &amp;a)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Output , typename A &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a><br class="typebreak" />
&lt; typename <br class="typebreak" />
<a class="el" href="structpp_1_1internal_1_1_type_unwrapper.html">internal::TypeUnwrapper</a><br class="typebreak" />
&lt; Output &gt;::StorageType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_factory.html#a85f3416759e1d7297025f5a0fb037fd9">NewCallbackWithOutput</a> (void(T::*method)(int32_t, Output, A), const A &amp;a)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Method , typename A , typename B &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_factory.html#a3d32cb2060a1da7ce73e8657c94f15fa">NewCallback</a> (Method method, const A &amp;a, const B &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Method , typename A , typename B &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_factory.html#abe32b7e60edc4699de46dc8640e90bcb">NewOptionalCallback</a> (Method method, const A &amp;a, const B &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Output , typename A , typename B &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a><br class="typebreak" />
&lt; typename <br class="typebreak" />
<a class="el" href="structpp_1_1internal_1_1_type_unwrapper.html">internal::TypeUnwrapper</a><br class="typebreak" />
&lt; Output &gt;::StorageType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_factory.html#a5f1288cad38fa17aa1f07f5793908e24">NewCallbackWithOutput</a> (void(T::*method)(int32_t, Output, A, B), const A &amp;a, const B &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Method , typename A , typename B , typename C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_factory.html#a4110e491c1358c951903ef1b0fecf58d">NewCallback</a> (Method method, const A &amp;a, const B &amp;b, const C &amp;c)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Method , typename A , typename B , typename C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_factory.html#aaa7f305418d469d8be2ec801dd0bfeda">NewOptionalCallback</a> (Method method, const A &amp;a, const B &amp;b, const C &amp;c)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Output , typename A , typename B , typename C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a><br class="typebreak" />
&lt; typename <br class="typebreak" />
<a class="el" href="structpp_1_1internal_1_1_type_unwrapper.html">internal::TypeUnwrapper</a><br class="typebreak" />
&lt; Output &gt;::StorageType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_factory.html#a3653f981f4decf82d697e46a6d21519f">NewCallbackWithOutput</a> (void(T::*method)(int32_t, Output, A, B, C), const A &amp;a, const B &amp;b, const C &amp;c)</td></tr>
</table>
<hr /><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename ThreadTraits = ThreadSafeThreadTraits&gt;<br />
class pp::CompletionCallbackFactory&lt; T, ThreadTraits &gt;</h3>
<p>CompletionCallbackFactory&lt;T&gt; may be used to create <a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a> objects that are bound to member functions. </p>
<p>If a factory is destroyed, then any pending callbacks will be cancelled preventing any bound member functions from being called. The <a class="el" href="classpp_1_1_completion_callback_factory.html#ad43328a7d8c19233e3fa0b762f357088" title="CancelAll() cancels all CompletionCallbacks allocated from this factory.">CancelAll()</a> method allows pending callbacks to be cancelled without destroying the factory.</p>
<p><b>Note: </b><code>CompletionCallbackFactory&lt;T&gt;</code> isn't thread safe, but it is somewhat thread-friendly when used with a thread-safe traits class as the second template element. However, it only guarantees safety for creating a callback from another thread, the callback itself needs to execute on the same thread as the thread that creates/destroys the factory. With this restriction, it is safe to create the <code><a class="el" href="classpp_1_1_completion_callback_factory.html" title="CompletionCallbackFactory&lt;T&gt; may be used to create CompletionCallback objects that are bound to membe...">CompletionCallbackFactory</a></code> on the main thread, create callbacks from any thread and pass them to CallOnMainThread().</p>
<p><b>Example: </b></p>
<div class="fragment"><pre class="fragment">   <span class="keyword">class </span>MyClass {
    <span class="keyword">public</span>:
     <span class="comment">// If an compiler warns on following using |this| in the initializer</span>
     <span class="comment">// list, use PP_ALLOW_THIS_IN_INITIALIZER_LIST macro.</span>
     MyClass() : factory_(this) {
     }

     <span class="keywordtype">void</span> OpenFile(<span class="keyword">const</span> <a class="code" href="classpp_1_1_file_ref.html" title='The FileRef class represents a "weak pointer" to a file in a file system.'>pp::FileRef</a>&amp; file) {
       <a class="code" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">pp::CompletionCallback</a> cc = factory_.NewCallback(&amp;MyClass::DidOpen);
       int32_t rv = file_io_.Open(file, PP_FileOpenFlag_Read, cc);
       CHECK(rv == PP_OK_COMPLETIONPENDING);
     }

    <span class="keyword">private</span>:
     <span class="keywordtype">void</span> DidOpen(int32_t result) {
       <span class="keywordflow">if</span> (result == PP_OK) {
         <span class="comment">// The file is open, and we can begin reading.</span>
         <span class="comment">// ...</span>
       } <span class="keywordflow">else</span> {
         <span class="comment">// Failed to open the file with error given by &#39;result&#39;.</span>
       }
     }

     <a class="code" href="classpp_1_1_completion_callback_factory.html" title="CompletionCallbackFactory&lt;T&gt; may be used to create CompletionCallback objects that are bound to membe...">pp::CompletionCallbackFactory&lt;MyClass&gt;</a> factory_;
   };
</pre></div><p><b>Passing additional parameters to your callback</b></p>
<p>As a convenience, the <code><a class="el" href="classpp_1_1_completion_callback_factory.html" title="CompletionCallbackFactory&lt;T&gt; may be used to create CompletionCallback objects that are bound to membe...">CompletionCallbackFactory</a></code> can optionally create a closure with up to three bound parameters that it will pass to your callback function. This can be useful for passing information about the request to your callback function, which is especially useful if your class has multiple asynchronous callbacks pending.</p>
<p>For the above example, of opening a file, let's say you want to keep some description associated with your request, you might implement your OpenFile and DidOpen callback as follows:</p>
<div class="fragment"><pre class="fragment">   <span class="keywordtype">void</span> OpenFile(<span class="keyword">const</span> <a class="code" href="classpp_1_1_file_ref.html" title='The FileRef class represents a "weak pointer" to a file in a file system.'>pp::FileRef</a>&amp; file) {
     std::string message = <span class="stringliteral">&quot;Opening file!&quot;</span>;
     <a class="code" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">pp::CompletionCallback</a> cc = factory_.NewCallback(&amp;MyClass::DidOpen,
                                                      message);
     int32_t rv = file_io_.Open(file, PP_FileOpenFlag_Read, cc);
     CHECK(rv == PP_OK_COMPLETIONPENDING);
   }
   <span class="keywordtype">void</span> DidOpen(int32_t result, <span class="keyword">const</span> std::string&amp; message) {
     <span class="comment">// &quot;message&quot; will be &quot;Opening file!&quot;.</span>
     ...
   }
</pre></div><p><b>Optional versus required callbacks</b></p>
<p>When you create an "optional" callback, the browser may return the results synchronously if they are available. This can allow for higher performance in some cases if data is available quickly (for example, for network loads where there may be a lot of data coming quickly). In this case, the callback will never be run.</p>
<p>When creating a new callback with the factory, there will be data allocated on the heap that tracks the callback information and any bound arguments. This data is freed when the callback executes. In the case of optional callbacks, since the browser will never issue the callback, the internal tracking data will be leaked.</p>
<p>Therefore, if you use optional callbacks, it's important to manually issue the callback to free up this data. The typical pattern is:</p>
<div class="fragment"><pre class="fragment">   <a class="code" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">pp::CompletionCallback</a> callback = callback_factory.NewOptionalCallback(
       &amp;MyClass::OnDataReady);
   int32_t result = interface-&gt;GetData(callback);
   <span class="keywordflow">if</span> (result != PP_OK_COMPLETIONPENDING)
      callback.<a class="code" href="classpp_1_1_completion_callback.html#a7795404cc15a4f96523c28db21d364c4" title="Run() is used to run the CompletionCallback.">Run</a>(result);
</pre></div><p>Because of this additional complexity, it's generally recommended that you not use optional callbacks except when performance is more important (such as loading large resources from the network). In most other cases, the performance difference will not be worth the additional complexity, and most functions may never actually have the ability to complete synchronously.</p>
<p><b>Completion callbacks with output</b></p>
<p>For some API calls, the browser returns data to the caller via an output parameter. These can be difficult to manage since the output parameter must remain valid for as long as the callback is pending. Note also that CancelAll (or destroying the callback factory) does <em>not</em> cancel the callback from the browser's perspective, only the execution of the callback in the plugin code, and the output parameter will still be written to! This means that you can't use class members as output parameters without risking crashes.</p>
<p>To make this case easier, the <a class="el" href="classpp_1_1_completion_callback_factory.html" title="CompletionCallbackFactory&lt;T&gt; may be used to create CompletionCallback objects that are bound to membe...">CompletionCallbackFactory</a> can allocate and manage the output data for you and pass it to your callback function. This makes such calls more natural and less error-prone.</p>
<p>To create such a callback, use NewCallbackWithOutput and specify a callback function that takes the output parameter as its second argument. Let's say you're calling a function GetFile which asynchronously returns a <a class="el" href="classpp_1_1_file_ref.html" title='The FileRef class represents a "weak pointer" to a file in a file system.'>pp::FileRef</a>. GetFile's signature will be <code>int32_t GetFile(const CompletionCallbackWithOutput&lt;pp::FileRef&gt;&amp; callback);</code> and your calling code would look like this:</p>
<div class="fragment"><pre class="fragment">   <span class="keywordtype">void</span> RequestFile() {
     file_interface-&gt;GetFile(callback_factory_.NewCallbackWithOutput(
         &amp;MyClass::GotFile));
   }
   <span class="keywordtype">void</span> GotFile(int32_t result, <span class="keyword">const</span> <a class="code" href="classpp_1_1_file_ref.html" title='The FileRef class represents a "weak pointer" to a file in a file system.'>pp::FileRef</a>&amp; file) {
     <span class="keywordflow">if</span> (result == PP_OK) {
       ...use file...
     } <span class="keywordflow">else</span> {
       ...handle error...
     }
   }
</pre></div><p>As with regular completion callbacks, you can optionally add up to three bound arguments. These are passed following the output argument.</p>
<p>Your callback may take the output argument as a copy (common for small types like integers, a const reference (common for structures and resources to avoid an extra copy), or as a non-const reference. One optimization you can do if your callback function may take large arrays is to accept your output argument as a non-const reference and to swap() the argument with a vector of your own to store it. This means you don't have to copy the buffer to consume it. </p>
</div><hr /><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab870c8d37638facb949a86226c5138dc"></a><!-- doxytag: member="pp::CompletionCallbackFactory::CompletionCallbackFactory" ref="ab870c8d37638facb949a86226c5138dc" args="(T *object=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ThreadTraits  = ThreadSafeThreadTraits&gt; </div>
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback_factory.html">pp::CompletionCallbackFactory</a>&lt; T, ThreadTraits &gt;::<a class="el" href="classpp_1_1_completion_callback_factory.html">CompletionCallbackFactory</a> </td>
<td>(</td>
<td class="paramtype">T *&#160;</td>
<td class="paramname"><em>object</em> = <code>NULL</code></td><td>)</td>
<td><code> [inline, explicit]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>This constructor creates a <code><a class="el" href="classpp_1_1_completion_callback_factory.html" title="CompletionCallbackFactory&lt;T&gt; may be used to create CompletionCallback objects that are bound to membe...">CompletionCallbackFactory</a></code> bound to an object. </p>
<p>If the constructor is called without an argument, the default value of <code>NULL</code> is used. The user then must call <a class="el" href="classpp_1_1_completion_callback_factory.html#a6289f165e3ce15a07061f8be411e186c" title="Initialize() binds the CallbackFactory to a particular object.">Initialize()</a> to initialize the object.</p>
<p>param[in] object Optional parameter. An object whose member functions are to be bound to CompletionCallbacks created by this <code><a class="el" href="classpp_1_1_completion_callback_factory.html" title="CompletionCallbackFactory&lt;T&gt; may be used to create CompletionCallback objects that are bound to membe...">CompletionCallbackFactory</a></code>. The default value of this parameter is <code>NULL</code>. </p>
</div>
</div>
<a class="anchor" id="a8341b9bfa1660d5f3f38d2530a0a9d42"></a><!-- doxytag: member="pp::CompletionCallbackFactory::~CompletionCallbackFactory" ref="a8341b9bfa1660d5f3f38d2530a0a9d42" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ThreadTraits  = ThreadSafeThreadTraits&gt; </div>
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback_factory.html">pp::CompletionCallbackFactory</a>&lt; T, ThreadTraits &gt;::~<a class="el" href="classpp_1_1_completion_callback_factory.html">CompletionCallbackFactory</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Destructor. </p>
</div>
</div>
<hr /><h2>Member Function Documentation</h2>
<a class="anchor" id="ad43328a7d8c19233e3fa0b762f357088"></a><!-- doxytag: member="pp::CompletionCallbackFactory::CancelAll" ref="ad43328a7d8c19233e3fa0b762f357088" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ThreadTraits  = ThreadSafeThreadTraits&gt; </div>
<table class="memname">
<tr>
<td class="memname">void <a class="el" href="classpp_1_1_completion_callback_factory.html">pp::CompletionCallbackFactory</a>&lt; T, ThreadTraits &gt;::<a class="el" href="classpp_1_1_completion_callback_factory.html#ad43328a7d8c19233e3fa0b762f357088">CancelAll</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_completion_callback_factory.html#ad43328a7d8c19233e3fa0b762f357088" title="CancelAll() cancels all CompletionCallbacks allocated from this factory.">CancelAll()</a> cancels all <code>CompletionCallbacks</code> allocated from this factory. </p>
</div>
</div>
<a class="anchor" id="a5cd104c9185333647e1a752860ca0336"></a><!-- doxytag: member="pp::CompletionCallbackFactory::GetObject" ref="a5cd104c9185333647e1a752860ca0336" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ThreadTraits  = ThreadSafeThreadTraits&gt; </div>
<table class="memname">
<tr>
<td class="memname">T* <a class="el" href="classpp_1_1_completion_callback_factory.html">pp::CompletionCallbackFactory</a>&lt; T, ThreadTraits &gt;::<a class="el" href="classpp_1_1_completion_callback_factory.html#a5cd104c9185333647e1a752860ca0336">GetObject</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_completion_callback_factory.html#a5cd104c9185333647e1a752860ca0336" title="GetObject() returns the object that was passed at initialization to Intialize().">GetObject()</a> returns the object that was passed at initialization to Intialize(). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the object passed to the constructor or Intialize(). </dd></dl>
</div>
</div>
<a class="anchor" id="a6289f165e3ce15a07061f8be411e186c"></a><!-- doxytag: member="pp::CompletionCallbackFactory::Initialize" ref="a6289f165e3ce15a07061f8be411e186c" args="(T *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ThreadTraits  = ThreadSafeThreadTraits&gt; </div>
<table class="memname">
<tr>
<td class="memname">void <a class="el" href="classpp_1_1_completion_callback_factory.html">pp::CompletionCallbackFactory</a>&lt; T, ThreadTraits &gt;::<a class="el" href="classpp_1_1_completion_callback_factory.html#a6289f165e3ce15a07061f8be411e186c">Initialize</a> </td>
<td>(</td>
<td class="paramtype">T *&#160;</td>
<td class="paramname"><em>object</em></td><td>)</td>
<td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_completion_callback_factory.html#a6289f165e3ce15a07061f8be411e186c" title="Initialize() binds the CallbackFactory to a particular object.">Initialize()</a> binds the <code>CallbackFactory</code> to a particular object. </p>
<p>Use this when the object is not available at <code>CallbackFactory</code> creation, and the <code>NULL</code> default is passed to the constructor. The object may only be initialized once, either by the constructor, or by a call to <a class="el" href="classpp_1_1_completion_callback_factory.html#a6289f165e3ce15a07061f8be411e186c" title="Initialize() binds the CallbackFactory to a particular object.">Initialize()</a>.</p>
<p>This class may not be used on any thread until initialization is complete.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>The object whose member functions are to be bound to the <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> created by this <code><a class="el" href="classpp_1_1_completion_callback_factory.html" title="CompletionCallbackFactory&lt;T&gt; may be used to create CompletionCallback objects that are bound to membe...">CompletionCallbackFactory</a></code>. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab25d7ebdcdcd28f06ab767fdbbd4868f"></a><!-- doxytag: member="pp::CompletionCallbackFactory::NewCallback" ref="ab25d7ebdcdcd28f06ab767fdbbd4868f" args="(Method method)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ThreadTraits  = ThreadSafeThreadTraits&gt; </div>
<div class="memtemplate">
template&lt;typename Method &gt; </div>
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> <a class="el" href="classpp_1_1_completion_callback_factory.html">pp::CompletionCallbackFactory</a>&lt; T, ThreadTraits &gt;::<a class="el" href="classpp_1_1_completion_callback_factory.html#ab25d7ebdcdcd28f06ab767fdbbd4868f">NewCallback</a> </td>
<td>(</td>
<td class="paramtype">Method&#160;</td>
<td class="paramname"><em>method</em></td><td>)</td>
<td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>NewCallback allocates a new, single-use <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code>. </p>
<p>The <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> must be run in order for the memory allocated by the methods to be freed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>The method to be invoked upon completion of the operation.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code>. </dd></dl>
</div>
</div>
<a class="anchor" id="aaa341cc4aa04c12dfe58a4452467b225"></a><!-- doxytag: member="pp::CompletionCallbackFactory::NewCallback" ref="aaa341cc4aa04c12dfe58a4452467b225" args="(Method method, const A &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ThreadTraits  = ThreadSafeThreadTraits&gt; </div>
<div class="memtemplate">
template&lt;typename Method , typename A &gt; </div>
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> <a class="el" href="classpp_1_1_completion_callback_factory.html">pp::CompletionCallbackFactory</a>&lt; T, ThreadTraits &gt;::<a class="el" href="classpp_1_1_completion_callback_factory.html#ab25d7ebdcdcd28f06ab767fdbbd4868f">NewCallback</a> </td>
<td>(</td>
<td class="paramtype">Method&#160;</td>
<td class="paramname"><em>method</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const A &amp;&#160;</td>
<td class="paramname"><em>a</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_completion_callback_factory.html#ab25d7ebdcdcd28f06ab767fdbbd4868f" title="NewCallback allocates a new, single-use CompletionCallback.">NewCallback()</a> allocates a new, single-use <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code>. </p>
<p>The <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> must be run in order for the memory allocated by the methods to be freed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>The method to be invoked upon completion of the operation. Method should be of type: <code>void (T::*)(int32_t result, const A&amp; a)</code></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Passed to <code>method</code> when the completion callback runs.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code>. </dd></dl>
</div>
</div>
<a class="anchor" id="a3d32cb2060a1da7ce73e8657c94f15fa"></a><!-- doxytag: member="pp::CompletionCallbackFactory::NewCallback" ref="a3d32cb2060a1da7ce73e8657c94f15fa" args="(Method method, const A &amp;a, const B &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ThreadTraits  = ThreadSafeThreadTraits&gt; </div>
<div class="memtemplate">
template&lt;typename Method , typename A , typename B &gt; </div>
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> <a class="el" href="classpp_1_1_completion_callback_factory.html">pp::CompletionCallbackFactory</a>&lt; T, ThreadTraits &gt;::<a class="el" href="classpp_1_1_completion_callback_factory.html#ab25d7ebdcdcd28f06ab767fdbbd4868f">NewCallback</a> </td>
<td>(</td>
<td class="paramtype">Method&#160;</td>
<td class="paramname"><em>method</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const A &amp;&#160;</td>
<td class="paramname"><em>a</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const B &amp;&#160;</td>
<td class="paramname"><em>b</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_completion_callback_factory.html#ab25d7ebdcdcd28f06ab767fdbbd4868f" title="NewCallback allocates a new, single-use CompletionCallback.">NewCallback()</a> allocates a new, single-use <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code>. </p>
<p>The <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> must be run in order for the memory allocated by the methods to be freed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir"></td><td class="paramname">method</td><td>The method taking the callback. Method should be of type: <code>void (T::*)(int32_t result, const A&amp; a, const B&amp; b)</code></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Passed to <code>method</code> when the completion callback runs.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Passed to <code>method</code> when the completion callback runs.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code>. </dd></dl>
</div>
</div>
<a class="anchor" id="a4110e491c1358c951903ef1b0fecf58d"></a><!-- doxytag: member="pp::CompletionCallbackFactory::NewCallback" ref="a4110e491c1358c951903ef1b0fecf58d" args="(Method method, const A &amp;a, const B &amp;b, const C &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ThreadTraits  = ThreadSafeThreadTraits&gt; </div>
<div class="memtemplate">
template&lt;typename Method , typename A , typename B , typename C &gt; </div>
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> <a class="el" href="classpp_1_1_completion_callback_factory.html">pp::CompletionCallbackFactory</a>&lt; T, ThreadTraits &gt;::<a class="el" href="classpp_1_1_completion_callback_factory.html#ab25d7ebdcdcd28f06ab767fdbbd4868f">NewCallback</a> </td>
<td>(</td>
<td class="paramtype">Method&#160;</td>
<td class="paramname"><em>method</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const A &amp;&#160;</td>
<td class="paramname"><em>a</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const B &amp;&#160;</td>
<td class="paramname"><em>b</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const C &amp;&#160;</td>
<td class="paramname"><em>c</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_completion_callback_factory.html#ab25d7ebdcdcd28f06ab767fdbbd4868f" title="NewCallback allocates a new, single-use CompletionCallback.">NewCallback()</a> allocates a new, single-use <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code>. </p>
<p>The <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> must be run in order for the memory allocated by the methods to be freed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir"></td><td class="paramname">method</td><td>The method taking the callback. Method should be of type: <code> void (T::*)(int32_t result, const A&amp; a, const B&amp; b, const C&amp; c) </code></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Passed to <code>method</code> when the completion callback runs.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Passed to <code>method</code> when the completion callback runs.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Passed to <code>method</code> when the completion callback runs.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code>. </dd></dl>
</div>
</div>
<a class="anchor" id="a8c550ff8d18548ba962af29309880eeb"></a><!-- doxytag: member="pp::CompletionCallbackFactory::NewCallbackWithOutput" ref="a8c550ff8d18548ba962af29309880eeb" args="(void(T::*method)(int32_t, Output))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ThreadTraits  = ThreadSafeThreadTraits&gt; </div>
<div class="memtemplate">
template&lt;typename Output &gt; </div>
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a>&lt; typename <a class="el" href="structpp_1_1internal_1_1_type_unwrapper.html">internal::TypeUnwrapper</a>&lt;Output&gt;::StorageType&gt; <a class="el" href="classpp_1_1_completion_callback_factory.html">pp::CompletionCallbackFactory</a>&lt; T, ThreadTraits &gt;::<a class="el" href="classpp_1_1_completion_callback_factory.html#a8c550ff8d18548ba962af29309880eeb">NewCallbackWithOutput</a> </td>
<td>(</td>
<td class="paramtype">void(T::*)(int32_t, Output)&#160;</td>
<td class="paramname"><em>method</em></td><td>)</td>
<td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_completion_callback_factory.html#a8c550ff8d18548ba962af29309880eeb" title="NewCallbackWithOutput() allocates a new, single-use CompletionCallback where the browser will pass an...">NewCallbackWithOutput()</a> allocates a new, single-use <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> where the browser will pass an additional parameter containing the result of the request. </p>
<p>The <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> must be run in order for the memory allocated by the methods to be freed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>The method to be invoked upon completion of the operation.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code>. </dd></dl>
</div>
</div>
<a class="anchor" id="a85f3416759e1d7297025f5a0fb037fd9"></a><!-- doxytag: member="pp::CompletionCallbackFactory::NewCallbackWithOutput" ref="a85f3416759e1d7297025f5a0fb037fd9" args="(void(T::*method)(int32_t, Output, A), const A &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ThreadTraits  = ThreadSafeThreadTraits&gt; </div>
<div class="memtemplate">
template&lt;typename Output , typename A &gt; </div>
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a>&lt; typename <a class="el" href="structpp_1_1internal_1_1_type_unwrapper.html">internal::TypeUnwrapper</a>&lt;Output&gt;::StorageType&gt; <a class="el" href="classpp_1_1_completion_callback_factory.html">pp::CompletionCallbackFactory</a>&lt; T, ThreadTraits &gt;::<a class="el" href="classpp_1_1_completion_callback_factory.html#a8c550ff8d18548ba962af29309880eeb">NewCallbackWithOutput</a> </td>
<td>(</td>
<td class="paramtype">void(T::*)(int32_t, Output, A)&#160;</td>
<td class="paramname"><em>method</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const A &amp;&#160;</td>
<td class="paramname"><em>a</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_completion_callback_factory.html#a8c550ff8d18548ba962af29309880eeb" title="NewCallbackWithOutput() allocates a new, single-use CompletionCallback where the browser will pass an...">NewCallbackWithOutput()</a> allocates a new, single-use <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> where the browser will pass an additional parameter containing the result of the request. </p>
<p>The <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> must be run in order for the memory allocated by the methods to be freed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>The method to be invoked upon completion of the operation.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Passed to <code>method</code> when the completion callback runs.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code>. </dd></dl>
</div>
</div>
<a class="anchor" id="a5f1288cad38fa17aa1f07f5793908e24"></a><!-- doxytag: member="pp::CompletionCallbackFactory::NewCallbackWithOutput" ref="a5f1288cad38fa17aa1f07f5793908e24" args="(void(T::*method)(int32_t, Output, A, B), const A &amp;a, const B &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ThreadTraits  = ThreadSafeThreadTraits&gt; </div>
<div class="memtemplate">
template&lt;typename Output , typename A , typename B &gt; </div>
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a>&lt; typename <a class="el" href="structpp_1_1internal_1_1_type_unwrapper.html">internal::TypeUnwrapper</a>&lt;Output&gt;::StorageType&gt; <a class="el" href="classpp_1_1_completion_callback_factory.html">pp::CompletionCallbackFactory</a>&lt; T, ThreadTraits &gt;::<a class="el" href="classpp_1_1_completion_callback_factory.html#a8c550ff8d18548ba962af29309880eeb">NewCallbackWithOutput</a> </td>
<td>(</td>
<td class="paramtype">void(T::*)(int32_t, Output, A, B)&#160;</td>
<td class="paramname"><em>method</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const A &amp;&#160;</td>
<td class="paramname"><em>a</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const B &amp;&#160;</td>
<td class="paramname"><em>b</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_completion_callback_factory.html#a8c550ff8d18548ba962af29309880eeb" title="NewCallbackWithOutput() allocates a new, single-use CompletionCallback where the browser will pass an...">NewCallbackWithOutput()</a> allocates a new, single-use <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> where the browser will pass an additional parameter containing the result of the request. </p>
<p>The <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> must be run in order for the memory allocated by the methods to be freed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>The method to be invoked upon completion of the operation.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Passed to <code>method</code> when the completion callback runs.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Passed to <code>method</code> when the completion callback runs.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code>. </dd></dl>
</div>
</div>
<a class="anchor" id="a3653f981f4decf82d697e46a6d21519f"></a><!-- doxytag: member="pp::CompletionCallbackFactory::NewCallbackWithOutput" ref="a3653f981f4decf82d697e46a6d21519f" args="(void(T::*method)(int32_t, Output, A, B, C), const A &amp;a, const B &amp;b, const C &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ThreadTraits  = ThreadSafeThreadTraits&gt; </div>
<div class="memtemplate">
template&lt;typename Output , typename A , typename B , typename C &gt; </div>
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a>&lt; typename <a class="el" href="structpp_1_1internal_1_1_type_unwrapper.html">internal::TypeUnwrapper</a>&lt;Output&gt;::StorageType&gt; <a class="el" href="classpp_1_1_completion_callback_factory.html">pp::CompletionCallbackFactory</a>&lt; T, ThreadTraits &gt;::<a class="el" href="classpp_1_1_completion_callback_factory.html#a8c550ff8d18548ba962af29309880eeb">NewCallbackWithOutput</a> </td>
<td>(</td>
<td class="paramtype">void(T::*)(int32_t, Output, A, B, C)&#160;</td>
<td class="paramname"><em>method</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const A &amp;&#160;</td>
<td class="paramname"><em>a</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const B &amp;&#160;</td>
<td class="paramname"><em>b</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const C &amp;&#160;</td>
<td class="paramname"><em>c</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_completion_callback_factory.html#a8c550ff8d18548ba962af29309880eeb" title="NewCallbackWithOutput() allocates a new, single-use CompletionCallback where the browser will pass an...">NewCallbackWithOutput()</a> allocates a new, single-use <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> where the browser will pass an additional parameter containing the result of the request. </p>
<p>The <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> must be run in order for the memory allocated by the methods to be freed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir"></td><td class="paramname">method</td><td>The method to be run.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Passed to <code>method</code> when the completion callback runs.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Passed to <code>method</code> when the completion callback runs.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Passed to <code>method</code> when the completion callback runs.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code>. </dd></dl>
</div>
</div>
<a class="anchor" id="adacce232874e0d5ab52ffa4bd8af9ef7"></a><!-- doxytag: member="pp::CompletionCallbackFactory::NewOptionalCallback" ref="adacce232874e0d5ab52ffa4bd8af9ef7" args="(Method method)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ThreadTraits  = ThreadSafeThreadTraits&gt; </div>
<div class="memtemplate">
template&lt;typename Method &gt; </div>
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> <a class="el" href="classpp_1_1_completion_callback_factory.html">pp::CompletionCallbackFactory</a>&lt; T, ThreadTraits &gt;::<a class="el" href="classpp_1_1_completion_callback_factory.html#adacce232874e0d5ab52ffa4bd8af9ef7">NewOptionalCallback</a> </td>
<td>(</td>
<td class="paramtype">Method&#160;</td>
<td class="paramname"><em>method</em></td><td>)</td>
<td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_completion_callback_factory.html#adacce232874e0d5ab52ffa4bd8af9ef7" title="NewOptionalCallback() allocates a new, single-use CompletionCallback that might not run if the method...">NewOptionalCallback()</a> allocates a new, single-use <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> that might not run if the method taking it can complete synchronously. </p>
<p>Thus, if after passing the <a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a> to a Pepper method, the method does not return PP_OK_COMPLETIONPENDING, then you should manually call the <a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a>'s Run method, or memory will be leaked.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>The method to be invoked upon completion of the operation.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code>. </dd></dl>
</div>
</div>
<a class="anchor" id="a221758746a8b10563148990cf63d085d"></a><!-- doxytag: member="pp::CompletionCallbackFactory::NewOptionalCallback" ref="a221758746a8b10563148990cf63d085d" args="(Method method, const A &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ThreadTraits  = ThreadSafeThreadTraits&gt; </div>
<div class="memtemplate">
template&lt;typename Method , typename A &gt; </div>
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> <a class="el" href="classpp_1_1_completion_callback_factory.html">pp::CompletionCallbackFactory</a>&lt; T, ThreadTraits &gt;::<a class="el" href="classpp_1_1_completion_callback_factory.html#adacce232874e0d5ab52ffa4bd8af9ef7">NewOptionalCallback</a> </td>
<td>(</td>
<td class="paramtype">Method&#160;</td>
<td class="paramname"><em>method</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const A &amp;&#160;</td>
<td class="paramname"><em>a</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_completion_callback_factory.html#adacce232874e0d5ab52ffa4bd8af9ef7" title="NewOptionalCallback() allocates a new, single-use CompletionCallback that might not run if the method...">NewOptionalCallback()</a> allocates a new, single-use <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> that might not run if the method taking it can complete synchronously. </p>
<p>Thus, if after passing the <a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a> to a Pepper method, the method does not return PP_OK_COMPLETIONPENDING, then you should manually call the <a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a>'s Run method, or memory will be leaked.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>The method to be invoked upon completion of the operation. Method should be of type: <code>void (T::*)(int32_t result, const A&amp; a)</code></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Passed to <code>method</code> when the completion callback runs.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code>. </dd></dl>
</div>
</div>
<a class="anchor" id="abe32b7e60edc4699de46dc8640e90bcb"></a><!-- doxytag: member="pp::CompletionCallbackFactory::NewOptionalCallback" ref="abe32b7e60edc4699de46dc8640e90bcb" args="(Method method, const A &amp;a, const B &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ThreadTraits  = ThreadSafeThreadTraits&gt; </div>
<div class="memtemplate">
template&lt;typename Method , typename A , typename B &gt; </div>
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> <a class="el" href="classpp_1_1_completion_callback_factory.html">pp::CompletionCallbackFactory</a>&lt; T, ThreadTraits &gt;::<a class="el" href="classpp_1_1_completion_callback_factory.html#adacce232874e0d5ab52ffa4bd8af9ef7">NewOptionalCallback</a> </td>
<td>(</td>
<td class="paramtype">Method&#160;</td>
<td class="paramname"><em>method</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const A &amp;&#160;</td>
<td class="paramname"><em>a</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const B &amp;&#160;</td>
<td class="paramname"><em>b</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_completion_callback_factory.html#adacce232874e0d5ab52ffa4bd8af9ef7" title="NewOptionalCallback() allocates a new, single-use CompletionCallback that might not run if the method...">NewOptionalCallback()</a> allocates a new, single-use <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> that might not run if the method taking it can complete synchronously. </p>
<p>Thus, if after passing the <a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a> to a Pepper method, the method does not return PP_OK_COMPLETIONPENDING, then you should manually call the <a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a>'s Run method, or memory will be leaked.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>The method taking the callback. Method should be of type: <code>void (T::*)(int32_t result, const A&amp; a, const B&amp; b)</code></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Passed to <code>method</code> when the completion callback runs.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Passed to <code>method</code> when the completion callback runs.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code>. </dd></dl>
</div>
</div>
<a class="anchor" id="aaa7f305418d469d8be2ec801dd0bfeda"></a><!-- doxytag: member="pp::CompletionCallbackFactory::NewOptionalCallback" ref="aaa7f305418d469d8be2ec801dd0bfeda" args="(Method method, const A &amp;a, const B &amp;b, const C &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ThreadTraits  = ThreadSafeThreadTraits&gt; </div>
<div class="memtemplate">
template&lt;typename Method , typename A , typename B , typename C &gt; </div>
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> <a class="el" href="classpp_1_1_completion_callback_factory.html">pp::CompletionCallbackFactory</a>&lt; T, ThreadTraits &gt;::<a class="el" href="classpp_1_1_completion_callback_factory.html#adacce232874e0d5ab52ffa4bd8af9ef7">NewOptionalCallback</a> </td>
<td>(</td>
<td class="paramtype">Method&#160;</td>
<td class="paramname"><em>method</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const A &amp;&#160;</td>
<td class="paramname"><em>a</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const B &amp;&#160;</td>
<td class="paramname"><em>b</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const C &amp;&#160;</td>
<td class="paramname"><em>c</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_completion_callback_factory.html#adacce232874e0d5ab52ffa4bd8af9ef7" title="NewOptionalCallback() allocates a new, single-use CompletionCallback that might not run if the method...">NewOptionalCallback()</a> allocates a new, single-use <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> that might not run if the method taking it can complete synchronously. </p>
<p>Thus, if after passing the <a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a> to a Pepper method, the method does not return PP_OK_COMPLETIONPENDING, then you should manually call the <a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a>'s Run method, or memory will be leaked.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>The method taking the callback. Method should be of type: <code> void (T::*)(int32_t result, const A&amp; a, const B&amp; b, const C&amp; c) </code></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Passed to <code>method</code> when the completion callback runs.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Passed to <code>method</code> when the completion callback runs.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Passed to <code>method</code> when the completion callback runs.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code>. </dd></dl>
</div>
</div>
<hr />The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="completion__callback__factory_8h.html">completion_callback_factory.h</a></li>
</ul>
</div><!-- contents -->
</div>
{{/partials.standard_nacl_api}}
