# Copyright 2015 The Chromium Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# ==============================================================================
# TEST SETUP
# ==============================================================================

import("//build/config/chromeos/args.gni")
import("//build/config/chromeos/ui_mode.gni")
import("//build/config/devtools.gni")
import("//build/config/gclient_args.gni")
import("//build/config/rts.gni")
import("//build/rust/rust_static_library.gni")
import("//build_overrides/build.gni")

declare_args() {
  # Some component repos (e.g. ANGLE) import //testing but do not have
  # "location_tags.json", and so we don't want to try and upload the tags
  # for their tests.
  # And, some build configs may simply turn off generation altogether.
  tests_have_location_tags = generate_location_tags
}

# On Fuchsia, the test executable has a suffix and is a dependency of the
# common |target_name| target. For `visibility`, the executable must be
# specified. Cross-platform targets that include `test` targets in their
# visibility lists, add `${exec_target_suffix}` immediately after the test
# target name. This is not necessary when the target is a `source_set`.
if (is_fuchsia) {
  exec_target_suffix = "__exec"
} else {
  exec_target_suffix = ""
}

if (is_android) {
  import("//build/config/android/config.gni")
  import("//build/config/android/create_unwind_table.gni")
  import("//build/config/android/extract_unwind_tables.gni")
  import("//build/config/android/rules.gni")
  import("//build/config/sanitizers/sanitizers.gni")
} else if (is_fuchsia) {
  import("//build/config/chromecast_build.gni")
  import("//build/config/fuchsia/generate_runner_scripts.gni")
  import("//third_party/fuchsia-sdk/sdk/build/cmc.gni")
  import("//third_party/fuchsia-sdk/sdk/build/component.gni")
  import("//third_party/fuchsia-sdk/sdk/build/package.gni")
} else if (is_chromeos && is_chromeos_device) {
  import("//build/config/chromeos/rules.gni")
  import("//build/config/sanitizers/sanitizers.gni")
  import("//build/util/generate_wrapper.gni")
} else if (is_ios) {
  import("//build/config/ios/ios_sdk.gni")
  import("//build/config/ios/ios_test_runner_wrapper.gni")
  import("//build/config/ios/rules.gni")
} else {
  import("//build/config/sanitizers/sanitizers.gni")
  import("//build/util/generate_wrapper.gni")
}

# This template generates the test target (of type `target_type`) but also
# generates a rust library that includes all .rs files found in sources and
# depends on that from the test target.
template("mixed_test") {
  assert(defined(invoker.target_type) && invoker.target_type != "")

  # The crate_root variable would transform the target into a Rust binary
  # which is incorrect. To not use a generated crate root set:
  # ```
  # test_crate_root = "path/to/root.rs"
  # ```
  assert(!defined(invoker.crate_root))

  _rs_vars = [
    "sources",  # We split this list into two.
    "crate_name",  # Android test template overrides the crate name.
  ]

  if (defined(invoker.sources)) {
    _rs_sources = filter_include(invoker.sources, [ "*.rs" ])
    _cc_sources = filter_exclude(invoker.sources, [ "*.rs" ])
  } else {
    _rs_sources = []
    _cc_sources = []
  }

  if (_rs_sources != []) {
    if (defined(invoker.crate_name)) {
      _rust_target_name = "${invoker.crate_name}_rust_objects"
    } else {
      _rust_target_name = "${target_name}_rust_objects"
    }

    # We could automatically add `deps += [ "//testing/rust_gtest_interop" ]`
    # if `rs_sources` is non-empty. But we don't automatically provide
    # //testing/gtest either so it would be asymmetric and could break in that
    # case. So, we act instead as if //testing/rust_gtest_interop is part of
    # the //testing/gtest dependency. If you add one, and have `rs_sources`
    # listed, you get both.
    _gtest_is_in_deps = false
    if (defined(invoker.deps) && invoker.deps != []) {
      foreach(dep, invoker.deps) {
        if (get_label_info(dep, "label_no_toolchain") ==
            "//testing/gtest:gtest") {
          _gtest_is_in_deps = true
        }
      }
    }

    # TODO(danakj): This could be a rust_source_set perhaps, the point being
    # that we need to link in all the .o object files inside the library,
    # instead of dropping unreachable ones during linking (which would drop the
    # tests). Alternatively we could use a special name suffix or other similar
    # trick perhaps to ensure that all object files are linked in here.
    rust_static_library(_rust_target_name) {
      forward_variables_from(invoker,
                             TESTONLY_AND_VISIBILITY + [
                                   "allow_unsafe",
                                   "deps",
                                   "generate_crate_root",
                                   "public_deps",
                                 ])
      configs += [ "//build/rust:test" ]
      if (defined(invoker.test_crate_root)) {
        crate_root = invoker.test_crate_root
      } else {
        generate_crate_root = true
      }
      sources = _rs_sources

      if (_gtest_is_in_deps) {
        deps += [ "//testing/rust_gtest_interop" ]
      }
    }
  } else {
    not_needed(invoker, _rs_vars)
  }

  target(invoker.target_type, target_name) {
    forward_variables_from(invoker, "*", TESTONLY_AND_VISIBILITY + _rs_vars)
    forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
    sources = _cc_sources
    if (!defined(deps)) {
      deps = []
    }
    if (!defined(ldflags)) {
      ldflags = []
    }

    if (_rs_sources != []) {
      deps += [ ":${_rust_target_name}" ]
    }

    if (current_os != "aix" && !is_win) {
      # Inform the build system that this binary contains Rust unit tests. The
      # test-containing rlibs linked into it must not be discarded by the linker
      # even if there will be no edges going into them.
      #
      # For C++ this is done by not putting them in a library at all, but Rust
      # must be compiled into an rlib.
      #
      # On AIX there's no flag to avoid pruning unit tests in this library from
      # the linking step. On Windows, there's no need for it.
      if (_rs_sources != []) {
        ldflags +=
            [ "-LinkWrapper,add-whole-archive=${_rust_target_name}.rlib" ]
      }

      # Do the same for any Rust dependencies with unit tests in them. This will
      # only match rust targets by looking for rlib extensions.
      foreach(d, deps) {
        _dep_target_name = get_label_info(d, "name")
        ldflags += [ "-LinkWrapper,add-whole-archive=${_dep_target_name}.rlib" ]
      }
    }
  }
}

# Define a test as an executable (or apk on Android) with the "testonly" flag
# set.
# Variable:
#   use_xvfb: (optional) whether to run the executable under Xvfb.
#   use_raw_android_executable: Use executable() rather than android_apk().
#   use_native_activity: Test implements ANativeActivity_onCreate().
#   test_runner_shard: (Fuchsia, optional): for CFv2 tests, use the given test
#      runner shard rather than the default shard for the ELF runner when
#      assembling the test component. This is useful, for example, to use the
#      elf_test_ambient_exec_runner for tests that require
#      job_policy_ambient_mark_vmo_exec.
#   fuchsia_package_deps: (Fuchsia, optional) List of fuchsia_component()
#      targets that this test package contains.
#   # TODO(crbug/1280705): remove when all tests are migrated to CFv2.
#   is_xctest: (iOS, optional) whether to build the executable as XCTest.
#      Similar to the GN arg 'enable_run_ios_unittests_with_xctest' but
#      for build targets.
#   allow_cleartext_traffic: (Android, optional) whether to allow cleartext
#      network requests during the test.
template("test") {
  # Ensures the rts file exists and if not, creates a dummy file
  if (use_rts) {
    action("${target_name}__rts_filters") {
      script = "//build/add_rts_filters.py"
      rts_file = "${root_build_dir}/gen/rts/${invoker.target_name}.filter"
      inverted_rts_file =
          "${root_build_dir}/gen/rts/${invoker.target_name}_inverted.filter"
      args = [
        rebase_path(rts_file, root_build_dir),
        rebase_path(inverted_rts_file, root_build_dir),
      ]
      outputs = [
        rts_file,
        inverted_rts_file,
      ]
    }
  }

  testonly = true
  if (!is_ios) {
    assert(!defined(invoker.is_xctest) || !invoker.is_xctest,
           "is_xctest can be set only for iOS builds")
  }
  if (!is_android) {
    assert(!defined(invoker.allow_cleartext_traffic),
           "allow_cleartext_traffic can be set only for Android tests")
  }

  if (is_android) {
    assert(!defined(invoker.use_xvfb) || !invoker.use_xvfb)

    _use_default_launcher =
        !defined(invoker.use_default_launcher) || invoker.use_default_launcher
    if (!defined(invoker.use_raw_android_executable)) {
      # Checkouts where build_with_chromium == false often have a custom GN
      # template wrapper around test() which sets use_default_launcher == false.
      # Set the _use_raw_android_executable default so that test() targets which
      # do not use the custom wrapper
      # (1) Do not cause "gn gen" to fail
      # (2) Do not need to be moved into if(build_with_chromium) block.
      _use_raw_android_executable =
          !build_with_chromium && _use_default_launcher
    } else {
      not_needed([ "_use_default_launcher" ])
      _use_raw_android_executable = invoker.use_raw_android_executable
    }

    # output_name is used to allow targets with the same name but in different
    # packages to still produce unique runner scripts.
    _output_name = invoker.target_name
    if (defined(invoker.output_name)) {
      _output_name = invoker.output_name
    }

    _test_runner_target = "${_output_name}__test_runner_script"
    _wrapper_script_vars = [
      "android_test_runner_script",
      "ignore_all_data_deps",
      "shard_timeout",
    ]

    assert(_use_raw_android_executable || enable_java_templates)

    if (_use_raw_android_executable) {
      not_needed(invoker, [ "add_unwind_tables_in_apk" ])

      _exec_target = "${target_name}__exec"
      _dist_target = "${target_name}__dist"
      _exec_output =
          "$target_out_dir/${invoker.target_name}/${invoker.target_name}"

      mixed_test(_exec_target) {
        target_type = "executable"

        # Configs will always be defined since we set_defaults in
        # BUILDCONFIG.gn.
        configs = []
        forward_variables_from(
            invoker,
            "*",
            TESTONLY_AND_VISIBILITY + _wrapper_script_vars + [
                  "data_deps",
                  "extra_dist_files",
                ])

        # Thanks to the set_defaults() for test(), configs are initialized with
        # the default shared_library configs rather than executable configs.
        configs -= [
          "//build/config:shared_library_config",
          "//build/config/android:hide_all_but_jni",
        ]
        configs += [ "//build/config:executable_config" ]

        if (defined(invoker.data_deps)) {
          data_deps = invoker.data_deps
        } else {
          data_deps = []
        }
        if (!defined(data)) {
          data = []
        }
        if (tests_have_location_tags) {
          data += [ "//testing/location_tags.json" ]
        }

        # Don't output to the root or else conflict with the group() below.
        output_name = rebase_path(_exec_output, root_out_dir)

        if (use_rts) {
          data_deps += [ ":${invoker.target_name}__rts_filters" ]
        }
      }

      create_native_executable_dist(_dist_target) {
        dist_dir = "$root_out_dir/$target_name"
        binary = _exec_output
        deps = [ ":$_exec_target" ]
        if (defined(invoker.extra_dist_files)) {
          extra_files = invoker.extra_dist_files
        }

        if (use_rts) {
          if (!defined(data_deps)) {
            data_deps = []
          }
          data_deps += [ ":${invoker.target_name}__rts_filters" ]
        }
      }
    } else {
      _library_target_name = "${target_name}__library"
      _library_crate_name = "${target_name}_library"
      _apk_target_name = "${target_name}__apk"
      _apk_specific_vars = [
        "allow_cleartext_traffic",
        "android_manifest",
        "android_manifest_dep",
        "android_manifest_template",
        "app_as_shared_lib",
        "enable_multidex",
        "generate_final_jni",
        "product_config_java_packages",
        "loadable_modules",
        "loadable_module_deps",
        "min_sdk_version",
        "proguard_configs",
        "proguard_enabled",
        "srcjar_deps",
        "target_sdk_version",
        "use_default_launcher",
        "use_native_activity",
      ]

      _add_unwind_tables_in_apk =
          defined(invoker.add_unwind_tables_in_apk) &&
          invoker.add_unwind_tables_in_apk && target_cpu == "arm"

      # Adds the unwind tables from unstripped binary as an asset file in the
      # apk, if |add_unwind_tables_in_apk| is specified by the test.
      if (_add_unwind_tables_in_apk) {
        # TODO(crbug.com/1315603): Remove generation of v1 unwind asset when
        # `CFIBacktraceAndroid` is replaced with `ChromeUnwinderAndroid`.
        _unwind_table_name = "${_library_target_name}_unwind_v1"
        unwind_table_v1(_unwind_table_name) {
          library_target = ":$_library_target_name"
        }

        if (use_android_unwinder_v2) {
          _unwind_table_v2_name = "${_library_target_name}_unwind_v2"
          unwind_table_v2(_unwind_table_v2_name) {
            library_target = ":$_library_target_name"
          }
        }

        _unwind_table_asset_name = "${target_name}__unwind_assets"
        android_assets(_unwind_table_asset_name) {
          sources = [ "$target_out_dir/$_unwind_table_name/$unwind_table_asset_v1_filename" ]
          disable_compression = true
          deps = [ ":$_unwind_table_name" ]
          if (use_android_unwinder_v2) {
            sources += [ "$target_out_dir/$_unwind_table_v2_name/$unwind_table_asset_v2_filename" ]
            deps += [ ":$_unwind_table_v2_name" ]
          }
        }
      }

      mixed_test(_library_target_name) {
        target_type = "shared_library"

        # Configs will always be defined since we set_defaults in
        # BUILDCONFIG.gn.
        configs = []  # Prevent list overwriting warning.
        configs = invoker.configs

        if (_add_unwind_tables_in_apk) {
          # Remove -gz if present, as dump_syms does not support it.
          # Add and then remove because "-=" removes all, but errors if none are found.
          configs += [ "//build/config:compress_debug_sections" ]
          configs -= [ "//build/config:compress_debug_sections" ]
        }

        forward_variables_from(
            invoker,
            "*",
            [
                  "configs",
                  "deps",
                ] + _apk_specific_vars + _wrapper_script_vars +
                TESTONLY_AND_VISIBILITY)

        # Use a crate name that avoids creating a warning due to double
        # underscore (ie. `__`).
        crate_name = _library_crate_name

        # Native targets do not need to depend on java targets. Filter them out
        # so that the shared library can be built without needing to wait for
        # dependent java targets.
        deps = []
        if (defined(invoker.deps)) {
          deps = filter_exclude(invoker.deps, java_target_patterns)
        }

        if (_use_default_launcher) {
          deps += [ "//testing/android/native_test:native_test_native_code" ]
        }
      }
      unittest_apk(_apk_target_name) {
        forward_variables_from(invoker, _apk_specific_vars)
        shared_library = ":$_library_target_name"
        apk_name = invoker.target_name
        if (defined(invoker.output_name)) {
          apk_name = invoker.output_name
          install_script_name = "install_${invoker.output_name}"
        }

        if (defined(invoker.deps)) {
          deps = invoker.deps
        } else {
          deps = []
        }
        if (defined(loadable_module_deps)) {
          deps += loadable_module_deps
        }

        # Add the Java classes so that each target does not have to do it.
        if (_use_default_launcher) {
          deps += [ "//base/test:test_support_java" ]
        }

        if (defined(_unwind_table_asset_name)) {
          deps += [ ":${_unwind_table_asset_name}" ]
        }

        if (use_rts) {
          data_deps = [ ":${invoker.target_name}__rts_filters" ]
        }
      }
    }

    test_runner_script(_test_runner_target) {
      forward_variables_from(invoker, _wrapper_script_vars)

      if (_use_raw_android_executable) {
        executable_dist_dir = "$root_out_dir/$_dist_target"
        data_deps = [ ":$_exec_target" ]
      } else {
        apk_target = ":$_apk_target_name"
        incremental_apk = incremental_install

        # Dep needed for the test runner .runtime_deps file to pick up data
        # deps from the forward_variables_from(invoker, "*") on the library.
        data_deps = [ ":$_library_target_name" ]
      }
      test_name = _output_name
      test_suite = _output_name
      test_type = "gtest"

      if (use_rts) {
        data_deps += [ ":${invoker.target_name}__rts_filters" ]
      }
    }

    # Create a wrapper script rather than using a group() in order to ensure
    # "ninja $target_name" always works. If this was a group(), then GN would
    # not create a top-level alias for it if a target exists in another
    # directory with the same $target_name.
    # Also - bots run this script directly for "components_perftests".
    generate_wrapper(target_name) {
      forward_variables_from(invoker, [ "visibility" ])
      executable = "$root_build_dir/bin/run_$_output_name"
      wrapper_script = "$root_build_dir/$_output_name"
      deps = [ ":$_test_runner_target" ]
      if (_use_raw_android_executable) {
        deps += [ ":$_dist_target" ]
      } else {
        # Dep needed for the swarming .isolate file to pick up data
        # deps from the forward_variables_from(invoker, "*") on the library.
        deps += [
          ":$_apk_target_name",
          ":$_library_target_name",
        ]
      }

      if (defined(invoker.data_deps)) {
        data_deps = invoker.data_deps
      } else {
        data_deps = []
      }

      data_deps += [ "//testing:test_scripts_shared" ]

      if (tests_have_location_tags) {
        data = [ "//testing/location_tags.json" ]
      }

      if (use_rts) {
        data_deps += [ ":${invoker.target_name}__rts_filters" ]
      }
    }
  } else if (is_fuchsia) {
    assert(!defined(invoker.use_xvfb) || !invoker.use_xvfb)

    _output_name = invoker.target_name
    _pkg_target = "${_output_name}_pkg"
    _exec_target = "${_output_name}__exec"
    _program_name = get_label_info(":${_exec_target}", "name")

    # Generate a CML fragment that provides the program name.
    _test_program_fragment_target = "${target_name}_program-fragment"
    _test_program_fragment = "${target_out_dir}/${target_name}_program.test-cml"
    generated_file(_test_program_fragment_target) {
      contents = {
        program = {
          binary = _program_name
        }
      }
      outputs = [ _test_program_fragment ]
      output_conversion = "json"
    }

    _test_runner_shard =
        "//build/config/fuchsia/test/elf_test_runner.shard.test-cml"
    if (defined(invoker.test_runner_shard)) {
      _test_runner_shard = invoker.test_runner_shard
    }

    # Collate the complete set of elements to include in the test component's
    # manifest.

    _manifest_fragments = [
      _test_program_fragment,
      _test_runner_shard,
    ]

    # Select the Fuchsia test realm in which to run the test.
    if (defined(invoker.run_as_chromium_system_test) &&
        invoker.run_as_chromium_system_test) {
      _manifest_fragments += [
        "//build/config/fuchsia/test/chromium_system_test_facet.shard.test-cml",
        "//build/config/fuchsia/test/system_test_minimum.shard.test-cml",
      ]
    } else {
      _manifest_fragments += [
        "//build/config/fuchsia/test/chromium_test_facet.shard.test-cml",
        "//build/config/fuchsia/test/minimum.shard.test-cml",
      ]
    }

    _test_component_manifest = "${target_out_dir}/${target_name}.cml"
    _merged_manifest_name = "${_output_name}.cml"

    if (defined(invoker.additional_manifest_fragments)) {
      _manifest_fragments += invoker.additional_manifest_fragments
    }

    # Generate the test component manifest from the specified elements.
    _test_component_manifest_target = "${target_name}_component-manifest"
    cmc_merge(_test_component_manifest_target) {
      sources = _manifest_fragments
      output_name = "${_merged_manifest_name}"
      deps = [ ":${_test_program_fragment_target}" ]
    }

    # Define the test component, dependent on the generated manifest, and the
    # test executable target.
    _test_component_target = "${target_name}_component"
    fuchsia_component(_test_component_target) {
      deps = [ ":$_test_component_manifest_target" ]
      data_deps = [ ":$_exec_target" ]
      manifest = _test_component_manifest
      visibility = [ ":*" ]
    }

    _test_component_targets = [ ":${_test_component_target}" ]

    # Define components for each entry in |additional_manifests|, if any. Since
    # manifests may themselves depend-on the outputs of |deps|, these components
    # must each individually depend on |invoker.deps|.
    if (defined(invoker.additional_manifests)) {
      foreach(filename, invoker.additional_manifests) {
        _additional_component_target =
            target_name + "_" + get_path_info(filename, "name")
        _test_component_targets += [ ":${_additional_component_target}" ]
        fuchsia_component(_additional_component_target) {
          forward_variables_from(invoker, [ "testonly" ])
          data_deps = [ ":$_exec_target" ]
          visibility = [ ":*" ]
          manifest = filename

          # Depend on |invoker.deps|, in case it includes a dependency that
          # creates this additional component's manifest.
          if (defined(invoker.deps)) {
            deps = invoker.deps
          }
        }
      }
    }

    # Define the package target that will bundle the test and additional
    # components and their data.
    fuchsia_package(_pkg_target) {
      forward_variables_from(invoker,
                             [
                               "excluded_files",
                               "excluded_dirs",
                               "excluded_paths",
                             ])
      package_name = _output_name
      deps = _test_component_targets

      if (defined(invoker.fuchsia_package_deps)) {
        deps += invoker.fuchsia_package_deps
      }
      if (!defined(excluded_paths)) {
        excluded_paths = []
      }
      excluded_paths += [
        "${devtools_root_location}/*",
        "*.git/*",
        "*.svn/*",
        "*.hg/*",
      ]
      if (devtools_root_location != "") {
        excluded_paths += [ "${devtools_root_location}/*" ]
      }
    }

    # |target_name| refers to the package-runner rule, so that building
    # "base_unittests" will build not only the executable, component, and
    # package, but also the script required to run them.
    fuchsia_test_runner(target_name) {
      forward_variables_from(invoker,
                             [
                               "data",
                               "data_deps",
                               "package_deps",
                               "use_test_server",
                             ])

      is_test_exe = true
      package = ":$_pkg_target"
      package_name = _output_name

      if (!defined(deps)) {
        deps = []
      }
      if (defined(invoker.deps)) {
        deps += invoker.deps
      }

      if (!defined(data)) {
        data = []
      }
      if (tests_have_location_tags) {
        data += [ "//testing/location_tags.json" ]
      }

      if (!defined(data_deps)) {
        data_deps = []
      }

      data_deps += [ "//testing:test_scripts_shared" ]

      if (use_rts) {
        data_deps += [ ":${target_name}__rts_filters" ]
      }
    }

    mixed_test(_exec_target) {
      target_type = "executable"
      forward_variables_from(invoker, "*", TESTONLY_AND_VISIBILITY)
      output_name = _exec_target
    }
  } else if (is_ios) {
    assert(!defined(invoker.use_xvfb) || !invoker.use_xvfb)
    _runtime_deps_file = "$root_out_dir/${target_name}.runtime_deps"

    declare_args() {
      # Keep the unittest-as-xctest functionality defaulted to off until the
      # bots are updated to handle it properly.
      # TODO(crbug.com/1001667): Remove this arg once the iOS test runner
      # supports running unittests with xctest.
      enable_run_ios_unittests_with_xctest = false
    }

    _test_target = target_name
    _output_name = target_name
    if (defined(invoker.output_name)) {
      _output_name = invoker.output_name
    }

    _wrapper_output_name = "run_${target_name}"
    ios_test_runner_wrapper(_wrapper_output_name) {
      forward_variables_from(invoker,
                             [
                               "data",
                               "deps",
                               "executable_args",
                               "output_name",
                               "retries",
                               "shards",
                             ])

      _root_build_dir = rebase_path("${root_build_dir}", root_build_dir)

      if (!defined(executable_args)) {
        executable_args = []
      }
      executable_args += [
        "--app",
        "@WrappedPath(${_root_build_dir}/${_test_target}.app)",
      ]

      wrapper_output_name = "${_wrapper_output_name}"

      if (!defined(data)) {
        data = []
      }
      if (tests_have_location_tags) {
        data += [ "//testing/location_tags.json" ]
      }
    }

    _resources_bundle_data = target_name + "_resources_bundle_data"

    bundle_data(_resources_bundle_data) {
      visibility = [ ":$_test_target" ]
      sources = [ "//testing/gtest_ios/Default.png" ]
      outputs = [ "{{bundle_resources_dir}}/{{source_file_part}}" ]
    }

    force_xctest = enable_run_ios_unittests_with_xctest ||
                   (defined(invoker.is_xctest) && invoker.is_xctest)

    mixed_test(_test_target) {
      if (force_xctest) {
        target_type = "ios_xctest_test"
      } else {
        target_type = "ios_app_bundle"
      }
      testonly = true

      if (force_xctest && build_with_chromium) {
        xctest_module_target = "//base/test:google_test_runner"
      }

      forward_variables_from(invoker, "*", TESTONLY_AND_VISIBILITY)

      # Provide sensible defaults in case invoker did not define any of those
      # required variables.
      if (!defined(info_plist) && !defined(info_plist_target)) {
        info_plist = "//testing/gtest_ios/unittest-Info.plist"
      }

      if (ios_use_shared_bundle_id_for_test_apps) {
        bundle_identifier = shared_bundle_id_for_test_apps
        not_needed([ "_output_name" ])
      } else {
        bundle_identifier = "$ios_app_bundle_id_prefix.chrome." +
                            string_replace(_output_name, "_", "-")
      }

      if (!defined(bundle_deps)) {
        bundle_deps = []
      }
      bundle_deps += [ ":$_resources_bundle_data" ]

      if (!defined(data_deps)) {
        data_deps = []
      }

      data_deps += [ "//testing:test_scripts_shared" ]

      # Include the generate_wrapper as part of data_deps
      data_deps += [ ":${_wrapper_output_name}" ]
      write_runtime_deps = _runtime_deps_file

      if (use_rts) {
        data_deps += [ ":${invoker.target_name}__rts_filters" ]
      }
    }
  } else if ((is_chromeos_ash || (is_chromeos_lacros && is_chromeos_device)) &&
             cros_board != "") {
    assert(!defined(invoker.use_xvfb) || !invoker.use_xvfb)

    # Building for a cros board (ie: not linux-chromeos or linux-lacros).

    _gen_runner_target = "${target_name}__runner"
    _runtime_deps_file =
        "$root_out_dir/gen.runtime/" + get_label_info(target_name, "dir") +
        "/" + get_label_info(target_name, "name") + ".runtime_deps"

    _generated_script = "$root_build_dir/bin/run_" + invoker.target_name
    if (is_skylab) {
      generate_skylab_deps(_gen_runner_target) {
        generated_script = _generated_script
        test_exe = invoker.target_name
      }
    } else {
      generate_runner_script(_gen_runner_target) {
        generated_script = _generated_script
        test_exe = invoker.target_name
        runtime_deps_file = _runtime_deps_file

        if (is_chromeos_lacros) {
          # At build time, Lacros tests don't know whether they'll run on VM or
          # HW, and instead, these flags are specified at runtime when invoking
          # the generated runner script.
          skip_generating_board_args = true
        }

        if (tests_have_location_tags) {
          data = [ "//testing/location_tags.json" ]
        }

        if (use_rts) {
          data_deps = [ ":${invoker.target_name}__rts_filters" ]
        }
      }
    }

    mixed_test(target_name) {
      target_type = "executable"
      forward_variables_from(invoker, "*", TESTONLY_AND_VISIBILITY)
      forward_variables_from(invoker, [ "visibility" ])
      if (!defined(deps)) {
        deps = []
      }
      if (!defined(data)) {
        data = []
      }

      # We use a special trigger script for CrOS hardware tests.
      data += [ "//testing/trigger_scripts/chromeos_device_trigger.py" ]

      write_runtime_deps = _runtime_deps_file
      data += [ _runtime_deps_file ]
      deps += [ ":$_gen_runner_target" ]

      if (!defined(data_deps)) {
        data_deps = []
      }

      data_deps += [ "//testing:test_scripts_shared" ]

      if (use_rts) {
        data_deps += [ ":${invoker.target_name}__rts_filters" ]
      }
    }
  } else if (is_chromeos_lacros && !is_chromeos_device) {
    _runtime_deps_file = "$root_out_dir/${target_name}.runtime_deps"
    _executable = target_name
    _gen_runner_target = "${target_name}__runner"

    if (defined(invoker.use_xvfb)) {
      _use_xvfb = invoker.use_xvfb
    } else {
      _use_xvfb = false
    }

    # When use_xvfb is set by the invoker, it indicates that running this test
    # target requires a window, and in lacros build, ash-chrome serves as the
    # display server. Note that even though the tests themselves do not require
    # xvfb anymore, xvfb.py is still needed to invoke the lacros test runner
    # because ash-chrome is based on x11.
    _use_ash_chrome = _use_xvfb

    generate_wrapper(_gen_runner_target) {
      wrapper_script = "$root_build_dir/bin/run_" + _executable

      data = []
      data_deps = [ "//testing:test_scripts_shared" ]

      if (_use_xvfb) {
        executable = "//testing/xvfb.py"
        data += [ "//.vpython3" ]
      } else {
        executable = "//testing/test_env.py"
      }
      if (tests_have_location_tags) {
        data += [ "//testing/location_tags.json" ]
      }

      executable_args = [
        "@WrappedPath(../../build/lacros/test_runner.py)",
        "test",
        "@WrappedPath(./${_executable})",
        "--test-launcher-bot-mode",
      ]

      if (_use_ash_chrome) {
        executable_args += [ "--ash-chrome-path" ]

        # Can't use --ash-chrome-path=path because WrappedPath
        # won't be expanded for that usage.
        executable_args += [ "@WrappedPath(./ash_clang_x64/test_ash_chrome)" ]
      }

      if (is_asan) {
        executable_args += [ "--asan=1" ]
      }
      if (is_msan) {
        executable_args += [ "--msan=1" ]
      }
      if (is_tsan) {
        executable_args += [ "--tsan=1" ]
      }
      if (use_cfi_diag) {
        executable_args += [ "--cfi-diag=1" ]
      }

      data += [ "//build/lacros/test_runner.py" ]

      if (use_rts) {
        data_deps += [ ":${invoker.target_name}__rts_filters" ]
      }
    }

    mixed_test(target_name) {
      target_type = "executable"
      forward_variables_from(invoker, "*", TESTONLY_AND_VISIBILITY)
      forward_variables_from(invoker, [ "visibility" ])
      if (!defined(deps)) {
        deps = []
      }

      if (!defined(data_deps)) {
        data_deps = []
      }

      data_deps += [ "//testing:test_scripts_shared" ]

      write_runtime_deps = _runtime_deps_file
      deps += [ ":$_gen_runner_target" ]
      if (_use_ash_chrome && also_build_ash_chrome) {
        data_deps += [ "//chrome/test:test_ash_chrome(//build/toolchain/linux:ash_clang_x64)" ]
      }

      if (use_rts) {
        data_deps += [ ":${invoker.target_name}__rts_filters" ]
      }
    }
  } else if (!is_nacl) {
    if (is_mac || is_win) {
      assert(!defined(invoker.use_xvfb) || !invoker.use_xvfb)
    }

    _runtime_deps_file = "$root_out_dir/${target_name}.runtime_deps"
    _executable = target_name
    _gen_runner_target = "${target_name}__runner"

    if ((is_linux || is_chromeos) && defined(invoker.use_xvfb)) {
      _use_xvfb = invoker.use_xvfb
    } else {
      _use_xvfb = false
    }

    generate_wrapper(_gen_runner_target) {
      wrapper_script = "$root_build_dir/bin/run_" + _executable

      data = []
      data_deps = [ "//testing:test_scripts_shared" ]

      if (_use_xvfb) {
        executable = "//testing/xvfb.py"
      } else {
        executable = "//testing/test_env.py"
      }
      if (tests_have_location_tags) {
        data += [ "//testing/location_tags.json" ]
      }

      executable_args = [
        "@WrappedPath(./${_executable})",
        "--test-launcher-bot-mode",
      ]
      if (is_asan) {
        executable_args += [ "--asan=1" ]
      }
      if (is_msan) {
        executable_args += [ "--msan=1" ]
      }
      if (is_tsan) {
        executable_args += [ "--tsan=1" ]
      }
      if (use_cfi_diag) {
        executable_args += [ "--cfi-diag=1" ]
      }

      if (use_rts) {
        data_deps += [ ":${invoker.target_name}__rts_filters" ]
      }
    }

    mixed_test(target_name) {
      target_type = "executable"
      forward_variables_from(invoker,
                             "*",
                             TESTONLY_AND_VISIBILITY + [ "use_xvfb" ])
      forward_variables_from(invoker, [ "visibility" ])
      if (!defined(deps)) {
        deps = []
      }

      deps += [
        # Give tests the default manifest on Windows (a no-op elsewhere).
        "//build/win:default_exe_manifest",
      ]

      write_runtime_deps = _runtime_deps_file
      deps += [ ":$_gen_runner_target" ]

      if (!defined(data_deps)) {
        data_deps = []
      }

      data_deps += [ "//testing:test_scripts_shared" ]

      if (use_rts) {
        data_deps += [ ":${invoker.target_name}__rts_filters" ]
      }
    }
  } else {
    # This is a catch-all clause for NaCl toolchains and other random
    # configurations that might define tests; test() in these configs
    # will just define the underlying executables.
    assert(!defined(invoker.use_xvfb) || !invoker.use_xvfb,
           "use_xvfb should not be defined for a non-linux configuration")
    mixed_test(target_name) {
      target_type = "executable"
      forward_variables_from(invoker, "*", TESTONLY_AND_VISIBILITY)
      forward_variables_from(invoker, [ "visibility" ])
      if (!defined(deps)) {
        deps = []
      }

      if (!defined(data_deps)) {
        data_deps = []
      }

      data_deps += [ "//testing:test_scripts_shared" ]

      if (use_rts) {
        data_deps += [ ":${invoker.target_name}__rts_filters" ]
      }
    }
  }
}

# Defines a type of test that invokes a script to run, rather than
# invoking an executable.
#
# The script must implement the
# [test executable API](//docs/testing/test_executable_api.md).
#
# The template must be passed the `script` parameter, which specifies the path
# to the script to run. It may optionally be passed a `args` parameter, which
# can be used to include a list of args to be specified by default. The
# template will produce a `$root_build_dir/run_$target_name` wrapper and write
# the runtime_deps for the target to
# $root_build_dir/${target_name}.runtime_deps, as per the conventions listed in
# the [test wrapper API](//docs/testing/test_wrapper_api.md).
template("script_test") {
  if (use_rts) {
    action("${target_name}__rts_filters") {
      script = "//build/add_rts_filters.py"
      rts_file = "${root_build_dir}/gen/rts/${invoker.target_name}.filter"
      inverted_rts_file =
          "${root_build_dir}/gen/rts/${invoker.target_name}_inverted.filter"
      args = [
        rebase_path(rts_file, root_build_dir),
        rebase_path(inverted_rts_file, root_build_dir),
      ]
      outputs = [
        rts_file,
        inverted_rts_file,
      ]
    }
  }

  generate_wrapper(target_name) {
    testonly = true
    wrapper_script = "${root_build_dir}/bin/run_${target_name}"

    executable = "//testing/test_env.py"

    executable_args =
        [ "@WrappedPath(" + rebase_path(invoker.script, root_build_dir) + ")" ]
    if (defined(invoker.args)) {
      executable_args += invoker.args
    }

    data = [ invoker.script ]

    if (defined(invoker.data)) {
      data += invoker.data
    }
    if (tests_have_location_tags) {
      data += [ "//testing/location_tags.json" ]
    }

    data_deps = [ "//testing:test_scripts_shared" ]
    if (defined(invoker.data_deps)) {
      data_deps += invoker.data_deps
    }

    forward_variables_from(invoker,
                           "*",
                           TESTONLY_AND_VISIBILITY + [
                                 "args",
                                 "data",
                                 "data_deps",
                                 "script",
                               ])
    forward_variables_from(invoker, [ "visibility" ])

    write_runtime_deps = "${root_build_dir}/${target_name}.runtime_deps"

    if (use_rts) {
      data_deps += [ ":${invoker.target_name}__rts_filters" ]
    }
  }
}

# Defines a test target that uses exit code for pass/fail.
template("isolated_script_test") {
  script_test(target_name) {
    forward_variables_from(invoker,
                           "*",
                           TESTONLY_AND_VISIBILITY + [
                                 "args",
                                 "deps",
                                 "script",
                               ])
    forward_variables_from(invoker, [ "visibility" ])
    deps = [ "//testing:run_isolated_script_test" ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
    script = "//testing/scripts/run_isolated_script_test.py"
    data = [ invoker.script ]
    args = [
      rebase_path(invoker.script, root_build_dir),
      "--script-type=bare",
    ]
    if (defined(invoker.args)) {
      args += invoker.args
    }
  }
}

# Test defaults.
set_defaults("test") {
  if (is_android) {
    configs = default_shared_library_configs
    configs -= [ "//build/config/android:hide_all_but_jni_onload" ]
    configs += [ "//build/config/android:hide_all_but_jni" ]

    # Compress sections to stay under 4gb hard limit on 32-bit current_cpu.
    # https://crbug.com/1354616
    if (symbol_level == 2 && !use_debug_fission &&
        (current_cpu == "arm" || current_cpu == "x86")) {
      configs += [ "//build/config:compress_debug_sections" ]
    }
  } else {
    configs = default_executable_configs
  }
}
