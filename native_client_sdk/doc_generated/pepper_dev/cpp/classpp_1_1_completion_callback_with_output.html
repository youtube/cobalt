{{+bindTo:partials.standard_nacl_api}}
<h1>pp::CompletionCallbackWithOutput&lt; T &gt; Class Template Reference</h1>
<div id="doxygen-ref">
{{- dummy div to appease doxygen -}}
  <div>
<!-- Generated by Doxygen 1.7.6.1 -->



</div>
<!--header-->
<div class="contents">
<!-- doxytag: class="pp::CompletionCallbackWithOutput" --><!-- doxytag: inherits="pp::CompletionCallback" --><div class="dynheader">
Inheritance diagram for pp::CompletionCallbackWithOutput&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classpp_1_1_completion_callback_with_output__inherit__graph.png" border="0" usemap="#pp_1_1_completion_callback_with_output_3_01_t_01_4_inherit__map" alt="Inheritance graph" /></div>
<map name="pp_1_1_completion_callback_with_output_3_01_t_01_4_inherit__map" id="pp_1_1_completion_callback_with_output_3_01_t_01_4_inherit__map">
<area shape="rect" id="node2" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl..." alt="" coords="59,5,231,32"></area></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<p><a href="classpp_1_1_completion_callback_with_output-members.html">List of all members.</a></p>
<h2>
Public Types</h2><table class="memberdecls">

<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak" />
internal::CallbackOutputTraits<br class="typebreak" />
&lt; T &gt;::StorageType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_with_output.html#a333f3b00a9f6549b3b70291787f31459">OutputStorageType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak" />
internal::CallbackOutputTraits<br class="typebreak" />
&lt; T &gt;::<a class="el" href="classpp_1_1_completion_callback_with_output.html#aca381518bda2f9cb12c4ddc725da91ce">APIArgType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_with_output.html#aca381518bda2f9cb12c4ddc725da91ce">APIArgType</a></td></tr>
</table><h2>
Public Member Functions</h2><table class="memberdecls">
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_with_output.html#a29dd26e95218dce78e2475f29ea669cb">CompletionCallbackWithOutput</a> (<a class="el" href="classpp_1_1_completion_callback_with_output.html#a333f3b00a9f6549b3b70291787f31459">OutputStorageType</a> *<a class="el" href="classpp_1_1_completion_callback_with_output.html#a8fac51ce72828752c025ca888897f2ef">output</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_with_output.html#a36bc9e5fd9e8d503020fe338b8b9802e">CompletionCallbackWithOutput</a> (PP_CompletionCallback_Func func, void *user_data, <a class="el" href="classpp_1_1_completion_callback_with_output.html#a333f3b00a9f6549b3b70291787f31459">OutputStorageType</a> *<a class="el" href="classpp_1_1_completion_callback_with_output.html#a8fac51ce72828752c025ca888897f2ef">output</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_with_output.html#a311725af061d86e58cc89a588fa542f9">CompletionCallbackWithOutput</a> (PP_CompletionCallback_Func func, void *user_data, int32_t <a class="el" href="classpp_1_1_completion_callback.html#a60e466572fe7de362969dd41179c971f">flags</a>, <a class="el" href="classpp_1_1_completion_callback_with_output.html#a333f3b00a9f6549b3b70291787f31459">OutputStorageType</a> *<a class="el" href="classpp_1_1_completion_callback_with_output.html#a8fac51ce72828752c025ca888897f2ef">output</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpp_1_1_completion_callback_with_output.html#aca381518bda2f9cb12c4ddc725da91ce">APIArgType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback_with_output.html#a8fac51ce72828752c025ca888897f2ef">output</a> () const </td></tr>
</table>
<hr /><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class pp::CompletionCallbackWithOutput&lt; T &gt;</h3>
<p>A <a class="el" href="classpp_1_1_completion_callback_with_output.html" title="A CompletionCallbackWithOutput defines a completion callback that additionally stores a pointer to so...">CompletionCallbackWithOutput</a> defines a completion callback that additionally stores a pointer to some output data. </p>
<p>Some C++ wrappers take a <a class="el" href="classpp_1_1_completion_callback_with_output.html" title="A CompletionCallbackWithOutput defines a completion callback that additionally stores a pointer to so...">CompletionCallbackWithOutput</a> when the browser is returning a bit of data as part of the function call. The "output" parameter stored in the <a class="el" href="classpp_1_1_completion_callback_with_output.html" title="A CompletionCallbackWithOutput defines a completion callback that additionally stores a pointer to so...">CompletionCallbackWithOutput</a> will receive the data from the browser.</p>
<p>You can create this yourself, but it is most common to use with the <a class="el" href="classpp_1_1_completion_callback_factory.html" title="CompletionCallbackFactory&lt;T&gt; may be used to create CompletionCallback objects that are bound to membe...">CompletionCallbackFactory</a>'s NewCallbackWithOutput, which manages the storage for the output parameter for you and passes it as an argument to your callback function.</p>
<p>Note that this class doesn't actually do anything with the output data, it just stores a pointer to it. C++ wrapper objects that accept a <a class="el" href="classpp_1_1_completion_callback_with_output.html" title="A CompletionCallbackWithOutput defines a completion callback that additionally stores a pointer to so...">CompletionCallbackWithOutput</a> will retrieve this pointer and pass it to the browser as the output parameter. </p>
</div><hr /><h2>Member Typedef Documentation</h2>
<a class="anchor" id="aca381518bda2f9cb12c4ddc725da91ce"></a><!-- doxytag: member="pp::CompletionCallbackWithOutput::APIArgType" ref="aca381518bda2f9cb12c4ddc725da91ce" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="memname">
<tr>
<td class="memname">typedef internal::CallbackOutputTraits&lt;T&gt;::<a class="el" href="classpp_1_1_completion_callback_with_output.html#aca381518bda2f9cb12c4ddc725da91ce">APIArgType</a> <a class="el" href="classpp_1_1_completion_callback_with_output.html">pp::CompletionCallbackWithOutput</a>&lt; T &gt;::<a class="el" href="classpp_1_1_completion_callback_with_output.html#aca381518bda2f9cb12c4ddc725da91ce">APIArgType</a></td>
</tr>
</table>
</div>
<div class="memdoc">
</div>
</div>
<a class="anchor" id="a333f3b00a9f6549b3b70291787f31459"></a><!-- doxytag: member="pp::CompletionCallbackWithOutput::OutputStorageType" ref="a333f3b00a9f6549b3b70291787f31459" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="memname">
<tr>
<td class="memname">typedef internal::CallbackOutputTraits&lt;T&gt;::StorageType <a class="el" href="classpp_1_1_completion_callback_with_output.html">pp::CompletionCallbackWithOutput</a>&lt; T &gt;::<a class="el" href="classpp_1_1_completion_callback_with_output.html#a333f3b00a9f6549b3b70291787f31459">OutputStorageType</a></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>The type that will actually be stored in the completion callback. </p>
<p>In the common case, this will be equal to the template parameter (for example, CompletionCallbackWithOutput&lt;int&gt; would obviously take an int*. However, resources are passed as PP_Resource, vars as PP_Var, and arrays as our special ArrayOutputAdapter object. The CallbackOutputTraits defines specializations for all of these cases. </p>
</div>
</div>
<hr /><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a29dd26e95218dce78e2475f29ea669cb"></a><!-- doxytag: member="pp::CompletionCallbackWithOutput::CompletionCallbackWithOutput" ref="a29dd26e95218dce78e2475f29ea669cb" args="(OutputStorageType *output)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback_with_output.html">pp::CompletionCallbackWithOutput</a>&lt; T &gt;::<a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a> </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classpp_1_1_completion_callback_with_output.html#a333f3b00a9f6549b3b70291787f31459">OutputStorageType</a> *&#160;</td>
<td class="paramname"><em>output</em></td><td>)</td>
<td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>The default constructor will create a blocking <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> that references the given output data. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>A pointer to the data associated with the callback. The caller must ensure that this pointer outlives the completion callback.</td></tr>
</table>
</dd>
</dl>
<p><b>Note:</b> Blocking completion callbacks are only allowed from from background threads. </p>
</div>
</div>
<a class="anchor" id="a36bc9e5fd9e8d503020fe338b8b9802e"></a><!-- doxytag: member="pp::CompletionCallbackWithOutput::CompletionCallbackWithOutput" ref="a36bc9e5fd9e8d503020fe338b8b9802e" args="(PP_CompletionCallback_Func func, void *user_data, OutputStorageType *output)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback_with_output.html">pp::CompletionCallbackWithOutput</a>&lt; T &gt;::<a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a> </td>
<td>(</td>
<td class="paramtype">PP_CompletionCallback_Func&#160;</td>
<td class="paramname"><em>func</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void *&#160;</td>
<td class="paramname"><em>user_data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classpp_1_1_completion_callback_with_output.html#a333f3b00a9f6549b3b70291787f31459">OutputStorageType</a> *&#160;</td>
<td class="paramname"><em>output</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>A constructor for creating a <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> that references the given output data. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function to be called on completion. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>The user data to be passed to the callback function. This is optional and is typically used to help track state in case of multiple pending callbacks. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>A pointer to the data associated with the callback. The caller must ensure that this pointer outlives the completion callback. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a311725af061d86e58cc89a588fa542f9"></a><!-- doxytag: member="pp::CompletionCallbackWithOutput::CompletionCallbackWithOutput" ref="a311725af061d86e58cc89a588fa542f9" args="(PP_CompletionCallback_Func func, void *user_data, int32_t flags, OutputStorageType *output)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback_with_output.html">pp::CompletionCallbackWithOutput</a>&lt; T &gt;::<a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a> </td>
<td>(</td>
<td class="paramtype">PP_CompletionCallback_Func&#160;</td>
<td class="paramname"><em>func</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void *&#160;</td>
<td class="paramname"><em>user_data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>flags</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classpp_1_1_completion_callback_with_output.html#a333f3b00a9f6549b3b70291787f31459">OutputStorageType</a> *&#160;</td>
<td class="paramname"><em>output</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>A constructor for creating a <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> that references the given output data. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function to be called on completion.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>The user data to be passed to the callback function. This is optional and is typically used to help track state in case of multiple pending callbacks.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Bit field combination of <code>PP_CompletionCallback_Flag</code> flags used to control how non-NULL callbacks are scheduled by asynchronous methods.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>A pointer to the data associated with the callback. The caller must ensure that this pointer outlives the completion callback. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<hr /><h2>Member Function Documentation</h2>
<a class="anchor" id="a8fac51ce72828752c025ca888897f2ef"></a><!-- doxytag: member="pp::CompletionCallbackWithOutput::output" ref="a8fac51ce72828752c025ca888897f2ef" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback_with_output.html#aca381518bda2f9cb12c4ddc725da91ce">APIArgType</a> <a class="el" href="classpp_1_1_completion_callback_with_output.html">pp::CompletionCallbackWithOutput</a>&lt; T &gt;::<a class="el" href="classpp_1_1_completion_callback_with_output.html#a8fac51ce72828752c025ca888897f2ef">output</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const<code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
</div>
</div>
<hr />The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="completion__callback_8h.html">completion_callback.h</a></li>
</ul>
</div><!-- contents -->
</div>
{{/partials.standard_nacl_api}}
