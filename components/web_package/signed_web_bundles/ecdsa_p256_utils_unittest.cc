// Copyright 2024 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "components/web_package/signed_web_bundles/ecdsa_p256_utils.h"

#include <array>
#include <vector>

#include "base/containers/span.h"
#include "base/test/gmock_expected_support.h"
#include "components/web_package/signed_web_bundles/ecdsa_p256_public_key.h"
#include "testing/gmock/include/gmock/gmock.h"
#include "testing/gtest/include/gtest/gtest.h"

namespace web_package {

namespace {

constexpr std::string_view kMessage = "test message";
constexpr std::string_view kOtherMessage = "other test message";

// Valid ECDSA P-256 signature.
constexpr std::array<uint8_t, EcdsaP256PublicKey::kLength> kEcdsaP256PublicKey =
    {0x03, 0xdc, 0x6a, 0x8f, 0x95, 0x0f, 0x18, 0x5e, 0x69, 0xf8, 0xfa,
     0x88, 0x9a, 0xdf, 0x03, 0x3d, 0x0a, 0x8f, 0xa9, 0x67, 0xe2, 0x65,
     0x9b, 0x5b, 0x92, 0xb4, 0xaf, 0x4d, 0xda, 0x56, 0x5b, 0x81, 0xfe};

// Valid ECDSA P-256 signature, corresponding to a SHA-256 hash of `kMessage`
// signed by `kEdcsaP256PublicKey`.
constexpr std::array<uint8_t, 72> kEcdsa256Signature = {
    0x30, 0x46, 0x02, 0x21, 0x00, 0xfb, 0xec, 0xdc, 0xcc, 0xee, 0xf6, 0xc5,
    0x89, 0xa0, 0x8c, 0x93, 0xb3, 0xf4, 0xf0, 0xeb, 0x7c, 0x2b, 0x47, 0x15,
    0xbd, 0xdc, 0xb5, 0x1b, 0xe6, 0xa4, 0x21, 0xd8, 0x26, 0x1d, 0x9d, 0xce,
    0x31, 0x02, 0x21, 0x00, 0xa7, 0xd8, 0xf6, 0xc9, 0x40, 0x3e, 0x2e, 0x24,
    0x87, 0x63, 0x32, 0x5b, 0xcf, 0x34, 0xa9, 0x39, 0xd2, 0xf5, 0x99, 0x1f,
    0xe6, 0x53, 0xaf, 0xf0, 0xbd, 0x5f, 0xd6, 0x09, 0x24, 0x7c, 0x79, 0x36};

// `kEcdsa256Signature` with the first byte changed to 0x04 (invalid).
constexpr std::array<uint8_t, 72> kInvalidSignature = {
    0x04, 0x46, 0x02, 0x21, 0x00, 0xfb, 0xec, 0xdc, 0xcc, 0xee, 0xf6, 0xc5,
    0x89, 0xa0, 0x8c, 0x93, 0xb3, 0xf4, 0xf0, 0xeb, 0x7c, 0x2b, 0x47, 0x15,
    0xbd, 0xdc, 0xb5, 0x1b, 0xe6, 0xa4, 0x21, 0xd8, 0x26, 0x1d, 0x9d, 0xce,
    0x31, 0x02, 0x21, 0x00, 0xa7, 0xd8, 0xf6, 0xc9, 0x40, 0x3e, 0x2e, 0x24,
    0x87, 0x63, 0x32, 0x5b, 0xcf, 0x34, 0xa9, 0x39, 0xd2, 0xf5, 0x99, 0x1f,
    0xe6, 0x53, 0xaf, 0xf0, 0xbd, 0x5f, 0xd6, 0x09, 0x24, 0x7c, 0x79, 0x36};

}  // namespace

TEST(EcdsaP256UtilsTest, VerifyMessageSignedWithEcdsaP256SHA256) {
  ASSERT_OK_AND_ASSIGN(auto public_key,
                       EcdsaP256PublicKey::Create(kEcdsaP256PublicKey));

  // `signature` corresponds to `kMessage` signed by `public_key`, but not to
  // `kOtherMessage`.
  EXPECT_TRUE(internal::VerifyMessageSignedWithEcdsaP256SHA256(
      base::as_byte_span(kMessage), kEcdsa256Signature, public_key));
  EXPECT_FALSE(internal::VerifyMessageSignedWithEcdsaP256SHA256(
      base::as_byte_span(kOtherMessage), kEcdsa256Signature, public_key));
  EXPECT_FALSE(internal::VerifyMessageSignedWithEcdsaP256SHA256(
      base::as_byte_span(kMessage), kInvalidSignature, public_key));
  EXPECT_FALSE(internal::VerifyMessageSignedWithEcdsaP256SHA256(
      base::as_byte_span(kOtherMessage), kInvalidSignature, public_key));
}

}  // namespace web_package
