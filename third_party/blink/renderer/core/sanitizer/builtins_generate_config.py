# Copyright 2024 The Chromium Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
"""Generate static sanitizer configuration. For use with the default config."""

import json
import optparse
import sys

# Mapping of (namespace, localname) to C++ name for elements and attributes.
# These are expected to be set once, at the beginning of the program, and be
# immutable for the entire remeining execution.
ELEMENT_CPP_MAP = {}
ATTRIBUTE_CPP_MAP = {}


def error(context, *infos):
    print("Error: " + context.strip() + "\n")
    for info in infos:
        print("\t" + str(info))
    sys.exit(1)


def lstrip(string):
    """Call str.lstrip on each line of text."""
    return "\n".join(map(str.lstrip, string.split("\n")))


def element(name):
    namespace = ("http://www.w3.org/1999/xhtml"
                 if isinstance(name, str) else name["namespace"])
    name = (name if isinstance(name, str) else name["name"])
    return ELEMENT_CPP_MAP[(namespace, name)]


def attribute(name):
    if isinstance(name, str):
        lname = name
        namespace = None
    else:
        lname = name["name"]
        namespace = name["namespace"]
    return ATTRIBUTE_CPP_MAP[(namespace, lname.lower())]


def bool(value):
    return "true" if value else "false"


def generate_nameset(name, default_config, formatter_fn, output):
    if name in default_config:
        print("  /* %s */" % name, file=output)
        print("  std::make_unique<SanitizerNameSet>(", file=output)
        print("    std::initializer_list<SanitizerNameSet::ValueType>({",
              file=output)
        for item in default_config.get(name):
            print("      %s," % formatter_fn(item), file=output)
        print("    })", file=output)
        print("  ),", file=output)
    else:
        print("  /* %s */ nullptr," % name, file=output)


def generate_namemap(key, subkey, default_config, output):
    print("  /* %s[%s] */" % (key, subkey), file=output)
    print("  SanitizerNameMap(", file=output)
    print("    std::initializer_list<SanitizerNameMap::ValueType>({",
          file=output)
    for elem in default_config.get(key, []):
        if subkey in elem:
            print("      SanitizerNameMap::ValueType(", file=output)
            print("        %s," % element(elem), file=output)
            print(
                "        SanitizerNameMap::MappedType("
                "std::initializer_list<"
                "SanitizerNameMap::MappedType::ValueType>"
                "({",
                file=output)
            for attr in elem.get(subkey, {}):
                print("          %s," % attribute(attr), file=output)
            print("      }))),", file=output)
    print("    })", file=output)
    print("  ),", file=output)


def generate_config(default_config, output):
    generate_nameset("elements", default_config, element, output)
    generate_nameset("removeElements", default_config, element, output)
    generate_nameset("replaceWithChildrenElements", default_config, element,
                     output)
    generate_nameset("attributes", default_config, attribute, output)
    generate_nameset("removeAttributes", default_config, attribute, output)
    generate_namemap("elements", "attributes", default_config, output)
    generate_namemap("elements", "removeAttributes", default_config, output)
    print("  /* comments */ %s," % bool(default_config.get("comments")),
          file=output)
    print("  /* dataAttributes */ %s" %
          bool(default_config.get("dataAttributes")),
          file=output)


def generate_file(name, default_config, output):
    print(lstrip("""
        // Copyright 2024 The Chromium Authors
        // Use of this source code is governed by a BSD-style license that can be
        // found in the LICENSE file.

        // This file is automatically generated. Do not edit. Just generate.
        //
        // Manually re-generate:
        // $ ninja -C ... third_party/blink/renderer/core/sanitizer:generated

        #include "third_party/blink/renderer/core/sanitizer/sanitizer_builtins.h"
        #include "third_party/blink/renderer/core/sanitizer/sanitizer.h"

        #include "third_party/blink/renderer/core/html_names.h"
        #include "third_party/blink/renderer/core/mathml_names.h"
        #include "third_party/blink/renderer/core/svg_names.h"
        #include "third_party/blink/renderer/core/xlink_names.h"
        #include "third_party/blink/renderer/core/xml_names.h"
        #include "third_party/blink/renderer/core/xmlns_names.h"

        namespace blink {
        namespace sanitizer_generated_builtins {

        Sanitizer* %s() {
          Sanitizer* sanitizer = MakeGarbageCollected<Sanitizer>(""" % name),
          file=output)
    generate_config(default_config, output)
    print(lstrip("""
          );
          return sanitizer;
        }
        }  // namespace sanitizer_generated_builtins
        }  // namespace blink"""),
          file=output)


def set_elements_cpp_mapping(all_known):
    CPP_NAME_EXCEPTIONS = {
        "html": "HTML",
        "rtc": "RTC",
        "iframe": "IFrame",
        "annotation-xml": "AnnotationXml",
        "mpath": "MPath",
        "svg": "SVG",
        "tspan": "TSpan"
    }
    for elem in all_known["elements"]:
        cppname = elem["name"]
        # Normalize to match C++ style. Unfortunately, some C++ names are not
        # regularly formed so we use a small table of exceptions.
        cppname = CPP_NAME_EXCEPTIONS.get(cppname, cppname)
        if cppname.startswith("fe") and cppname != "fencedframe":
            cppname = "FE" + cppname[2:]
        cppname = cppname[0].upper() + cppname[1:]
        ELEMENT_CPP_MAP[(elem["namespace"], elem["name"])] = (
            "%s_names::k%sTag" % (elem["cppnamespace"].lower(), cppname))


def set_attributes_cpp_mapping(all_known):
    for attr in all_known["attributes"]:
        cppname = attr["name"]

        # Normalize name to match C++ style, by up-casing the first letter
        # and every letter following a dash. And remove the dashes.
        cppname = cppname[0].upper() + cppname[1:]
        while '-' in cppname:
            pos = cppname.index("-")
            cppname = cppname[0:pos] + cppname[pos + 1].upper() + cppname[pos +
                                                                          2:]
        ATTRIBUTE_CPP_MAP[(attr["namespace"], attr["name"].lower())] = (
            "%s_names::k%sAttr" % (attr["cppnamespace"].lower(), cppname))


def set_cpp_mapping(all_known):
    set_elements_cpp_mapping(all_known)
    set_attributes_cpp_mapping(all_known)


def main(argv):
    parser = optparse.OptionParser()
    parser.add_option("--out")
    parser.add_option("--name")
    parser.add_option("--default-configuration")
    parser.add_option("--all-known")
    options, args = parser.parse_args(argv)
    if not options.out:
        parser.error("No --out")
    if not options.name:
        parser.error("No --name")
    if not options.default_configuration:
        parser.error("No --default-configuration")
    if not options.all_known:
        parser.error("No --all-known")
    if args:
        parser.error("Unknown argument: " + args)

    try:
        all_known = json.load(open(options.all_known, "r"))
        set_cpp_mapping(all_known)
    except BaseException as err:
        error("Cannod load table of all known elements/attribuutes.",
              options.allknown, err)

    try:
        default_config = json.load(open(options.default_configuration, "r"))
    except BaseException as err:
        error("Cannot load default config as JSON.",
              options.default_configuration, err)
    try:
        with open(options.out, "w") as output:
            try:
                generate_file(options.name, default_config, output)
            except BaseException as err:
                error("Cannot generate output content", err)
    except BaseException as err:
        error("Cannot open output file for writing.", options.out, err)
    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
