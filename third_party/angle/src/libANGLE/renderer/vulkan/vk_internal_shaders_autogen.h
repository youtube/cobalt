// GENERATED FILE - DO NOT EDIT.
// Generated by gen_vk_internal_shaders.py using data from shaders/src/*
//
// Copyright 2018 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// vk_internal_shaders_autogen.h:
//   Pre-generated shader library for the ANGLE Vulkan back-end.

#ifndef LIBANGLE_RENDERER_VULKAN_VK_INTERNAL_SHADERS_AUTOGEN_H_
#define LIBANGLE_RENDERER_VULKAN_VK_INTERNAL_SHADERS_AUTOGEN_H_

#include "libANGLE/renderer/vulkan/vk_utils.h"

namespace rx
{
namespace vk
{
namespace InternalShader
{
namespace Blit3DSrc_frag
{
enum Blit
{
    kBlitFloat = 0x00000000,
    kBlitInt   = 0x00000001,
    kBlitUint  = 0x00000002,
};
constexpr size_t kArrayLen = 0x00000003;
}  // namespace Blit3DSrc_frag

namespace BlitResolve_frag
{
enum flags
{
    kSrcIsArray = 0x00000001,
    kIsResolve  = 0x00000002,
};
enum Blit
{
    kBlitColorFloat   = 0x00000000,
    kBlitColorInt     = 0x00000004,
    kBlitColorUint    = 0x00000008,
    kBlitDepth        = 0x0000000C,
    kBlitStencil      = 0x00000010,
    kBlitDepthStencil = 0x00000014,
};
constexpr size_t kArrayLen = 0x00000018;
}  // namespace BlitResolve_frag

namespace BlitResolveStencilNoExport_comp
{
enum flags
{
    kSrcIsArray = 0x00000001,
    kIsResolve  = 0x00000002,
};
constexpr size_t kArrayLen = 0x00000004;
}  // namespace BlitResolveStencilNoExport_comp

namespace ConvertIndex_comp
{
enum flags
{
    kIsPrimitiveRestartEnabled = 0x00000001,
    kIsIndirect                = 0x00000002,
};
constexpr size_t kArrayLen = 0x00000004;
}  // namespace ConvertIndex_comp

namespace ConvertIndexIndirectLineLoop_comp
{
enum IndicesBitsWidth
{
    kIs8Bits  = 0x00000000,
    kIs16Bits = 0x00000001,
    kIs32Bits = 0x00000002,
};
constexpr size_t kArrayLen = 0x00000003;
}  // namespace ConvertIndexIndirectLineLoop_comp

namespace ConvertIndirectLineLoop_comp
{
constexpr size_t kArrayLen = 0x00000001;
}  // namespace ConvertIndirectLineLoop_comp

namespace ConvertVertex_comp
{
enum Conversion
{
    kSintToSint   = 0x00000000,
    kUintToUint   = 0x00000001,
    kSintToFloat  = 0x00000002,
    kUintToFloat  = 0x00000003,
    kSnormToFloat = 0x00000004,
    kUnormToFloat = 0x00000005,
    kFixedToFloat = 0x00000006,
    kFloatToFloat = 0x00000007,
};
constexpr size_t kArrayLen = 0x00000008;
}  // namespace ConvertVertex_comp

namespace CopyImageToBuffer_comp
{
enum SrcFormat
{
    kSrcIsFloat = 0x00000000,
};
enum SrcType
{
    kSrcIs2D = 0x00000000,
    kSrcIs3D = 0x00000001,
};
constexpr size_t kArrayLen = 0x00000002;
}  // namespace CopyImageToBuffer_comp

namespace EtcToBc_comp
{
enum OutputFormat
{
    kEtcRgba8ToBC3 = 0x00000000,
    kEtcRg11ToBC5  = 0x00000001,
};
constexpr size_t kArrayLen = 0x00000002;
}  // namespace EtcToBc_comp

namespace ExportStencil_frag
{
constexpr size_t kArrayLen = 0x00000001;
}  // namespace ExportStencil_frag

namespace FullScreenTri_vert
{
constexpr size_t kArrayLen = 0x00000001;
}  // namespace FullScreenTri_vert

namespace GenerateFragmentShadingRate_comp
{
constexpr size_t kArrayLen = 0x00000001;
}  // namespace GenerateFragmentShadingRate_comp

namespace GenerateMipmap_comp
{
enum MaxSupportedDest
{
    kDestSize4 = 0x00000000,
    kDestSize6 = 0x00000001,
};
enum Format
{
    kIsRGBA8          = 0x00000000,
    kIsRGBA8_UseHalf  = 0x00000002,
    kIsRGBA16         = 0x00000004,
    kIsRGBA16_UseHalf = 0x00000006,
    kIsRGBA32F        = 0x00000008,
};
constexpr size_t kArrayLen = 0x0000000A;
}  // namespace GenerateMipmap_comp

namespace ImageClear_frag
{
enum flags
{
    kClearDepth = 0x00000001,
};
enum AttachmentIndex
{
    kAttachment0 = 0x00000000,
    kAttachment1 = 0x00000002,
    kAttachment2 = 0x00000004,
    kAttachment3 = 0x00000006,
    kAttachment4 = 0x00000008,
    kAttachment5 = 0x0000000A,
    kAttachment6 = 0x0000000C,
    kAttachment7 = 0x0000000E,
};
enum Format
{
    kIsFloat = 0x00000000,
    kIsSint  = 0x00000010,
    kIsUint  = 0x00000020,
};
constexpr size_t kArrayLen = 0x00000030;
}  // namespace ImageClear_frag

namespace ImageCopy_frag
{
enum DstFormat
{
    kDstIsFloat = 0x00000000,
    kDstIsSint  = 0x00000001,
    kDstIsUint  = 0x00000002,
};
enum SrcFormat
{
    kSrcIsFloat = 0x00000000,
    kSrcIsSint  = 0x00000004,
    kSrcIsUint  = 0x00000008,
};
enum SrcType
{
    kSrcIs2D      = 0x00000000,
    kSrcIs2DArray = 0x00000010,
    kSrcIs3D      = 0x00000020,
};
constexpr size_t kArrayLen = 0x0000002B;
}  // namespace ImageCopy_frag

namespace ImageCopyFloat_frag
{
enum SrcType
{
    kSrcIsYUV  = 0x00000000,
    kSrcIs2DMS = 0x00000001,
};
constexpr size_t kArrayLen = 0x00000002;
}  // namespace ImageCopyFloat_frag

namespace OverlayDraw_frag
{
constexpr size_t kArrayLen = 0x00000001;
}  // namespace OverlayDraw_frag

namespace OverlayDraw_vert
{
constexpr size_t kArrayLen = 0x00000001;
}  // namespace OverlayDraw_vert

}  // namespace InternalShader

class ShaderLibrary final : angle::NonCopyable
{
  public:
    ShaderLibrary();
    ~ShaderLibrary();

    void destroy(VkDevice device);

    angle::Result getBlit3DSrc_frag(ErrorContext *context,
                                    uint32_t shaderFlags,
                                    ShaderModulePtr *shaderOut);
    angle::Result getBlitResolve_frag(ErrorContext *context,
                                      uint32_t shaderFlags,
                                      ShaderModulePtr *shaderOut);
    angle::Result getBlitResolveStencilNoExport_comp(ErrorContext *context,
                                                     uint32_t shaderFlags,
                                                     ShaderModulePtr *shaderOut);
    angle::Result getConvertIndex_comp(ErrorContext *context,
                                       uint32_t shaderFlags,
                                       ShaderModulePtr *shaderOut);
    angle::Result getConvertIndexIndirectLineLoop_comp(ErrorContext *context,
                                                       uint32_t shaderFlags,
                                                       ShaderModulePtr *shaderOut);
    angle::Result getConvertIndirectLineLoop_comp(ErrorContext *context,
                                                  uint32_t shaderFlags,
                                                  ShaderModulePtr *shaderOut);
    angle::Result getConvertVertex_comp(ErrorContext *context,
                                        uint32_t shaderFlags,
                                        ShaderModulePtr *shaderOut);
    angle::Result getCopyImageToBuffer_comp(ErrorContext *context,
                                            uint32_t shaderFlags,
                                            ShaderModulePtr *shaderOut);
    angle::Result getEtcToBc_comp(ErrorContext *context,
                                  uint32_t shaderFlags,
                                  ShaderModulePtr *shaderOut);
    angle::Result getExportStencil_frag(ErrorContext *context,
                                        uint32_t shaderFlags,
                                        ShaderModulePtr *shaderOut);
    angle::Result getFullScreenTri_vert(ErrorContext *context,
                                        uint32_t shaderFlags,
                                        ShaderModulePtr *shaderOut);
    angle::Result getGenerateFragmentShadingRate_comp(ErrorContext *context,
                                                      uint32_t shaderFlags,
                                                      ShaderModulePtr *shaderOut);
    angle::Result getGenerateMipmap_comp(ErrorContext *context,
                                         uint32_t shaderFlags,
                                         ShaderModulePtr *shaderOut);
    angle::Result getImageClear_frag(ErrorContext *context,
                                     uint32_t shaderFlags,
                                     ShaderModulePtr *shaderOut);
    angle::Result getImageCopy_frag(ErrorContext *context,
                                    uint32_t shaderFlags,
                                    ShaderModulePtr *shaderOut);
    angle::Result getImageCopyFloat_frag(ErrorContext *context,
                                         uint32_t shaderFlags,
                                         ShaderModulePtr *shaderOut);
    angle::Result getOverlayDraw_frag(ErrorContext *context,
                                      uint32_t shaderFlags,
                                      ShaderModulePtr *shaderOut);
    angle::Result getOverlayDraw_vert(ErrorContext *context,
                                      uint32_t shaderFlags,
                                      ShaderModulePtr *shaderOut);

  private:
    ShaderModulePtr mBlit3DSrc_frag_shaders[InternalShader::Blit3DSrc_frag::kArrayLen];
    ShaderModulePtr mBlitResolve_frag_shaders[InternalShader::BlitResolve_frag::kArrayLen];
    ShaderModulePtr mBlitResolveStencilNoExport_comp_shaders
        [InternalShader::BlitResolveStencilNoExport_comp::kArrayLen];
    ShaderModulePtr mConvertIndex_comp_shaders[InternalShader::ConvertIndex_comp::kArrayLen];
    ShaderModulePtr mConvertIndexIndirectLineLoop_comp_shaders
        [InternalShader::ConvertIndexIndirectLineLoop_comp::kArrayLen];
    ShaderModulePtr mConvertIndirectLineLoop_comp_shaders
        [InternalShader::ConvertIndirectLineLoop_comp::kArrayLen];
    ShaderModulePtr mConvertVertex_comp_shaders[InternalShader::ConvertVertex_comp::kArrayLen];
    ShaderModulePtr
        mCopyImageToBuffer_comp_shaders[InternalShader::CopyImageToBuffer_comp::kArrayLen];
    ShaderModulePtr mEtcToBc_comp_shaders[InternalShader::EtcToBc_comp::kArrayLen];
    ShaderModulePtr mExportStencil_frag_shaders[InternalShader::ExportStencil_frag::kArrayLen];
    ShaderModulePtr mFullScreenTri_vert_shaders[InternalShader::FullScreenTri_vert::kArrayLen];
    ShaderModulePtr mGenerateFragmentShadingRate_comp_shaders
        [InternalShader::GenerateFragmentShadingRate_comp::kArrayLen];
    ShaderModulePtr mGenerateMipmap_comp_shaders[InternalShader::GenerateMipmap_comp::kArrayLen];
    ShaderModulePtr mImageClear_frag_shaders[InternalShader::ImageClear_frag::kArrayLen];
    ShaderModulePtr mImageCopy_frag_shaders[InternalShader::ImageCopy_frag::kArrayLen];
    ShaderModulePtr mImageCopyFloat_frag_shaders[InternalShader::ImageCopyFloat_frag::kArrayLen];
    ShaderModulePtr mOverlayDraw_frag_shaders[InternalShader::OverlayDraw_frag::kArrayLen];
    ShaderModulePtr mOverlayDraw_vert_shaders[InternalShader::OverlayDraw_vert::kArrayLen];
};
}  // namespace vk
}  // namespace rx

#endif  // LIBANGLE_RENDERER_VULKAN_VK_INTERNAL_SHADERS_AUTOGEN_H_
