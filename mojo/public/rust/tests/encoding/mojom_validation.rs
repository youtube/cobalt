// Copyright 2023 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

//! This file was auto-generated by the Rust bindings generator.
#![allow(bad_style)]
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]

use mojo::bindings::decoding::{self, Decoder, ValidationError};
use mojo::bindings::encoding::{
    self, Context, DataHeaderValue, Encoder, EncodingState, DATA_HEADER_SIZE,
};
use mojo::bindings::message::{self, MessageHeader};
use mojo::bindings::mojom::{
    self, MojomEncodable, MojomInterface, MojomInterfaceRecv, MojomInterfaceSend, MojomMessage,
    MojomMessageOption, MojomPointer, MojomStruct, MojomUnion, UNION_SIZE,
};

use mojo::bindings::{
    impl_encodable_for_interface, impl_encodable_for_pointer, impl_encodable_for_union,
};

use mojo::system::{self, message_pipe, CastHandle, UntypedHandle};

use std::collections::HashMap;
use std::vec::Vec;

// Top-level constants:

// Structs:
// -- StructA --

// Constants
// Enums
// Struct version information
const StructAVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct StructA {
    pub i: u64,
}

impl MojomPointer for StructA {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.i, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&StructAVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let i = match <u64>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(StructA { i: i })
    }
}

impl MojomEncodable for StructA {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.i.compute_size(context.clone())
    }
}

impl MojomStruct for StructA {}
// -- StructB --

// Constants
// Enums
// Struct version information
const StructBVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct StructB {
    pub struct_a: StructA,
}

impl MojomPointer for StructB {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.struct_a, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&StructBVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let struct_a = match <StructA>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(StructB { struct_a: struct_a })
    }
}

impl MojomEncodable for StructB {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.struct_a.compute_size(context.clone())
    }
}

impl MojomStruct for StructB {}
// -- StructC --

// Constants
// Enums
// Struct version information
const StructCVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct StructC {
    pub data: Vec<u8>,
}

impl MojomPointer for StructC {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.data, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&StructCVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let data = match <Vec<u8>>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(StructC { data: data })
    }
}

impl MojomEncodable for StructC {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.data.compute_size(context.clone())
    }
}

impl MojomStruct for StructC {}
// -- StructD --

// Constants
// Enums
// Struct version information
const StructDVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct StructD {
    pub message_pipes: Vec<message_pipe::MessageEndpoint>,
}

impl MojomPointer for StructD {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.message_pipes, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&StructDVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let message_pipes =
            match <Vec<message_pipe::MessageEndpoint>>::decode(decoder, context.clone()) {
                Ok(value) => value,
                Err(err) => return Err(err),
            };
        Ok(StructD { message_pipes: message_pipes })
    }
}

impl MojomEncodable for StructD {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.message_pipes.compute_size(context.clone())
    }
}

impl MojomStruct for StructD {}
// -- StructE --

// Constants
// Enums
// Struct version information
const StructEVersions: [(u32, u32); 1] = [(0, 24)];

// Struct definition
pub struct StructE {
    pub struct_d: StructD,
    pub data_pipe_consumer: system::data_pipe::Consumer<u8>,
}

impl MojomPointer for StructE {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        24
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.struct_d, encoder, state, context.clone());
        MojomEncodable::encode(self.data_pipe_consumer, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&StructEVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let struct_d = match <StructD>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        let data_pipe_consumer =
            match <system::data_pipe::Consumer<u8>>::decode(decoder, context.clone()) {
                Ok(value) => value,
                Err(err) => return Err(err),
            };
        Ok(StructE { struct_d: struct_d, data_pipe_consumer: data_pipe_consumer })
    }
}

impl MojomEncodable for StructE {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.struct_d.compute_size(context.clone())
            + self.data_pipe_consumer.compute_size(context.clone())
    }
}

impl MojomStruct for StructE {}
// -- StructF --

// Constants
// Enums
// Struct version information
const StructFVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct StructF {
    pub fixed_size_array: [u8; 3],
}

impl MojomPointer for StructF {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.fixed_size_array, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&StructFVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let fixed_size_array = match <[u8; 3]>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(StructF { fixed_size_array: fixed_size_array })
    }
}

impl MojomEncodable for StructF {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.fixed_size_array.compute_size(context.clone())
    }
}

impl MojomStruct for StructF {}
// -- StructG --

// Constants
// Enums
// Struct version information
const StructGVersions: [(u32, u32); 3] = [(0, 16), (1, 24), (3, 32)];

// Struct definition
pub struct StructG {
    pub i: i32,
    pub b: bool,
    pub struct_a: Option<StructA>,
    pub str: Option<String>,
}

impl MojomPointer for StructG {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(3)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        32
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.i, encoder, state, context.clone());
        MojomEncodable::encode(self.b, encoder, state, context.clone());
        MojomEncodable::encode(self.struct_a, encoder, state, context.clone());
        MojomEncodable::encode(self.str, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&StructGVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let i = match <i32>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        let b = if version >= 3 {
            match <bool>::decode(decoder, context.clone()) {
                Ok(value) => value,
                Err(err) => return Err(err),
            }
        } else {
            Default::default()
        };
        let struct_a = if version >= 1 {
            match <Option<StructA>>::decode(decoder, context.clone()) {
                Ok(value) => value,
                Err(err) => return Err(err),
            }
        } else {
            Default::default()
        };
        let str = if version >= 3 {
            match <Option<String>>::decode(decoder, context.clone()) {
                Ok(value) => value,
                Err(err) => return Err(err),
            }
        } else {
            Default::default()
        };
        Ok(StructG { i: i, b: b, struct_a: struct_a, str: str })
    }
}

impl MojomEncodable for StructG {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.i.compute_size(context.clone())
            + self.b.compute_size(context.clone())
            + self.struct_a.compute_size(context.clone())
            + self.str.compute_size(context.clone())
    }
}

impl MojomStruct for StructG {}
// -- StructH --

// Constants
// Enums
// Struct version information
const StructHVersions: [(u32, u32); 1] = [(0, 48)];

// Struct definition
pub struct StructH {
    pub a: bool,
    pub b: u8,
    pub c: Option<UnionA>,
    pub d: Option<Vec<UnionA>>,
    pub e: Option<HashMap<u8, UnionA>>,
}

impl MojomPointer for StructH {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        48
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.a, encoder, state, context.clone());
        MojomEncodable::encode(self.b, encoder, state, context.clone());
        MojomEncodable::encode(self.c, encoder, state, context.clone());
        MojomEncodable::encode(self.d, encoder, state, context.clone());
        MojomEncodable::encode(self.e, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&StructHVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let a = match <bool>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        let b = match <u8>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        let c = match <Option<UnionA>>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        let d = match <Option<Vec<UnionA>>>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        let e = match <Option<HashMap<u8, UnionA>>>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(StructH { a: a, b: b, c: c, d: d, e: e })
    }
}

impl MojomEncodable for StructH {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.a.compute_size(context.clone())
            + self.b.compute_size(context.clone())
            + self.c.compute_size(context.clone())
            + self.d.compute_size(context.clone())
            + self.e.compute_size(context.clone())
    }
}

impl MojomStruct for StructH {}
// -- BasicStruct --

// Constants
// Enums
// Struct version information
const BasicStructVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct BasicStruct {
    pub a: i32,
}

impl MojomPointer for BasicStruct {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.a, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&BasicStructVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let a = match <i32>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(BasicStruct { a: a })
    }
}

impl MojomEncodable for BasicStruct {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.a.compute_size(context.clone())
    }
}

impl MojomStruct for BasicStruct {}
// -- StructWithEnum --

// Constants
// Enums
type StructWithEnumEnumWithin = i32;
const StructWithEnumEnumWithin_A: StructWithEnumEnumWithin = 0;
const StructWithEnumEnumWithin_B: StructWithEnumEnumWithin = 1;
const StructWithEnumEnumWithin_C: StructWithEnumEnumWithin = 2;
const StructWithEnumEnumWithin_D: StructWithEnumEnumWithin = 3;

const StructWithEnumEnumWithin__UNKNOWN: StructWithEnumEnumWithin = 0x7FFFFFFF;

// Struct version information
const StructWithEnumVersions: [(u32, u32); 1] = [(0, 8)];

// Struct definition
pub struct StructWithEnum {}

impl MojomPointer for StructWithEnum {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        8
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {}
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&StructWithEnumVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        Ok(StructWithEnum {})
    }
}

impl MojomEncodable for StructWithEnum {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
    }
}

impl MojomStruct for StructWithEnum {}

// Mojom Unions:
// -- UnionA --

type UnionATag = u32;
const UnionATag_a: UnionATag = 0;
const UnionATag_b: UnionATag = 1;
const UnionATag_c: UnionATag = 2;
const UnionATag_d: UnionATag = 3;
const UnionATag_e: UnionATag = 4;
const UnionATag_f: UnionATag = 5;
const UnionATag_g: UnionATag = 6;
const UnionATag_h: UnionATag = 7;
const UnionATag_i: UnionATag = 8;
const UnionATag_j: UnionATag = 9;

const UnionATag__UNKNOWN: UnionATag = 0xFFFFFFFF;

pub enum UnionA {
    a(u16),
    b(u32),
    c(Option<StructA>),
    d(Option<Vec<u8>>),
    e(Option<HashMap<String, u8>>),
    f(Option<UnionB>),
    g(StructA),
    h(Vec<u8>),
    i(HashMap<String, u8>),
    j(UnionB),
    _Unknown(u64),
}

impl MojomUnion for UnionA {
    fn get_tag(&self) -> u32 {
        match *self {
            UnionA::a(_) => UnionATag_a,
            UnionA::b(_) => UnionATag_b,
            UnionA::c(_) => UnionATag_c,
            UnionA::d(_) => UnionATag_d,
            UnionA::e(_) => UnionATag_e,
            UnionA::f(_) => UnionATag_f,
            UnionA::g(_) => UnionATag_g,
            UnionA::h(_) => UnionATag_h,
            UnionA::i(_) => UnionATag_i,
            UnionA::j(_) => UnionATag_j,
            UnionA::_Unknown(_) => UnionATag__UNKNOWN,
        }
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        match self {
            UnionA::a(val) => MojomEncodable::encode(val, encoder, state, context.clone()),
            UnionA::b(val) => MojomEncodable::encode(val, encoder, state, context.clone()),
            UnionA::c(val) => MojomEncodable::encode(val, encoder, state, context.clone()),
            UnionA::d(val) => MojomEncodable::encode(val, encoder, state, context.clone()),
            UnionA::e(val) => MojomEncodable::encode(val, encoder, state, context.clone()),
            UnionA::f(val) => MojomEncodable::encode(val, encoder, state, context.clone()),
            UnionA::g(val) => MojomEncodable::encode(val, encoder, state, context.clone()),
            UnionA::h(val) => MojomEncodable::encode(val, encoder, state, context.clone()),
            UnionA::i(val) => MojomEncodable::encode(val, encoder, state, context.clone()),
            UnionA::j(val) => MojomEncodable::encode(val, encoder, state, context.clone()),
            UnionA::_Unknown(val) => MojomEncodable::encode(val, encoder, state, context.clone()),
        }
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let tag = {
            let state = decoder.get_mut(&context);
            let bytes = state.decode::<u32>();
            if (bytes as usize) != UNION_SIZE {
                return Err(ValidationError::UnexpectedNullUnion);
            }
            state.decode::<u32>()
        };
        Ok(match tag {
            UnionATag_a => UnionA::a({
                match <u16>::decode(decoder, context.clone()) {
                    Ok(value) => value,
                    Err(err) => return Err(err),
                }
            }),
            UnionATag_b => UnionA::b({
                match <u32>::decode(decoder, context.clone()) {
                    Ok(value) => value,
                    Err(err) => return Err(err),
                }
            }),
            UnionATag_c => UnionA::c({
                match <Option<StructA>>::decode(decoder, context.clone()) {
                    Ok(value) => value,
                    Err(err) => return Err(err),
                }
            }),
            UnionATag_d => UnionA::d({
                match <Option<Vec<u8>>>::decode(decoder, context.clone()) {
                    Ok(value) => value,
                    Err(err) => return Err(err),
                }
            }),
            UnionATag_e => UnionA::e({
                match <Option<HashMap<String, u8>>>::decode(decoder, context.clone()) {
                    Ok(value) => value,
                    Err(err) => return Err(err),
                }
            }),
            UnionATag_f => UnionA::f({
                match <Option<UnionB>>::decode(decoder, context.clone()) {
                    Ok(value) => value,
                    Err(err) => return Err(err),
                }
            }),
            UnionATag_g => UnionA::g({
                match <StructA>::decode(decoder, context.clone()) {
                    Ok(value) => value,
                    Err(err) => return Err(err),
                }
            }),
            UnionATag_h => UnionA::h({
                match <Vec<u8>>::decode(decoder, context.clone()) {
                    Ok(value) => value,
                    Err(err) => return Err(err),
                }
            }),
            UnionATag_i => UnionA::i({
                match <HashMap<String, u8>>::decode(decoder, context.clone()) {
                    Ok(value) => value,
                    Err(err) => return Err(err),
                }
            }),
            UnionATag_j => UnionA::j({
                match <UnionB>::decode(decoder, context.clone()) {
                    Ok(value) => value,
                    Err(err) => return Err(err),
                }
            }),
            _ => UnionA::_Unknown(u64::decode(decoder, context.clone()).unwrap()),
        })
    }
}

impl MojomEncodable for UnionA {
    impl_encodable_for_union!();
    fn compute_size(&self, context: Context) -> usize {
        UNION_SIZE
            + match *self {
                UnionA::a(ref val) => val.compute_size(context.clone()),
                UnionA::b(ref val) => val.compute_size(context.clone()),
                UnionA::c(ref val) => val.compute_size(context.clone()),
                UnionA::d(ref val) => val.compute_size(context.clone()),
                UnionA::e(ref val) => val.compute_size(context.clone()),
                UnionA::f(ref val) => val.compute_size(context.clone()),
                UnionA::g(ref val) => val.compute_size(context.clone()),
                UnionA::h(ref val) => val.compute_size(context.clone()),
                UnionA::i(ref val) => val.compute_size(context.clone()),
                UnionA::j(ref val) => val.compute_size(context.clone()),
                UnionA::_Unknown(ref val) => 0,
            }
    }
}

// -- UnionB --

type UnionBTag = u32;
const UnionBTag_a: UnionBTag = 0;
const UnionBTag_b: UnionBTag = 1;
const UnionBTag_c: UnionBTag = 2;
const UnionBTag_d: UnionBTag = 3;

const UnionBTag__UNKNOWN: UnionBTag = 0xFFFFFFFF;

pub enum UnionB {
    a(u16),
    b(u32),
    c(u64),
    d(u32),
    _Unknown(u64),
}

impl MojomUnion for UnionB {
    fn get_tag(&self) -> u32 {
        match *self {
            UnionB::a(_) => UnionBTag_a,
            UnionB::b(_) => UnionBTag_b,
            UnionB::c(_) => UnionBTag_c,
            UnionB::d(_) => UnionBTag_d,
            UnionB::_Unknown(_) => UnionBTag__UNKNOWN,
        }
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        match self {
            UnionB::a(val) => MojomEncodable::encode(val, encoder, state, context.clone()),
            UnionB::b(val) => MojomEncodable::encode(val, encoder, state, context.clone()),
            UnionB::c(val) => MojomEncodable::encode(val, encoder, state, context.clone()),
            UnionB::d(val) => MojomEncodable::encode(val, encoder, state, context.clone()),
            UnionB::_Unknown(val) => MojomEncodable::encode(val, encoder, state, context.clone()),
        }
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let tag = {
            let state = decoder.get_mut(&context);
            let bytes = state.decode::<u32>();
            if (bytes as usize) != UNION_SIZE {
                return Err(ValidationError::UnexpectedNullUnion);
            }
            state.decode::<u32>()
        };
        Ok(match tag {
            UnionBTag_a => UnionB::a({
                match <u16>::decode(decoder, context.clone()) {
                    Ok(value) => value,
                    Err(err) => return Err(err),
                }
            }),
            UnionBTag_b => UnionB::b({
                match <u32>::decode(decoder, context.clone()) {
                    Ok(value) => value,
                    Err(err) => return Err(err),
                }
            }),
            UnionBTag_c => UnionB::c({
                match <u64>::decode(decoder, context.clone()) {
                    Ok(value) => value,
                    Err(err) => return Err(err),
                }
            }),
            UnionBTag_d => UnionB::d({
                match <u32>::decode(decoder, context.clone()) {
                    Ok(value) => value,
                    Err(err) => return Err(err),
                }
            }),
            _ => UnionB::_Unknown(u64::decode(decoder, context.clone()).unwrap()),
        })
    }
}

impl MojomEncodable for UnionB {
    impl_encodable_for_union!();
    fn compute_size(&self, context: Context) -> usize {
        UNION_SIZE
            + match *self {
                UnionB::a(ref val) => val.compute_size(context.clone()),
                UnionB::b(ref val) => val.compute_size(context.clone()),
                UnionB::c(ref val) => val.compute_size(context.clone()),
                UnionB::d(ref val) => val.compute_size(context.clone()),
                UnionB::_Unknown(ref val) => 0,
            }
    }
}

// Mojom Enums:
type BasicEnum = i32;
const BasicEnum_A: BasicEnum = 0;
const BasicEnum_B: BasicEnum = 1;
const BasicEnum_C: BasicEnum = 0;
const BasicEnum_D: BasicEnum = -3;
const BasicEnum_E: BasicEnum = 10;

const BasicEnum__UNKNOWN: BasicEnum = 0x7FFFFFFF;

// Interfaces:
// --- InterfaceA ---

pub mod InterfaceA {
    pub const SERVICE_NAME: &'static str = "";
    pub const VERSION: u32 = 0;
}

pub struct InterfaceAClient {
    pipe: message_pipe::MessageEndpoint,
    version: u32,
}

impl InterfaceAClient {
    pub fn new(pipe: message_pipe::MessageEndpoint) -> InterfaceAClient {
        InterfaceAClient { pipe: pipe, version: InterfaceA::VERSION }
    }
    pub fn with_version(pipe: message_pipe::MessageEndpoint, version: u32) -> InterfaceAClient {
        InterfaceAClient { pipe: pipe, version: version }
    }
}

impl MojomInterface for InterfaceAClient {
    fn service_name() -> &'static str {
        InterfaceA::SERVICE_NAME
    }
    fn version(&self) -> u32 {
        self.version
    }
    fn pipe(&self) -> &message_pipe::MessageEndpoint {
        &self.pipe
    }
    fn unwrap(self) -> message_pipe::MessageEndpoint {
        self.pipe
    }
}

impl CastHandle for InterfaceAClient {
    unsafe fn from_untyped(handle: system::UntypedHandle) -> InterfaceAClient {
        let pipe = unsafe { message_pipe::MessageEndpoint::from_untyped(handle) };
        InterfaceAClient {
            pipe,
            version: 0, // Since we have no other information, assume its the base
        }
    }
    fn as_untyped(self) -> system::UntypedHandle {
        self.pipe.as_untyped()
    }
}

impl MojomEncodable for InterfaceAClient {
    impl_encodable_for_interface!();
}

impl<R: InterfaceARequest> MojomInterfaceSend<R> for InterfaceAClient {}
impl MojomInterfaceRecv for InterfaceAClient {
    type Container = InterfaceAResponseOption;
}

pub struct InterfaceAServer {
    pipe: message_pipe::MessageEndpoint,
    version: u32,
}

impl InterfaceAServer {
    pub fn new(pipe: message_pipe::MessageEndpoint) -> InterfaceAServer {
        InterfaceAServer { pipe: pipe, version: InterfaceA::VERSION }
    }
    pub fn with_version(pipe: message_pipe::MessageEndpoint, version: u32) -> InterfaceAServer {
        InterfaceAServer { pipe: pipe, version: version }
    }
}

impl MojomInterface for InterfaceAServer {
    fn service_name() -> &'static str {
        InterfaceA::SERVICE_NAME
    }
    fn version(&self) -> u32 {
        self.version
    }
    fn pipe(&self) -> &message_pipe::MessageEndpoint {
        &self.pipe
    }
    fn unwrap(self) -> message_pipe::MessageEndpoint {
        self.pipe
    }
}

impl CastHandle for InterfaceAServer {
    unsafe fn from_untyped(handle: system::UntypedHandle) -> InterfaceAServer {
        let pipe = unsafe { message_pipe::MessageEndpoint::from_untyped(handle) };
        InterfaceAServer {
            pipe,
            version: 0, // Since we have no other information, assume its the base
        }
    }
    fn as_untyped(self) -> system::UntypedHandle {
        self.pipe.as_untyped()
    }
}

impl MojomEncodable for InterfaceAServer {
    impl_encodable_for_interface!();
}

impl<R: InterfaceAResponse> MojomInterfaceSend<R> for InterfaceAServer {}
impl MojomInterfaceRecv for InterfaceAServer {
    type Container = InterfaceARequestOption;
}

// Enums

// Constants

pub trait InterfaceARequest: MojomMessage {}
pub trait InterfaceAResponse: MojomMessage {}

pub enum InterfaceARequestOption {}

impl MojomMessageOption for InterfaceARequestOption {
    fn decode_payload(
        header: MessageHeader,
        buffer: &[u8],
        handles: Vec<UntypedHandle>,
    ) -> Result<Self, ValidationError> {
        match header.name {
            _ => Err(ValidationError::MessageHeaderUnknownMethod),
        }
    }
}

pub enum InterfaceAResponseOption {}

impl MojomMessageOption for InterfaceAResponseOption {
    fn decode_payload(
        header: MessageHeader,
        buffer: &[u8],
        handles: Vec<UntypedHandle>,
    ) -> Result<Self, ValidationError> {
        if header.flags != message::MESSAGE_HEADER_IS_RESPONSE {
            return Err(ValidationError::MessageHeaderInvalidFlags);
        }
        match header.name {
            _ => Err(ValidationError::MessageHeaderUnknownMethod),
        }
    }
}

// --- BoundsCheckTestInterface ---

pub mod BoundsCheckTestInterface {
    pub const SERVICE_NAME: &'static str = "this.is.the.service.name.for.BoundsCheckTestInterface";
    pub const VERSION: u32 = 0;
}

pub struct BoundsCheckTestInterfaceClient {
    pipe: message_pipe::MessageEndpoint,
    version: u32,
}

impl BoundsCheckTestInterfaceClient {
    pub fn new(pipe: message_pipe::MessageEndpoint) -> BoundsCheckTestInterfaceClient {
        BoundsCheckTestInterfaceClient { pipe: pipe, version: BoundsCheckTestInterface::VERSION }
    }
    pub fn with_version(
        pipe: message_pipe::MessageEndpoint,
        version: u32,
    ) -> BoundsCheckTestInterfaceClient {
        BoundsCheckTestInterfaceClient { pipe: pipe, version: version }
    }
}

impl MojomInterface for BoundsCheckTestInterfaceClient {
    fn service_name() -> &'static str {
        BoundsCheckTestInterface::SERVICE_NAME
    }
    fn version(&self) -> u32 {
        self.version
    }
    fn pipe(&self) -> &message_pipe::MessageEndpoint {
        &self.pipe
    }
    fn unwrap(self) -> message_pipe::MessageEndpoint {
        self.pipe
    }
}

impl CastHandle for BoundsCheckTestInterfaceClient {
    unsafe fn from_untyped(handle: system::UntypedHandle) -> BoundsCheckTestInterfaceClient {
        let pipe = unsafe { message_pipe::MessageEndpoint::from_untyped(handle) };
        BoundsCheckTestInterfaceClient {
            pipe,
            version: 0, // Since we have no other information, assume its the base
        }
    }
    fn as_untyped(self) -> system::UntypedHandle {
        self.pipe.as_untyped()
    }
}

impl MojomEncodable for BoundsCheckTestInterfaceClient {
    impl_encodable_for_interface!();
}

impl<R: BoundsCheckTestInterfaceRequest> MojomInterfaceSend<R> for BoundsCheckTestInterfaceClient {}
impl MojomInterfaceRecv for BoundsCheckTestInterfaceClient {
    type Container = BoundsCheckTestInterfaceResponseOption;
}

pub struct BoundsCheckTestInterfaceServer {
    pipe: message_pipe::MessageEndpoint,
    version: u32,
}

impl BoundsCheckTestInterfaceServer {
    pub fn new(pipe: message_pipe::MessageEndpoint) -> BoundsCheckTestInterfaceServer {
        BoundsCheckTestInterfaceServer { pipe: pipe, version: BoundsCheckTestInterface::VERSION }
    }
    pub fn with_version(
        pipe: message_pipe::MessageEndpoint,
        version: u32,
    ) -> BoundsCheckTestInterfaceServer {
        BoundsCheckTestInterfaceServer { pipe: pipe, version: version }
    }
}

impl MojomInterface for BoundsCheckTestInterfaceServer {
    fn service_name() -> &'static str {
        BoundsCheckTestInterface::SERVICE_NAME
    }
    fn version(&self) -> u32 {
        self.version
    }
    fn pipe(&self) -> &message_pipe::MessageEndpoint {
        &self.pipe
    }
    fn unwrap(self) -> message_pipe::MessageEndpoint {
        self.pipe
    }
}

impl CastHandle for BoundsCheckTestInterfaceServer {
    unsafe fn from_untyped(handle: system::UntypedHandle) -> BoundsCheckTestInterfaceServer {
        let pipe = unsafe { message_pipe::MessageEndpoint::from_untyped(handle) };
        BoundsCheckTestInterfaceServer {
            pipe,
            version: 0, // Since we have no other information, assume its the base
        }
    }
    fn as_untyped(self) -> system::UntypedHandle {
        self.pipe.as_untyped()
    }
}

impl MojomEncodable for BoundsCheckTestInterfaceServer {
    impl_encodable_for_interface!();
}

impl<R: BoundsCheckTestInterfaceResponse> MojomInterfaceSend<R> for BoundsCheckTestInterfaceServer {}
impl MojomInterfaceRecv for BoundsCheckTestInterfaceServer {
    type Container = BoundsCheckTestInterfaceRequestOption;
}

// Enums

// Constants

pub trait BoundsCheckTestInterfaceRequest: MojomMessage {}
pub trait BoundsCheckTestInterfaceResponse: MojomMessage {}

pub enum BoundsCheckTestInterfaceRequestOption {
    BoundsCheckTestInterfaceMethod0(BoundsCheckTestInterfaceMethod0Request),
    BoundsCheckTestInterfaceMethod1(BoundsCheckTestInterfaceMethod1Request),
}

impl MojomMessageOption for BoundsCheckTestInterfaceRequestOption {
    fn decode_payload(
        header: MessageHeader,
        buffer: &[u8],
        handles: Vec<UntypedHandle>,
    ) -> Result<Self, ValidationError> {
        match header.name {
            BoundsCheckTestInterfaceMethod0::ORDINAL => {
                if header.flags != message::MESSAGE_HEADER_EXPECT_RESPONSE {
                    return Err(ValidationError::MessageHeaderInvalidFlags);
                }
                match BoundsCheckTestInterfaceMethod0Request::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(BoundsCheckTestInterfaceRequestOption::BoundsCheckTestInterfaceMethod0(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            BoundsCheckTestInterfaceMethod1::ORDINAL => {
                if header.flags != message::MESSAGE_HEADER_NO_FLAG {
                    return Err(ValidationError::MessageHeaderInvalidFlags);
                }
                match BoundsCheckTestInterfaceMethod1Request::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(BoundsCheckTestInterfaceRequestOption::BoundsCheckTestInterfaceMethod1(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            _ => Err(ValidationError::MessageHeaderUnknownMethod),
        }
    }
}

pub enum BoundsCheckTestInterfaceResponseOption {
    BoundsCheckTestInterfaceMethod0(BoundsCheckTestInterfaceMethod0Response),
}

impl MojomMessageOption for BoundsCheckTestInterfaceResponseOption {
    fn decode_payload(
        header: MessageHeader,
        buffer: &[u8],
        handles: Vec<UntypedHandle>,
    ) -> Result<Self, ValidationError> {
        if header.flags != message::MESSAGE_HEADER_IS_RESPONSE {
            return Err(ValidationError::MessageHeaderInvalidFlags);
        }
        match header.name {
            BoundsCheckTestInterfaceMethod0::ORDINAL => {
                match BoundsCheckTestInterfaceMethod0Response::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(BoundsCheckTestInterfaceResponseOption::BoundsCheckTestInterfaceMethod0(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            _ => Err(ValidationError::MessageHeaderUnknownMethod),
        }
    }
}

/// Message: BoundsCheckTestInterfaceMethod0
pub mod BoundsCheckTestInterfaceMethod0 {
    pub const ORDINAL: u32 = 0;
    pub const MIN_VERSION: u32 = 0;
}
// -- BoundsCheckTestInterfaceMethod0Request --

// Constants
// Enums
// Struct version information
const BoundsCheckTestInterfaceMethod0RequestVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct BoundsCheckTestInterfaceMethod0Request {
    pub param0: u8,
}

impl MojomPointer for BoundsCheckTestInterfaceMethod0Request {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&BoundsCheckTestInterfaceMethod0RequestVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <u8>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(BoundsCheckTestInterfaceMethod0Request { param0: param0 })
    }
}

impl MojomEncodable for BoundsCheckTestInterfaceMethod0Request {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
    }
}

impl MojomStruct for BoundsCheckTestInterfaceMethod0Request {}
impl MojomMessage for BoundsCheckTestInterfaceMethod0Request {
    fn min_version() -> u32 {
        BoundsCheckTestInterfaceMethod0::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            1,
            BoundsCheckTestInterfaceMethod0::ORDINAL,
            message::MESSAGE_HEADER_EXPECT_RESPONSE,
        )
    }
}
impl BoundsCheckTestInterfaceRequest for BoundsCheckTestInterfaceMethod0Request {}

// -- BoundsCheckTestInterfaceMethod0Response --

// Constants
// Enums
// Struct version information
const BoundsCheckTestInterfaceMethod0ResponseVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct BoundsCheckTestInterfaceMethod0Response {
    pub param0: u8,
}

impl MojomPointer for BoundsCheckTestInterfaceMethod0Response {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&BoundsCheckTestInterfaceMethod0ResponseVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <u8>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(BoundsCheckTestInterfaceMethod0Response { param0: param0 })
    }
}

impl MojomEncodable for BoundsCheckTestInterfaceMethod0Response {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
    }
}

impl MojomStruct for BoundsCheckTestInterfaceMethod0Response {}

impl MojomMessage for BoundsCheckTestInterfaceMethod0Response {
    fn min_version() -> u32 {
        BoundsCheckTestInterfaceMethod0::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            1,
            BoundsCheckTestInterfaceMethod0::ORDINAL,
            message::MESSAGE_HEADER_IS_RESPONSE,
        )
    }
}
impl BoundsCheckTestInterfaceResponse for BoundsCheckTestInterfaceMethod0Response {}
/// Message: BoundsCheckTestInterfaceMethod1
pub mod BoundsCheckTestInterfaceMethod1 {
    pub const ORDINAL: u32 = 1;
    pub const MIN_VERSION: u32 = 0;
}
// -- BoundsCheckTestInterfaceMethod1Request --

// Constants
// Enums
// Struct version information
const BoundsCheckTestInterfaceMethod1RequestVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct BoundsCheckTestInterfaceMethod1Request {
    pub param0: u8,
}

impl MojomPointer for BoundsCheckTestInterfaceMethod1Request {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&BoundsCheckTestInterfaceMethod1RequestVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <u8>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(BoundsCheckTestInterfaceMethod1Request { param0: param0 })
    }
}

impl MojomEncodable for BoundsCheckTestInterfaceMethod1Request {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
    }
}

impl MojomStruct for BoundsCheckTestInterfaceMethod1Request {}
impl MojomMessage for BoundsCheckTestInterfaceMethod1Request {
    fn min_version() -> u32 {
        BoundsCheckTestInterfaceMethod1::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            0,
            BoundsCheckTestInterfaceMethod1::ORDINAL,
            message::MESSAGE_HEADER_NO_FLAG,
        )
    }
}
impl BoundsCheckTestInterfaceRequest for BoundsCheckTestInterfaceMethod1Request {}

// --- ConformanceTestInterface ---

pub mod ConformanceTestInterface {
    pub const SERVICE_NAME: &'static str = "";
    pub const VERSION: u32 = 0;
}

pub struct ConformanceTestInterfaceClient {
    pipe: message_pipe::MessageEndpoint,
    version: u32,
}

impl ConformanceTestInterfaceClient {
    pub fn new(pipe: message_pipe::MessageEndpoint) -> ConformanceTestInterfaceClient {
        ConformanceTestInterfaceClient { pipe: pipe, version: ConformanceTestInterface::VERSION }
    }
    pub fn with_version(
        pipe: message_pipe::MessageEndpoint,
        version: u32,
    ) -> ConformanceTestInterfaceClient {
        ConformanceTestInterfaceClient { pipe: pipe, version: version }
    }
}

impl MojomInterface for ConformanceTestInterfaceClient {
    fn service_name() -> &'static str {
        ConformanceTestInterface::SERVICE_NAME
    }
    fn version(&self) -> u32 {
        self.version
    }
    fn pipe(&self) -> &message_pipe::MessageEndpoint {
        &self.pipe
    }
    fn unwrap(self) -> message_pipe::MessageEndpoint {
        self.pipe
    }
}

impl CastHandle for ConformanceTestInterfaceClient {
    unsafe fn from_untyped(handle: system::UntypedHandle) -> ConformanceTestInterfaceClient {
        let pipe = unsafe { message_pipe::MessageEndpoint::from_untyped(handle) };
        ConformanceTestInterfaceClient {
            pipe,
            version: 0, // Since we have no other information, assume its the base
        }
    }
    fn as_untyped(self) -> system::UntypedHandle {
        self.pipe.as_untyped()
    }
}

impl MojomEncodable for ConformanceTestInterfaceClient {
    impl_encodable_for_interface!();
}

impl<R: ConformanceTestInterfaceRequest> MojomInterfaceSend<R> for ConformanceTestInterfaceClient {}
impl MojomInterfaceRecv for ConformanceTestInterfaceClient {
    type Container = ConformanceTestInterfaceResponseOption;
}

pub struct ConformanceTestInterfaceServer {
    pipe: message_pipe::MessageEndpoint,
    version: u32,
}

impl ConformanceTestInterfaceServer {
    pub fn new(pipe: message_pipe::MessageEndpoint) -> ConformanceTestInterfaceServer {
        ConformanceTestInterfaceServer { pipe: pipe, version: ConformanceTestInterface::VERSION }
    }
    pub fn with_version(
        pipe: message_pipe::MessageEndpoint,
        version: u32,
    ) -> ConformanceTestInterfaceServer {
        ConformanceTestInterfaceServer { pipe: pipe, version: version }
    }
}

impl MojomInterface for ConformanceTestInterfaceServer {
    fn service_name() -> &'static str {
        ConformanceTestInterface::SERVICE_NAME
    }
    fn version(&self) -> u32 {
        self.version
    }
    fn pipe(&self) -> &message_pipe::MessageEndpoint {
        &self.pipe
    }
    fn unwrap(self) -> message_pipe::MessageEndpoint {
        self.pipe
    }
}

impl CastHandle for ConformanceTestInterfaceServer {
    unsafe fn from_untyped(handle: system::UntypedHandle) -> ConformanceTestInterfaceServer {
        let pipe = unsafe { message_pipe::MessageEndpoint::from_untyped(handle) };
        ConformanceTestInterfaceServer {
            pipe,
            version: 0, // Since we have no other information, assume its the base
        }
    }
    fn as_untyped(self) -> system::UntypedHandle {
        self.pipe.as_untyped()
    }
}

impl MojomEncodable for ConformanceTestInterfaceServer {
    impl_encodable_for_interface!();
}

impl<R: ConformanceTestInterfaceResponse> MojomInterfaceSend<R> for ConformanceTestInterfaceServer {}
impl MojomInterfaceRecv for ConformanceTestInterfaceServer {
    type Container = ConformanceTestInterfaceRequestOption;
}

// Enums

// Constants

pub trait ConformanceTestInterfaceRequest: MojomMessage {}
pub trait ConformanceTestInterfaceResponse: MojomMessage {}

pub enum ConformanceTestInterfaceRequestOption {
    ConformanceTestInterfaceMethod3(ConformanceTestInterfaceMethod3Request),
    ConformanceTestInterfaceMethod4(ConformanceTestInterfaceMethod4Request),
    ConformanceTestInterfaceMethod5(ConformanceTestInterfaceMethod5Request),
    ConformanceTestInterfaceMethod7(ConformanceTestInterfaceMethod7Request),
    ConformanceTestInterfaceMethod12(ConformanceTestInterfaceMethod12Request),
    ConformanceTestInterfaceMethod14(ConformanceTestInterfaceMethod14Request),
    ConformanceTestInterfaceMethod15(ConformanceTestInterfaceMethod15Request),
    ConformanceTestInterfaceMethod1(ConformanceTestInterfaceMethod1Request),
    ConformanceTestInterfaceMethod2(ConformanceTestInterfaceMethod2Request),
    ConformanceTestInterfaceMethod6(ConformanceTestInterfaceMethod6Request),
    ConformanceTestInterfaceMethod8(ConformanceTestInterfaceMethod8Request),
    ConformanceTestInterfaceMethod10(ConformanceTestInterfaceMethod10Request),
    ConformanceTestInterfaceMethod11(ConformanceTestInterfaceMethod11Request),
    ConformanceTestInterfaceMethod0(ConformanceTestInterfaceMethod0Request),
    ConformanceTestInterfaceMethod9(ConformanceTestInterfaceMethod9Request),
    ConformanceTestInterfaceMethod13(ConformanceTestInterfaceMethod13Request),
}

impl MojomMessageOption for ConformanceTestInterfaceRequestOption {
    fn decode_payload(
        header: MessageHeader,
        buffer: &[u8],
        handles: Vec<UntypedHandle>,
    ) -> Result<Self, ValidationError> {
        match header.name {
            ConformanceTestInterfaceMethod3::ORDINAL => {
                if header.flags != message::MESSAGE_HEADER_NO_FLAG {
                    return Err(ValidationError::MessageHeaderInvalidFlags);
                }
                match ConformanceTestInterfaceMethod3Request::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(ConformanceTestInterfaceRequestOption::ConformanceTestInterfaceMethod3(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            ConformanceTestInterfaceMethod4::ORDINAL => {
                if header.flags != message::MESSAGE_HEADER_NO_FLAG {
                    return Err(ValidationError::MessageHeaderInvalidFlags);
                }
                match ConformanceTestInterfaceMethod4Request::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(ConformanceTestInterfaceRequestOption::ConformanceTestInterfaceMethod4(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            ConformanceTestInterfaceMethod5::ORDINAL => {
                if header.flags != message::MESSAGE_HEADER_NO_FLAG {
                    return Err(ValidationError::MessageHeaderInvalidFlags);
                }
                match ConformanceTestInterfaceMethod5Request::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(ConformanceTestInterfaceRequestOption::ConformanceTestInterfaceMethod5(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            ConformanceTestInterfaceMethod7::ORDINAL => {
                if header.flags != message::MESSAGE_HEADER_NO_FLAG {
                    return Err(ValidationError::MessageHeaderInvalidFlags);
                }
                match ConformanceTestInterfaceMethod7Request::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(ConformanceTestInterfaceRequestOption::ConformanceTestInterfaceMethod7(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            ConformanceTestInterfaceMethod12::ORDINAL => {
                if header.flags != message::MESSAGE_HEADER_EXPECT_RESPONSE {
                    return Err(ValidationError::MessageHeaderInvalidFlags);
                }
                match ConformanceTestInterfaceMethod12Request::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(ConformanceTestInterfaceRequestOption::ConformanceTestInterfaceMethod12(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            ConformanceTestInterfaceMethod14::ORDINAL => {
                if header.flags != message::MESSAGE_HEADER_NO_FLAG {
                    return Err(ValidationError::MessageHeaderInvalidFlags);
                }
                match ConformanceTestInterfaceMethod14Request::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(ConformanceTestInterfaceRequestOption::ConformanceTestInterfaceMethod14(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            ConformanceTestInterfaceMethod15::ORDINAL => {
                if header.flags != message::MESSAGE_HEADER_NO_FLAG {
                    return Err(ValidationError::MessageHeaderInvalidFlags);
                }
                match ConformanceTestInterfaceMethod15Request::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(ConformanceTestInterfaceRequestOption::ConformanceTestInterfaceMethod15(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            ConformanceTestInterfaceMethod1::ORDINAL => {
                if header.flags != message::MESSAGE_HEADER_NO_FLAG {
                    return Err(ValidationError::MessageHeaderInvalidFlags);
                }
                match ConformanceTestInterfaceMethod1Request::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(ConformanceTestInterfaceRequestOption::ConformanceTestInterfaceMethod1(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            ConformanceTestInterfaceMethod2::ORDINAL => {
                if header.flags != message::MESSAGE_HEADER_NO_FLAG {
                    return Err(ValidationError::MessageHeaderInvalidFlags);
                }
                match ConformanceTestInterfaceMethod2Request::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(ConformanceTestInterfaceRequestOption::ConformanceTestInterfaceMethod2(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            ConformanceTestInterfaceMethod6::ORDINAL => {
                if header.flags != message::MESSAGE_HEADER_NO_FLAG {
                    return Err(ValidationError::MessageHeaderInvalidFlags);
                }
                match ConformanceTestInterfaceMethod6Request::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(ConformanceTestInterfaceRequestOption::ConformanceTestInterfaceMethod6(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            ConformanceTestInterfaceMethod8::ORDINAL => {
                if header.flags != message::MESSAGE_HEADER_NO_FLAG {
                    return Err(ValidationError::MessageHeaderInvalidFlags);
                }
                match ConformanceTestInterfaceMethod8Request::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(ConformanceTestInterfaceRequestOption::ConformanceTestInterfaceMethod8(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            ConformanceTestInterfaceMethod10::ORDINAL => {
                if header.flags != message::MESSAGE_HEADER_NO_FLAG {
                    return Err(ValidationError::MessageHeaderInvalidFlags);
                }
                match ConformanceTestInterfaceMethod10Request::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(ConformanceTestInterfaceRequestOption::ConformanceTestInterfaceMethod10(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            ConformanceTestInterfaceMethod11::ORDINAL => {
                if header.flags != message::MESSAGE_HEADER_NO_FLAG {
                    return Err(ValidationError::MessageHeaderInvalidFlags);
                }
                match ConformanceTestInterfaceMethod11Request::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(ConformanceTestInterfaceRequestOption::ConformanceTestInterfaceMethod11(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            ConformanceTestInterfaceMethod0::ORDINAL => {
                if header.flags != message::MESSAGE_HEADER_NO_FLAG {
                    return Err(ValidationError::MessageHeaderInvalidFlags);
                }
                match ConformanceTestInterfaceMethod0Request::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(ConformanceTestInterfaceRequestOption::ConformanceTestInterfaceMethod0(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            ConformanceTestInterfaceMethod9::ORDINAL => {
                if header.flags != message::MESSAGE_HEADER_NO_FLAG {
                    return Err(ValidationError::MessageHeaderInvalidFlags);
                }
                match ConformanceTestInterfaceMethod9Request::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(ConformanceTestInterfaceRequestOption::ConformanceTestInterfaceMethod9(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            ConformanceTestInterfaceMethod13::ORDINAL => {
                if header.flags != message::MESSAGE_HEADER_NO_FLAG {
                    return Err(ValidationError::MessageHeaderInvalidFlags);
                }
                match ConformanceTestInterfaceMethod13Request::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(ConformanceTestInterfaceRequestOption::ConformanceTestInterfaceMethod13(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            _ => Err(ValidationError::MessageHeaderUnknownMethod),
        }
    }
}

pub enum ConformanceTestInterfaceResponseOption {
    ConformanceTestInterfaceMethod12(ConformanceTestInterfaceMethod12Response),
}

impl MojomMessageOption for ConformanceTestInterfaceResponseOption {
    fn decode_payload(
        header: MessageHeader,
        buffer: &[u8],
        handles: Vec<UntypedHandle>,
    ) -> Result<Self, ValidationError> {
        if header.flags != message::MESSAGE_HEADER_IS_RESPONSE {
            return Err(ValidationError::MessageHeaderInvalidFlags);
        }
        match header.name {
            ConformanceTestInterfaceMethod12::ORDINAL => {
                match ConformanceTestInterfaceMethod12Response::deserialize(buffer, handles) {
                    Ok(value) => Ok(
                        ConformanceTestInterfaceResponseOption::ConformanceTestInterfaceMethod12(
                            value,
                        ),
                    ),
                    Err(err) => return Err(err),
                }
            }
            _ => Err(ValidationError::MessageHeaderUnknownMethod),
        }
    }
}

/// Message: ConformanceTestInterfaceMethod3
pub mod ConformanceTestInterfaceMethod3 {
    pub const ORDINAL: u32 = 3;
    pub const MIN_VERSION: u32 = 0;
}
// -- ConformanceTestInterfaceMethod3Request --

// Constants
// Enums
// Struct version information
const ConformanceTestInterfaceMethod3RequestVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct ConformanceTestInterfaceMethod3Request {
    pub param0: Vec<bool>,
}

impl MojomPointer for ConformanceTestInterfaceMethod3Request {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&ConformanceTestInterfaceMethod3RequestVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <Vec<bool>>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(ConformanceTestInterfaceMethod3Request { param0: param0 })
    }
}

impl MojomEncodable for ConformanceTestInterfaceMethod3Request {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
    }
}

impl MojomStruct for ConformanceTestInterfaceMethod3Request {}
impl MojomMessage for ConformanceTestInterfaceMethod3Request {
    fn min_version() -> u32 {
        ConformanceTestInterfaceMethod3::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            0,
            ConformanceTestInterfaceMethod3::ORDINAL,
            message::MESSAGE_HEADER_NO_FLAG,
        )
    }
}
impl ConformanceTestInterfaceRequest for ConformanceTestInterfaceMethod3Request {}

/// Message: ConformanceTestInterfaceMethod4
pub mod ConformanceTestInterfaceMethod4 {
    pub const ORDINAL: u32 = 4;
    pub const MIN_VERSION: u32 = 0;
}
// -- ConformanceTestInterfaceMethod4Request --

// Constants
// Enums
// Struct version information
const ConformanceTestInterfaceMethod4RequestVersions: [(u32, u32); 1] = [(0, 24)];

// Struct definition
pub struct ConformanceTestInterfaceMethod4Request {
    pub param0: StructC,
    pub param1: Vec<u8>,
}

impl MojomPointer for ConformanceTestInterfaceMethod4Request {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        24
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
        MojomEncodable::encode(self.param1, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&ConformanceTestInterfaceMethod4RequestVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <StructC>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        let param1 = match <Vec<u8>>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(ConformanceTestInterfaceMethod4Request { param0: param0, param1: param1 })
    }
}

impl MojomEncodable for ConformanceTestInterfaceMethod4Request {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
            + self.param1.compute_size(context.clone())
    }
}

impl MojomStruct for ConformanceTestInterfaceMethod4Request {}
impl MojomMessage for ConformanceTestInterfaceMethod4Request {
    fn min_version() -> u32 {
        ConformanceTestInterfaceMethod4::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            0,
            ConformanceTestInterfaceMethod4::ORDINAL,
            message::MESSAGE_HEADER_NO_FLAG,
        )
    }
}
impl ConformanceTestInterfaceRequest for ConformanceTestInterfaceMethod4Request {}

/// Message: ConformanceTestInterfaceMethod5
pub mod ConformanceTestInterfaceMethod5 {
    pub const ORDINAL: u32 = 5;
    pub const MIN_VERSION: u32 = 0;
}
// -- ConformanceTestInterfaceMethod5Request --

// Constants
// Enums
// Struct version information
const ConformanceTestInterfaceMethod5RequestVersions: [(u32, u32); 1] = [(0, 24)];

// Struct definition
pub struct ConformanceTestInterfaceMethod5Request {
    pub param0: StructE,
    pub param1: system::data_pipe::Producer<u8>,
}

impl MojomPointer for ConformanceTestInterfaceMethod5Request {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        24
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
        MojomEncodable::encode(self.param1, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&ConformanceTestInterfaceMethod5RequestVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <StructE>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        let param1 = match <system::data_pipe::Producer<u8>>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(ConformanceTestInterfaceMethod5Request { param0: param0, param1: param1 })
    }
}

impl MojomEncodable for ConformanceTestInterfaceMethod5Request {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
            + self.param1.compute_size(context.clone())
    }
}

impl MojomStruct for ConformanceTestInterfaceMethod5Request {}
impl MojomMessage for ConformanceTestInterfaceMethod5Request {
    fn min_version() -> u32 {
        ConformanceTestInterfaceMethod5::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            0,
            ConformanceTestInterfaceMethod5::ORDINAL,
            message::MESSAGE_HEADER_NO_FLAG,
        )
    }
}
impl ConformanceTestInterfaceRequest for ConformanceTestInterfaceMethod5Request {}

/// Message: ConformanceTestInterfaceMethod7
pub mod ConformanceTestInterfaceMethod7 {
    pub const ORDINAL: u32 = 7;
    pub const MIN_VERSION: u32 = 0;
}
// -- ConformanceTestInterfaceMethod7Request --

// Constants
// Enums
// Struct version information
const ConformanceTestInterfaceMethod7RequestVersions: [(u32, u32); 1] = [(0, 24)];

// Struct definition
pub struct ConformanceTestInterfaceMethod7Request {
    pub param0: StructF,
    pub param1: [Option<[u8; 3]>; 2],
}

impl MojomPointer for ConformanceTestInterfaceMethod7Request {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        24
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
        MojomEncodable::encode(self.param1, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&ConformanceTestInterfaceMethod7RequestVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <StructF>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        let param1 = match <[Option<[u8; 3]>; 2]>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(ConformanceTestInterfaceMethod7Request { param0: param0, param1: param1 })
    }
}

impl MojomEncodable for ConformanceTestInterfaceMethod7Request {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
            + self.param1.compute_size(context.clone())
    }
}

impl MojomStruct for ConformanceTestInterfaceMethod7Request {}
impl MojomMessage for ConformanceTestInterfaceMethod7Request {
    fn min_version() -> u32 {
        ConformanceTestInterfaceMethod7::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            0,
            ConformanceTestInterfaceMethod7::ORDINAL,
            message::MESSAGE_HEADER_NO_FLAG,
        )
    }
}
impl ConformanceTestInterfaceRequest for ConformanceTestInterfaceMethod7Request {}

/// Message: ConformanceTestInterfaceMethod12
pub mod ConformanceTestInterfaceMethod12 {
    pub const ORDINAL: u32 = 12;
    pub const MIN_VERSION: u32 = 0;
}
// -- ConformanceTestInterfaceMethod12Request --

// Constants
// Enums
// Struct version information
const ConformanceTestInterfaceMethod12RequestVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct ConformanceTestInterfaceMethod12Request {
    pub param0: f32,
}

impl MojomPointer for ConformanceTestInterfaceMethod12Request {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&ConformanceTestInterfaceMethod12RequestVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <f32>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(ConformanceTestInterfaceMethod12Request { param0: param0 })
    }
}

impl MojomEncodable for ConformanceTestInterfaceMethod12Request {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
    }
}

impl MojomStruct for ConformanceTestInterfaceMethod12Request {}
impl MojomMessage for ConformanceTestInterfaceMethod12Request {
    fn min_version() -> u32 {
        ConformanceTestInterfaceMethod12::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            1,
            ConformanceTestInterfaceMethod12::ORDINAL,
            message::MESSAGE_HEADER_EXPECT_RESPONSE,
        )
    }
}
impl ConformanceTestInterfaceRequest for ConformanceTestInterfaceMethod12Request {}

// -- ConformanceTestInterfaceMethod12Response --

// Constants
// Enums
// Struct version information
const ConformanceTestInterfaceMethod12ResponseVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct ConformanceTestInterfaceMethod12Response {
    pub param0: f32,
}

impl MojomPointer for ConformanceTestInterfaceMethod12Response {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&ConformanceTestInterfaceMethod12ResponseVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <f32>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(ConformanceTestInterfaceMethod12Response { param0: param0 })
    }
}

impl MojomEncodable for ConformanceTestInterfaceMethod12Response {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
    }
}

impl MojomStruct for ConformanceTestInterfaceMethod12Response {}

impl MojomMessage for ConformanceTestInterfaceMethod12Response {
    fn min_version() -> u32 {
        ConformanceTestInterfaceMethod12::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            1,
            ConformanceTestInterfaceMethod12::ORDINAL,
            message::MESSAGE_HEADER_IS_RESPONSE,
        )
    }
}
impl ConformanceTestInterfaceResponse for ConformanceTestInterfaceMethod12Response {}
/// Message: ConformanceTestInterfaceMethod14
pub mod ConformanceTestInterfaceMethod14 {
    pub const ORDINAL: u32 = 14;
    pub const MIN_VERSION: u32 = 0;
}
// -- ConformanceTestInterfaceMethod14Request --

// Constants
// Enums
// Struct version information
const ConformanceTestInterfaceMethod14RequestVersions: [(u32, u32); 1] = [(0, 24)];

// Struct definition
pub struct ConformanceTestInterfaceMethod14Request {
    pub param0: UnionA,
}

impl MojomPointer for ConformanceTestInterfaceMethod14Request {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        24
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&ConformanceTestInterfaceMethod14RequestVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <UnionA>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(ConformanceTestInterfaceMethod14Request { param0: param0 })
    }
}

impl MojomEncodable for ConformanceTestInterfaceMethod14Request {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
    }
}

impl MojomStruct for ConformanceTestInterfaceMethod14Request {}
impl MojomMessage for ConformanceTestInterfaceMethod14Request {
    fn min_version() -> u32 {
        ConformanceTestInterfaceMethod14::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            0,
            ConformanceTestInterfaceMethod14::ORDINAL,
            message::MESSAGE_HEADER_NO_FLAG,
        )
    }
}
impl ConformanceTestInterfaceRequest for ConformanceTestInterfaceMethod14Request {}

/// Message: ConformanceTestInterfaceMethod15
pub mod ConformanceTestInterfaceMethod15 {
    pub const ORDINAL: u32 = 15;
    pub const MIN_VERSION: u32 = 0;
}
// -- ConformanceTestInterfaceMethod15Request --

// Constants
// Enums
// Struct version information
const ConformanceTestInterfaceMethod15RequestVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct ConformanceTestInterfaceMethod15Request {
    pub param0: StructH,
}

impl MojomPointer for ConformanceTestInterfaceMethod15Request {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&ConformanceTestInterfaceMethod15RequestVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <StructH>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(ConformanceTestInterfaceMethod15Request { param0: param0 })
    }
}

impl MojomEncodable for ConformanceTestInterfaceMethod15Request {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
    }
}

impl MojomStruct for ConformanceTestInterfaceMethod15Request {}
impl MojomMessage for ConformanceTestInterfaceMethod15Request {
    fn min_version() -> u32 {
        ConformanceTestInterfaceMethod15::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            0,
            ConformanceTestInterfaceMethod15::ORDINAL,
            message::MESSAGE_HEADER_NO_FLAG,
        )
    }
}
impl ConformanceTestInterfaceRequest for ConformanceTestInterfaceMethod15Request {}

/// Message: ConformanceTestInterfaceMethod1
pub mod ConformanceTestInterfaceMethod1 {
    pub const ORDINAL: u32 = 1;
    pub const MIN_VERSION: u32 = 0;
}
// -- ConformanceTestInterfaceMethod1Request --

// Constants
// Enums
// Struct version information
const ConformanceTestInterfaceMethod1RequestVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct ConformanceTestInterfaceMethod1Request {
    pub param0: StructA,
}

impl MojomPointer for ConformanceTestInterfaceMethod1Request {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&ConformanceTestInterfaceMethod1RequestVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <StructA>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(ConformanceTestInterfaceMethod1Request { param0: param0 })
    }
}

impl MojomEncodable for ConformanceTestInterfaceMethod1Request {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
    }
}

impl MojomStruct for ConformanceTestInterfaceMethod1Request {}
impl MojomMessage for ConformanceTestInterfaceMethod1Request {
    fn min_version() -> u32 {
        ConformanceTestInterfaceMethod1::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            0,
            ConformanceTestInterfaceMethod1::ORDINAL,
            message::MESSAGE_HEADER_NO_FLAG,
        )
    }
}
impl ConformanceTestInterfaceRequest for ConformanceTestInterfaceMethod1Request {}

/// Message: ConformanceTestInterfaceMethod2
pub mod ConformanceTestInterfaceMethod2 {
    pub const ORDINAL: u32 = 2;
    pub const MIN_VERSION: u32 = 0;
}
// -- ConformanceTestInterfaceMethod2Request --

// Constants
// Enums
// Struct version information
const ConformanceTestInterfaceMethod2RequestVersions: [(u32, u32); 1] = [(0, 24)];

// Struct definition
pub struct ConformanceTestInterfaceMethod2Request {
    pub param0: StructB,
    pub param1: StructA,
}

impl MojomPointer for ConformanceTestInterfaceMethod2Request {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        24
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
        MojomEncodable::encode(self.param1, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&ConformanceTestInterfaceMethod2RequestVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <StructB>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        let param1 = match <StructA>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(ConformanceTestInterfaceMethod2Request { param0: param0, param1: param1 })
    }
}

impl MojomEncodable for ConformanceTestInterfaceMethod2Request {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
            + self.param1.compute_size(context.clone())
    }
}

impl MojomStruct for ConformanceTestInterfaceMethod2Request {}
impl MojomMessage for ConformanceTestInterfaceMethod2Request {
    fn min_version() -> u32 {
        ConformanceTestInterfaceMethod2::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            0,
            ConformanceTestInterfaceMethod2::ORDINAL,
            message::MESSAGE_HEADER_NO_FLAG,
        )
    }
}
impl ConformanceTestInterfaceRequest for ConformanceTestInterfaceMethod2Request {}

/// Message: ConformanceTestInterfaceMethod6
pub mod ConformanceTestInterfaceMethod6 {
    pub const ORDINAL: u32 = 6;
    pub const MIN_VERSION: u32 = 0;
}
// -- ConformanceTestInterfaceMethod6Request --

// Constants
// Enums
// Struct version information
const ConformanceTestInterfaceMethod6RequestVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct ConformanceTestInterfaceMethod6Request {
    pub param0: Vec<Vec<u8>>,
}

impl MojomPointer for ConformanceTestInterfaceMethod6Request {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&ConformanceTestInterfaceMethod6RequestVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <Vec<Vec<u8>>>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(ConformanceTestInterfaceMethod6Request { param0: param0 })
    }
}

impl MojomEncodable for ConformanceTestInterfaceMethod6Request {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
    }
}

impl MojomStruct for ConformanceTestInterfaceMethod6Request {}
impl MojomMessage for ConformanceTestInterfaceMethod6Request {
    fn min_version() -> u32 {
        ConformanceTestInterfaceMethod6::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            0,
            ConformanceTestInterfaceMethod6::ORDINAL,
            message::MESSAGE_HEADER_NO_FLAG,
        )
    }
}
impl ConformanceTestInterfaceRequest for ConformanceTestInterfaceMethod6Request {}

/// Message: ConformanceTestInterfaceMethod8
pub mod ConformanceTestInterfaceMethod8 {
    pub const ORDINAL: u32 = 8;
    pub const MIN_VERSION: u32 = 0;
}
// -- ConformanceTestInterfaceMethod8Request --

// Constants
// Enums
// Struct version information
const ConformanceTestInterfaceMethod8RequestVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct ConformanceTestInterfaceMethod8Request {
    pub param0: Vec<Option<Vec<String>>>,
}

impl MojomPointer for ConformanceTestInterfaceMethod8Request {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&ConformanceTestInterfaceMethod8RequestVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <Vec<Option<Vec<String>>>>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(ConformanceTestInterfaceMethod8Request { param0: param0 })
    }
}

impl MojomEncodable for ConformanceTestInterfaceMethod8Request {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
    }
}

impl MojomStruct for ConformanceTestInterfaceMethod8Request {}
impl MojomMessage for ConformanceTestInterfaceMethod8Request {
    fn min_version() -> u32 {
        ConformanceTestInterfaceMethod8::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            0,
            ConformanceTestInterfaceMethod8::ORDINAL,
            message::MESSAGE_HEADER_NO_FLAG,
        )
    }
}
impl ConformanceTestInterfaceRequest for ConformanceTestInterfaceMethod8Request {}

/// Message: ConformanceTestInterfaceMethod10
pub mod ConformanceTestInterfaceMethod10 {
    pub const ORDINAL: u32 = 10;
    pub const MIN_VERSION: u32 = 0;
}
// -- ConformanceTestInterfaceMethod10Request --

// Constants
// Enums
// Struct version information
const ConformanceTestInterfaceMethod10RequestVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct ConformanceTestInterfaceMethod10Request {
    pub param0: HashMap<String, u8>,
}

impl MojomPointer for ConformanceTestInterfaceMethod10Request {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&ConformanceTestInterfaceMethod10RequestVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <HashMap<String, u8>>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(ConformanceTestInterfaceMethod10Request { param0: param0 })
    }
}

impl MojomEncodable for ConformanceTestInterfaceMethod10Request {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
    }
}

impl MojomStruct for ConformanceTestInterfaceMethod10Request {}
impl MojomMessage for ConformanceTestInterfaceMethod10Request {
    fn min_version() -> u32 {
        ConformanceTestInterfaceMethod10::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            0,
            ConformanceTestInterfaceMethod10::ORDINAL,
            message::MESSAGE_HEADER_NO_FLAG,
        )
    }
}
impl ConformanceTestInterfaceRequest for ConformanceTestInterfaceMethod10Request {}

/// Message: ConformanceTestInterfaceMethod11
pub mod ConformanceTestInterfaceMethod11 {
    pub const ORDINAL: u32 = 11;
    pub const MIN_VERSION: u32 = 0;
}
// -- ConformanceTestInterfaceMethod11Request --

// Constants
// Enums
// Struct version information
const ConformanceTestInterfaceMethod11RequestVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct ConformanceTestInterfaceMethod11Request {
    pub param0: StructG,
}

impl MojomPointer for ConformanceTestInterfaceMethod11Request {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&ConformanceTestInterfaceMethod11RequestVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <StructG>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(ConformanceTestInterfaceMethod11Request { param0: param0 })
    }
}

impl MojomEncodable for ConformanceTestInterfaceMethod11Request {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
    }
}

impl MojomStruct for ConformanceTestInterfaceMethod11Request {}
impl MojomMessage for ConformanceTestInterfaceMethod11Request {
    fn min_version() -> u32 {
        ConformanceTestInterfaceMethod11::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            0,
            ConformanceTestInterfaceMethod11::ORDINAL,
            message::MESSAGE_HEADER_NO_FLAG,
        )
    }
}
impl ConformanceTestInterfaceRequest for ConformanceTestInterfaceMethod11Request {}

/// Message: ConformanceTestInterfaceMethod0
pub mod ConformanceTestInterfaceMethod0 {
    pub const ORDINAL: u32 = 0;
    pub const MIN_VERSION: u32 = 0;
}
// -- ConformanceTestInterfaceMethod0Request --

// Constants
// Enums
// Struct version information
const ConformanceTestInterfaceMethod0RequestVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct ConformanceTestInterfaceMethod0Request {
    pub param0: f32,
}

impl MojomPointer for ConformanceTestInterfaceMethod0Request {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&ConformanceTestInterfaceMethod0RequestVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <f32>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(ConformanceTestInterfaceMethod0Request { param0: param0 })
    }
}

impl MojomEncodable for ConformanceTestInterfaceMethod0Request {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
    }
}

impl MojomStruct for ConformanceTestInterfaceMethod0Request {}
impl MojomMessage for ConformanceTestInterfaceMethod0Request {
    fn min_version() -> u32 {
        ConformanceTestInterfaceMethod0::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            0,
            ConformanceTestInterfaceMethod0::ORDINAL,
            message::MESSAGE_HEADER_NO_FLAG,
        )
    }
}
impl ConformanceTestInterfaceRequest for ConformanceTestInterfaceMethod0Request {}

/// Message: ConformanceTestInterfaceMethod9
pub mod ConformanceTestInterfaceMethod9 {
    pub const ORDINAL: u32 = 9;
    pub const MIN_VERSION: u32 = 0;
}
// -- ConformanceTestInterfaceMethod9Request --

// Constants
// Enums
// Struct version information
const ConformanceTestInterfaceMethod9RequestVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct ConformanceTestInterfaceMethod9Request {
    pub param0: Option<Vec<Vec<Option<system::UntypedHandle>>>>,
}

impl MojomPointer for ConformanceTestInterfaceMethod9Request {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&ConformanceTestInterfaceMethod9RequestVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <Option<Vec<Vec<Option<system::UntypedHandle>>>>>::decode(
            decoder,
            context.clone(),
        ) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(ConformanceTestInterfaceMethod9Request { param0: param0 })
    }
}

impl MojomEncodable for ConformanceTestInterfaceMethod9Request {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
    }
}

impl MojomStruct for ConformanceTestInterfaceMethod9Request {}
impl MojomMessage for ConformanceTestInterfaceMethod9Request {
    fn min_version() -> u32 {
        ConformanceTestInterfaceMethod9::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            0,
            ConformanceTestInterfaceMethod9::ORDINAL,
            message::MESSAGE_HEADER_NO_FLAG,
        )
    }
}
impl ConformanceTestInterfaceRequest for ConformanceTestInterfaceMethod9Request {}

/// Message: ConformanceTestInterfaceMethod13
pub mod ConformanceTestInterfaceMethod13 {
    pub const ORDINAL: u32 = 13;
    pub const MIN_VERSION: u32 = 0;
}
// -- ConformanceTestInterfaceMethod13Request --

// Constants
// Enums
// Struct version information
const ConformanceTestInterfaceMethod13RequestVersions: [(u32, u32); 1] = [(0, 32)];

// Struct definition
pub struct ConformanceTestInterfaceMethod13Request {
    pub param0: Option<InterfaceAClient>,
    pub param1: u32,
    pub param2: Option<InterfaceAClient>,
}

impl MojomPointer for ConformanceTestInterfaceMethod13Request {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        32
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
        MojomEncodable::encode(self.param1, encoder, state, context.clone());
        MojomEncodable::encode(self.param2, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&ConformanceTestInterfaceMethod13RequestVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <Option<InterfaceAClient>>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        let param1 = match <u32>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        let param2 = match <Option<InterfaceAClient>>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(ConformanceTestInterfaceMethod13Request {
            param0: param0,
            param1: param1,
            param2: param2,
        })
    }
}

impl MojomEncodable for ConformanceTestInterfaceMethod13Request {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
            + self.param1.compute_size(context.clone())
            + self.param2.compute_size(context.clone())
    }
}

impl MojomStruct for ConformanceTestInterfaceMethod13Request {}
impl MojomMessage for ConformanceTestInterfaceMethod13Request {
    fn min_version() -> u32 {
        ConformanceTestInterfaceMethod13::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            0,
            ConformanceTestInterfaceMethod13::ORDINAL,
            message::MESSAGE_HEADER_NO_FLAG,
        )
    }
}
impl ConformanceTestInterfaceRequest for ConformanceTestInterfaceMethod13Request {}

// --- IntegrationTestInterface ---

pub mod IntegrationTestInterface {
    pub const SERVICE_NAME: &'static str = "";
    pub const VERSION: u32 = 0;
}

pub struct IntegrationTestInterfaceClient {
    pipe: message_pipe::MessageEndpoint,
    version: u32,
}

impl IntegrationTestInterfaceClient {
    pub fn new(pipe: message_pipe::MessageEndpoint) -> IntegrationTestInterfaceClient {
        IntegrationTestInterfaceClient { pipe: pipe, version: IntegrationTestInterface::VERSION }
    }
    pub fn with_version(
        pipe: message_pipe::MessageEndpoint,
        version: u32,
    ) -> IntegrationTestInterfaceClient {
        IntegrationTestInterfaceClient { pipe: pipe, version: version }
    }
}

impl MojomInterface for IntegrationTestInterfaceClient {
    fn service_name() -> &'static str {
        IntegrationTestInterface::SERVICE_NAME
    }
    fn version(&self) -> u32 {
        self.version
    }
    fn pipe(&self) -> &message_pipe::MessageEndpoint {
        &self.pipe
    }
    fn unwrap(self) -> message_pipe::MessageEndpoint {
        self.pipe
    }
}

impl CastHandle for IntegrationTestInterfaceClient {
    unsafe fn from_untyped(handle: system::UntypedHandle) -> IntegrationTestInterfaceClient {
        let pipe = unsafe { message_pipe::MessageEndpoint::from_untyped(handle) };
        IntegrationTestInterfaceClient {
            pipe,
            version: 0, // Since we have no other information, assume its the base
        }
    }
    fn as_untyped(self) -> system::UntypedHandle {
        self.pipe.as_untyped()
    }
}

impl MojomEncodable for IntegrationTestInterfaceClient {
    impl_encodable_for_interface!();
}

impl<R: IntegrationTestInterfaceRequest> MojomInterfaceSend<R> for IntegrationTestInterfaceClient {}
impl MojomInterfaceRecv for IntegrationTestInterfaceClient {
    type Container = IntegrationTestInterfaceResponseOption;
}

pub struct IntegrationTestInterfaceServer {
    pipe: message_pipe::MessageEndpoint,
    version: u32,
}

impl IntegrationTestInterfaceServer {
    pub fn new(pipe: message_pipe::MessageEndpoint) -> IntegrationTestInterfaceServer {
        IntegrationTestInterfaceServer { pipe: pipe, version: IntegrationTestInterface::VERSION }
    }
    pub fn with_version(
        pipe: message_pipe::MessageEndpoint,
        version: u32,
    ) -> IntegrationTestInterfaceServer {
        IntegrationTestInterfaceServer { pipe: pipe, version: version }
    }
}

impl MojomInterface for IntegrationTestInterfaceServer {
    fn service_name() -> &'static str {
        IntegrationTestInterface::SERVICE_NAME
    }
    fn version(&self) -> u32 {
        self.version
    }
    fn pipe(&self) -> &message_pipe::MessageEndpoint {
        &self.pipe
    }
    fn unwrap(self) -> message_pipe::MessageEndpoint {
        self.pipe
    }
}

impl CastHandle for IntegrationTestInterfaceServer {
    unsafe fn from_untyped(handle: system::UntypedHandle) -> IntegrationTestInterfaceServer {
        let pipe = unsafe { message_pipe::MessageEndpoint::from_untyped(handle) };
        IntegrationTestInterfaceServer {
            pipe,
            version: 0, // Since we have no other information, assume its the base
        }
    }
    fn as_untyped(self) -> system::UntypedHandle {
        self.pipe.as_untyped()
    }
}

impl MojomEncodable for IntegrationTestInterfaceServer {
    impl_encodable_for_interface!();
}

impl<R: IntegrationTestInterfaceResponse> MojomInterfaceSend<R> for IntegrationTestInterfaceServer {}
impl MojomInterfaceRecv for IntegrationTestInterfaceServer {
    type Container = IntegrationTestInterfaceRequestOption;
}

// Enums

// Constants

pub trait IntegrationTestInterfaceRequest: MojomMessage {}
pub trait IntegrationTestInterfaceResponse: MojomMessage {}

pub enum IntegrationTestInterfaceRequestOption {
    IntegrationTestInterfaceMethod0(IntegrationTestInterfaceMethod0Request),
}

impl MojomMessageOption for IntegrationTestInterfaceRequestOption {
    fn decode_payload(
        header: MessageHeader,
        buffer: &[u8],
        handles: Vec<UntypedHandle>,
    ) -> Result<Self, ValidationError> {
        match header.name {
            IntegrationTestInterfaceMethod0::ORDINAL => {
                if header.flags != message::MESSAGE_HEADER_EXPECT_RESPONSE {
                    return Err(ValidationError::MessageHeaderInvalidFlags);
                }
                match IntegrationTestInterfaceMethod0Request::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(IntegrationTestInterfaceRequestOption::IntegrationTestInterfaceMethod0(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            _ => Err(ValidationError::MessageHeaderUnknownMethod),
        }
    }
}

pub enum IntegrationTestInterfaceResponseOption {
    IntegrationTestInterfaceMethod0(IntegrationTestInterfaceMethod0Response),
}

impl MojomMessageOption for IntegrationTestInterfaceResponseOption {
    fn decode_payload(
        header: MessageHeader,
        buffer: &[u8],
        handles: Vec<UntypedHandle>,
    ) -> Result<Self, ValidationError> {
        if header.flags != message::MESSAGE_HEADER_IS_RESPONSE {
            return Err(ValidationError::MessageHeaderInvalidFlags);
        }
        match header.name {
            IntegrationTestInterfaceMethod0::ORDINAL => {
                match IntegrationTestInterfaceMethod0Response::deserialize(buffer, handles) {
                    Ok(value) => {
                        Ok(IntegrationTestInterfaceResponseOption::IntegrationTestInterfaceMethod0(
                            value,
                        ))
                    }
                    Err(err) => return Err(err),
                }
            }
            _ => Err(ValidationError::MessageHeaderUnknownMethod),
        }
    }
}

/// Message: IntegrationTestInterfaceMethod0
pub mod IntegrationTestInterfaceMethod0 {
    pub const ORDINAL: u32 = 0;
    pub const MIN_VERSION: u32 = 0;
}
// -- IntegrationTestInterfaceMethod0Request --

// Constants
// Enums
// Struct version information
const IntegrationTestInterfaceMethod0RequestVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct IntegrationTestInterfaceMethod0Request {
    pub param0: BasicStruct,
}

impl MojomPointer for IntegrationTestInterfaceMethod0Request {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&IntegrationTestInterfaceMethod0RequestVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <BasicStruct>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(IntegrationTestInterfaceMethod0Request { param0: param0 })
    }
}

impl MojomEncodable for IntegrationTestInterfaceMethod0Request {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
    }
}

impl MojomStruct for IntegrationTestInterfaceMethod0Request {}
impl MojomMessage for IntegrationTestInterfaceMethod0Request {
    fn min_version() -> u32 {
        IntegrationTestInterfaceMethod0::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            1,
            IntegrationTestInterfaceMethod0::ORDINAL,
            message::MESSAGE_HEADER_EXPECT_RESPONSE,
        )
    }
}
impl IntegrationTestInterfaceRequest for IntegrationTestInterfaceMethod0Request {}

// -- IntegrationTestInterfaceMethod0Response --

// Constants
// Enums
// Struct version information
const IntegrationTestInterfaceMethod0ResponseVersions: [(u32, u32); 1] = [(0, 16)];

// Struct definition
pub struct IntegrationTestInterfaceMethod0Response {
    pub param0: Vec<u8>,
}

impl MojomPointer for IntegrationTestInterfaceMethod0Response {
    fn header_data(&self) -> DataHeaderValue {
        DataHeaderValue::Version(0)
    }
    fn serialized_size(&self, _context: &Context) -> usize {
        16
    }
    fn encode_value(self, encoder: &mut Encoder, state: &mut EncodingState, context: Context) {
        MojomEncodable::encode(self.param0, encoder, state, context.clone());
    }
    fn decode_value(decoder: &mut Decoder, context: Context) -> Result<Self, ValidationError> {
        let version = {
            let state = decoder.get_mut(&context);
            match state.decode_struct_header(&IntegrationTestInterfaceMethod0ResponseVersions) {
                Ok(header) => header.data(),
                Err(err) => return Err(err),
            }
        };
        let param0 = match <Vec<u8>>::decode(decoder, context.clone()) {
            Ok(value) => value,
            Err(err) => return Err(err),
        };
        Ok(IntegrationTestInterfaceMethod0Response { param0: param0 })
    }
}

impl MojomEncodable for IntegrationTestInterfaceMethod0Response {
    impl_encodable_for_pointer!();
    fn compute_size(&self, context: Context) -> usize {
        encoding::align_default(self.serialized_size(&context))
            + self.param0.compute_size(context.clone())
    }
}

impl MojomStruct for IntegrationTestInterfaceMethod0Response {}

impl MojomMessage for IntegrationTestInterfaceMethod0Response {
    fn min_version() -> u32 {
        IntegrationTestInterfaceMethod0::MIN_VERSION
    }
    fn create_header() -> MessageHeader {
        MessageHeader::new(
            1,
            IntegrationTestInterfaceMethod0::ORDINAL,
            message::MESSAGE_HEADER_IS_RESPONSE,
        )
    }
}
impl IntegrationTestInterfaceResponse for IntegrationTestInterfaceMethod0Response {}
