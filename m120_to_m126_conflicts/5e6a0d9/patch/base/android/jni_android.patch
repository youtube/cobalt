--- base/android/jni_android.cc
+++ base/android/jni_android.cc
@@ -4,7 +4,6 @@
 
 #include "base/android/jni_android.h"
 
-#include <cstring>
 #include <stddef.h>
 #include <sys/prctl.h>
 
@@ -15,8 +14,6 @@
 #include "base/debug/debugging_buildflags.h"
 #include "base/feature_list.h"
 #include "base/logging.h"
-#include "base/base_switches.h"
-#include "base/command_line.h"
 #include "build/build_config.h"
 #include "build/robolectric_buildflags.h"
 #include "third_party/abseil-cpp/absl/base/attributes.h"
@@ -44,7 +41,6 @@
 
 jclass g_out_of_memory_error_class = nullptr;
 
-<<<<<<< HEAD
 #if !BUILDFLAG(IS_ROBOLECTRIC)
 jmethodID g_class_loader_load_class_method_id = nullptr;
 // ClassLoader.loadClass() accepts either slashes or dots on Android, but JVM
@@ -57,81 +53,6 @@
   return static_cast<jclass>(env->CallObjectMethod(
       GetSplitClassLoader(env, split_name), g_class_loader_load_class_method_id,
       ConvertUTF8ToJavaString(env, class_name).obj()));
-=======
-/* Cobalt specific hack to move Java classes to a custom namespace.
-   For every class org.chromium.foo moves them to cobalt.org.chromium.foo
-   This works around link-time conflicts when building the final
-   package against other Chromium release artifacts. */
-#if BUILDFLAG(IS_COBALT)
-const char* COBALT_ORG_CHROMIUM = "cobalt/org/chromium";
-const char* ORG_CHROMIUM = "org/chromium";
-
-bool g_add_cobalt_prefix = false;
-std::atomic<bool> g_checked_command_line(false);
-
-std::string getRepackagedName(const char* signature) {
-  std::string holder(signature);
-  size_t pos = 0;
-  while ((pos = holder.find(ORG_CHROMIUM, pos)) != std::string::npos) {
-    holder.replace(pos, strlen(ORG_CHROMIUM), COBALT_ORG_CHROMIUM);
-    pos += strlen(COBALT_ORG_CHROMIUM);
-  }
-  return holder;
-}
-
-bool shouldAddCobaltPrefix() {
-  if (!g_checked_command_line && base::CommandLine::InitializedForCurrentProcess()) {
-    g_add_cobalt_prefix = base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kCobaltJniPrefix);
-    g_checked_command_line = true;
-  }
-  return g_add_cobalt_prefix;
-}
-#endif
-
-ScopedJavaLocalRef<jclass> GetClassInternal(JNIEnv* env,
-#if BUILDFLAG(IS_COBALT)
-                                            const char* original_class_name,
-                                            jobject class_loader) {
-  const char* class_name;
-  std::string holder;
-  if (shouldAddCobaltPrefix()) {
-    holder = getRepackagedName(original_class_name);
-    class_name = holder.c_str();
-  } else {
-    class_name = original_class_name;
-  }
-#else
-                                            const char* class_name,
-                                            jobject class_loader) {
-#endif
-  jclass clazz;
-  if (class_loader != nullptr) {
-    // ClassLoader.loadClass expects a classname with components separated by
-    // dots instead of the slashes that JNIEnv::FindClass expects. The JNI
-    // generator generates names with slashes, so we have to replace them here.
-    // TODO(torne): move to an approach where we always use ClassLoader except
-    // for the special case of base::android::GetClassLoader(), and change the
-    // JNI generator to generate dot-separated names. http://crbug.com/461773
-    size_t bufsize = strlen(class_name) + 1;
-    char dotted_name[bufsize];
-    memmove(dotted_name, class_name, bufsize);
-    for (size_t i = 0; i < bufsize; ++i) {
-      if (dotted_name[i] == '/') {
-        dotted_name[i] = '.';
-      }
-    }
-
-    clazz = static_cast<jclass>(
-        env->CallObjectMethod(class_loader, g_class_loader_load_class_method_id,
-                              ConvertUTF8ToJavaString(env, dotted_name).obj()));
-  } else {
-    clazz = env->FindClass(class_name);
-  }
-  if (ClearException(env) || !clazz) {
-    LOG(FATAL) << "Failed to find class " << class_name;
-  }
-  return ScopedJavaLocalRef<jclass>(env, clazz);
->>>>>>> 71ccb5ab6f6 (CoAT changes to support Kimono build (#4506))
 }
 
 // Must be called before using GetClassFromSplit - we need to set the global,
@@ -189,164 +110,6 @@
   DCHECK(g_out_of_memory_error_class);
 }
 
-<<<<<<< HEAD
-=======
-bool IsVMInitialized() {
-  return g_jvm != nullptr;
-}
-
-JavaVM* GetVM() {
-  return g_jvm;
-}
-
-void DisableJvmForTesting() {
-  g_jvm = nullptr;
-}
-
-void InitGlobalClassLoader(JNIEnv* env) {
-  DCHECK(g_class_loader == nullptr);
-
-  ScopedJavaLocalRef<jclass> class_loader_clazz =
-      GetClass(env, "java/lang/ClassLoader");
-  CHECK(!ClearException(env));
-  g_class_loader_load_class_method_id =
-      env->GetMethodID(class_loader_clazz.obj(),
-                       "loadClass",
-                       "(Ljava/lang/String;)Ljava/lang/Class;");
-  CHECK(!ClearException(env));
-
-  // GetClassLoader() caches the reference, so we do not need to wrap it in a
-  // smart pointer as well.
-  g_class_loader = GetClassLoader(env);
-}
-
-ScopedJavaLocalRef<jclass> GetClass(JNIEnv* env,
-                                    const char* class_name,
-                                    const char* split_name) {
-  return GetClassInternal(env, class_name,
-                          GetSplitClassLoader(env, split_name));
-}
-
-ScopedJavaLocalRef<jclass> GetClass(JNIEnv* env, const char* class_name) {
-  return GetClassInternal(env, class_name, g_class_loader);
-}
-
-// This is duplicated with LazyGetClass below because these are performance
-// sensitive.
-jclass LazyGetClass(JNIEnv* env,
-                    const char* class_name,
-                    const char* split_name,
-                    std::atomic<jclass>* atomic_class_id) {
-  const jclass value = atomic_class_id->load(std::memory_order_acquire);
-  if (value)
-    return value;
-  ScopedJavaGlobalRef<jclass> clazz;
-  clazz.Reset(GetClass(env, class_name, split_name));
-  jclass cas_result = nullptr;
-  if (atomic_class_id->compare_exchange_strong(cas_result, clazz.obj(),
-                                               std::memory_order_acq_rel)) {
-    // We intentionally leak the global ref since we now storing it as a raw
-    // pointer in |atomic_class_id|.
-    return clazz.Release();
-  } else {
-    return cas_result;
-  }
-}
-
-// This is duplicated with LazyGetClass above because these are performance
-// sensitive.
-jclass LazyGetClass(JNIEnv* env,
-                    const char* class_name,
-                    std::atomic<jclass>* atomic_class_id) {
-  const jclass value = atomic_class_id->load(std::memory_order_acquire);
-  if (value)
-    return value;
-  ScopedJavaGlobalRef<jclass> clazz;
-  clazz.Reset(GetClass(env, class_name));
-  jclass cas_result = nullptr;
-  if (atomic_class_id->compare_exchange_strong(cas_result, clazz.obj(),
-                                               std::memory_order_acq_rel)) {
-    // We intentionally leak the global ref since we now storing it as a raw
-    // pointer in |atomic_class_id|.
-    return clazz.Release();
-  } else {
-    return cas_result;
-  }
-}
-
-template<MethodID::Type type>
-jmethodID MethodID::Get(JNIEnv* env,
-                        jclass clazz,
-                        const char* method_name,
-                        const char* jni_signature) {
-  auto get_method_ptr = type == MethodID::TYPE_STATIC ?
-      &JNIEnv::GetStaticMethodID :
-      &JNIEnv::GetMethodID;
-  jmethodID id = (env->*get_method_ptr)(clazz, method_name, jni_signature);
-  if (base::android::ClearException(env) || !id) {
-    LOG(FATAL) << "Failed to find " <<
-        (type == TYPE_STATIC ? "static " : "") <<
-        "method " << method_name << " " << jni_signature;
-  }
-  return id;
-}
-
-// If |atomic_method_id| set, it'll return immediately. Otherwise, it'll call
-// into ::Get() above. If there's a race, it's ok since the values are the same
-// (and the duplicated effort will happen only once).
-template <MethodID::Type type>
-jmethodID MethodID::LazyGet(JNIEnv* env,
-                            jclass clazz,
-                            const char* method_name,
-                            const char* jni_signature,
-                            std::atomic<jmethodID>* atomic_method_id) {
-  const jmethodID value = atomic_method_id->load(std::memory_order_acquire);
-  if (value)
-    return value;
-#if BUILDFLAG(IS_COBALT)
-  jmethodID id;
-  if (shouldAddCobaltPrefix()) {
-    std::string holder = getRepackagedName(jni_signature);
-    id = MethodID::Get<type>(env, clazz, method_name, holder.c_str());
-  } else {
-    id = MethodID::Get<type>(env, clazz, method_name, jni_signature);
-  }
-#else
-  jmethodID id = MethodID::Get<type>(env, clazz, method_name, jni_signature);
-#endif
-  atomic_method_id->store(id, std::memory_order_release);
-  return id;
-}
-
-// Various template instantiations.
-template jmethodID MethodID::Get<MethodID::TYPE_STATIC>(
-    JNIEnv* env, jclass clazz, const char* method_name,
-    const char* jni_signature);
-
-template jmethodID MethodID::Get<MethodID::TYPE_INSTANCE>(
-    JNIEnv* env, jclass clazz, const char* method_name,
-    const char* jni_signature);
-
-template jmethodID MethodID::LazyGet<MethodID::TYPE_STATIC>(
-    JNIEnv* env, jclass clazz, const char* method_name,
-    const char* jni_signature, std::atomic<jmethodID>* atomic_method_id);
-
-template jmethodID MethodID::LazyGet<MethodID::TYPE_INSTANCE>(
-    JNIEnv* env, jclass clazz, const char* method_name,
-    const char* jni_signature, std::atomic<jmethodID>* atomic_method_id);
-
-bool HasException(JNIEnv* env) {
-  return env->ExceptionCheck() != JNI_FALSE;
-}
-
-bool ClearException(JNIEnv* env) {
-  if (!HasException(env))
-    return false;
-  env->ExceptionDescribe();
-  env->ExceptionClear();
-  return true;
-}
->>>>>>> 71ccb5ab6f6 (CoAT changes to support Kimono build (#4506))
 
 void CheckException(JNIEnv* env) {
   if (!jni_zero::HasException(env)) {
