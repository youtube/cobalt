# Copyright 2021 The Cobalt Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# This provides the nasm_assemble() template which uses NASM to
# assemble assembly files.
#
# Files to be assembled with NASM should have an extension of .asm
#
# Example:
#
#   nasm_assemble("my_nasm_target") {
#     source = [
#       "example.asm",
#     ]
#     include_dirs = [ "assembly_include" ]
#   }

if (is_mac || is_ios) {
  if (current_cpu == "x86") {
    _nasm_flags = [ "-fmacho32" ]
  } else if (current_cpu == "x64") {
    _nasm_flags = [ "-fmacho64" ]
  }
} else if (is_posix || is_fuchsia) {
  if (current_cpu == "x86") {
    _nasm_flags = [ "-felf32" ]
  } else if (current_cpu == "x64") {
    _nasm_flags = [ "-felf64" ]
  }
} else if (is_win) {
  if (current_cpu == "x86") {
    _nasm_flags = [
      "-DPREFIX",
      "-fwin32",
    ]
  } else if (current_cpu == "x64") {
    _nasm_flags = [ "-fwin64" ]
  }
}

template("nasm_assemble") {
  assert(defined(invoker.sources), "Need sources defined for $target_name")
  assert(current_cpu == "x86" || current_cpu == "x64")

  action_name = "${target_name}_action"
  source_set_name = target_name

  action_foreach(action_name) {
    # Only the source set can depend on this.
    visibility = [ ":$source_set_name" ]

    script = "//starboard/build/run_bash.py"
    forward_variables_from(invoker,
                           [
                             "sources",
                             "inputs",
                             "deps",
                           ])

    # Flags.
    args = [ "$path_to_yasm" ]
    args += _nasm_flags
    if (defined(invoker.nasm_flags)) {
      args += invoker.nasm_flags
    }

    # User defined include dirs go first.
    if (defined(invoker.include_dirs)) {
      foreach(include, invoker.include_dirs) {
        # NASM does not append path separators when processing the -I flags,
        # so -Ifoo means includes of bar look up "foobar" rather than "foo/bar".
        # Add the trailing slash for it.
        args += [ "-I" + rebase_path(include, root_build_dir) + "/" ]
      }
    }

    # Default nasm include dirs. Make it match the native build (source root
    # and root generated code directory).
    # This goes to the end of include list. Note that, as above, we must
    # append path separators because NASM does not do it itself.
    args += [
      "-I./",

      # rebase_path("//") already includes a trailing slash.
      "-I" + rebase_path("//", root_build_dir),
      "-I" + rebase_path(root_gen_dir, root_build_dir) + "/",
    ]

    # Extra defines.
    if (defined(invoker.defines)) {
      foreach(def, invoker.defines) {
        args += [ "-D$def" ]
      }
    }

    # Output file.
    outputs = [
      "$root_out_dir/obj/third_party/libjpeg-turbo/{{source_name_part}}.asm.o",
    ]
    args += [
      "-o",
      rebase_path(outputs[0], root_build_dir),
      "{{source}}",
    ]

    depfile = outputs[0] + ".d"
  }

  # Gather the .o files into a linkable thing. This doesn't actually link
  # anything (a source set just compiles files to link later), but will pass
  # the object files generated by the action up the dependency chain.
  static_library(source_set_name) {
    if (defined(invoker.visibility)) {
      visibility = invoker.visibility
    }

    sources = get_target_outputs(":$action_name")

    # Do not publicize any header to remove build dependency
    public = []

    deps = [ ":$action_name" ]
  }
}
