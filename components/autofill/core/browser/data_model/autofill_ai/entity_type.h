// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_AUTOFILL_CORE_BROWSER_DATA_MODEL_AUTOFILL_AI_ENTITY_TYPE_H_
#define COMPONENTS_AUTOFILL_CORE_BROWSER_DATA_MODEL_AUTOFILL_AI_ENTITY_TYPE_H_

#include <ostream>
#include <string_view>
#include <type_traits>

#include "base/containers/span.h"
#include "base/notreached.h"
#include "base/types/optional_ref.h"
#include "base/types/pass_key.h"
#include "components/autofill/core/browser/country_type.h"
#include "components/autofill/core/browser/data_model/autofill_ai/entity_type_names.h"
#include "components/autofill/core/browser/field_types.h"
#include "components/autofill/core/common/dense_set.h"

namespace autofill {

// Entity and attribute types are blueprints for entity and attribute instances.
//
// For example, "passport" is an entity type and its attribute types include
// "name", "country", "issue date", "expiry date", etc.
//
// A specific passport is an entity instance, which has attribute instances with
// values such "John Doe", "USA", "05/2019", "04/2029", etc.
//
// Entity types are generated at compile time from the schema definition in
// entity_schema.json.
class EntityType;
class AttributeType;
class EntityTable;

// An attribute type is the blueprint for an attribute instance, which in turn
// represents a string value with additional metadata.
//
// An AttributeType is uniquely identified by its AttributeTypeName from
// entity_type_names.h generated by transpile_entity_schema.py. AttributeType is
// merely a thin wrapper with member functions.
class AttributeType final {
 public:
  // The underlying representation of the data stored in this attribute.
  enum class DataType {
    kCountry,
    kDate,
    kName,
    kState,
    kString,
    kMaxValue = kString,
  };

  // Comparator that ranks types by their priority for disambiguating different
  // instances of the same entity type, as specified in the schema.
  // `DisambiguationOrder(x, y) == true` means `x` has higher priority than `y`.
  //
  // For example, when disambiguating different passport instances, the name and
  // country should likely take precedence over the passport number.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  static bool DisambiguationOrder(const AttributeType& lhs,
                                  const AttributeType& rhs);

  constexpr explicit AttributeType(AttributeTypeName n) : name_(n) {}

  constexpr AttributeType(const AttributeType&) = default;
  constexpr AttributeType& operator=(const AttributeType&) = default;
  constexpr AttributeType(AttributeType&&) = default;
  constexpr AttributeType& operator=(AttributeType&&) = default;

  constexpr AttributeTypeName name() const { return name_; }

  EntityType entity_type() const;

  constexpr DataType data_type() const;

  // There are three kinds of AttributeType / FieldType associations:
  // - `field_type()` is the one that best describes the full attribute.
  //   Except for name types, the `field_type()` uniquely identifies the
  //   AttributeType.
  // - `field_subtypes()` additionally include more fine-granular ones.
  //   Except for name types, `field_subtypes() == {field_type}`.
  //   For name types, `field_subtypes()` includes `NAME_FIRST` etc.
  // - `storable_field_types()` are the ones that may be physically stored in
  //   the database.
  constexpr FieldType field_type() const;
  constexpr FieldTypeSet field_subtypes() const;
  FieldTypeSet storable_field_types(base::PassKey<EntityTable> pass_key) const;

  // Returns whether the attribute should be obfuscated in preview and
  // suggestion labels.
  bool is_obfuscated() const;

  // Whether this attribute type is part of the entity's disambiguating fields
  // list.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  bool is_disambiguation_type() const;

  // The string representation of the name. This is unique among all attribute
  // types of the associated entity type. (It is not globally unique!)
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  std::string_view name_as_string() const;

  // The i18n string representation of the name.
  std::u16string GetNameForI18n() const;

  friend constexpr bool operator==(const AttributeType& lhs,
                                   const AttributeType& rhs) = default;

  friend constexpr auto operator<=>(const AttributeType& lhs,
                                    const AttributeType& rhs) = default;

 private:
  AttributeTypeName name_{};
};

constexpr AttributeType::DataType AttributeType::data_type() const {
  switch (name_) {
    case AttributeTypeName::kDriversLicenseName:
    case AttributeTypeName::kFlightReservationPassengerName:
    case AttributeTypeName::kKnownTravelerNumberName:
    case AttributeTypeName::kNationalIdCardName:
    case AttributeTypeName::kPassportName:
    case AttributeTypeName::kRedressNumberName:
    case AttributeTypeName::kVehicleOwner:
      return DataType::kName;
    case AttributeTypeName::kNationalIdCardCountry:
    case AttributeTypeName::kPassportCountry:
      return DataType::kCountry;
    case AttributeTypeName::kDriversLicenseExpirationDate:
    case AttributeTypeName::kDriversLicenseIssueDate:
    case AttributeTypeName::kFlightReservationDepartureDate:
    case AttributeTypeName::kKnownTravelerNumberExpirationDate:
    case AttributeTypeName::kNationalIdCardIssueDate:
    case AttributeTypeName::kNationalIdCardExpirationDate:
    case AttributeTypeName::kPassportExpirationDate:
    case AttributeTypeName::kPassportIssueDate:
      return DataType::kDate;
    case AttributeTypeName::kDriversLicenseState:
    case AttributeTypeName::kVehiclePlateState:
      return DataType::kState;
    case AttributeTypeName::kDriversLicenseNumber:
    case AttributeTypeName::kFlightReservationFlightNumber:
    case AttributeTypeName::kFlightReservationTicketNumber:
    case AttributeTypeName::kFlightReservationConfirmationCode:
    case AttributeTypeName::kFlightReservationDepartureAirport:
    case AttributeTypeName::kFlightReservationArrivalAirport:
    case AttributeTypeName::kKnownTravelerNumberNumber:
    case AttributeTypeName::kNationalIdCardNumber:
    case AttributeTypeName::kPassportNumber:
    case AttributeTypeName::kRedressNumberNumber:
    case AttributeTypeName::kVehiclePlateNumber:
    case AttributeTypeName::kVehicleVin:
    case AttributeTypeName::kVehicleMake:
    case AttributeTypeName::kVehicleModel:
    case AttributeTypeName::kVehicleYear:
      return DataType::kString;
  }
  NOTREACHED();
}

constexpr FieldType AttributeType::field_type() const {
  switch (name_) {
    case AttributeTypeName::kDriversLicenseName:
      return NAME_FULL;
    case AttributeTypeName::kDriversLicenseState:
      return DRIVERS_LICENSE_REGION;
    case AttributeTypeName::kDriversLicenseNumber:
      return DRIVERS_LICENSE_NUMBER;
    case AttributeTypeName::kDriversLicenseExpirationDate:
      return DRIVERS_LICENSE_EXPIRATION_DATE;
    case AttributeTypeName::kDriversLicenseIssueDate:
      return DRIVERS_LICENSE_ISSUE_DATE;

    case AttributeTypeName::kFlightReservationPassengerName:
      return NAME_FULL;
    case AttributeTypeName::kFlightReservationFlightNumber:
      return FLIGHT_RESERVATION_FLIGHT_NUMBER;
    case AttributeTypeName::kFlightReservationTicketNumber:
      return FLIGHT_RESERVATION_TICKET_NUMBER;
    case AttributeTypeName::kFlightReservationConfirmationCode:
      return FLIGHT_RESERVATION_CONFIRMATION_CODE;
    case AttributeTypeName::kFlightReservationDepartureAirport:
      return FLIGHT_RESERVATION_DEPARTURE_AIRPORT;
    case AttributeTypeName::kFlightReservationArrivalAirport:
      return FLIGHT_RESERVATION_ARRIVAL_AIRPORT;
    case AttributeTypeName::kFlightReservationDepartureDate:
      return FLIGHT_RESERVATION_DEPARTURE_DATE;

    case AttributeTypeName::kKnownTravelerNumberNumber:
      return KNOWN_TRAVELER_NUMBER;
    case AttributeTypeName::kKnownTravelerNumberExpirationDate:
      return KNOWN_TRAVELER_NUMBER_EXPIRATION_DATE;
    case AttributeTypeName::kKnownTravelerNumberName:
      return NAME_FULL;

    case AttributeTypeName::kNationalIdCardName:
      return NAME_FULL;
    case AttributeTypeName::kNationalIdCardCountry:
      return NATIONAL_ID_CARD_ISSUING_COUNTRY;
    case AttributeTypeName::kNationalIdCardNumber:
      return NATIONAL_ID_CARD_NUMBER;
    case AttributeTypeName::kNationalIdCardIssueDate:
      return NATIONAL_ID_CARD_ISSUE_DATE;
    case AttributeTypeName::kNationalIdCardExpirationDate:
      return NATIONAL_ID_CARD_EXPIRATION_DATE;

    case AttributeTypeName::kPassportName:
      return NAME_FULL;
    case AttributeTypeName::kPassportNumber:
      return PASSPORT_NUMBER;
    case AttributeTypeName::kPassportCountry:
      return PASSPORT_ISSUING_COUNTRY;
    case AttributeTypeName::kPassportExpirationDate:
      return PASSPORT_EXPIRATION_DATE;
    case AttributeTypeName::kPassportIssueDate:
      return PASSPORT_ISSUE_DATE;

    case AttributeTypeName::kRedressNumberNumber:
      return REDRESS_NUMBER;
    case AttributeTypeName::kRedressNumberName:
      return NAME_FULL;

    case AttributeTypeName::kVehicleOwner:
      return NAME_FULL;
    case AttributeTypeName::kVehiclePlateNumber:
      return VEHICLE_LICENSE_PLATE;
    case AttributeTypeName::kVehicleVin:
      return VEHICLE_VIN;
    case AttributeTypeName::kVehicleMake:
      return VEHICLE_MAKE;
    case AttributeTypeName::kVehicleModel:
      return VEHICLE_MODEL;
    case AttributeTypeName::kVehicleYear:
      return VEHICLE_YEAR;
    case AttributeTypeName::kVehiclePlateState:
      return VEHICLE_PLATE_STATE;
  }
  NOTREACHED();
}

constexpr FieldTypeSet AttributeType::field_subtypes() const {
  if (data_type() == DataType::kName) {
    return FieldTypesOfGroup(FieldTypeGroup::kName);
  }
  return {field_type()};
}

template <>
struct DenseSetTraits<AttributeType> {
  using T = AttributeType;
  using N = AttributeTypeName;
  using UnderlyingType = std::underlying_type_t<N>;

  static constexpr T from_underlying(UnderlyingType x) {
    return T(static_cast<N>(x));
  }
  static constexpr UnderlyingType to_underlying(T x) {
    return base::to_underlying(x.name());
  }
  static constexpr bool is_valid(T x) { return true; }

  static constexpr auto kMinValue = T(static_cast<N>(0));
  static constexpr auto kMaxValue = T(N::kMaxValue);
  static constexpr bool kPacked = false;
};

// An entity type is the blueprint for an entity instance. It defines the
// available attributes and additional metadata.
//
// An EntityType is uniquely identified by its EntityTypeName from
// entity_type_names.h generated by transpile_entity_schema.py. EntityType is
// merely a thin wrapper with member functions.
class EntityType final {
 public:
  constexpr explicit EntityType(EntityTypeName n) : name_(n) {}

  constexpr EntityType(const EntityType&) = default;
  constexpr EntityType& operator=(const EntityType&) = default;
  constexpr EntityType(EntityType&&) = default;
  constexpr EntityType& operator=(EntityType&&) = default;

  // Comparator that ranks types by their priority for import on form
  // submission.
  // `ImportOrder(x, y) == true` means `x` has higher priority than `y`.
  static bool ImportOrder(const EntityType& lhs, const EntityType& rhs);

  constexpr EntityTypeName name() const { return name_; }

  // The string representation of the name. This is unique among all entity
  // types.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  std::string_view name_as_string() const;

  // The i18n string representation of the name.
  std::u16string GetNameForI18n() const;

  // The attributes supported by this entity type, as specified in the schema.
  // An instance of this entity may define values for some or all of these
  // attributes.
  //
  // For example, for a passport entity this may be the number, the name, the
  // country etc.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  DenseSet<AttributeType> attributes() const;

  // Required fields are a precondition for a form to be considered an
  // AutofillAi form. An AutofillAi form is a form where filling suggestions are
  // displayed, save/update prompts can appear after submission, specifics
  // metrics are emitted etc.
  //
  // The required fields are a list of set of attributes where only when at
  // least one of these sets is present, a form is considered to be AutofillAi.
  //
  // For example, for a passport the required fields may be {number} and
  // {expiry date}. Then the following forms would be considered AutofillAi
  // forms: {number}, {expiry date}, {number, name} but {name, country} would
  // not.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  base::span<const DenseSet<AttributeType>> required_fields() const;

  // An import constraint is a precondition for importing an EntityInstance on
  // form submission: it is a set of attributes all of which the instance must
  // set.
  // At least one of the import constraints must be satisfied.
  //
  // For example, for a passport the import constraints may be {number} and
  // {name, country}. Then it suffices for an instances to define either the
  // number or both the name and country.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  base::span<const DenseSet<AttributeType>> import_constraints() const;

  // A merge constraint is a precondition for merging two EntityInstances: it is
  // a set of attributes which both instances must agree on, i.e., they must set
  // it to the same value.
  // At least one of the merge constraints must be satisfied.
  //
  // Intuitively, the attributes of a merge constraint uniquely identify an
  // entity instances.
  //
  // For example, for a passport the two alternative constraints may be {number}
  // and {name, country, issue date} because passport numbers generally serve
  // as unique identifiers and also a single user usually only has one passport
  // per name, country, and date.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  base::span<const DenseSet<AttributeType>> merge_constraints() const;

  // A strike key is a tuple of attributes whose values are used as a key in the
  // strike database for save prompts.
  //
  // For example, a passport may have {number} and {name, country} as strike
  // keys. In that case we will stop showing save prompts for a given passport
  // number if save prompts with the same number have been ignored or declined
  // enough consecutive times. Similarly, we will stop showing save prompts for
  // a given (passport name, passport country) combination if the save prompts
  // with the same attribute values have been ignored or declined enough times
  // in a row.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  base::span<const DenseSet<AttributeType>> strike_keys() const;

  // Indicates if the entity is enabled.
  //
  // An entity can be:
  // - Disabled for all country codes, i.e., when gated behind a disabled
  //   feature flag. Such entities cannot be filled, imported, or created in
  //   settings.
  //   This is configured by specifying "experiment feature" in the entity
  //   schema.
  // - Disabled for specific country codes only. Such entities cannot be
  //   imported or created in settings, but they can be filled.
  //   This is configured by specifying "excluded geo-ips" in the entity schema.
  // - Enabled.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  bool enabled(base::optional_ref<const GeoIpCountryCode> country_code =
                   std::nullopt) const;

  // Indicates if the entity is read only.
  //
  // Read only entities cannot be updated nor created in Chrome settings.
  // If the flag is set to `true`, `import_constraints`, `merge_constraints`
  // and `strike_keys` must be empty - this is validated during schema
  // transpilation. This implies the entity cannot be imported or updated from
  // forms. The entity might be ingested from external data source, like Wallet.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  bool read_only() const;

  friend constexpr bool operator==(const EntityType& lhs,
                                   const EntityType& rhs) = default;

  friend constexpr auto operator<=>(const EntityType& lhs,
                                    const EntityType& rhs) = default;

 private:
  EntityTypeName name_{};
};

// Validates a raw value corresponding to an `EntityTypeName` object. Returns
// the corresponding enum value if valid, or `std::nullopt` otherwise.
std::optional<EntityTypeName> ToSafeEntityTypeName(
    std::underlying_type_t<EntityTypeName> raw_value);

template <>
struct DenseSetTraits<EntityType> {
  using T = EntityType;
  using N = EntityTypeName;
  using UnderlyingType = std::underlying_type_t<N>;

  static constexpr T from_underlying(UnderlyingType x) {
    return T(static_cast<N>(x));
  }
  static constexpr UnderlyingType to_underlying(T x) {
    return base::to_underlying(x.name());
  }
  static constexpr bool is_valid(T x) { return true; }

  static constexpr auto kMinValue = T(static_cast<N>(0));
  static constexpr auto kMaxValue = T(N::kMaxValue);
  static constexpr bool kPacked = false;
};

class EntityTable;

// Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
std::optional<EntityType> StringToEntityType(std::string_view entity_type_name);
std::optional<AttributeType> StringToAttributeType(
    EntityType entity_type,
    std::string_view attribute_type_name);

std::ostream& operator<<(std::ostream& os, AttributeType a);
std::ostream& operator<<(std::ostream& os, EntityType t);

}  // namespace autofill

#endif  // COMPONENTS_AUTOFILL_CORE_BROWSER_DATA_MODEL_AUTOFILL_AI_ENTITY_TYPE_H_
