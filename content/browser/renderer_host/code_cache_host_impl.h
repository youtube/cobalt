// Copyright 2018 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CONTENT_BROWSER_RENDERER_HOST_CODE_CACHE_HOST_IMPL_H_
#define CONTENT_BROWSER_RENDERER_HOST_CODE_CACHE_HOST_IMPL_H_

#include <string>

#include "base/memory/raw_ptr.h"
#include "base/memory/scoped_refptr.h"
#include "base/sequence_checker.h"
#include "build/build_config.h"
#include "components/services/storage/public/mojom/cache_storage_control.mojom-forward.h"
#include "content/common/content_export.h"
#include "mojo/public/cpp/base/big_buffer.h"
#include "mojo/public/cpp/bindings/pending_receiver.h"
#include "mojo/public/cpp/bindings/receiver_set.h"
#include "mojo/public/cpp/bindings/unique_receiver_set.h"
#include "net/base/network_isolation_key.h"
#include "third_party/blink/public/common/storage_key/storage_key.h"
#include "third_party/blink/public/mojom/loader/code_cache.mojom.h"

class GURL;

namespace content {

class GeneratedCodeCache;
class GeneratedCodeCacheContext;

// An abstract base for an implementation of a CodeCacheHost, which stores and
// retrieves resource metadata (either bytecode or native code) generated by a
// renderer process. A concrete implementation is selected at runtime via
// CodeCacheHostImpl::Create on the basis of the
// `UsePersistentCacheForCodeCache` feature. When enabled, inserts take place in
// the browser process while fetches take place in renderers via
// CodeCacheWithPersistentCacheHostImpl in blink.
//
// When PersistentCache is not used, there are two independent caches:
//
//  GeneratedCodeCache:
//    Entries are keyed by URL, cache type, and network isolation key.
//    See: - `DidGenerateCacheableMetadata`
//         - `FetchCachedCode`
//         - `ClearCodeCacheEntry`
//
//  CacheStorage:
//    Entries are keyed by URL, cache name, and storage key.
//    This class only supports writing such data. Data is stored as
//    "side data" in the cache storage cache.
//    See: - `DidGenerateCacheableMetadataInCacheStorage`
//         - `CacheStorageCache::WriteSideData`
//
// When PersistentCache is used, there is an independent cache for each origin
// lock so that renderers can be given read-only access to a cache for lookups
// without the cost of IPC messages back to the browser.
//
// This class is sequence-friendly and is not necessarily bound to a physical
// thread.
class CONTENT_EXPORT CodeCacheHostImpl : public blink::mojom::CodeCacheHost {
 public:
  // Holds a receiver set which will automatically add and clear receivers on
  // the code cache thread.
  class ReceiverSet {
   public:
    explicit ReceiverSet(
        scoped_refptr<GeneratedCodeCacheContext> generated_code_cache_context);
    ~ReceiverSet();

    using CodeCacheHostReceiverHandler = base::OnceCallback<void(
        CodeCacheHostImpl*,
        mojo::ReceiverId,
        mojo::UniqueReceiverSet<blink::mojom::CodeCacheHost>&)>;
    void Add(int render_process_id,
             const net::NetworkIsolationKey& nik,
             const blink::StorageKey& storage_key,
             mojo::PendingReceiver<blink::mojom::CodeCacheHost> receiver,
             CodeCacheHostReceiverHandler handler);
    void Add(int render_process_id,
             const net::NetworkIsolationKey& nik,
             const blink::StorageKey& storage_key,
             mojo::PendingReceiver<blink::mojom::CodeCacheHost> receiver);
    void Clear();

   private:
    scoped_refptr<GeneratedCodeCacheContext> generated_code_cache_context_;
    std::unique_ptr<mojo::UniqueReceiverSet<blink::mojom::CodeCacheHost>,
                    base::OnTaskRunnerDeleter>
        receiver_set_;
  };

  // Returns a new instance on the basis of the `UsePersistentCacheForCodeCache`
  // feature. |render_process_id| is used to get the storage partition that
  // should be used by the fetch requests. This could be null in tests that use
  // SetCacheStorageControlForTesting.
  static std::unique_ptr<CodeCacheHostImpl> Create(
      int render_process_id,
      scoped_refptr<GeneratedCodeCacheContext> generated_code_cache_context,
      const net::NetworkIsolationKey& nik,
      const blink::StorageKey& storage_key);

  CodeCacheHostImpl(const CodeCacheHostImpl&) = delete;
  CodeCacheHostImpl& operator=(const CodeCacheHostImpl&) = delete;

  ~CodeCacheHostImpl() override;

  void SetCacheStorageControlForTesting(
      storage::mojom::CacheStorageControl* cache_storage_control);

  static void SetUseEmptySecondaryKeyForTesting();

 protected:
  CodeCacheHostImpl(
      int render_process_id,
      scoped_refptr<GeneratedCodeCacheContext> generated_code_cache_context,
      const net::NetworkIsolationKey& nik,
      const blink::StorageKey& storage_key);

  int render_process_id() const { return render_process_id_; }

  GeneratedCodeCacheContext* generated_code_cache_context() {
    return generated_code_cache_context_.get();
  }

  const net::NetworkIsolationKey& network_isolation_key() const {
    return network_isolation_key_;
  }

  const blink::StorageKey& storage_key() const { return storage_key_; }

  SEQUENCE_CHECKER(sequence_checker_);

 private:
  FRIEND_TEST_ALL_PREFIXES(CodeCacheHostImplTest,
                           PersistentCacheWriteAndReadFullIsolationSetup);
  FRIEND_TEST_ALL_PREFIXES(CodeCacheHostImplTest,
                           PersistentCacheNoCachingWhenNoProperIsolation);
  FRIEND_TEST_ALL_PREFIXES(
      CodeCacheHostImplTest,
      PersistentCacheLockedAndUnlockedProcessesShareNoData);

  // blink::mojom::CodeCacheHost:
  void DidGenerateCacheableMetadataInCacheStorage(
      const GURL& url,
      base::Time expected_response_time,
      mojo_base::BigBuffer data,
      const std::string& cache_storage_cache_name) override;

  // Our render process host ID, used to bind to the correct render process.
  const int render_process_id_;

  const scoped_refptr<GeneratedCodeCacheContext> generated_code_cache_context_;

  // The key used to partition code cached in the `GeneratedCodeCache`.
  const net::NetworkIsolationKey network_isolation_key_;

  // The key used to partition code cached in the cache API.
  const blink::StorageKey storage_key_;

  // Used to override the CacheStorageControl from the RHPI as needed.
  raw_ptr<storage::mojom::CacheStorageControl>
      cache_storage_control_for_testing_ = nullptr;
};

}  // namespace content

#endif  // CONTENT_BROWSER_RENDERER_HOST_CODE_CACHE_HOST_IMPL_H_
