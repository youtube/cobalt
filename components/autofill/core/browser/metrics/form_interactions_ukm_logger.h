// Copyright 2024 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_AUTOFILL_CORE_BROWSER_METRICS_FORM_INTERACTIONS_UKM_LOGGER_H_
#define COMPONENTS_AUTOFILL_CORE_BROWSER_METRICS_FORM_INTERACTIONS_UKM_LOGGER_H_

#include <optional>

#include "base/memory/raw_ptr.h"
#include "base/memory/raw_ref.h"
#include "base/time/time.h"
#include "base/types/pass_key.h"
#include "components/autofill/core/browser/data_model/payments/credit_card.h"
#include "components/autofill/core/browser/form_structure.h"
#include "components/autofill/core/browser/foundations/autofill_client.h"
#include "components/autofill/core/browser/metrics/autofill_metrics.h"
#include "components/autofill/core/browser/metrics/prediction_quality_metrics.h"
#include "services/metrics/public/cpp/ukm_recorder.h"
#include "services/metrics/public/cpp/ukm_source_id.h"

namespace autofill::autofill_metrics {

// To reduce traffic, only a random sample of browser sessions upload UKM data.
// This function returns whether we should record autofill UKM events for the
// current session.
bool ShouldRecordUkm();

class UkmTimestampPin;

// Utility to log URL keyed form interaction events.
// Owned by AutofillClient. Therefore, it must not have page-specific state. In
// particular, the page-specific `ukm::SourceId`s must be passed as a parameter.
class FormInteractionsUkmLogger {
 public:
  // The autofill statuses of a field that are recorded into UKM to help us
  // understand the autofill performance and user behaviors.
  // These values are persisted to logs. Entries should not be renumbered and
  // numeric values should never be reused.
  enum class AutofillStatus {
    kIsFocusable = 0,
    // kWasFocusedByTapOrClick indicates that autofill was queried to
    // potentially show a suggestions (a focus-by-tab-key or focus-on-pageload
    // is insufficient).
    kWasFocusedByTapOrClick = 1,
    // Indicates that the user accepted an autofill suggestion which affected
    // this field (the suggestion was generated by focus on this or another
    // field of the form). Note that this event is recorded regardless whether
    // the iframe autofill security policy permitted to fill the field or not.
    kWasAutofillTriggeredAnywhereOnForm = 2,
    // kShouldBeAutofilledBeforeSecurityPolicy indicates that the user asked to
    // autofill this field (by accepting a suggestion while this or another
    // field was focused).
    // Note that this is set before checking the iframe security policy.
    // This value is true even when the filling was prevented because of the
    // cross iframe autofill security policy.
    kShouldBeAutofilledBeforeSecurityPolicy = 3,
    // Indicates whether the field was ever refilled due to a change in a
    // dynamic form. (see FormFiller::TriggerRefill()).
    kWasRefill = 4,
    // The below suggestion statuses are set only when kWasFocused is set.
    kSuggestionWasAvailable = 5,
    kSuggestionWasShown = 6,
    // A suggestion was shown and accepted on this specific field. This is
    // recorded regardless whether security policies allowed filling.
    kWasAutofillTriggeredOnField = 7,
    kUserTypedIntoField = 8,
    kFilledValueWasModified = 9,
    kHadValueBeforeFilling = 10,
    kHadTypedOrFilledValueAtSubmission = 11,
    kIsInSubFrame = 12,
    kFillingPreventedByIframeSecurityPolicy = 13,
    // The field was sent to the renderer for autofilling. Note that this is
    // still true if the user later edited the autofilled value.
    kWasAutofilledAfterSecurityPolicy = 14,
    kWasFocused = 15,
    kMaxValue = kWasFocused
  };

  using FormEventSetTraits =
      EnumDenseSetTraits<FormEvent,
                         static_cast<FormEvent>(0),
                         static_cast<FormEvent>(NUM_FORM_EVENTS - 1)>;
  using FormEventSet = DenseSet<FormEvent, FormEventSetTraits>;

  explicit FormInteractionsUkmLogger(AutofillClient* autofill_client);

  bool has_pinned_timestamp(base::PassKey<UkmTimestampPin> pass_key) const {
    return !pinned_timestamp_.is_null();
  }
  void set_pinned_timestamp(base::TimeTicks t,
                            base::PassKey<UkmTimestampPin> pass_key) {
    pinned_timestamp_ = t;
  }

  void LogInteractedWithForm(ukm::SourceId ukm_source_id,
                             bool is_for_credit_card,
                             size_t local_record_type_count,
                             size_t server_record_type_count,
                             FormSignature form_signature);
  void LogSuggestionsShown(ukm::SourceId ukm_source_id,
                           const FormStructure& form,
                           const AutofillField& field,
                           base::TimeTicks form_parsed_timestamp,
                           bool off_the_record);
  // For address suggestions, the `record_type` is irrelevant.
  void LogDidFillSuggestion(
      ukm::SourceId ukm_source_id,
      const FormStructure& form,
      const AutofillField& field,
      std::optional<CreditCard::RecordType> record_type = std::nullopt);
  void LogTextFieldValueChanged(ukm::SourceId ukm_source_id,
                                const FormStructure& form,
                                const AutofillField& field);
  void LogEditedAutofilledFieldAtSubmission(ukm::SourceId ukm_source_id,
                                            const FormStructure& form,
                                            const AutofillField& field);
  void LogFieldFillStatus(ukm::SourceId ukm_source_id,
                          const FormStructure& form,
                          const AutofillField& field,
                          QualityMetricType metric_type);
  void LogFieldType(ukm::SourceId ukm_source_id,
                    base::TimeTicks form_parsed_timestamp,
                    FormSignature form_signature,
                    FieldSignature field_signature,
                    QualityMetricPredictionSource prediction_source,
                    QualityMetricType metric_type,
                    FieldType predicted_type,
                    FieldType actual_type);
  void LogAutofillFieldInfoAtFormRemove(
      ukm::SourceId ukm_source_id,
      const FormStructure& form,
      const AutofillField& field,
      AutofillMetrics::AutocompleteState autocomplete_state);
  void LogAutofillFormSummaryAtFormRemove(
      ukm::SourceId ukm_source_id,
      const FormStructure& form_structure,
      FormEventSet form_events,
      base::TimeTicks initial_interaction_timestamp,
      base::TimeTicks form_submitted_timestamp);
  void LogAutofillFormWithExperimentalFieldsCountAtFormRemove(
      ukm::SourceId ukm_source_id,
      const FormStructure& form_structure);
  void LogFocusedComplexFormAtFormRemove(
      ukm::SourceId ukm_source_id,
      const FormStructure& form_structure,
      FormEventSet form_events,
      base::TimeTicks initial_interaction_timestamp,
      base::TimeTicks form_submitted_timestamp);
  void LogKeyMetrics(ukm::SourceId ukm_source_id,
                     const DenseSet<FormTypeNameForLogging>& form_types,
                     bool data_to_fill_available,
                     bool suggestions_shown,
                     bool edited_autofilled_field,
                     bool suggestion_filled,
                     const FormInteractionCounts& form_interaction_counts,
                     const FormInteractionsFlowId& flow_id,
                     std::optional<int64_t> fast_checkout_run_id);
  void LogFormEvent(ukm::SourceId ukm_source_id,
                    FormEvent form_event,
                    const DenseSet<FormTypeNameForLogging>& form_types,
                    base::TimeTicks form_parsed_timestamp);

  // Logs whether the autofill decided to skip or to fill each
  // hidden/representational field.
  void LogHiddenRepresentationalFieldSkipDecision(ukm::SourceId ukm_source_id,
                                                  const FormStructure& form,
                                                  const AutofillField& field,
                                                  bool is_skipped);

 private:
  bool CanLog(ukm::SourceId ukm_source_id) const;
  int64_t MillisecondsSinceFormParsed(
      base::TimeTicks form_parsed_timestamp) const;

  const raw_ref<AutofillClient> autofill_client_;

  // The pinned timestamp is used to that metrics logged sequentially refer to
  // the same timestamp to determine MillisecondsSinceFormParsed().
  //
  // For example, in
  //   UkmTimestampPin timestamp_pin(&logger);
  //   LogFoo(&logger);
  //   LogBar(&logger);
  // all logged metrics use the same value for MillisecondsSinceFormParsed().
  base::TimeTicks pinned_timestamp_;
};

// Utility class to pin the timestamp used by the FormInteractionsUkmLogger
// while an instance of this class is in scope. Pinned timestamps cannot be
// nested.
class UkmTimestampPin {
 public:
  UkmTimestampPin() = delete;

  explicit UkmTimestampPin(FormInteractionsUkmLogger* logger);

  UkmTimestampPin(const UkmTimestampPin&) = delete;
  UkmTimestampPin& operator=(const UkmTimestampPin&) = delete;

  ~UkmTimestampPin();

 private:
  const raw_ref<FormInteractionsUkmLogger> logger_;
};

// This defines a second-to-minute-scale prioritized set of buckets for
// recording user interaction time with forms. Pure exponential bucketing is
// generally not appropriate for analyzing interactions at this time scale, as
// we tend not to care about durations at the millisecond level, while small
// changes at the 2-3 minute scale may be invisible with exponential buckets.
// This set of buckets contains a large linear section between 1 and 30s, and
// between 30s and 10m, after which it proceeds in the same way as
// ukm::GetSemanticBucketMinForDurationTiming
int64_t GetSemanticBucketMinForAutofillDurationTiming(int64_t sample);

}  // namespace autofill::autofill_metrics

#endif  // COMPONENTS_AUTOFILL_CORE_BROWSER_METRICS_FORM_INTERACTIONS_UKM_LOGGER_H_
