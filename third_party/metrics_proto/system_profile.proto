// Copyright 2014 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto2";

option optimize_for = LITE_RUNTIME;
option java_package = "org.chromium.components.metrics";

option java_outer_classname = "SystemProfileProtos";

package metrics;

import "extension_install.proto";

// Stores information about the user's brower and system configuration.
// Almost all the fields should be populated on every upload. (The only
// exception is some fields in the stability section that are only uploaded
// once per browsing session, usually shortly after startup.)
// Next tag: 44
message SystemProfileProto {
  // The time when the client was compiled/linked, in seconds since the epoch.
  optional int64 build_timestamp = 1;

  // A version number string for the application.
  // Most commonly this is the browser version number found in a user agent
  // string, and is typically a 4-tuple of numbers separated by periods.  In
  // cases where the user agent version might be ambiguous (example: Linux 64-
  // bit build, rather than 32-bit build, or a Windows version used in some
  // special context, such as ChromeFrame running in IE), then this may include
  // some additional postfix to provide clarification not available in the UA
  // string.
  //
  // An example of a browser version 4-tuple is "5.0.322.0".  Currently used
  // postfixes are:
  //
  //   "-64": a 64-bit build
  //   "-F": Chrome is running under control of ChromeFrame
  //   "-devel": this is not an official build of Chrome
  //
  // A full version number string could look similar to:
  // "5.0.322.0-F-devel".
  //
  // This value, when available, is more trustworthy than the UA string
  // associated with the request; and including the postfix, may be more
  // specific.
  optional string app_version = 2;

  // The application can create logs about previous versions. In particular the
  // initial stability log refers to the previous run, which can be an older
  // version. This field is set by the client when the log being written has an
  // app_version that's different than the version of the app writing the log.
  // Note that the version uploading the log may also be different.
  optional string log_written_by_app_version = 40;

  // The brand code or distribution tag assigned to a partner, if available.
  // Brand codes are only available on Windows.  Not every Windows install
  // though will have a brand code.
  optional string brand_code = 12;

  // The possible channels for an installation, from least to most stable.
  enum Channel {
    CHANNEL_UNKNOWN = 0;  // Unknown channel -- perhaps an unofficial build?
    CHANNEL_CANARY = 1;
    CHANNEL_DEV = 2;
    CHANNEL_BETA = 3;
    CHANNEL_STABLE = 4;
  }
  optional Channel channel = 10;

  // True for a client following updates on the extended stable channel;
  // see go/chrome-extended-dd.
  optional bool is_extended_stable_channel = 36 [default = false];

  // True if Chrome build is instrumented (e.g. built with ASAN instrumentation
  // or with DCHECKs enabled).
  // This field was renamed from |is_asan_build| to reflect its actual meaning.
  optional bool is_instrumented_build = 20 [default = false];

  // For Chrome, the date the user enabled UMA, in seconds since the epoch.
  // If the user has toggled the UMA enabled state multiple times, this will
  // be the most recent date on which UMA was enabled.
  // For privacy, this is rounded to the nearest hour (M30+).
  // For WebView, the field stores the date "January 1st, 2014 00:00:00 UTC"
  // if the user opted into metrics collection before WebView started tracking
  // this information. Otherwise, the field value should correctly reflect the
  // first startup for this app after the user opted into metrics collection.
  optional int64 uma_enabled_date = 3;

  // The time when the client was installed, in seconds since the epoch.
  // For privacy, this is rounded to the nearest hour.
  optional int64 install_date = 16;

  // A message about the cloned install detection that helps improve data
  // quality by identifying potential VMs and bots. This message will be
  // set in every record after the client has ever been reset due to cloned
  // install detection. However, the `cloned_from_client_id`
  // field will only be set in the resetting session because this is not
  // persisted in the local prefs.
  // Next tag: 5
  message ClonedInstallInfo {
    // The latest timestamp we reset a cloned client’s client id, in seconds
    // since the epoch. For privacy, this is rounded to the nearest hour.
    optional int64 last_timestamp = 1;

    // The client_id that this client is cloned from. This field is tied to the
    // cloned install detector only; any other way of resetting client_id
    // doesn't touch this field. This field is only reported in the
    // resetting session.
    optional fixed64 cloned_from_client_id = 2;

    // The first timestamp when we reset a cloned client’s client id, in seconds
    // since the epoch. For privacy, this is rounded to the nearest hour.
    optional int64 first_timestamp = 3;

    // The number of times this client has been reset due to cloned install.
    // Increment by one per reset happens.
    optional int32 count = 4;
  }
  optional ClonedInstallInfo cloned_install_info = 39;

  // The non-identifying low entropy source value. This value seeds the
  // pseudorandom generator which picks experimental groups. Clients only report
  // the value that they used for picking experimental groups on startup which
  // means this value won't be changed within the session even even if the low
  // entropy source is reset (e.g. via the UMA checkbox) because group
  // assignments won't be changed until restart.
  optional int32 low_entropy_source = 31;

  // The old low entropy value. This value is thought to be biased in the wild,
  // and is no longer used for experiments requiring low entropy. Clients which
  // already have an "old" value continue incorporating it into the high entropy
  // source, to avoid changing those group assignments. New clients only have
  // the new source.
  optional int32 old_low_entropy_source = 32;

  // A pseudo low entropy value. The actual low_entropy_source value is used for
  // assignment to experiment arms, and this use may cause drift over time (for
  // example, if a bad experiment arm drives away some users permanently.) This
  // pseudo low entropy value is generated identically to low_entropy_source,
  // but it is generated with a different randomization seed and is not used for
  // experiment randomization. Consequently, it can be used in statistical
  // validation to answer the question of how our data would be distributed if
  // we didn't have to worry about low entropy source drift.
  optional int32 pseudo_low_entropy_source = 37;

  // The user's selected application locale, i.e. the user interface language.
  // The locale includes a language code and, possibly, also a country code,
  // e.g. "en-US".
  optional string application_locale = 4;

  // Hashes of command line keys used in the browser session when the MetricsLog
  // is created. This takes into account the command line switches that were
  // used when launching the session, as well as any modifications made to them,
  // for example via CommandLine::AppendSwitch and CommandLine::RemoveSwitch.
  // Values are the lower 32-bit of SHA1 hash in little-endian.
  repeated fixed32 command_line_key_hash = 38 [packed = true];

  // Information on the user's operating system.
  // Next tag: 11
  message OS {
    // The user's operating system. This should be one of:
    // - 'Android'
    // - 'Windows NT'
    // - 'CrOS' (as of 07/2020)
    // - 'Lacros'  (the Lacros browser runs on Chrome OS, but reports a special
    //              OS name to differentiate itself from the built-in ash
    //              browser + window manager binary.)
    // - 'Linux' (includes ChromeOS prior to 07/2020)
    // - 'iOS' (iOS versions >= 9)
    // - 'iPhone OS' (iOS versions <= 8)
    // - 'iPadOS'
    // - 'Mac OS X'
    optional string name = 1;

    // The version of the OS.  The meaning of this field is OS-dependent.
    optional string version = 2;

    // The fingerprint of the build.  This field is used only on Android.
    optional string build_fingerprint = 3;

    // Whether the version of iOS appears to be "jailbroken". This field is
    // used only on iOS. Chrome for iOS detects whether device contains a
    // DynamicLibraries/ directory. It's a necessary but insufficient indicator
    // of whether the operating system has been jailbroken.
    // Deprecated 01/2023. This was never set.
    optional bool DEPRECATED_is_jailbroken = 4 [deprecated = true];

    // The build number for the OS version. The same OS version may have a
    // different build number. The meaning of this field is OS-dependent.
    optional string build_number = 5;

    // The version of the kernel. Linux based operating systems, such as
    // ChromeOS and Android, have a kernel version that the OS release version
    // was built with that differs from the version field above.
    optional string kernel_version = 6;

    // Information on ChromeOS ARC runtime. This is collected to ease analysis
    // on ARC-specific metrics, since this info varies by different boards /
    // build configs / releases.
    // Next tag: 2
    message Arc {
      // Android release number from build.prop "ro.build.version.release", e.g.
      // "7.1.1" for N and "9" for P.
      optional string release = 1;
    }
    // Available since M76. This field is reported if current build supports
    // ARC, regardless of whether ARC is enabled or not. Check "Arc.State"
    // histogram to determine if ARC is enabled for current report.
    // Logged on ChromeOS only.
    optional Arc arc = 7;

    // Data related to system-level dark mode configuration. This is currently
    // only uploaded on Android. "*_APP" variants are included to reflect when
    // the user overrides the system configuration within the browser
    enum DarkModeState {
      UNKNOWN = 0;

      // Both the system and the browser are in dark mode.
      DARK_MODE_SYSTEM = 1;

      // The browser is in dark mode, but the state of the system either cannot
      // be determined or has been overridden by the user.
      DARK_MODE_APP = 2;

      // Both the system and the browser are in light mode.
      LIGHT_MODE_SYSTEM = 3;

      // The browser is in light mode, but the state of the system either cannot
      // be determined or has been overridden by the user.
      LIGHT_MODE_APP = 4;
    }
    optional DarkModeState dark_mode_state = 8 [default = UNKNOWN];

    // The value returned by the "XDG_SESSION_TYPE" environment variable, as
    // translated to a base::nix::SessionType, this field is only set on Linux.
    // Some features are enabled/disabled depending on this value.
    enum XdgSessionType {
      UNSET = 0;
      OTHER_SESSION_TYPE = 1;
      UNSPECIFIED = 2;
      TTY = 3;
      X11 = 4;
      WAYLAND = 5;
      MIR = 6;
    }
    optional XdgSessionType xdg_session_type = 9;

    // The value returned by the "XDG_CURRENT_DESKTOP" environment variable, as
    // translated to a base::nix::DesktopEnvironment. Note that all KDE values
    // from that enum are bucketed together. This field is only set on Linux.
    // Some bugs reproduce only in particular desktop environments.
    enum XdgCurrentDesktop {
      OTHER = 0;
      CINNAMON = 1;
      DEEPIN = 2;
      GNOME = 3;
      KDE = 4;
      PANTHEON = 5;
      UKUI = 6;
      UNITY = 7;
      XFCE = 8;
      LXQT = 9;
    }
    optional XdgCurrentDesktop xdg_current_desktop = 10;
  }
  optional OS os = 5;

  // Information on the user's hardware.
  // Next tag: 27
  message Hardware {
    // OS CPU architecture. Common options are: x86, x86_64, arm64, armv7,
    // armv7l, armv8l and aarch64.
    // Note: On Windows, this is not the true OS CPU architecture in the case
    // of running under emulation (e.g. on Windows on ARM, which would report
    // either x86 or x86_64, depending on the bitness of the exe being run).
    // Started being correctly recorded on iOS in M90: crrev/c/2723012.
    optional string cpu_architecture = 1;

    // Browser process CPU architecture. Will be different from
    // `cpu_architecture` in the case where Chromium runs non-natively (e.g.
    // macOS Rosetta or Arm Windows). One of four values: x86, x86_64, ARM,
    // ARM_64. Added in M90.
    optional string app_cpu_architecture = 21;

    // The amount of RAM present on the system, in megabytes.
    optional int64 system_ram_mb = 2;

    // The base memory address that chrome.dll was loaded at.
    // (Logged only on Windows.)
    optional int64 dll_base = 3;

    // The hardware_class describes the current machine model, e.g. "MacPro1,1"
    // on Mac, "iPhone9,3" on iOS or "Nexus 5" on Android. Implemented on OS X,
    // iOS, Android, Chrome OS.
    //
    // The iOS device hardware class was added in Chrome M60 release. Prior
    // to that, device hardware class was incorrectly recorded in
    // cpu_architecture field.
    //
    // For Chrome OS, prior to M69, this field had the value that is
    // currently in |full_hardware_class| field. In M69+, this contains the
    // board name only. E.G. "CELES", "VEYRON_MINNIE".

    optional string hardware_class = 4;

    // This field is only sent on Chrome OS. The full hardware class is a unique
    // string associated with each Chrome OS device product revision generally
    // assigned at hardware qualification time. The hardware class effectively
    // identifies the configured system components such as CPU, WiFi adapter,
    // etc.
    //
    // An example of such a hardware class is "IEC MARIO PONY 6101".  An
    // internal database associates this hardware class with the qualified
    // device specifications including OEM information, schematics, hardware
    // qualification reports, test device tags, etc.
    optional string full_hardware_class = 18;

    // This field is only sent on Chrome OS devices with cellular support.
    // This represents the variant of cellular modem present on the device.
    optional string cellular_device_variant = 24;

    // The number of physical screens.
    optional int32 screen_count = 5;

    // The screen dimensions of the primary screen, in pixels.
    optional int32 primary_screen_width = 6;
    optional int32 primary_screen_height = 7;

    // The device scale factor of the primary screen.
    optional float primary_screen_scale_factor = 12;

    // Max DPI for any attached screen. (Windows only)
    optional float max_dpi_x = 9;
    optional float max_dpi_y = 10;

    // The form factor of the device. Added in M101.
    // Android devices can be phone, tablet, or TV. iOS devices can be phone or
    // tablet. For Windows, Mac, ChromeOS, Lacros, and Linux, the desktop form
    // factor is always used.
    enum FormFactor {
      FORM_FACTOR_UNKNOWN = 0;
      FORM_FACTOR_DESKTOP = 1;
      FORM_FACTOR_PHONE = 2;
      FORM_FACTOR_TABLET = 3;
      FORM_FACTOR_TV = 4;
      FORM_FACTOR_MEET_DEVICE = 5;
      FORM_FACTOR_AUTOMOTIVE = 6;
    }
    optional FormFactor form_factor = 22;

    // Information on the CPU obtained by CPUID.
    message CPU {
      // A 12 character string naming the vendor, e.g. "GenuineIntel".
      optional string vendor_name = 1;

      // The signature reported by CPUID (from EAX).
      optional uint32 signature = 2;

      // Number of logical processors/cores on the current machine, which
      // includes hyperthreaded cores.
      optional uint32 num_cores = 3;

      // Whether the CPU is running in a hypervisor.
      optional bool is_hypervisor = 4;
    }
    optional CPU cpu = 13;

    // Type of BIOS (can change at each boot).
    enum BiosType {
      BIOS_TYPE_UNKNOWN = 0;
      // Legacy BIOS or UEFI with CSM mode.
      BIOS_TYPE_LEGACY = 1;
      // BIOS is UEFI and booted into UEFI mode.
      BIOS_TYPE_UEFI = 2;
    }
    // Motherboard information.
    message Motherboard {
      // Manufacturer for the motherboard.
      optional string manufacturer = 1;
      // Model for the motherboard.
      optional string model = 2;
      // Manufacturer for the BIOS.
      optional string bios_manufacturer = 3;
      // Version of the BIOS currently installed.
      optional string bios_version = 4;
      // What mode of BIOS is booted.
      optional BiosType bios_type = 5;
    }
    optional Motherboard motherboard = 25;

    // Information on the GPU
    message Graphics {
      // The GPU manufacturer's vendor id.
      optional uint32 vendor_id = 1;

      // The GPU manufacturer's device id for the chip set.
      optional uint32 device_id = 2;

      // The driver version on the GPU.
      optional string driver_version = 3;

      // The GL_VENDOR string. An example of a gl_vendor string is
      // "Imagination Technologies". "" if we are not using OpenGL.
      optional string gl_vendor = 6;

      // The GL_RENDERER string. An example of a gl_renderer string is
      // "PowerVR SGX 540". "" if we are not using OpenGL.
      optional string gl_renderer = 7;
    }
    optional Graphics gpu = 8;

    // Whether the internal display produces touch events. Omitted if unknown.
    // Logged on ChromeOS only.
    optional bool internal_display_supports_touch = 14;

    // Internal storage device information on ChromeOS. Added in M94.
    // Next tag: 9
    message InternalStorageDevice {
      // Id of the storage device manufacturer.
      // Can be vendor_id (for NVMe, 32bit), manfid (for eMMC, 16bit, since
      // M113), oemid (for eMMC, 16bit, before M113), JEDEC manfid (for UFS,
      // 16bit) etc. depending on the device type.
      optional uint32 vendor_id = 1;

      // Id of the storage device product.
      // Can be product_id (for NVMe, 32bit), PNM (for eMMC, 48bit), hashed
      // model name (for UFS, 32bit) etc. depending on the device type.
      optional uint64 product_id = 2;

      // Revision of the storage device product.
      // Can be PCIe rev (for NVMe, 8bit), PRV(for eMMC, 8bit) etc. depending on
      // the device type.
      optional uint32 revision = 3;

      // Storage Device model. Comes from /sys/block/<device>/device/model.
      optional string model = 4;

      // Storage Device capacity in MB.
      optional uint32 size_mb = 5;

      // 8 byte FW revision of a storage device. Usually a string, but may
      // contain non-printable characters.
      optional uint64 firmware_version = 6;

      // Type of the storage device interface.
      // TYPE_UNKNOWN signifies an error on population side.
      enum Type {
        TYPE_UNKNOWN = 0;
        TYPE_EMMC = 1;
        TYPE_NVME = 2;
        TYPE_UFS = 3;
        TYPE_SD_EXPRESS_INTERNAL = 4;
      }
      optional Type type = 7;

      // Purpose defines how the OS uses the device.
      // PURPOSE_UNKNOWN signifies an error on population side.
      enum Purpose {
        PURPOSE_UNKNOWN = 0;
        PURPOSE_BOOT = 1;
        PURPOSE_SWAP = 2;
        PURPOSE_BOOT_SWAP = 3;
      }
      optional Purpose purpose = 8;
    }
    // List of internal storage devices on a Chrome OS device.
    repeated InternalStorageDevice internal_storage_devices = 20;

    // Drive messages are currently logged on Windows 7+, iOS, and Android.
    message Drive {
      // Whether this drive incurs a time penalty when randomly accessed. This
      // should be true for spinning disks but false for SSDs or other
      // flash-based drives.
      optional bool has_seek_penalty = 1;
    }
    // The drive that the application executable was loaded from.
    optional Drive app_drive = 16;
    // The drive that the current user data directory was loaded from.
    optional Drive user_data_drive = 17;

    // Type of TPM on the device. This field is only filled in on ChromeOS
    // devices (both CrOS and LaCrOS platforms). This includes Chromebooks with
    // TPM1.2 or GSC (cr50 and ti50), flex devices (ChromeOS installed on
    // devices with other OS) which has TPM type "runtime selection", and lastly
    // generic TPM2 devices that use TPM2 chips that aren't manufactured by
    // Google.
    enum TpmType {
      TPM_TYPE_UNKNOWN = 0;
      TPM_TYPE_1 = 1;
      TPM_TYPE_CR50 = 2;
      TPM_TYPE_TI50 = 3;
      TPM_TYPE_RUNTIME_SELECTION = 4;
      TPM_TYPE_GENERIC_2 = 5;
    }
    optional TpmType tpm_type = 23;

    // Firmware version of the TPM on the device. This field is only filled in
    // on ChromeOS devices (both CrOS and LaCrOS platforms).
    optional uint64 tpm_firmware_version = 26;
  }
  optional Hardware hardware = 6;

  // Information about the network connection.
  // Next tag: 9
  message Network {
    // Set to true if connection_type changed during the lifetime of the log.
    optional bool connection_type_is_ambiguous = 1;

    // Derived from net::NetworkChangeNotifier::ConnectionType translated
    // through NetworkMetricsProvider::GetConnectionType.
    enum ConnectionType {
      CONNECTION_UNKNOWN = 0;
      CONNECTION_ETHERNET = 1;
      CONNECTION_WIFI = 2;
      CONNECTION_2G = 3;
      CONNECTION_3G = 4;
      CONNECTION_4G = 5;
      CONNECTION_BLUETOOTH = 6;
      CONNECTION_NONE = 7;
      // As an alternative to connection_type_is_ambiguous above,
      // CONNECTION_AMBIGUOUS can be used for connection_type instead. This is
      // to be used in logs processing as a more convenient way to manage the
      // ambiguous case when breaking down stats by connection_type.
      CONNECTION_AMBIGUOUS = 8;
      CONNECTION_5G = 9;
    }
    // The connection type according to NetworkChangeNotifier.
    optional ConnectionType connection_type = 2;

    // Set to true if wifi_phy_layer_protocol changed during the lifetime of the
    // log.
    optional bool wifi_phy_layer_protocol_is_ambiguous = 3;

    // See net::WifiPHYLayerProtocol.
    enum WifiPHYLayerProtocol {
      WIFI_PHY_LAYER_PROTOCOL_NONE = 0;
      WIFI_PHY_LAYER_PROTOCOL_ANCIENT = 1;
      WIFI_PHY_LAYER_PROTOCOL_A = 2;
      WIFI_PHY_LAYER_PROTOCOL_B = 3;
      WIFI_PHY_LAYER_PROTOCOL_G = 4;
      WIFI_PHY_LAYER_PROTOCOL_N = 5;
      WIFI_PHY_LAYER_PROTOCOL_UNKNOWN = 6;
      WIFI_PHY_LAYER_PROTOCOL_AC = 7;
      WIFI_PHY_LAYER_PROTOCOL_AD = 8;
      WIFI_PHY_LAYER_PROTOCOL_AX = 9;
    }
    // The physical layer mode of the associated wifi access point, if any.
    optional WifiPHYLayerProtocol wifi_phy_layer_protocol = 4;

    // Derived from net::NetworkQualityEstimator::EffectiveConnectionType
    // translated through NetworkMetricsProvider::GetConnectionType.
    enum EffectiveConnectionType {
      EFFECTIVE_CONNECTION_TYPE_UNKNOWN = 0;
      // Deprecated: Specifies that the connection_type changed during the
      // lifetime of the log.
      DEPRECATED_EFFECTIVE_CONNECTION_TYPE_AMBIGUOUS = 1 [deprecated = true];
      EFFECTIVE_CONNECTION_TYPE_OFFLINE = 2;
      EFFECTIVE_CONNECTION_TYPE_SLOW_2G = 3;
      EFFECTIVE_CONNECTION_TYPE_2G = 4;
      EFFECTIVE_CONNECTION_TYPE_3G = 5;
      EFFECTIVE_CONNECTION_TYPE_4G = 6;
    }

    // The minimum and maximum values of the effective connection type enum
    // during the lifetime of the log according to net::NetworkQualityEstimator.
    // EffectiveConnectionType is the connection type whose typical performance
    // is most similar to the measured performance of the network in use. In
    // many cases, the "effective" connection type and the actual type of
    // connection in use are the same, but often a network connection performs
    // significantly differently, usually worse, from its expected capabilities.
    optional EffectiveConnectionType min_effective_connection_type = 7;
    optional EffectiveConnectionType max_effective_connection_type = 8;
  }
  optional Network network = 13;

  // Information on the Google Update install that is managing this client.
  message GoogleUpdate {
    // Whether the Google Update install is system-level or user-level.
    optional bool is_system_install = 1;

    // The date at which Google Update last started performing an automatic
    // update check, in seconds since the Unix epoch.
    optional int64 last_automatic_start_timestamp = 2;

    // The date at which Google Update last successfully sent an update check
    // and received an intact response from the server, in seconds since the
    // Unix epoch. (The updates don't need to be successfully installed.)
    optional int64 last_update_check_timestamp = 3;

    // Describes a product being managed by Google Update. (This can also
    // describe Google Update itself.)
    message ProductInfo {
      // The current version of the product that is installed.
      optional string version = 1;

      // The date at which Google Update successfully updated this product,
      // stored in seconds since the Unix epoch.  This is updated when an update
      // is successfully applied, or if the server reports that no update
      // is available.
      optional int64 last_update_success_timestamp = 2;

      // The result reported by the product updater on its last run.
      enum InstallResult {
        INSTALL_RESULT_SUCCESS = 0;
        INSTALL_RESULT_FAILED_CUSTOM_ERROR = 1;
        INSTALL_RESULT_FAILED_MSI_ERROR = 2;
        INSTALL_RESULT_FAILED_SYSTEM_ERROR = 3;
        INSTALL_RESULT_EXIT_CODE = 4;
      }
      optional InstallResult last_result = 3;

      // The error code reported by the product updater on its last run.  This
      // will typically be a error code specific to the product installer.
      optional int32 last_error = 4;

      // The extra error code reported by the product updater on its last run.
      // This will typically be a Win32 error code.
      optional int32 last_extra_error = 5;
    }
    optional ProductInfo google_update_status = 4;
    optional ProductInfo client_status = 5;
  }
  optional GoogleUpdate google_update = 11;

  // Figures that can be used to generate application stability metrics.
  // All values are counts of events since the last time that these
  // values were reported.
  // Next tag: 32
  message Stability {
    // Total amount of time that the program was running, in seconds,
    // since the last time a log was recorded, as measured using a client-side
    // clock implemented via TimeTicks, which guarantees that it is monotonic
    // and does not jump if the user changes their clock.  The TimeTicks
    // implementation also makes the clock not count time the computer is
    // suspended.
    optional int64 incremental_uptime_sec = 1;

    // Total amount of time that the program was running, in seconds,
    // since startup, as measured using a client-side clock implemented
    // via TimeTicks, which guarantees that it is monotonic and does not
    // jump if the user changes their clock.  The TimeTicks implementation
    // also makes the clock not count time the computer is suspended.
    // This field was added for M-35.
    optional int64 uptime_sec = 23;

    // Logged on Android only as of late Q2 2022. Used by only Android WebView.
    // Other platforms should use Stability.Counts2.
    optional int32 page_load_count = 2;

    // Logged on Android only as of Q2 2022. Used by only Android WebView. Other
    // platforms should use Stability.Counts2.
    optional int32 renderer_launch_count = 26;

    // Number of times the browser has crashed while logged in as the "other
    // user" (guest) account.
    // Logged on ChromeOS only.
    optional int32 other_user_crash_count = 7;

    // Number of times the kernel has crashed.
    // Logged on ChromeOS only.
    optional int32 kernel_crash_count = 8;

    // Number of times the system has shut down uncleanly.
    // Logged on ChromeOS only.
    optional int32 unclean_system_shutdown_count = 9;

    // All the remaining fields in the Stability are recorded at most once per
    // client session.

    // The number of times the program was launched since the last time metrics
    // was uploaded. For the initial metrics upload (right after startup), this
    // will often be equal to 1. However, it is possible that Chrome was unable
    // to upload stability metrics for previous launches (e.g. due to crashing
    // early during startup), making this value greater than 1. For subsequent
    // metrics uploads, this value will be 0.
    //
    // Logged on Android only as of Q1 2022. Used by only Android WebView. Other
    // platforms should use Stability.Counts2.
    optional int32 launch_count = 15;
    // Android only. The number of times Chrome didn't exit cleanly and the GMS
    // Core version has changed from the last session. This is in addition to
    // |crash_count| in which we exclude unclean exits that are likely caused by
    // GMS Core updates.
    optional int32 crash_count_due_to_gms_core_update = 30;

    // Whether the metrics being reported are from a previous run picked up via
    // the left-over memory mapped files.
    optional bool from_previous_run = 29;
  }
  optional Stability stability = 8;

  // Description of a field trial or experiment that the user is currently
  // enrolled in.
  // All metrics reported in this upload can potentially be influenced by the
  // field trial.
  message FieldTrial {
    // The name of the field trial, as a 32-bit identifier.
    // Currently, the identifier is a hash of the field trial's name.
    optional fixed32 name_id = 1;

    // The user's group within the field trial, as a 32-bit identifier.
    // Currently, the identifier is a hash of the group's name.
    optional fixed32 group_id = 2;
  }
  repeated FieldTrial field_trial = 9;

  // Seed version from variations_seed.proto used to instantiate FieldTrials
  // for this session.
  optional string variations_seed_version = 28;

  // Whether the client_id in the log matches the client_id we used to assign
  // field trials.
  optional bool client_id_was_used_for_trial_assignment = 33;

  // The unhashed client_id for this report. This is a uuid in its canonical
  // textual representation in the form 8-4-4-4-12 for a total of 36 characters.
  // Used to simulate field trial assignments for the client.
  optional string client_uuid = 34;

  // Information about the A/V output device(s) (typically just a TV).
  // However, a configuration may have one or more intermediate A/V devices
  // between the source device and the TV (e.g. an A/V receiver, video
  // processor, etc.).
  message ExternalAudioVideoDevice {
    // The manufacturer name (possibly encoded as a 3-letter code, e.g. "YMH"
    // for Yamaha).
    optional string manufacturer_name = 1;

    // The model name (e.g. "RX-V1900"). Some devices may report generic names
    // like "receiver" or use the full manufacturer name (e.g "PHILIPS").
    optional string model_name = 2;

    // The product code (e.g. "0218").
    optional string product_code = 3;

    // The device types. A single device can have multiple types (e.g. a set-top
    // box could be both a tuner and a player).  The same type may even be
    // repeated (e.g a device that reports two tuners).
    enum AVDeviceType {
      AV_DEVICE_TYPE_UNKNOWN = 0;
      AV_DEVICE_TYPE_TV = 1;
      AV_DEVICE_TYPE_RECORDER = 2;
      AV_DEVICE_TYPE_TUNER = 3;
      AV_DEVICE_TYPE_PLAYER = 4;
      AV_DEVICE_TYPE_AUDIO_SYSTEM = 5;
    }
    repeated AVDeviceType av_device_type = 4;

    // The year of manufacture.
    optional int32 manufacture_year = 5;

    // The week of manufacture.
    // Note: per the Wikipedia EDID article, numbering for this field may not
    // be consistent between manufacturers.
    optional int32 manufacture_week = 6;

    // Selected horizontal resolution in pixels.
    optional int32 horizontal_resolution = 7;

    // Selected vertical resolution in pixels.
    optional int32 vertical_resolution = 8;

    // Audio capabilities of the device.
    // Ref: http://en.wikipedia.org/wiki/Extended_display_identification_data
    // Next tag: 7
    message AudioDescription {
      // Audio format
      enum AudioFormat {
        AUDIO_FORMAT_UNKNOWN = 0;
        AUDIO_FORMAT_LPCM = 1;
        AUDIO_FORMAT_AC_3 = 2;
        AUDIO_FORMAT_MPEG1 = 3;
        AUDIO_FORMAT_MP3 = 4;
        AUDIO_FORMAT_MPEG2 = 5;
        AUDIO_FORMAT_AAC = 6;
        AUDIO_FORMAT_DTS = 7;
        AUDIO_FORMAT_ATRAC = 8;
        AUDIO_FORMAT_ONE_BIT = 9;
        AUDIO_FORMAT_DD_PLUS = 10;
        AUDIO_FORMAT_DTS_HD = 11;
        AUDIO_FORMAT_MLP_DOLBY_TRUEHD = 12;
        AUDIO_FORMAT_DST_AUDIO = 13;
        AUDIO_FORMAT_MICROSOFT_WMA_PRO = 14;
      }
      optional AudioFormat audio_format = 1;

      // Number of channels (e.g. 1, 2, 8, etc.).
      optional int32 num_channels = 2;

      // Supported sample frequencies in Hz (e.g. 32000, 44100, etc.).
      // Multiple frequencies may be specified.
      repeated int32 sample_frequency_hz = 3;

      // Maximum bit rate in bits/s.
      optional int32 max_bit_rate_per_second = 4;

      // Bit depth (e.g. 16, 20, 24, etc.).
      optional int32 bit_depth = 5;

      // Output mode: analog vs digital.
      enum OutputMode {
        ANALOG = 0;
        DIGITAL = 1;
      }
      optional OutputMode output_mode = 6;
    }
    repeated AudioDescription audio_description = 9;

    // The position in AV setup.
    // A value of 0 means this device is the TV.
    // A value of 1 means this device is directly connected to one of
    // the TV's inputs.
    // Values > 1 indicate there are 1 or more devices between this device
    // and the TV.
    optional int32 position_in_setup = 10;

    // Whether this device is in the path to the TV.
    optional bool is_in_path_to_tv = 11;

    // The CEC version the device supports.
    // CEC stands for Consumer Electronics Control, a part of the HDMI
    // specification.  Not all HDMI devices support CEC.
    // Only devices that support CEC will report a value here.
    optional int32 cec_version = 12;

    // This message reports CEC commands seen by a device.
    // After each log is sent, this information is cleared and gathered again.
    // By collecting CEC status information by opcode we can determine
    // which CEC features can be supported.
    message CECCommand {
      // The CEC command opcode.  CEC supports up to 256 opcodes.
      // We add only one CECCommand message per unique opcode.  Only opcodes
      // seen by the device will be reported. The remainder of the message
      // accumulates status for this opcode (and device).
      optional int32 opcode = 1;

      // The total number of commands received from the external device.
      optional int32 num_received_direct = 2;

      // The number of commands received from the external device as part of a
      // broadcast message.
      optional int32 num_received_broadcast = 3;

      // The total number of commands sent to the external device.
      optional int32 num_sent_direct = 4;

      // The number of commands sent to the external device as part of a
      // broadcast message.
      optional int32 num_sent_broadcast = 5;

      // The number of aborted commands for unknown reasons.
      optional int32 num_aborted_unknown_reason = 6;

      // The number of aborted commands because of an unrecognized opcode.
      optional int32 num_aborted_unrecognized = 7;
    }
    repeated CECCommand cec_command = 13;

    // Selected Frame rate
    optional int32 frame_rate = 14;

    // Selected color encoding.
    enum ColorEncoding {
      COLOR_ENCODING_UNKNOWN = 0;
      COLOR_ENCODING_RGB = 1;
      COLOR_ENCODING_YUV444 = 2;
      COLOR_ENCODING_YUV422 = 3;
      COLOR_ENCODING_YUV420 = 4;
    }
    optional ColorEncoding color_encoding = 15;

    // Selected bit-depth.
    optional int32 bit_depth = 16;

    // Devices's max TMDS char rate.
    optional int32 tmds = 17;

    // HDR10 support.
    optional bool hdr10_support = 18;

    // Dolby vision support.
    optional bool dolby_vision_support = 19;

    // Supported EOTF's.
    // EOTF support according to the spec:
    //   eotf_support & 0x1 -> SDR supported
    //   (eotf_support > 1) & 0x1 -> traditional HDR supported
    //   (eotf_support > 2) & 0x1 -> ST2084 supported
    optional int32 eotf_support = 20;

    // Supports YUV.
    optional bool yuv_support = 21;

    // Supports YUV_420.
    optional bool yuv_420_support = 22;

    // The maximum HDCP version supported by the sink.
    optional int32 maximum_supported_hdcp_version = 23;

    // The current HDCP version negotiated with the sink.
    optional int32 current_hdcp_version = 24;
  }
  repeated ExternalAudioVideoDevice external_audio_video_device = 14;

  // Information about the current wireless access point. Collected directly
  // from the wireless access point via standard apis if the device is
  // connected to the Internet wirelessly. Introduced for Chrome on TV devices
  // but also can be collected by cast devices running Chrome OS and Android.
  // Not logged by Chrome browser platforms.
  message ExternalAccessPoint {
    // The manufacturer name, for example "ASUSTeK Computer Inc.".
    optional string manufacturer = 1;

    // The model name, for example "Wi-Fi Protected Setup Router".
    optional string model_name = 2;

    // The model number, for example "RT-N16".
    optional string model_number = 3;

    // The device name (sometime same as model_number), for example "RT-N16".
    optional string device_name = 4;

    // The organizationally unique identifier, for example "08:9E:08".
    // OUI is the highest three bytes of MAC address
    // Google's OUI (08:9E:08) is encoded as 0x00089E08
    // Never recorded server side, but some old clients may send values with
    // this tag.
    reserved 5;
  }
  optional ExternalAccessPoint external_access_point = 15;

  // Number of users currently signed into a multiprofile session.
  // A zero value indicates that the user count changed while the log is open.
  // Logged only on ChromeOS.
  optional uint32 multi_profile_user_count = 17;

  // Information about extensions that are installed, masked to provide better
  // privacy.  Only extensions from a single profile are reported; this will
  // generally be the profile used when the browser is started.  The profile
  // reported on will remain consistent at least until the browser is
  // relaunched (or the profile is deleted by the user).
  //
  // Each client first picks a value for client_key derived from its UMA
  // client_id:
  //   client_key = client_id % 4096
  // Then, each installed extension is mapped into a hash bucket according to
  //   bucket = CityHash64(StringPrintf("%d:%s",
  //                                    client_key, extension_id)) % 1024
  // The client reports the set of hash buckets occupied by all installed
  // extensions.  If multiple extensions map to the same bucket, that bucket is
  // still only reported once.
  repeated int32 occupied_extension_bucket = 18;

  // The state of loaded extensions for this system. The system can have either
  // no applicable extensions, extensions only from the webstore and verified by
  // the webstore, extensions only from the webstore but not verified, or
  // extensions not from the store. If there is a single off-store extension,
  // then HAS_OFFSTORE is reported. This should be kept in sync with the
  // corresponding enum in chrome/browser/metrics/extensions_metrics_provider.cc
  enum ExtensionsState {
    NO_EXTENSIONS = 0;
    NO_OFFSTORE_VERIFIED = 1;
    NO_OFFSTORE_UNVERIFIED = 2;
    HAS_OFFSTORE = 3;
  }
  optional ExtensionsState offstore_extensions_state = 19;

  // The nature of the choice the user was given concerning metrics recording.
  // Specifically, whether the enable metrics/crash reporting checkbox that was
  // shown on first run was checked or unchecked by default.
  // This state is recorded on first run, and uploaded in every UMA log.
  enum UmaDefaultState {
    // The enable checkbox was unchecked by default.
    OPT_IN = 0;
    // The enable checkbox was checked by default.
    OPT_OUT = 1;
    // Policy mandated that UMA be enabled, the user had no choice.
    POLICY_FORCED_ENABLED = 2;
    // The client has no record of which consent flow was used.
    OPT_UNKNOWN = 3;
  }
  optional UmaDefaultState uma_default_state = 22;

  enum AntiVirusState {
    // The security product software is turned on and protecting the user.
    STATE_ON = 0;
    // The security product software is turned off and protection is disabled.
    STATE_OFF = 1;
    // The security product software is in the snoozed state, temporarily off,
    // and not actively protecting the computer.
    STATE_SNOOZED = 2;
    // The security product software has expired and is no longer actively
    // protecting the computer.
    STATE_EXPIRED = 3;
  }

  // Information about AntiVirus products installed.
  // Next Tag: 6
  message AntiVirusProduct {
    // The product name e.g. "System Center Endpoint Protection". This might not
    // be recorded, see ShouldReportFullNames() in
    // chrome/browser/metrics/antivirus_metrics_provider_win.cc.
    optional string product_name = 1;

    // The hash of the product name.
    optional fixed32 product_name_hash = 2;

    // The version of the product, as read from the file information. This might
    // not be recorded, see ShouldReportFullNames() in
    // chrome/browser/metrics/antivirus_metrics_provider_win.cc.
    optional string product_version = 3;

    // The hash of the product version. Might not be set if the product version
    // could not be obtained from the disk.
    optional fixed32 product_version_hash = 4;

    // The current state of the product.
    optional AntiVirusState product_state = 5;
  }
  repeated AntiVirusProduct antivirus_product = 23;

  enum ComponentId {
    // The client transmitted a component ID the server does not recognize.
    UNKNOWN = 1;

    // All the following are various components.
    FILE_TYPE_POLICIES = 2;
    ORIGIN_TRIALS = 3;
    PEPPER_FLASH = 4;
    PEPPER_FLASH_CHROMEOS = 5;
    PNACL = 6;
    RECOVERY = 7;
    SSL_ERROR_ASSISTANT = 8;
    STH_SET = 9;
    CRL_SET = 10;
    SUBRESOURCE_FILTER = 11;
    SW_REPORTER = 12;
    // Software Decryption CDM on all platforms of Chrome
    WIDEVINE_CDM = 13;
    EPSON_INKJET_PRINTER_ESCPR = 14;
    CROS_TERMINA = 15;
    STAR_CUPS_DRIVER = 16;
    SPEECH_SYNTHESIS_SV_SE = 17;
    OPTIMIZATION_HINTS = 18;
    DOWNLOADABLE_STRINGS = 19;
    VR_ASSETS = 20;
    RTANALYTICS_LIGHT = 21;
    RTANALYTICS_FULL = 22;
    CELLULAR = 23;
    DEMO_MODE_RESOURCES = 24;
    ON_DEVICE_HEAD_SUGGEST = 25;
    CROS_SMART_DIM = 26;
    ZXCVBN_DATA = 27;
    AUTOFILL_REGEX_CONSTANTS = 28;
    WEBVIEW_APPS_PACKAGE_NAMES_ALLOWLIST = 29;
    // Hardware Decryption CDM only for Chrome on Windows.
    MEDIA_FOUNDATION_WIDEVINE_CDM = 30;
    CROWD_DENY = 31;
    APP_PROVISIONING = 32;
    AUTOFILL_STATES = 33;
    CLIENT_SIDE_PHISHING = 34;
    COMMERCE_HEURISTICS = 35;
    CROW_DOMAIN_LIST = 36;
    DEMO_MODE_APP = 37;
    DESKTOP_SCREENSHOT_EDITOR = 38;
    DESKTOP_SHARING_HUB = 39;
    FIRST_PARTY_SETS = 40;
    HYPHENATION = 41;
    INTERVENTION_POLICY_DATABASE = 42;
    LACROS_DOGFOOD_BETA = 43;
    LACROS_DOGFOOD_CANARY = 44;
    LACROS_DOGFOOD_DEV = 45;
    LACROS_DOGFOOD_STABLE = 46;
    MEI_PRELOAD = 47;
    PKI_METADATA = 48;
    REAL_TIME_URL_CHECKS_ALLOWLIST = 49;
    RECOVERY_IMPROVED = 50;
    SAFETY_TIPS = 51;
    SCREEN_AI = 52;
    SMART_DIM = 53;
    SODA = 54;
    SODA_DE_DE = 55;
    SODA_EN_US = 56;
    SODA_ES_ES = 57;
    SODA_FR_FR = 58;
    SODA_IT_IT = 59;
    SODA_JA_JP = 60;
    THIRD_PARTY_MODULE_LIST = 61;
    TRUST_TOKEN_KEY_COMMITMENTS = 62;
  }

  // Information about what Chrome components are registered and at which
  // version.
  // Next Tag: 5
  message ChromeComponent {
    // Which component this information is for.
    optional ComponentId component_id = 1 [default = UNKNOWN];

    // Human-readable dotted-quad representation of the currently-installed
    // version of the component, e.g. "1.2.3.4".
    optional string version = 2;

    // The first 32 bits of the Omaha-style fingerprint of the installed
    // component, discarding any bits that describe the fingerprint format. In
    // practice this is the first 32 bits of the SHA256 hash of the package that
    // was installed as the component. It is a stronger version number that can
    // vary across platform, architecture, or branches of an A/B component test.
    optional fixed32 omaha_fingerprint = 3;

    // A hash of the cohort identifier of this component, excluding
    // non-assignment information. The hash function is Chromium's
    // PersistentHash.
    optional fixed32 cohort_hash = 4;
  }
  repeated ChromeComponent chrome_component = 24;

  // Information about the user's installed extensions. This will include
  // extensions from all fully-initialized profiles. If a single extension is
  // installed in multiple profiles, it will be recorded multiple times.
  repeated ExtensionInstallProto extension_install = 25;

  // Android-only.
  // For Chrome UMA records, this field contains the package name of the
  // version of Chrome that is running if it's different from
  // "com.android.chrome".  ("com.android.chrome" is the name of the Chrome
  // stable channel app package name.)
  // For WebView UMA records, under some conditions this field contains the
  // package name of the currently-running app.  See http://shortn/_5HRGU153JL
  // for details.
  optional string app_package_name = 26;

  // Indicates if the `app_package_name` should be filtered out on the
  // server-side. The client will use this to signal no further filtering is
  // required if filtering is enabled on the client-side. If the package name is
  // a system app and the server-side filtering is enabled, the client will use
  // this to indicate no filtering is required since system apps are not subject
  // to filtering. Only recorded on the Android WebView platform.
  enum AppPackageNameAllowlistFilter {
    // Indicates the package name filtering was not set.
    // This will be the case with data coming from old WebView versions.
    SERVER_SIDE_FILTER_UNSPECIFIED = 0;
    // Indicates the package name filtering should occur on the server-side
    SERVER_SIDE_FILTER_REQUIRED = 1;
    // Indicates the `app_package_name` does not need filtering since filtering
    // occurred on the client-side.
    NO_SERVER_SIDE_FILTER_REQUIRED_DUE_TO_CLIENT_FILTERING = 2;
    // Indicates the `app_package_name` does not need filtering since it is
    // a system app.
    NO_SERVER_SIDE_FILTER_REQUIRED_FOR_SYSTEM_APPS = 3;
  }

  optional AppPackageNameAllowlistFilter app_package_name_allowlist_filter = 42;

  enum ClientSideSamplingStatus {
    // Default value, no conclusion can be drawn.
    SAMPLING_UNKNOWN = 0;
    // Client-side sampling was applied.
    SAMPLING_APPLIED = 1;
    // Client-side sampling was not applied.
    SAMPLING_NOT_APPLIED = 2;
  }

  // Specifies whether sampling was applied on the client. Older clients will
  // not set this field, which will result in the default value of UNKNOWN.
  optional ClientSideSamplingStatus client_side_sampling_status = 43;

  // The package which installed Chrome, as reported by
  // PackageManager.getInstallerPackageName().
  enum InstallerPackage {
    // This field was not set.
    INSTALLER_PACKAGE_UNKNOWN = 0;
    // The installer package name returned by Android was empty.
    INSTALLER_PACKAGE_NONE = 1;
    // 'com.android.vending'.
    INSTALLER_PACKAGE_GOOGLE_PLAY_STORE = 2;
    // Any other non-empty value.
    INSTALLER_PACKAGE_OTHER = 3;
  }

  // The package which installed Chrome, as reported by Android.
  optional InstallerPackage installer_package = 35;

  // Data related to the "Better Together" multi-device features. This is only
  // uploaded on Chrome OS.
  // Next Tag: 5
  message LinkedAndroidPhoneData {
    // The pii-free model name of the phone used for Better Together with this
    // device. Will not be set if Better Together is not set up. Hashed using
    // variations::HashName() to produce a 32-bit SHA1 hash.
    optional fixed32 phone_model_name_hash = 1;

    // True if SmartLock is enabled on this Chromebook.
    optional bool is_smartlock_enabled = 2;

    // True if Instant Tethering is enabled on this Chromebook.
    optional bool is_instant_tethering_enabled = 3;

    // True if Messages integration is enabled on this Chromebook.
    optional bool is_messages_enabled = 4;
  }
  optional LinkedAndroidPhoneData linked_android_phone_data = 29;

  // Demo mode related dimension information.
  // Next Tag: 4
  message DemoModeDimensions {
    optional string country = 1;

    // Demo devices retailer id and store id, value is set during demo setup.
    // Next Tag: 3
    message Retailer {
      optional string retailer_id = 1;
      optional string store_id = 2;
    }
    optional Retailer retailer = 2;

    enum CustomizationFacet {
      UNDEFINED = 0;
      CLOUD_GAMING_DEVICE = 1;
    }
    repeated CustomizationFacet customization_facet = 3 [packed = true];
  }
  optional DemoModeDimensions demo_mode_dimensions = 41;
}
