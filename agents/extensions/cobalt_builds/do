#!/usr/bin/env vpython3
# Copyright 2025 The Cobalt Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""A command-line client for the Cobalt builds MCP server.

Run `do --help` to get a list of available commands.
"""

# [VPYTHON:BEGIN]
# python_version: "3.11"
# wheel: <
#   name: "infra/python/wheels/mcp-py3"
#   version: "version:1.9.4"
# >
# wheel: <
#   name: "infra/python/wheels/pydantic-py3"
#   version: "version:2.11.7"
# >
# wheel: <
#   name: "infra/python/wheels/starlette-py3"
#   version: "version:0.47.1"
# >
# wheel: <
#   name: "infra/python/wheels/anyio-py3"
#   version: "version:4.9.0"
# >
# wheel: <
#   name: "infra/python/wheels/sniffio-py3"
#   version: "version:1.3.0"
# >
# wheel: <
#   name: "infra/python/wheels/idna-py3"
#   version: "version:3.4"
# >
# wheel: <
#   name: "infra/python/wheels/typing-extensions-py3"
#   version: "version:4.13.2"
# >
# wheel: <
#   name: "infra/python/wheels/httpx_sse-py3"
#   version: "version:0.4.1"
# >
# wheel: <
#   name: "infra/python/wheels/httpx-py3"
#   version: "version:0.28.1"
# >
# wheel: <
#   name: "infra/python/wheels/certifi-py3"
#   version: "version:2025.4.26"
# >
# wheel: <
#   name: "infra/python/wheels/httpcore-py3"
#   version: "version:1.0.9"
# >
# wheel: <
#   name: "infra/python/wheels/h11-py3"
#   version: "version:0.16.0"
# >
# wheel: <
#   name: "infra/python/wheels/pydantic-settings-py3"
#   version: "version:2.10.1"
# >
# wheel: <
#   name: "infra/python/wheels/python-multipart-py3"
#   version: "version:0.0.20"
# >
# wheel: <
#   name: "infra/python/wheels/sse-starlette-py3"
#   version: "version:2.4.1"
# >
# wheel: <
#   name: "infra/python/wheels/uvicorn-py3"
#   version: "version:0.35.0"
# >
# wheel: <
#   name: "infra/python/wheels/annotated-types-py3"
#   version: "version:0.7.0"
# >
# wheel: <
#   name: "infra/python/wheels/pydantic_core/${vpython_platform}"
#   version: "version:2.33.2"
# >
# wheel: <
#   name: "infra/python/wheels/typing-inspection-py3"
#   version: "version:0.4.1"
# >
# wheel: <
#   name: "infra/python/wheels/python-dotenv-py3"
#   version: "version:1.1.1"
# >
# wheel: <
#   name: "infra/python/wheels/click-py3"
#   version: "version:8.0.3"
# >
# [VPYTHON:END]

import argparse
import asyncio
import json
import logging
import os
import shlex
import signal
import subprocess
import sys
import traceback
from datetime import datetime

# Suppress informational logs from the MCP client
logging.getLogger('mcp').setLevel(logging.WARNING)

from analysis import analyze_log


def format_output(data):
  """Formats the JSON output for human readability."""
  if not data.get('content'):
    return json.dumps(data, indent=2)

  content = data['content']
  # Handle simple list of strings
  if isinstance(content, list) and all(
      isinstance(item, dict) and 'text' in item for item in content):
    try:
      # Try to parse the text as JSON, assuming it's a list of strings
      parsed_content = json.loads(content[0]['text'])
      if isinstance(parsed_content, list):
        return '\n'.join(parsed_content)
    except (json.JSONDecodeError, IndexError):
      # Fallback to original behavior if parsing fails
      return '\n'.join(item['text'] for item in content)

  # Handle single string response
  if isinstance(content, dict) and 'text' in content:
    return content['text']

  # Fallback to pretty-printed JSON for other structures
  return json.dumps(data, indent=2)


async def process_command(session, args):
  """Processes a single command."""
  tool_name = args.command
  params = vars(args).copy()

  # Remove parser-specific keys
  params.pop('command', None)
  params.pop('worker', None)

  if tool_name == 'run' and 'main_arg' in params:
    if params.get('variant') and params.get('binary_name'):
      params['platform'] = params.pop('main_arg')
    else:
      params['build_id_or_log_file'] = params.pop('main_arg')
      params.pop('variant', None)
      params.pop('binary_name', None)

  if 'binary_args' in params:
    params['args'] = [arg for arg in params.pop('binary_args') if arg != '--']
  
  if 'debug' in params:
    params['debug'] = True

  result = await session.call_tool(tool_name, arguments=params)

  # For long-running build/run commands, tail the log file.
  if tool_name in ['build', 'run']:
    response_json = result.model_dump()['content'][0]['text']
    try:
      response_data = json.loads(response_json)
    except json.JSONDecodeError:
      print(response_json)
      return

    command = response_data.get('command')

    if 'dry_run' in args and args.dry_run:
      print(command)
      return

    task_id = response_data.get('build_id') or response_data.get('run_id')

    print(f'Executing command: {command}')
    print(f'Started task with ID: {task_id}')
    status_tool = 'check_status'
    id_key = 'task_id'
    stop_tool = 'stop'

    # Get the log path
    status_result = await session.call_tool(
        status_tool, arguments={id_key: task_id})
    status_json = status_result.model_dump()['content'][0]['text']
    status_data = json.loads(status_json)
    log_path = status_data['output_log']
    print(f'Tailing log file: {log_path}')

    tail_process = await asyncio.create_subprocess_exec('tail', '-f', log_path)

    try:
      while True:
        status_result = await session.call_tool(
            status_tool, arguments={id_key: task_id})
        status_json = status_result.model_dump()['content'][0]['text']
        status_data = json.loads(status_json)
        status = status_data.get('status')

        if status in ['success', 'failure', 'cancelled']:
          print(f'Task {task_id} finished with status: {status}')
          break
        await asyncio.sleep(2)
    except KeyboardInterrupt:
      print(f'\nStopping task {task_id}...')
      await session.call_tool(stop_tool, arguments={id_key: task_id})
      print('Task stopped.')
    finally:
      tail_process.terminate()
      await tail_process.wait()
  else:
    # For all other commands, just print the result.
    try:
      print(format_output(result.model_dump()))
    except KeyboardInterrupt:
      print("\nOperation cancelled by user.")
      sys.exit(1)


class NonExitingArgumentParser(argparse.ArgumentParser):
  """An ArgumentParser that raises an exception instead of exiting."""

  def error(self, message):
    """Override to raise an exception instead of calling sys.exit()."""
    raise argparse.ArgumentError(None, message)


class SinglePageHelpFormatter(argparse.RawTextHelpFormatter):
  """A help formatter that shows the full help for each subcommand."""

  def __init__(self, *args, **kwargs):
    super().__init__(*args, **kwargs)
    self._parser = None

  def format_help(self):
    # Get the default help message
    help_text = super().format_help()

    # Find and remove the 'positional arguments' section
    positional_args_header = 'positional arguments:'
    start_index = help_text.find(positional_args_header)
    if start_index != -1:
      options_header = 'options:'
      end_index = help_text.find(options_header, start_index)
      if end_index != -1:
        help_text = help_text[:start_index] + help_text[end_index:]

    # Add the custom formatted subcommand help
    subparser_action = next(
        (action
         for action in self._parser._actions
         if isinstance(action, argparse._SubParsersAction)), None)
    if subparser_action:
      for subparser in subparser_action.choices.values():
        help_text += f'\n {subparser.prog}\n'
        if subparser.description:
          help_text += f'    {subparser.description}\n'

        positional_actions = [
            act for act in subparser._actions if not act.option_strings
        ]
        optional_actions = [act for act in subparser._actions if act.option_strings]

        if positional_actions or optional_actions:
          usage = f'    Usage: {subparser.prog}'
          for act in positional_actions:
            usage += f' <{act.dest}>'
          for act in optional_actions:
            usage += f' [{act.option_strings[0]}]'
          help_text += usage + '\n'

        for act in subparser._actions:
          dest_str = act.dest.replace('_', '').lower().strip()
          help_str = (act.help or '').replace(' ', '').lower().strip()
          if dest_str != help_str and act.help is not None:
            if act.option_strings:
              help_text += f'        {act.option_strings[0]}: {act.help}\n'
            else:
              help_text += f'        <{act.dest}>: {act.help}\n'
    return help_text


def build_parser(tool_schemas, exit_on_error=True):
  """Builds the argparse parser from tool schemas."""
  formatter = SinglePageHelpFormatter('do', max_help_position=30)
  parser_class = argparse.ArgumentParser if exit_on_error else NonExitingArgumentParser
  parser = parser_class(
      description='A command-line client for the Cobalt builds MCP server.',
      formatter_class=lambda prog: formatter,
      add_help=False)
  formatter._parser = parser
  parser.add_argument(
      '-h',
      '--help',
      action='help',
      default=argparse.SUPPRESS,
      help='Show this help message and exit.')
  # Add the worker flag for internal use
  parser.add_argument('--worker', action='store_true', help=argparse.SUPPRESS)
  subparsers = parser.add_subparsers(dest='command', help='Available MCP tools')

  for tool in tool_schemas.tools:
    subparser = subparsers.add_parser(
        tool.name, help=tool.description, add_help=False)
    subparser.description = tool.description

    # Manually add the client-side --wait flag for build and run
    if tool.name in ['build', 'run']:
        subparser.add_argument(
            '--background',
            action='store_true',
            help='Run the command in the background and exit immediately.')

    for prop_name, prop_schema in tool.inputSchema.get('properties', {}).items():
      # Skip properties that are manually handled
      if tool.name in ['build', 'run'] and prop_name in ['background', 'dry_run', 'debug', 'wait']:
          continue
      if tool.name == 'build' and prop_name == 'extra_args':
          continue
      if tool.name == 'run' and prop_name == 'args':
          continue

      if prop_name == 'args':
        subparser.add_argument('binary_args', nargs=argparse.REMAINDER)
      elif prop_name == 'extra_args' and tool.name == 'build':
        subparser.add_argument('--extra_args', nargs=argparse.REMAINDER)
      elif prop_name == 'dry_run' and tool.name in ['build', 'run']:
        subparser.add_argument(
            '--dry-run',
            action='store_true',
            help='Print the command without executing it.')

      elif tool.name == 'analyze' and prop_name == 'task_id_or_log_file':
        subparser.add_argument(
            'task_id_or_log_file',
            help='The ID of the task or the path to the log file.')
      elif tool.name == 'analyze' and prop_name == 'log_type':
        subparser.add_argument(
            'log_type',
            nargs='?',
            help='The type of log file (e.g., build, test). Defaults to auto.')

      elif prop_name == 'debug' and tool.name == 'run':
        subparser.add_argument(
            '--debug',
            action='store_true',
            help='Run the binary under GDB to get a symbolized stack trace on crash.')
      elif tool.name == 'run' and prop_name in [
          'platform', 'variant', 'binary_name', 'build_id_or_log_file'
      ]:
        # Special handling for the 'run' command's flexible arguments
        if prop_name == 'platform':
          subparser.add_argument(
              'main_arg',
              help='Build ID, log file path, or platform.')
        elif prop_name == 'variant':
          subparser.add_argument(
              'variant', nargs='?', help='Variant (if platform is provided).')
        elif prop_name == 'binary_name':
          subparser.add_argument(
              'binary_name',
              nargs='?',
              help='Binary name (if platform is provided).')
      else:
        subparser.add_argument(prop_name, help=prop_schema.get('title'))

  return parser


async def interactive_launcher(parser):
    """Runs the interactive launcher."""
    print("Type 'help' for a list of commands.")
    while True:
        try:
            line = await asyncio.to_thread(input, 'cobalt> ')
            line = line.strip()
            if line.lower() in ['exit', 'quit']:
                break
            if line.lower() in ['help', '?']:
                parser.print_help()
                continue
            if not line:
                continue

            # Launch a worker process to handle the command
            worker_cmd = [sys.executable, __file__, '--worker'] + shlex.split(line)
            process = await asyncio.create_subprocess_exec(
                *worker_cmd,
                stdout=sys.stdout,
                stderr=sys.stderr
            )
            await process.wait()

        except (EOFError, KeyboardInterrupt):
            print()
            break
        except Exception as e:
            print(f'An error occurred: {e}')


async def main_async():
  """The async main entry point."""
  from mcp.client.session import ClientSession
  from mcp.client.stdio import StdioServerParameters, stdio_client

  async def get_tool_schemas(server_params):
    """Gets the tool schemas from the server."""
    server_process = await asyncio.create_subprocess_exec(
        server_params.command, *server_params.args)
    try:
      async with stdio_client(server_params) as (read, write):
        async with ClientSession(read, write) as session:
          await session.initialize()
          return await session.list_tools()
    finally:
      try:
        server_process.terminate()
      except ProcessLookupError:
        pass

  async def run_worker(server_params, parser, is_background=False):
    """Runs a worker process to handle a single command."""
    worker_args = [arg for arg in sys.argv[1:] if arg != '--worker']
    args = parser.parse_args(worker_args)

    # Launch the server in a new process group to allow detachment.
    server_process = await asyncio.create_subprocess_exec(
        server_params.command, *server_params.args,
        preexec_fn=os.setpgrp)
    try:
      async with stdio_client(server_params) as (read, write):
        async with ClientSession(read, write) as session:
          await session.initialize()
          await process_command(session, args)
    finally:
      # If we are not in background mode, clean up the server process group.
      if not is_background:
        try:
          os.killpg(server_process.pid, signal.SIGTERM)
        except ProcessLookupError:
          pass

  # Special case for local analysis to avoid server overhead
  if len(sys.argv) > 1 and sys.argv[1] == 'analyze':
    log_file = sys.argv[2] if len(sys.argv) > 2 else None
    log_type = sys.argv[3] if len(sys.argv) > 3 else None
    if not log_file:
      print("Usage: do analyze <log_file> [log_type]")
      sys.exit(1)
    result = analyze_log(log_file, log_type)
    print(result)
    return

  is_worker = '--worker' in sys.argv
  is_interactive = len(sys.argv) == 1 and not is_worker

  script_dir = os.path.dirname(os.path.abspath(__file__))
  server_path = os.path.join(script_dir, 'server.py')
  server_params = StdioServerParameters(
      command='vpython3',
      args=[server_path, '--serve'])

  tool_schemas = await get_tool_schemas(server_params)
  parser = build_parser(tool_schemas, exit_on_error=not is_interactive)

  if is_worker:
    is_background = '--background' in sys.argv
    await run_worker(server_params, parser, is_background)
  elif is_interactive:
    await interactive_launcher(parser)
  else:
    # Single command mode
    if '--background' in sys.argv:
      # Re-launch the worker detached
      worker_cmd = [sys.executable, __file__, '--worker'] + sys.argv[1:]
      subprocess.Popen(worker_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
      print("Task started in background.")
    else:
      # Launch the worker and wait for it
      worker_cmd = [sys.executable, __file__, '--worker'] + sys.argv[1:]
      process = await asyncio.create_subprocess_exec(
          *worker_cmd,
          stdout=sys.stdout,
          stderr=sys.stderr
      )
      await process.wait()


def main():
  """Main entry point."""
  try:
    asyncio.run(main_async())
  except KeyboardInterrupt:
    print()
    sys.exit(0)


if __name__ == '__main__':
  main()
