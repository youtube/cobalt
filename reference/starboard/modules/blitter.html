<!DOCTYPE html>
<html lang="en" itemscope itemtype="https://schema.org/WebPage">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Cobalt / Starboard Module Reference: blitter.h</title>

            <!-- Webfont -->
    <link href='http://fonts.googleapis.com/css?family=Kavoon|Material+Icons' rel='stylesheet' type='text/css'>
    
    <!-- Material Design Lite -->
    <link href="/cobalt/assets/material-design-lite/material.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">

    <!-- Bootstrap -->
    <link href="/cobalt/assets/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Styles -->
    <link rel="stylesheet" type="text/css" href="/cobalt/css/site.css" />

    <!-- Font Awesome icons -->
    <link href="/cobalt/assets/font-awesome-4.4.0/css/font-awesome.min.css"
          rel="stylesheet"
          type="text/css">
    
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>

    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="/cobalt/assets/bootstrap/js/bootstrap.min.js"></script>

    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

    <!-- material design lite -->
    <script src="/cobalt/assets/material-design-lite/material.min.js"></script>

    <!-- Include the common site javascript -->
    <script src="/cobalt/js/common.js" type="text/javascript" charset="utf-8"></script>

    <!-- metadata -->
    <meta name="og:title" content="Cobalt / "/>
    <meta name="og:image" content="/cobalt/images/cobalt-logo.png"/>
    <meta name="og:description" content="A high-performance, small-footprint platform that implements a subset of HTML5/CSS/JS to run applications, including the YouTube TV app."/>
  </head>
  <body class="" id="top_of_page">

    <span id="toc-depth" data-toc-depth="h2,h3"></span>
    <nav id="common-nav" class="navbar navbar-fixed-top inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
      <a class="navbar-brand" href="/cobalt/">
        <img class="logo" src="/cobalt/images/cobalt-logo.png" alt="Cobalt">
      </a>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="navbar-collapse-1">
      <ul class="nav navbar-nav navbar-right" id="standard-menu-links">
      <li><a href="/cobalt/starboard/porting.html">Porters</a></li>
      <li><a href="/cobalt/development/setup-linux.html">Developers</a></li>
      <li><a href="/cobalt/contributors/index.html">Contributors</a></li>
      <li><a href="https://cobalt.googlesource.com/cobalt"><i class="fa fa-github"></i> Code Repo</a></li>
      </ul>
      <ul class="nav nav-stacked mobile-left-nav-menu" id="collapsed-left-menu">
        
  
<li class="expand-container" data-expander-target-search="relative">
          <h4 class="submenu no-top-margin">Porters</h4>
  <ul class="content">
    <li><b>Guides</b>
      <ul>
        <li><a href="/cobalt/starboard/porting.html">Port Cobalt to your platform</a></li>
        <li><a href="/cobalt/starboard/testing.html">Testing with NPLB</a></li>
      </ul>
    </li>
    <li><b>Reference</b>
      <ul>
        <li><a href="/cobalt/reference/starboard/configuration-public.html">configuration_public.h</a></li>
        <li><a href="/cobalt/reference/starboard/gyp-configuration.html">gyp_configuration.gypi</a></li>
                <li><b>Starboard modules</b>
          <ul>
                      <li><a href="/cobalt/reference/starboard/modules/atomic.html">atomic.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/audio_sink.html">audio_sink.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/blitter.html">blitter.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/byte_swap.html">byte_swap.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/character.html">character.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/condition_variable.html">condition_variable.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/configuration.html">configuration.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/directory.html">directory.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/double.html">double.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/drm.html">drm.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/event.html">event.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/export.html">export.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/file.html">file.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/input.html">input.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/key.html">key.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/log.html">log.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/media.html">media.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/memory.html">memory.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/mutex.html">mutex.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/once.html">once.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/player.html">player.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/queue.html">queue.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/socket.html">socket.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/socket_waiter.html">socket_waiter.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/spin_lock.html">spin_lock.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/storage.html">storage.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/string.html">string.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/system.html">system.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/thread.html">thread.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/thread_types.html">thread_types.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/time.html">time.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/time_zone.html">time_zone.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/types.html">types.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/user.html">user.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/window.html">window.h</a></li>
          </ul>
      </ul>
    </li>
  </ul>
</li>
  
<li class="expand-container" data-expander-target-search="relative">
          <h4 class="submenu">Developers</h4>
  <ul class="content">
    <li><b>Guides</b>
      <ul>
        <li><a href="/cobalt/development/setup-linux.html">Setup - Linux</a></li>
        <li><a href="/cobalt/development/setup-raspi.html">Setup - RasPi</a></li>
      </ul>
    </li>
    <li><b>Reference</b>
      <ul>
        <li><a href="/cobalt/development/reference/supported-features.html">Cobalt support</a></li>
      </ul>
    </li>
  </ul>
</li>
  

<li class="expand-container" data-expander-target-search="relative">
<h4 class="no-submenu"><a href="/cobalt/contributors/index.html">Contributors</a></h4>
</li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container -->
</nav>
    
<div id="masthead">
  <div class="container">
    <div class="row">
      <div class="col-md-11">
        <h1>Starboard Module Reference: blitter.h</h1>
      </div>
    </div>
  </div>
</div>


<div class="container">
    <div class="row scroll-margin" id="toc-content-row">
    <div class="col-md-2" id="leftCol">
      <ul class="nav nav-stacked mobile-left-nav-menu" id="sidebar">
        
<li class="expand-container" data-expander-target-search="relative">
<h4 class="no-submenu no-top-margin"><a href="/cobalt/overview.html">Overview</a></h4>
</li>
        
  
<li class="expand-container" data-expander-target-search="relative">
          <h4 class="submenu no-top-margin">Porters</h4>
  <ul class="content">
    <li><b>Guides</b>
      <ul>
        <li><a href="/cobalt/starboard/porting.html">Port Cobalt to your platform</a></li>
        <li><a href="/cobalt/starboard/testing.html">Testing with NPLB</a></li>
      </ul>
    </li>
    <li><b>Reference</b>
      <ul>
        <li><a href="/cobalt/reference/starboard/configuration-public.html">configuration_public.h</a></li>
        <li><a href="/cobalt/reference/starboard/gyp-configuration.html">gyp_configuration.gypi</a></li>
                <li><b>Starboard modules</b>
          <ul>
                      <li><a href="/cobalt/reference/starboard/modules/atomic.html">atomic.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/audio_sink.html">audio_sink.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/blitter.html">blitter.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/byte_swap.html">byte_swap.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/character.html">character.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/condition_variable.html">condition_variable.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/configuration.html">configuration.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/directory.html">directory.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/double.html">double.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/drm.html">drm.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/event.html">event.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/export.html">export.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/file.html">file.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/input.html">input.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/key.html">key.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/log.html">log.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/media.html">media.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/memory.html">memory.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/mutex.html">mutex.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/once.html">once.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/player.html">player.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/queue.html">queue.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/socket.html">socket.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/socket_waiter.html">socket_waiter.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/spin_lock.html">spin_lock.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/storage.html">storage.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/string.html">string.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/system.html">system.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/thread.html">thread.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/thread_types.html">thread_types.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/time.html">time.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/time_zone.html">time_zone.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/types.html">types.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/user.html">user.h</a></li>
                      <li><a href="/cobalt/reference/starboard/modules/window.html">window.h</a></li>
          </ul>
      </ul>
    </li>
  </ul>
</li>
<li class="expand-container" data-expander-target-search="relative">
          <h4 class="submenu">Developers</h4>
  <ul class="content">
    <li><b>Guides</b>
      <ul>
        <li><a href="/cobalt/development/setup-linux.html">Setup - Linux</a></li>
        <li><a href="/cobalt/development/setup-raspi.html">Setup - RasPi</a></li>
      </ul>
    </li>
    <li><b>Reference</b>
      <ul>
        <li><a href="/cobalt/development/reference/supported-features.html">Cobalt support</a></li>
      </ul>
    </li>
  </ul>
</li>
<li class="expand-container" data-expander-target-search="relative">
<h4 class="no-submenu"><a href="/cobalt/contributors/index.html">Contributors</a></h4>
</li>
      </ul>
    </div>
    <div class="col-md-3 show-share-buttons-bottom" id="rightCol">
      <div class="nav nav-stacked" id="tocSidebar">
        
        <div id="toc"></div>
        
        
      </div>
    </div>
    <div class="col-md-7" id="centerCol">
      <div id="content">
        <p>The Blitter API provides support for issuing simple blit-style draw
commands to either an offscreen surface or to a Starboard SbWindow object.
This API is designed to allow implementations make use of GPU hardware
acceleration, if it is available.  Draw commands exist for solid-color
rectangles and rasterization/blitting of rectangular images onto
rectangular target patches.<br>
<strong>Threading Concerns:</strong><br>
Note that in general the Blitter API is not thread safe, except for all
SbBlitterDevice-related functions.  All functions that are not required to
internally ensure any thread safety guarantees are prefaced with a comment
indicating that they are not thread safe.
Functions which claim to not be thread safe can still be used from multiple
threads, but manual synchronization must be performed in order to ensure
their parameters are not referenced at the same time on another thread by
another function.
Examples:
<ul><li>Multiple threads should not issue commands to the same SbBlitterContext
object unless they are manually synchronized.
</li><li>Multiple threads should not issue draw calls to the same render target,
even if the draw calls are made within separate contexts.  In this case,
be sure to manually synchronize through the use of syncrhonization
primitives and use of the SbBlitterFlushContext() command.
</li><li>Multiple threads can operate on the swap chain, but they must perform
manual synchronization.</li></ul></p>

<h2 id="enums">Enums</h2>

<h3 id="sbblitterpixeldataformat">SbBlitterPixelDataFormat</h3>

<p>Defines the set of pixel formats that can be used with the Blitter API
SbBlitterPixelData objects.  Note that not all of these formats are
guaranteed to be supported by a particular device, so before using these
formats in pixel data creation commands, it should be checked that they are
supported first (e.g. via SbBlitterIsPixelFormatSupportedByPixelData()).
SbBlitterPixelDataFormat specifies specific orderings of the color channels,
and when doing so, byte-order is used, e.g. &quot;RGBA&quot; implies that a value for
red is stored in the byte with the lowest memory address.  All pixel values
are assumed to be in premultiplied alpha format.</p>

<p><strong>Values</strong></p>

<ul>
<li>  <code class="prettyprint">kSbBlitterPixelDataFormatARGB8</code> -  32-bit pixels with 8-bits per channel, the alpha component in the byte with the lowest address and blue in the byte with the highest address.</li>
<li>  <code class="prettyprint">kSbBlitterPixelDataFormatBGRA8</code> - 32-bit pixels with 8-bits per channel, the blue component in the bytewith the lowest address and alpha in the byte with the highest address.</li>
<li>  <code class="prettyprint">kSbBlitterPixelDataFormatRGBA8</code> - 32-bit pixels with 8-bits per channel, the red component in the bytewith the lowest address and alpha in the byte with the highest address.</li>
<li>  <code class="prettyprint">kSbBlitterPixelDataFormatA8</code> - 8-bit pixels that contain only a single alpha channel.  When rendered,surfaces in this format will have (R, G, B) values of (255, 255, 255).</li>
<li>  <code class="prettyprint">kSbBlitterNumPixelDataFormats</code> - Constant that indicates how many unique pixel formats Starboard supports.</li>
<li>  <code class="prettyprint">kSbBlitterInvalidPixelDataFormat</code></li>
</ul>

<h3 id="sbblittersurfaceformat">SbBlitterSurfaceFormat</h3>

<p>Enumeration that describes the color format of surfaces.  Note that
SbBlitterSurfaceFormat does not differentiate between permutations of the
color channel ordering (e.g. RGBA vs ARGB) since client code will never be
able to access surface pixels directly.  This is the main difference between
SbBlitterPixelDataFormat, which does explicitly dictate an ordering.</p>

<p><strong>Values</strong></p>

<ul>
<li>  <code class="prettyprint">kSbBlitterSurfaceFormatRGBA8</code> -  32-bit RGBA color, with 8 bits per channel.</li>
<li>  <code class="prettyprint">kSbBlitterSurfaceFormatA8</code> - 8-bit alpha-only color.</li>
<li>  <code class="prettyprint">kSbBlitterNumSurfaceFormats</code> - Constant that indicates how many unique surface formats Starboard supports.</li>
<li>  <code class="prettyprint">kSbBlitterInvalidSurfaceFormat</code></li>
</ul>

<h2 id="structs">Structs</h2>

<h3 id="sbblittercontextprivate">SbBlitterContextPrivate</h3>

<p>SbBlitterContext objects represent a stateful communications channel with
a device.  All state changes and draw calls will be made through a specific
SbBlitterContext object.  Every draw call made on a SbBlitterContext will
be submitted to the device with the SbBlitterContext&#39;s current state applied
to it.  Draw calls may be submitted to the device as they are made on the
SbBlitterContext, however they are not guaranteed to be submitted until
the SbBlitterContext object is flushed.
TODO: Last sentence uses &quot;submitted&quot; twice, seemingly with different
meanings.</p>

<h3 id="sbblitterdeviceprivate">SbBlitterDevicePrivate</h3>

<p>A SbBlitterDevice object represents a process&#39; connection to a blitter
device, such as a GPU.  It is through this device that all subsequent Blitter
API functionality can be accessed.</p>

<h3 id="sbblitterpixeldataprivate">SbBlitterPixelDataPrivate</h3>

<p>A SbBlitterPixelData object represents a buffer of pixels stored in
CPU-accessible memory.  In order to upload pixel data from the CPU to the
GPU, clients should first create a SbBlitterPixelData object, fill in
the pixel data, and then re-submit the filled in SbBlitterPixelData
object to the Blitter API in order to obtain a SbBlitterSurface object that
can be referenced by draw calls.</p>

<h3 id="sbblitterrect">SbBlitterRect</h3>

<p>Defines a rectangle via a point (x, y) and a size, (width, height).
This structure is used as a parameter type in various blit calls.</p>

<p><strong>Members</strong></p>

<table class="responsive">
  <tr><th colspan="2">Members</th></tr>
  <tr>
    <td><code>int</code><br>        <code>x</code></td>    <td></td>  </tr>
  <tr>
    <td><code>int</code><br>        <code>y</code></td>    <td></td>  </tr>
  <tr>
    <td><code>int</code><br>        <code>width</code></td>    <td></td>  </tr>
  <tr>
    <td><code>int</code><br>        <code>height</code></td>    <td></td>  </tr>
</table>

<h3 id="sbblitterrendertargetprivate">SbBlitterRenderTargetPrivate</h3>

<p>A SbBlitterRenderTarget may be obtained from either a SbBlitterSwapChain
if it represents a primary display output, or through a SbBlitterSurface
if it represents an offscreen rendering target.  A SbBlitterRenderTarget
must be specified within a SbBlitterContext before making a draw call.</p>

<h3 id="sbblittersurfaceinfo">SbBlitterSurfaceInfo</h3>

<p>SbBlitterSurfaceInfo collects information about surfaces that can be queried
from them at any time.</p>

<p><strong>Members</strong></p>

<table class="responsive">
  <tr><th colspan="2">Members</th></tr>
  <tr>
    <td><code>int</code><br>        <code>width</code></td>    <td></td>  </tr>
  <tr>
    <td><code>int</code><br>        <code>height</code></td>    <td></td>  </tr>
  <tr>
    <td><code>SbBlitterSurfaceFormat</code><br>        <code>format</code></td>    <td></td>  </tr>
</table>

<h3 id="sbblittersurfaceprivate">SbBlitterSurfacePrivate</h3>

<p>A SbBlitterSurface object represents a device-side surface of pixel data that
can be used as either the source or the target of device draw calls.
Note that depending on how the surface is created, it may not be able to
offer the ability to obtain a SbBlitterRenderTarget. SbBlitterSurface objects
may be populated by data either by the CPU via SbBlitterPixelData objects, or
via the device by using this SbBlitterSurface&#39;s SbBlitterRenderTarget object
as the target of draw calls.</p>

<h3 id="sbblitterswapchainprivate">SbBlitterSwapChainPrivate</h3>

<p>A SbBlitterSwapChain represents the (potentially back buffered) output
display device.  A SbBlitterRenderTarget can be retrieved from a
SbBlitterSwapChain, providing a target for draw commands.  The
SbBlitterSwapChain object also exposes the ability to flip back buffers.</p>

<h2 id="functions">Functions</h2>

<h3 id="sbblitterafromcolor">SbBlitterAFromColor</h3>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static SB_C_FORCE_INLINE uint8_t SbBlitterAFromColor(SbBlitterColor color) {
  return (color &amp; 0x000000FF) &gt;&gt; 0;
}
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterColor</code></td>
    <td><code>color</code></td>
  </tr>
</table>

<h3 id="sbblitterbfromcolor">SbBlitterBFromColor</h3>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static SB_C_FORCE_INLINE uint8_t SbBlitterBFromColor(SbBlitterColor color) {
  return (color &amp; 0x0000FF00) &gt;&gt; 8;
}
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterColor</code></td>
    <td><code>color</code></td>
  </tr>
</table>

<h3 id="sbblitterblitrecttorect">SbBlitterBlitRectToRect</h3>

<p><strong>Description</strong></p>

<p>Issues a draw call on <code class="prettyprint">context</code> that blits an area of <code class="prettyprint">source_surface</code>
specified by a <code class="prettyprint">src_rect</code> to <code class="prettyprint">context</code>&#39;s current render target at <code class="prettyprint">dst_rect</code>.
The source rectangle must lie within the dimensions of <code class="prettyprint">source_surface</code>.
Note that the <code class="prettyprint">source_surface</code>&#39;s alpha is modulated by <code class="prettyprint">opacity</code> before
being drawn. For <code class="prettyprint">opacity</code>, a value of 0 implies complete invisibility,
and a value of 255 implies complete opacity.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterBlitRectToRect(SbBlitterContext context,
                                       SbBlitterSurface source_surface,
                                       SbBlitterRect src_rect,
                                       SbBlitterRect dst_rect);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterContext</code><br>        <code>context</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SbBlitterSurface</code><br>        <code>source_surface</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SbBlitterRect</code><br>        <code>src_rect</code></td>
    <td>The area to be blitted. TODO: Is blitted proper past tense?</td>
  </tr>
  <tr>
    <td><code>SbBlitterRect</code><br>        <code>dst_rect</code></td>
    <td></td>
  </tr>
</table>

<h3 id="sbblitterblitrecttorecttiled">SbBlitterBlitRectToRectTiled</h3>

<p><strong>Description</strong></p>

<p>This function functions identically to <code><a href="#sbblitterblitrecttorect">SbBlitterBlitRectToRect()</a></code>, except
it permits values of <code class="prettyprint">src_rect</code> outside the dimensions of <code class="prettyprint">source_surface</code>.
In those regions, the pixel data from <code class="prettyprint">source_surface</code> will be wrapped.
Negative values for <code class="prettyprint">src_rect.x</code> and <code class="prettyprint">src_rect.y</code> are allowed.<br>
The output is all stretched to fit inside of <code class="prettyprint">dst_rect</code>.<br>
This function is not thread-safe.<br>
The return value indicates whether the draw call succeeded.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterBlitRectToRectTiled(SbBlitterContext context,
                                            SbBlitterSurface source_surface,
                                            SbBlitterRect src_rect,
                                            SbBlitterRect dst_rect);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterContext</code><br>        <code>context</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SbBlitterSurface</code><br>        <code>source_surface</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SbBlitterRect</code><br>        <code>src_rect</code></td>
    <td> </td>  </tr>
  <tr>
    <td><code>SbBlitterRect</code><br>        <code>dst_rect</code></td>
    <td> </td>  </tr>
</table>

<h3 id="sbblitterblitrectstorects">SbBlitterBlitRectsToRects</h3>

<p><strong>Description</strong></p>

<p>This function achieves the same effect as calling <code><a href="#sbblitterblitrecttorect">SbBlitterBlitRectToRect()</a></code>
<code class="prettyprint">num_rects</code> times with each of the <code class="prettyprint">num_rects</code> values of <code class="prettyprint">src_rects</code> and
<code class="prettyprint">dst_rects</code>. This function allows for greater efficiency than looped calls
to <code><a href="#sbblitterblitrecttorect">SbBlitterBlitRectToRect()</a></code>.<br>
This function is not thread-safe.<br>
The return value indicates whether the draw call succeeded.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterBlitRectsToRects(SbBlitterContext context,
                                         SbBlitterSurface source_surface,
                                         const SbBlitterRect* src_rects,
                                         const SbBlitterRect* dst_rects,
                                         int num_rects);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterContext</code><br>        <code>context</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SbBlitterSurface</code><br>        <code>source_surface</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>const SbBlitterRect*</code><br>        <code>src_rects</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>const SbBlitterRect*</code><br>        <code>dst_rects</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>int</code><br>        <code>num_rects</code></td>
    <td></td>
  </tr>
</table>

<h3 id="sbblitterbytesperpixelforformat">SbBlitterBytesPerPixelForFormat</h3>

<p><strong>Description</strong></p>

<p>A convenience function to return the number of bytes per pixel for a given
pixel format.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static SB_C_FORCE_INLINE int SbBlitterBytesPerPixelForFormat(
    SbBlitterPixelDataFormat format) {
  switch (format) {
    case kSbBlitterPixelDataFormatARGB8:
      return 4;
    case kSbBlitterPixelDataFormatBGRA8:
      return 4;
    case kSbBlitterPixelDataFormatRGBA8:
      return 4;
    case kSbBlitterPixelDataFormatA8:
      return 1;
    default:
      return 0;
  }
}
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterPixelDataFormat</code></td>
    <td><code>format</code></td>
  </tr>
</table>

<h3 id="sbblittercolorfromrgba">SbBlitterColorFromRGBA</h3>

<p><strong>Description</strong></p>

<p>A convenience function to create a SbBlitterColor object from separate
8-bit RGBA components.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static SB_C_FORCE_INLINE SbBlitterColor SbBlitterColorFromRGBA(uint8_t r,
                                                               uint8_t g,
                                                               uint8_t b,
                                                               uint8_t a) {
  return (r &lt;&lt; 24) | (g &lt;&lt; 16) | (b &lt;&lt; 8) | a;
}
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>uint8_t</code></td>
    <td><code>r</code></td>
  </tr>
  <tr>
    <td><code>uint8_t</code></td>
    <td><code>g</code></td>
  </tr>
  <tr>
    <td><code>uint8_t</code></td>
    <td><code>b</code></td>
  </tr>
  <tr>
    <td><code>uint8_t</code></td>
    <td><code>a</code></td>
  </tr>
</table>

<h3 id="sbblittercreatecontext">SbBlitterCreateContext</h3>

<p><strong>Description</strong></p>

<p>Creates a SbBlitterContext object on the specified <code class="prettyprint">device</code>. The returned
context can be used to set up draw state and issue draw calls.<br>
Note that there is a limit on the number of contexts that can exist
simultaneously, which can be queried by calling <code><a href="#sbblittergetmaxcontexts">SbBlitterGetMaxContexts()</a></code>.
(The limit is often <code class="prettyprint">1</code>.)<br>
SbBlitterContext objects keep track of draw state between a series of draw
calls. Please refer to the SbBlitterContext() definition for more
information about contexts.<br>
This function is thread-safe.<br>
This function returns kSbBlitterInvalidContext upon failure. Note that the
function fails if it has already been used to create the maximum number
of contexts.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT SbBlitterContext SbBlitterCreateContext(SbBlitterDevice device);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterDevice</code><br>        <code>device</code></td>
    <td>The device for which the SbBlitterContext object is created.</td>
  </tr>
</table>

<h3 id="sbblittercreatedefaultdevice">SbBlitterCreateDefaultDevice</h3>

<p><strong>Description</strong></p>

<p>Creates and returns a SbBlitterDevice object based on the Blitter API
implementation&#39;s decision of which device should be the default. The
returned SbBlitterDevice object represents a connection to a device
(like a GPU).
On many platforms there is always one single obvious choice for a device
to use, and that is the one that this function will return. For example,
if this is called on a platform that has a single GPU, this call should
return an object that represents that GPU. On a platform that has no GPU,
an object representing a software CPU implementation may be returned.<br>
Only one default device can exist within a process at a time.
This function is thread-safe.
Returns kSbBlitterInvalidDevice on failure.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT SbBlitterDevice SbBlitterCreateDefaultDevice();
</code></pre></div>
<h3 id="sbblittercreatepixeldata">SbBlitterCreatePixelData</h3>

<p><strong>Description</strong></p>

<p>Allocates a SbBlitterPixelData object through <code class="prettyprint">device</code> with <code class="prettyprint">width</code>,
<code class="prettyprint">height</code> and <code class="prettyprint">pixel_format</code>. <code class="prettyprint">pixel_format</code> must be supported by <code class="prettyprint">device</code>
(see <code><a href="#sbblitterispixelformatsupportedbypixeldata">SbBlitterIsPixelFormatSupportedByPixelData()</a></code>). This function is
thread-safe.<br>
Calling this function results in the allocation of CPU-accessible
(though perhaps blitter-device-resident) memory to store pixel data
of the requested size/format. A SbBlitterPixelData object should
eventually be passed either into a call to
SbBlitterCreateSurfaceFromPixelData() or into a call to
SbBlitterDestroyPixelData().<br>
Returns kSbBlitterInvalidPixelData upon failure.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT SbBlitterPixelData
SbBlitterCreatePixelData(SbBlitterDevice device,
                         int width,
                         int height,
                         SbBlitterPixelDataFormat pixel_format);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterDevice</code><br>        <code>device</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>int</code><br>        <code>width</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>int</code><br>        <code>height</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SbBlitterPixelDataFormat</code><br>        <code>pixel_format</code></td>
    <td></td>
  </tr>
</table>

<h3 id="sbblittercreaterendertargetsurface">SbBlitterCreateRenderTargetSurface</h3>

<p><strong>Description</strong></p>

<p>Creates a new surface with undefined pixel data on <code class="prettyprint">device</code> with the
specified <code class="prettyprint">width</code>, <code class="prettyprint">height</code> and <code class="prettyprint">pixel_format</code>. One can set the pixel data
on the resulting surface by getting its associated SbBlitterRenderTarget
object and then calling <code><a href="#sbblittergetrendertargetfromsurface">SbBlitterGetRenderTargetFromSurface()</a></code>.<br>
This function is thread safe.<br>
Returns kSbBlitterInvalidSurface upon failure.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT SbBlitterSurface
SbBlitterCreateRenderTargetSurface(SbBlitterDevice device,
                                   int width,
                                   int height,
                                   SbBlitterSurfaceFormat surface_format);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterDevice</code><br>        <code>device</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>int</code><br>        <code>width</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>int</code><br>        <code>height</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SbBlitterSurfaceFormat</code><br>        <code>surface_format</code></td>
    <td></td>
  </tr>
</table>

<h3 id="sbblittercreatesurfacefrompixeldata">SbBlitterCreateSurfaceFromPixelData</h3>

<p><strong>Description</strong></p>

<p>Creates a SbBlitterSurface object on <code class="prettyprint">device</code>. Note that <code class="prettyprint">device</code> must
match the device that was used to create the SbBlitterPixelData object
provided via the <code class="prettyprint">pixel_format</code> parameter.<br>
This function also destroys the input <code class="prettyprint">pixel_data</code> object. As a result,
<code class="prettyprint">pixel_data</code> should not be accessed again after a call to this function.<br>
The returned object cannot be used as a render target (e.g. calling
SbBlitterGetRenderTargetFromSurface() on it will return
SbBlitterInvalidRenderTarget).<br>
This function is thread-safe with respect to <code class="prettyprint">device</code>, but <code class="prettyprint">pixel_data</code>
should not be modified on another thread while this function is called.<br>
Returns kSbBlitterInvalidSurface in the event of an error.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT SbBlitterSurface
SbBlitterCreateSurfaceFromPixelData(SbBlitterDevice device,
                                    SbBlitterPixelData pixel_data);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterDevice</code><br>        <code>device</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SbBlitterPixelData</code><br>        <code>pixel_data</code></td>
    <td></td>
  </tr>
</table>

<h3 id="sbblittercreateswapchainfromwindow">SbBlitterCreateSwapChainFromWindow</h3>

<p><strong>Description</strong></p>

<p>Creates and returns a SbBlitterSwapChain object that can then be used to
send graphics to the display. This function links <code class="prettyprint">device</code> to <code class="prettyprint">window</code>&#39;s
output, and drawing to the returned swap chain will result in <code class="prettyprint">device</code>
being used to render to <code class="prettyprint">window</code>.<br>
This function must be called from the thread that called SbWindowCreate()
to create <code class="prettyprint">window</code>.<br>
Returns kSbBlitterInvalidSwapChain on failure.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT SbBlitterSwapChain
SbBlitterCreateSwapChainFromWindow(SbBlitterDevice device, SbWindow window);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterDevice</code><br>        <code>device</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SbWindow</code><br>        <code>window</code></td>
    <td></td>
  </tr>
</table>

<h3 id="sbblitterdestroycontext">SbBlitterDestroyContext</h3>

<p><strong>Description</strong></p>

<p>Destroys the specified <code class="prettyprint">context</code> created by <code class="prettyprint">device</code>, freeing all its
resources. This function is not thread-safe.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterDestroyContext(SbBlitterContext context);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterContext</code><br>        <code>context</code></td>
    <td>The object to be destroyed.</td>
  </tr>
</table>

<h3 id="sbblitterdestroydevice">SbBlitterDestroyDevice</h3>

<p><strong>Description</strong></p>

<p>Destroys <code class="prettyprint">device</code>, cleaning up all resources associated with it.
This function is thread safe, but it should not be called if the
<code class="prettyprint">device</code> is still being accessed elsewhere.
The return value indicates whether the destruction succeeded.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterDestroyDevice(SbBlitterDevice device);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterDevice</code><br>        <code>device</code></td>
    <td>The SbBlitterDevice object to be destroyed.</td>
  </tr>
</table>

<h3 id="sbblitterdestroypixeldata">SbBlitterDestroyPixelData</h3>

<p><strong>Description</strong></p>

<p>Destroys the <code class="prettyprint">pixel_data</code> object. Note that this function does not need
to be called and should not be called if
SbBlitterCreateSurfaceFromPixelData() has been called on <code class="prettyprint">pixel_data</code>
before. This function is thread safe.<br>
The return value indicates whether the destruction succeeded.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterDestroyPixelData(SbBlitterPixelData pixel_data);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterPixelData</code><br>        <code>pixel_data</code></td>
    <td>The object to be destroyed.</td>
  </tr>
</table>

<h3 id="sbblitterdestroysurface">SbBlitterDestroySurface</h3>

<p><strong>Description</strong></p>

<p>Destroys the <code class="prettyprint">surface</code> object, cleaning up all resources associated with it.
This function is not thread safe.<br>
The return value indicates whether the destruction succeeded.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterDestroySurface(SbBlitterSurface surface);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterSurface</code><br>        <code>surface</code></td>
    <td>The object to be destroyed.</td>
  </tr>
</table>

<h3 id="sbblitterdestroyswapchain">SbBlitterDestroySwapChain</h3>

<p><strong>Description</strong></p>

<p>Destroys <code class="prettyprint">swap_chain</code>, cleaning up all resources associated with it.
This function is not thread-safe and must be called on the same thread
that called <code><a href="#sbblittercreateswapchainfromwindow">SbBlitterCreateSwapChainFromWindow()</a></code>.
The return value indicates whether the destruction succeeded.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterDestroySwapChain(SbBlitterSwapChain swap_chain);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterSwapChain</code><br>        <code>swap_chain</code></td>
    <td>The swap chain to be destroyed.</td>
  </tr>
</table>

<h3 id="sbblitterdownloadsurfacepixels">SbBlitterDownloadSurfacePixels</h3>

<p><strong>Description</strong></p>

<p>Downloads <code class="prettyprint">surface</code> pixel data into CPU memory pointed to by
<code class="prettyprint">out_pixel_data</code>, formatted according to the requested <code class="prettyprint">pixel_format</code> and
the requested <code class="prettyprint">pitch_in_bytes</code>. Before calling this function, you can call
SbBlitterIsPixelFormatSupportedByDownloadSurfacePixels() to confirm that
your requested <code class="prettyprint">pixel_format</code> is valid for <code class="prettyprint">surface</code>.<br>
When this function is called, it first waits for all previously flushed
graphics commands to be executed by the device before downloading the data.
Since this function waits for the pipeline to empty, it should be used
sparingly, such as within in debug or test environments.<br>
The return value indicates whether the pixel data was downloaded
successfully.<br>
The returned alpha format will be premultiplied.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterDownloadSurfacePixels(
    SbBlitterSurface surface,
    SbBlitterPixelDataFormat pixel_format,
    int pitch_in_bytes,
    void* out_pixel_data);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterSurface</code><br>        <code>surface</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SbBlitterPixelDataFormat</code><br>        <code>pixel_format</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>int</code><br>        <code>pitch_in_bytes</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>void*</code><br>        <code>out_pixel_data</code></td>
    <td>A pointer to a region of memory with a size of
(surface_height * <code>pitch_in_bytes</code> *
SbBlitterBytesPerPixelForFormat(pixel_format) bytes.</td>
  </tr>
</table>

<h3 id="sbblitterfillrect">SbBlitterFillRect</h3>

<p><strong>Description</strong></p>

<p>Issues a draw call on <code class="prettyprint">context</code> that fills the specified rectangle <code class="prettyprint">rect</code>.
The rectangle&#39;s color is determined by the last call to <code><a href="#sbblittersetcolor">SbBlitterSetColor()</a></code>.<br>
This function is not thread-safe.<br>
The return value indicates whether the draw call succeeded.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterFillRect(SbBlitterContext context, SbBlitterRect rect);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterContext</code><br>        <code>context</code></td>
    <td>The context on which the draw call will operate.</td>
  </tr>
  <tr>
    <td><code>SbBlitterRect</code><br>        <code>rect</code></td>
    <td>The rectangle to be filled.</td>
  </tr>
</table>

<h3 id="sbblitterflipswapchain">SbBlitterFlipSwapChain</h3>

<p><strong>Description</strong></p>

<p>Flips the <code class="prettyprint">swap_chain</code> by making the buffer previously accessible to
draw commands via <code><a href="#sbblittergetrendertargetfromswapchain">SbBlitterGetRenderTargetFromSwapChain()</a></code> visible on the
display, while another buffer in an initially undefined state is set up
as the new draw command target. Note that you do not need to call
SbBlitterGetRenderTargetFromSwapChain() again after flipping, the swap
chain&#39;s render target always refers to its current back buffer.<br>
This function stalls the calling thread until the next vertical refresh.
In addition, to ensure consistency with the Starboard Player API when
rendering punch-out video, calls to SbPlayerSetBounds() do not take effect
until this method is called.<br>
The return value indicates whether the flip succeeded.<br>
This function is not thread safe.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterFlipSwapChain(SbBlitterSwapChain swap_chain);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterSwapChain</code><br>        <code>swap_chain</code></td>
    <td>The SbBlitterSwapChain object to be flipped.</td>
  </tr>
</table>

<h3 id="sbblitterflushcontext">SbBlitterFlushContext</h3>

<p><strong>Description</strong></p>

<p>Flushes all draw calls previously issued to <code class="prettyprint">context</code>. Calling this function
guarantees that the device processes all subsequent draw calls (on any
context) after all previous draw calls issued on this <code class="prettyprint">context</code>.<br>
It is often prudent to call this function before calling
SbBlitterFlipSwapChain(), to ensure that all draw calls are submitted
before the flip occurs.<br>
This function is not thread-safe.<br>
The return value indicates whether the flush succeeded.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterFlushContext(SbBlitterContext context);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterContext</code><br>        <code>context</code></td>
    <td>The context for which draw calls are being flushed.</td>
  </tr>
</table>

<h3 id="sbblittergfromcolor">SbBlitterGFromColor</h3>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static SB_C_FORCE_INLINE uint8_t SbBlitterGFromColor(SbBlitterColor color) {
  return (color &amp; 0x00FF0000) &gt;&gt; 16;
}
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterColor</code></td>
    <td><code>color</code></td>
  </tr>
</table>

<h3 id="sbblittergetmaxcontexts">SbBlitterGetMaxContexts</h3>

<p><strong>Description</strong></p>

<p>Returns the maximum number of contexts that <code class="prettyprint">device</code> can support in
parallel. Note that devices often support only a single context.<br>
This function is thread-safe.<br>
This function returns <code class="prettyprint">-1</code> upon failure.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT int SbBlitterGetMaxContexts(SbBlitterDevice device);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterDevice</code><br>        <code>device</code></td>
    <td>The device for which the maximum number of contexts is returned.</td>
  </tr>
</table>

<h3 id="sbblittergetpixeldatapitchinbytes">SbBlitterGetPixelDataPitchInBytes</h3>

<p><strong>Description</strong></p>

<p>Retrieves the pitch (in bytes) for <code class="prettyprint">pixel_data</code>. This indicates the number
of bytes per row of pixel data in the image. This function is not
thread-safe.<br>
Returns <code class="prettyprint">-1</code> in the event of an error.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT int SbBlitterGetPixelDataPitchInBytes(SbBlitterPixelData pixel_data);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterPixelData</code><br>        <code>pixel_data</code></td>
    <td>The object for which you are retrieving the pitch.</td>
  </tr>
</table>

<h3 id="sbblittergetpixeldatapointer">SbBlitterGetPixelDataPointer</h3>

<p><strong>Description</strong></p>

<p>Retrieves a CPU-accessible pointer to the pixel data represented by
<code class="prettyprint">pixel_data</code>. This pixel data can be modified by the CPU in order to
initialize it on the CPU before calling
SbBlitterCreateSurfaceFromPixelData().<br>
Note that the pointer returned here is valid as long as <code class="prettyprint">pixel_data</code>
is valid, i.e. until either <code><a href="#sbblittercreatesurfacefrompixeldata">SbBlitterCreateSurfaceFromPixelData()</a></code> or
SbBlitterDestroyPixelData() is called.<br>
This function is not thread safe.<br>
Returns <code class="prettyprint">NULL</code> in the event of an error.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT void* SbBlitterGetPixelDataPointer(SbBlitterPixelData pixel_data);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterPixelData</code><br>        <code>pixel_data</code></td>
    <td></td>
  </tr>
</table>

<h3 id="sbblittergetrendertargetfromsurface">SbBlitterGetRenderTargetFromSurface</h3>

<p><strong>Description</strong></p>

<p>Returns the SbBlitterRenderTarget object owned by <code class="prettyprint">surface</code>. The returned
object can be used as a target for draw calls.
This function returns kSbBlitterInvalidRenderTarget if <code class="prettyprint">surface</code> is not
able to provide a render target, or on any other error.<br>
This function is not thread safe.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT SbBlitterRenderTarget
SbBlitterGetRenderTargetFromSurface(SbBlitterSurface surface);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterSurface</code><br>        <code>surface</code></td>
    <td></td>
  </tr>
</table>

<h3 id="sbblittergetrendertargetfromswapchain">SbBlitterGetRenderTargetFromSwapChain</h3>

<p><strong>Description</strong></p>

<p>Returns the <code class="prettyprint">SbBlitterRenderTarget</code> object that is owned by <code class="prettyprint">swap_chain</code>.
The returned object can be used to provide a target to blitter draw calls
that draw directly to the display buffer. This function is not thread safe.<br>
Returns kSbBlitterInvalidRenderTarget on failure.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT SbBlitterRenderTarget
SbBlitterGetRenderTargetFromSwapChain(SbBlitterSwapChain swap_chain);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterSwapChain</code><br>        <code>swap_chain</code></td>
    <td>The swap chain for which the target object is being retrieved.</td>
  </tr>
</table>

<h3 id="sbblittergetsurfaceinfo">SbBlitterGetSurfaceInfo</h3>

<p><strong>Description</strong></p>

<p>Returns a SbBlitterSurfaceInfo structure, which describes immutable
parameters of the <code class="prettyprint">surface</code>, such as its width, height and pixel format.
The results are set on the output parameter <code class="prettyprint">surface_info</code>, which cannot
be NULL.<br>
Returns whether the information was retrieved successfully.<br>
This function is not thread safe.<br></p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterGetSurfaceInfo(SbBlitterSurface surface,
                                       SbBlitterSurfaceInfo* surface_info);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterSurface</code><br>        <code>surface</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SbBlitterSurfaceInfo*</code><br>        <code>surface_info</code></td>
    <td></td>
  </tr>
</table>

<h3 id="sbblitteriscontextvalid">SbBlitterIsContextValid</h3>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static SB_C_FORCE_INLINE bool SbBlitterIsContextValid(
    SbBlitterContext context) {
  return context != kSbBlitterInvalidContext;
}
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterContext</code></td>
    <td><code>context</code></td>
  </tr>
</table>

<h3 id="sbblitterisdevicevalid">SbBlitterIsDeviceValid</h3>

<p><strong>Description</strong></p>

<p>Helper functions to check whether or not a blitter object is invalid.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static SB_C_FORCE_INLINE bool SbBlitterIsDeviceValid(SbBlitterDevice device) {
  return device != kSbBlitterInvalidDevice;
}
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterDevice</code></td>
    <td><code>device</code></td>
  </tr>
</table>

<h3 id="sbblitterispixeldatavalid">SbBlitterIsPixelDataValid</h3>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static SB_C_FORCE_INLINE bool SbBlitterIsPixelDataValid(
    SbBlitterPixelData pixel_data) {
  return pixel_data != kSbBlitterInvalidPixelData;
}
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterPixelData</code></td>
    <td><code>pixel_data</code></td>
  </tr>
</table>

<h3 id="sbblitterispixelformatsupportedbydownloadsurfacepixels">SbBlitterIsPixelFormatSupportedByDownloadSurfacePixels</h3>

<p><strong>Description</strong></p>

<p>Indicates whether the combination of parameter values is valid for calls
to <code><a href="#sbblitterdownloadsurfacepixels">SbBlitterDownloadSurfacePixels()</a></code>.<br>
This function is not thread safe.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterIsPixelFormatSupportedByDownloadSurfacePixels(
    SbBlitterSurface surface,
    SbBlitterPixelDataFormat pixel_format);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterSurface</code><br>        <code>surface</code></td>
    <td>The surface being checked.</td>
  </tr>
  <tr>
    <td><code>SbBlitterPixelDataFormat</code><br>        <code>pixel_format</code></td>
    <td>The pixel format that would be used on the surface.</td>
  </tr>
</table>

<h3 id="sbblitterispixelformatsupportedbypixeldata">SbBlitterIsPixelFormatSupportedByPixelData</h3>

<p><strong>Description</strong></p>

<p>Indicates whether the <code class="prettyprint">device</code> supports calls to <code><a href="#sbblittercreatepixeldata">SbBlitterCreatePixelData()</a></code>
with the specified <code class="prettyprint">pixel_format</code>. This function is thread safe.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterIsPixelFormatSupportedByPixelData(
    SbBlitterDevice device,
    SbBlitterPixelDataFormat pixel_format);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterDevice</code><br>        <code>device</code></td>
    <td>The device for which compatibility is being checked.</td>
  </tr>
  <tr>
    <td><code>SbBlitterPixelDataFormat</code><br>        <code>pixel_format</code></td>
    <td>The pixel format for which compatibility is being checked.</td>
  </tr>
</table>

<h3 id="sbblitterisrendertargetvalid">SbBlitterIsRenderTargetValid</h3>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static SB_C_FORCE_INLINE bool SbBlitterIsRenderTargetValid(
    SbBlitterRenderTarget render_target) {
  return render_target != kSbBlitterInvalidRenderTarget;
}
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterRenderTarget</code></td>
    <td><code>render_target</code></td>
  </tr>
</table>

<h3 id="sbblitterissurfaceformatsupportedbyrendertargetsurface">SbBlitterIsSurfaceFormatSupportedByRenderTargetSurface</h3>

<p><strong>Description</strong></p>

<p>Indicates whether the <code class="prettyprint">device</code> supports calls to
SbBlitterCreateRenderTargetSurface() with <code class="prettyprint">surface_format</code>.<br>
This function is thread-safe.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterIsSurfaceFormatSupportedByRenderTargetSurface(
    SbBlitterDevice device,
    SbBlitterSurfaceFormat surface_format);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterDevice</code><br>        <code>device</code></td>
    <td>The device being checked for compatibility.</td>
  </tr>
  <tr>
    <td><code>SbBlitterSurfaceFormat</code><br>        <code>surface_format</code></td>
    <td>The surface format being checked for compatibility.</td>
  </tr>
</table>

<h3 id="sbblitterissurfacevalid">SbBlitterIsSurfaceValid</h3>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static SB_C_FORCE_INLINE bool SbBlitterIsSurfaceValid(
    SbBlitterSurface surface) {
  return surface != kSbBlitterInvalidSurface;
}
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterSurface</code></td>
    <td><code>surface</code></td>
  </tr>
</table>

<h3 id="sbblitterisswapchainvalid">SbBlitterIsSwapChainValid</h3>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static SB_C_FORCE_INLINE bool SbBlitterIsSwapChainValid(
    SbBlitterSwapChain swap_chain) {
  return swap_chain != kSbBlitterInvalidSwapChain;
}
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterSwapChain</code></td>
    <td><code>swap_chain</code></td>
  </tr>
</table>

<h3 id="sbblittermakerect">SbBlitterMakeRect</h3>

<p><strong>Description</strong></p>

<p>Convenience function to setup a rectangle with the specified parameters.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static SB_C_FORCE_INLINE SbBlitterRect SbBlitterMakeRect(int x,
                                                         int y,
                                                         int width,
                                                         int height) {
  SbBlitterRect rect;
  rect.x = x;
  rect.y = y;
  rect.width = width;
  rect.height = height;
  return rect;
}
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>int</code></td>
    <td><code>x</code></td>
  </tr>
  <tr>
    <td><code>int</code></td>
    <td><code>y</code></td>
  </tr>
  <tr>
    <td><code>int</code></td>
    <td><code>width</code></td>
  </tr>
  <tr>
    <td><code>int</code></td>
    <td><code>height</code></td>
  </tr>
</table>

<h3 id="sbblitterrfromcolor">SbBlitterRFromColor</h3>

<p><strong>Description</strong></p>

<p>The following helper functions can be used to extract specific color
components from a SbBlitterColor object.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static SB_C_FORCE_INLINE uint8_t SbBlitterRFromColor(SbBlitterColor color) {
  return (color &amp; 0xFF000000) &gt;&gt; 24;
}
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterColor</code></td>
    <td><code>color</code></td>
  </tr>
</table>

<h3 id="sbblittersetblending">SbBlitterSetBlending</h3>

<p><strong>Description</strong></p>

<p>Sets the blending state for the specified <code class="prettyprint">context</code>. By default, blending
is disabled on a SbBlitterContext.<br>
This function is not thread-safe.<br>
The return value indicates whether the blending state was set successfully.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterSetBlending(SbBlitterContext context, bool blending);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterContext</code><br>        <code>context</code></td>
    <td>The context for which the blending state is being set.</td>
  </tr>
  <tr>
    <td><code>bool</code><br>        <code>blending</code></td>
    <td>The blending state for the <code>context</code>.
If <code>blending</code> is <code>true</code>, the source alpha of subsequent draw calls
is used to blend with the destination color. In particular,
(<code>Fc = Sc * Sa + Dc * (1 - Sa)</code>), where:
<ul><li><code>Fc</code> is the final color.
</li><li><code>Sc</code> is the source color.
</li><li><code>Sa</code> is the source alpha.
</li><li><code>Dc</code> is the destination color.
If <code>blending</code> is <code>false</code>, the source color and source alpha overwrite
the destination color and alpha. TODO: What is the destination alpha?</td>
  </tr>
</table>

<h3 id="sbblittersetcolor">SbBlitterSetColor</h3>

<p><strong>Description</strong></p>

<p>Sets the context&#39;s current color. The current color&#39;s default value is
SbBlitterColorFromRGBA(255, 255, 255 255).
The current color affects the fill rectangle&#39;s color in calls to
SbBlitterFillRect(), and if <code><a href="#sbblittersetmodulateblitswithcolor">SbBlitterSetModulateBlitsWithColor()</a></code> has been
called to enable blit color modulation, the source blit surface pixel color
is also modulated by the color before being output.<br>
This function is not thread-safe.<br>
The return value indicates whether the color was set successfully.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterSetColor(SbBlitterContext context,
                                 SbBlitterColor color);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterContext</code><br>        <code>context</code></td>
    <td>The context for which the color is being set.</td>
  </tr>
  <tr>
    <td><code>SbBlitterColor</code><br>        <code>color</code></td>
    <td>The context's new color, specified in unpremultiplied alpha format.</td>
  </tr>
</table>

<h3 id="sbblittersetmodulateblitswithcolor">SbBlitterSetModulateBlitsWithColor</h3>

<p><strong>Description</strong></p>

<p>Sets whether or not blit calls should have their source pixels modulated by
the current color, which is set using <code><a href="#sbblittersetcolor">SbBlitterSetColor()</a></code>, before being
output. This function can apply opacity to blit calls, color alpha-only
surfaces, and apply other effects.<br>
This function is not thread-safe.<br>
The return value indicates whether the state was set successfully.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterSetModulateBlitsWithColor(
    SbBlitterContext context,
    bool modulate_blits_with_color);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterContext</code><br>        <code>context</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>bool</code><br>        <code>modulate_blits_with_color</code></td>
    <td>Indicates whether to modulate source pixels
in blit calls.</td>
  </tr>
</table>

<h3 id="sbblittersetrendertarget">SbBlitterSetRenderTarget</h3>

<p><strong>Description</strong></p>

<p>Sets up <code class="prettyprint">render_target</code> as the render target that all subsequent draw calls
made on <code class="prettyprint">context</code> will use.<br>
This function is not thread-safe.<br>
The return value indicates whether the render target was set successfully.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterSetRenderTarget(SbBlitterContext context,
                                        SbBlitterRenderTarget render_target);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterContext</code><br>        <code>context</code></td>
    <td>The object for which the render target is being set.</td>
  </tr>
  <tr>
    <td><code>SbBlitterRenderTarget</code><br>        <code>render_target</code></td>
    <td>The target that the <code>context</code> should use for draw calls.</td>
  </tr>
</table>

<h3 id="sbblittersetscissor">SbBlitterSetScissor</h3>

<p><strong>Description</strong></p>

<p>Sets the scissor rectangle, which dictates a visibility area that affects
all draw calls. Only pixels within the scissor rectangle are rendered, and
all drawing outside of that area is clipped.<br>
When <code><a href="#sbblittersetrendertarget">SbBlitterSetRenderTarget()</a></code> is called, that function automatically sets
the scissor rectangle to the size of the specified render target. If a
scissor rectangle is specified outside of the extents of the current render
target bounds, it will be intersected with the render target bounds.<br>
This function is not thread-safe.<br>
Returns whether the scissor was successfully set. It returns an error if
it is called before a render target has been specified for the context.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SB_EXPORT bool SbBlitterSetScissor(SbBlitterContext context,
                                   SbBlitterRect rect);
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterContext</code></td>
    <td><code>context</code></td>
  </tr>
  <tr>
    <td><code>SbBlitterRect</code></td>
    <td><code>rect</code></td>
  </tr>
</table>

<h3 id="sbblittersurfaceformat">SbBlitterSurfaceFormat</h3>

<p><strong>Description</strong></p>

<p>This function maps SbBlitterPixelDataFormat values to their corresponding
SbBlitterSurfaceFormat value.  Note that many SbBlitterPixelDataFormats
correspond to the same <code>SbBlitterSurfaceFormat</code>, so this function is not
invertible.  When creating a SbBlitterSurface object from a
SbBlitterPixelData object, the SbBlitterSurface&#39;s format will be computed
from the SbBlitterPixelData object by using this function.</p>

<p><strong>Declaration</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static SB_C_FORCE_INLINE SbBlitterSurfaceFormat
SbBlitterPixelDataFormatToSurfaceFormat(SbBlitterPixelDataFormat pixel_format) {
  switch (pixel_format) {
    case kSbBlitterPixelDataFormatARGB8:
      return kSbBlitterSurfaceFormatRGBA8;
    case kSbBlitterPixelDataFormatBGRA8:
      return kSbBlitterSurfaceFormatRGBA8;
    case kSbBlitterPixelDataFormatRGBA8:
      return kSbBlitterSurfaceFormatRGBA8;
    case kSbBlitterPixelDataFormatA8:
      return kSbBlitterSurfaceFormatA8;
    default:
      return kSbBlitterInvalidSurfaceFormat;
  }
}
</code></pre></div>
<p><strong>Parameters</strong></p>

<table class="responsive">
  <tr><th colspan="2">Parameters</th></tr>
  <tr>
    <td><code>SbBlitterPixelDataFormatToSurfaceFormat(SbBlitterPixelDataFormat</code></td>
    <td><code>pixel_format</code></td>
  </tr>
</table>

        
          
            
          
        
      </div>
    </div>
  </div>

</div>


    

<footer>
<div class="container">
    <div class="row">
        <div class="col-md-5 column-left">
    <span class="copyright-text"> Google 2016</span>
        </div>
        <div class="col-md-2 column-middle">
  <img class="footer-logo" src="/cobalt/images/cobalt-logo.png" alt="Cobalt"/>
        </div>
        <div class="col-md-5 column-right">&nbsp;</div>
            </div>
</div>
</footer>

    
  </body>
</html>
