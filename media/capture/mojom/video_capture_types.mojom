// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module media.mojom;

import "ui/gfx/geometry/mojom/geometry.mojom";

[Stable, Extensible]
enum VideoCapturePixelFormat {
  UNKNOWN,
  I420,
  YV12,
  I422,
  I420A,
  I444,
  NV12,
  NV21,
  UYVY,
  YUY2,
  ARGB,
  XRGB,
  RGB24,
  MJPEG,
  YUV420P9,
  YUV420P10,
  YUV422P9,
  YUV422P10,
  YUV444P9,
  YUV444P10,
  YUV420P12,
  YUV422P12,
  YUV444P12,
  Y16,
  ABGR,
  XBGR,
  P016LE,
  XR30,
  XB30,
  BGRA,
  RGBAF16,
  [MinVersion=1] I422A,
  [MinVersion=1] I444A,
  [MinVersion=1] YUV420AP10,
  [MinVersion=1] YUV422AP10,
  [MinVersion=1] YUV444AP10,
  [MinVersion=2] NV12A,
};

[Stable, Extensible]
enum ResolutionChangePolicy {
  FIXED_RESOLUTION,
  FIXED_ASPECT_RATIO,
  ANY_WITHIN_LIMIT,
};

[Stable, Extensible]
enum PowerLineFrequency {
  DEFAULT,
  HZ_50,
  HZ_60
};

[Stable, Extensible]
enum VideoFacingMode {
  NONE,
  USER,
  ENVIRONMENT
};

[Stable, Extensible]
enum VideoCaptureApi {
  LINUX_V4L2_SINGLE_PLANE,
  WIN_MEDIA_FOUNDATION,
  WIN_MEDIA_FOUNDATION_SENSOR,
  WIN_DIRECT_SHOW,
  MACOSX_AVFOUNDATION,
  MACOSX_DECKLINK,
  ANDROID_API1,
  ANDROID_API2_LEGACY,
  ANDROID_API2_FULL,
  ANDROID_API2_LIMITED,
  FUCHSIA_CAMERA3,
  VIRTUAL_DEVICE,
  UNKNOWN
};

[Stable, Extensible]
enum VideoCaptureTransportType {
  // For MACOSX_AVFOUNDATION Api, identifies devices that are built-in or USB.
  MACOSX_USB_OR_BUILT_IN,
  OTHER_TRANSPORT
};

[Stable, Extensible]
enum VideoCaptureBufferType {
  kSharedMemory,
  kSharedMemoryViaRawFileDescriptor_DEPRECATED,  // DEPRECATED, DO NOT USE
  kMailboxHolder,
  kGpuMemoryBuffer
};

// Represents capture device's support for different controls.
[Stable]
struct VideoCaptureControlSupport {
  bool pan;
  bool tilt;
  bool zoom;
};

[Stable, Extensible]
enum VideoCaptureError {
  kNone,
  kVideoCaptureControllerInvalidOrUnsupportedVideoCaptureParametersRequested,
  kVideoCaptureControllerIsAlreadyInErrorState,
  kVideoCaptureManagerDeviceConnectionLost,
  kFrameSinkVideoCaptureDeviceAlreadyEndedOnFatalError,
  kFrameSinkVideoCaptureDeviceEncounteredFatalError,
  kV4L2FailedToOpenV4L2DeviceDriverFile,
  kV4L2ThisIsNotAV4L2VideoCaptureDevice,
  kV4L2FailedToFindASupportedCameraFormat,
  kV4L2FailedToSetVideoCaptureFormat,
  kV4L2UnsupportedPixelFormat,
  kV4L2FailedToSetCameraFramerate,
  kV4L2ErrorRequestingMmapBuffers,
  kV4L2AllocateBufferFailed,
  kV4L2VidiocStreamonFailed,
  kV4L2VidiocStreamoffFailed,
  kV4L2FailedToVidiocReqbufsWithCount0,
  kV4L2PollFailed,
  kV4L2MultipleContinuousTimeoutsWhileReadPolling,
  kV4L2FailedToDequeueCaptureBuffer,
  kV4L2FailedToEnqueueCaptureBuffer,
  kSingleClientVideoCaptureHostLostConnectionToDevice,
  kSingleClientVideoCaptureDeviceLaunchAborted,
  kDesktopCaptureDeviceWebrtcDesktopCapturerHasFailed,
  kFileVideoCaptureDeviceCouldNotOpenVideoFile,
  kDeviceCaptureLinuxFailedToCreateVideoCaptureDelegate,
  kErrorFakeDeviceIntentionallyEmittingErrorEvent,
  kDeviceClientTooManyFramesDroppedY16,
  kDeviceMediaToMojoAdapterEncounteredUnsupportedBufferType,
  kVideoCaptureManagerProcessDeviceStartQueueDeviceInfoNotFound,
  kInProcessDeviceLauncherFailedToCreateDeviceInstance,
  kServiceDeviceLauncherLostConnectionToDeviceFactoryDuringDeviceStart,
  kServiceDeviceLauncherServiceRespondedWithDeviceNotFound,
  kServiceDeviceLauncherConnectionLostWhileWaitingForCallback,
  kIntentionalErrorRaisedByUnitTest,
  kCrosHalV3FailedToStartDeviceThread,
  kCrosHalV3DeviceDelegateMojoConnectionError,
  kCrosHalV3DeviceDelegateFailedToGetCameraInfo,
  kCrosHalV3DeviceDelegateMissingSensorOrientationInfo,
  kCrosHalV3DeviceDelegateFailedToOpenCameraDevice,
  kCrosHalV3DeviceDelegateFailedToInitializeCameraDevice,
  kCrosHalV3DeviceDelegateFailedToConfigureStreams,
  kCrosHalV3DeviceDelegateWrongNumberOfStreamsConfigured,
  kCrosHalV3DeviceDelegateFailedToGetDefaultRequestSettings,
  kCrosHalV3BufferManagerHalRequestedTooManyBuffers,
  kCrosHalV3BufferManagerFailedToCreateGpuMemoryBuffer,
  kCrosHalV3BufferManagerFailedToMapGpuMemoryBuffer,
  kCrosHalV3BufferManagerUnsupportedVideoPixelFormat,
  kCrosHalV3BufferManagerFailedToDupFd,
  kCrosHalV3BufferManagerFailedToWrapGpuMemoryHandle,
  kCrosHalV3BufferManagerFailedToRegisterBuffer,
  kCrosHalV3BufferManagerProcessCaptureRequestFailed,
  kCrosHalV3BufferManagerInvalidPendingResultId,
  kCrosHalV3BufferManagerReceivedDuplicatedPartialMetadata,
  kCrosHalV3BufferManagerIncorrectNumberOfOutputBuffersReceived,
  kCrosHalV3BufferManagerInvalidTypeOfOutputBuffersReceived,
  kCrosHalV3BufferManagerReceivedMultipleResultBuffersForFrame,
  kCrosHalV3BufferManagerUnknownStreamInCamera3NotifyMsg,
  kCrosHalV3BufferManagerReceivedInvalidShutterTime,
  kCrosHalV3BufferManagerFatalDeviceError,
  kCrosHalV3BufferManagerReceivedFrameIsOutOfOrder,
  kCrosHalV3BufferManagerFailedToUnwrapReleaseFenceFd,
  kCrosHalV3BufferManagerSyncWaitOnReleaseFenceTimedOut,
  kCrosHalV3BufferManagerInvalidJpegBlob,
  kAndroidFailedToAllocate,
  kAndroidFailedToStartCapture,
  kAndroidFailedToStopCapture,
  kAndroidApi1CameraErrorCallbackReceived,
  kAndroidApi2CameraDeviceErrorReceived,
  kAndroidApi2CaptureSessionConfigureFailed,
  kAndroidApi2ImageReaderUnexpectedImageFormat,
  kAndroidApi2ImageReaderSizeDidNotMatchImageSize,
  kAndroidApi2ErrorRestartingPreview,
  kAndroidScreenCaptureUnsupportedFormat,
  kAndroidScreenCaptureFailedToStartCaptureMachine,
  kAndroidScreenCaptureTheUserDeniedScreenCapture,
  kAndroidScreenCaptureFailedToStartScreenCapture,
  kWinDirectShowCantGetCaptureFormatSettings,
  kWinDirectShowFailedToGetNumberOfCapabilities,
  kWinDirectShowFailedToGetCaptureDeviceCapabilities,
  kWinDirectShowFailedToSetCaptureDeviceOutputFormat,
  kWinDirectShowFailedToConnectTheCaptureGraph,
  kWinDirectShowFailedToPauseTheCaptureDevice,
  kWinDirectShowFailedToStartTheCaptureDevice,
  kWinDirectShowFailedToStopTheCaptureGraph,
  kWinMediaFoundationEngineIsNull,
  kWinMediaFoundationEngineGetSourceFailed ,
  kWinMediaFoundationFillPhotoCapabilitiesFailed ,
  kWinMediaFoundationFillVideoCapabilitiesFailed,
  kWinMediaFoundationNoVideoCapabilityFound,
  kWinMediaFoundationGetAvailableDeviceMediaTypeFailed,
  kWinMediaFoundationSetCurrentDeviceMediaTypeFailed,
  kWinMediaFoundationEngineGetSinkFailed,
  kWinMediaFoundationSinkQueryCapturePreviewInterfaceFailed,
  kWinMediaFoundationSinkRemoveAllStreamsFailed,
  kWinMediaFoundationCreateSinkVideoMediaTypeFailed,
  kWinMediaFoundationConvertToVideoSinkMediaTypeFailed,
  kWinMediaFoundationSinkAddStreamFailed,
  kWinMediaFoundationSinkSetSampleCallbackFailed,
  kWinMediaFoundationEngineStartPreviewFailed,
  kWinMediaFoundationGetMediaEventStatusFailed,
  kMacSetCaptureDeviceFailed,
  kMacCouldNotStartCaptureDevice,
  kMacReceivedFrameWithUnexpectedResolution,
  kMacUpdateCaptureResolutionFailed,
  kMacDeckLinkDeviceIdNotFoundInTheSystem,
  kMacDeckLinkErrorQueryingInputInterface,
  kMacDeckLinkErrorCreatingDisplayModeIterator,
  kMacDeckLinkCouldNotFindADisplayMode,
  kMacDeckLinkCouldNotSelectTheVideoFormatWeLike,
  kMacDeckLinkCouldNotStartCapturing,
  kMacDeckLinkUnsupportedPixelFormat,
  kMacAvFoundationReceivedAVCaptureSessionRuntimeErrorNotification,
  kAndroidApi2ErrorConfiguringCamera,
  kCrosHalV3DeviceDelegateFailedToFlush,
  kFuchsiaCameraDeviceDisconnected,
  kFuchsiaCameraStreamDisconnected,
  kFuchsiaSysmemDidNotSetImageFormat,
  kFuchsiaSysmemInvalidBufferIndex,
  kFuchsiaSysmemInvalidBufferSize,
  kFuchsiaUnsupportedPixelFormat,
  kFuchsiaFailedToMapSysmemBuffer,
  kCrosHalV3DeviceContextDuplicatedClient,
  kDesktopCaptureDeviceMacFailedStreamCreate,
  kDesktopCaptureDeviceMacFailedStreamStart,
  kCrosHalV3BufferManagerFailedToReserveBuffers,
  [MinVersion=1] kWinMediaFoundationSystemPermissionDenied,
  [MinVersion=2] kVideoCaptureImplTimedOutOnStart,
  [MinVersion=3] kLacrosVideoCaptureDeviceProxyAlreadyEndedOnFatalError,
  [MinVersion=3] kLacrosVideoCaptureDeviceProxyEncounteredFatalError,
  [MinVersion=4] kScreenCaptureKitFailedGetShareableContent,
  [MinVersion=4] kScreenCaptureKitFailedAddStreamOutput,
  [MinVersion=4] kScreenCaptureKitFailedStartCapture,
  [MinVersion=4] kScreenCaptureKitFailedStopCapture,
  [MinVersion=4] kScreenCaptureKitStreamError,
  [MinVersion=4] kScreenCaptureKitFailedToFindSCDisplay,
  [MinVersion=5] kVideoCaptureControllerInvalid,
  [MinVersion=5] kVideoCaptureDeviceFactoryChromeOSCreateDeviceFailed,
  [MinVersion=5] kVideoCaptureControllerUnsupportedPixelFormat,
  [MinVersion=5] kVideoCaptureDeviceAlreadyReleased,
  [MinVersion=5] kVideoCaptureSystemDeviceIdNotFound,
  [MinVersion=5] kVideoCaptureDeviceFactoryWinUnknownError,
  [MinVersion=5] kWinMediaFoundationDeviceInitializationFailed,
  [MinVersion=5] kWinMediaFoundationSourceCreationFailed,
  [MinVersion=5] kWinDirectShowDeviceFilterCreationFailed,
  [MinVersion=5] kWinDirectShowDeviceInitializationFailed,
};

[Stable, Extensible]
enum VideoCaptureFrameDropReason {
  kNone,
  kDeviceClientFrameHasInvalidFormat,
  kDeviceClientLibyuvConvertToI420Failed,
  kV4L2BufferErrorFlagWasSet,
  kV4L2InvalidNumberOfBytesInBuffer,
  kAndroidThrottling,
  kAndroidGetByteArrayElementsFailed,
  kAndroidApi1UnexpectedDataLength,
  kAndroidApi2AcquiredImageIsNull,
  kWinDirectShowUnexpectedSampleLength,
  kWinDirectShowFailedToGetMemoryPointerFromMediaSample,
  kWinMediaFoundationReceivedSampleIsNull,
  kWinMediaFoundationLockingBufferDelieveredNullptr,
  kWinMediaFoundationGetBufferByIndexReturnedNull,
  kBufferPoolMaxBufferCountExceeded,
  kBufferPoolBufferAllocationFailed,
  kVideoCaptureImplNotInStartedState,
  kVideoCaptureImplFailedToWrapDataAsMediaVideoFrame,
  kVideoTrackAdapterHasNoResolutionAdapters,
  kResolutionAdapterFrameIsNotValid,
  kResolutionAdapterWrappingFrameForCroppingFailed,
  kResolutionAdapterTimestampTooCloseToPrevious,
  kResolutionAdapterFrameRateIsHigherThanRequested,
  kResolutionAdapterHasNoCallbacks,
  kVideoTrackFrameDelivererNotEnabledReplacingWithBlackFrame,
  kRendererSinkFrameDelivererIsNotStarted,
  [MinVersion=1] kCropVersionNotCurrent,
  [MinVersion=5] kGpuMemoryBufferMapFailed
};

[Stable]
struct VideoCaptureFormat {
  gfx.mojom.Size frame_size;
  float frame_rate;
  VideoCapturePixelFormat pixel_format;
};

[Stable]
struct VideoCaptureParams {
  VideoCaptureFormat requested_format;
  VideoCaptureBufferType buffer_type;
  ResolutionChangePolicy resolution_change_policy;
  PowerLineFrequency power_line_frequency;
  bool enable_face_detection;

  // TODO(https://crbug.com/1412589): remove this once HiDPI is enabled for
  // all video capture sessions.
  [MinVersion=1] bool is_high_dpi_enabled;
};

[Stable, RenamedFrom="media.mojom.VideoFrameFeedback"]
struct VideoCaptureFeedback {
  // Reports that the frame incurred some fractional utilization of the
  // downstream pipeline's per-frame processing capacity.
  // See code comments in media::base::VideoFrameMetadata for a discussion of
  // how utilization is interpreted. The capturer uses this information to
  // auto-adjust the capture resolution based on performance variances in the
  // live system environment.
  // -1.0 means no value present.
  double resource_utilization;

  // The requested maximum frame-rate, float::inifinty used to signal no limit.
  float max_framerate_fps;

  // The requested maximum resolution (in sense of image area).
  // int::max used to signal no limit.
  int32 max_pixels;

  // Reports that the consumer needs a cpu readable frame.
  // TODO(https://crbug.com/1191986): When |kWebRtcUseModernFrameAdapter| is
  // shipped to 100%, |require_mapped_frame| can be removed in favor of checking
  // if |mapped_sizes| is non-empty.
  bool require_mapped_frame;

  // Reports which sizes the video frame got mapped by the consumer for CPU
  // access. Only reported when |kWebRtcUseModernFrameAdapter| is enabled.
  [MinVersion=1] array<gfx.mojom.Size>? mapped_sizes;

  // The frame that this feedback is associated with. Some consumers do not
  // break down their analysis on a per-frame basis; while some may expect to
  // hear any reports with a particular frame, so they can build a "timeline" of
  // performance (e.g. to know if they have recovered). This struct is often
  // funneled through multiple layers, so this frame_id may only be used by an
  // intermediate layer to help route the feedback accordingly.
  // This should usually be set to the same value as the |frame_feedback_id|
  // received with the frame (often from a received `ReadyFrameInBuffer`).
  [MinVersion=2] int32 frame_id = 0;

  // Indicates whether or not the value in |frame_id| is valid.
  // TODO(https://crbug.com/657632): Remove this and replace frame_id with an
  // optional type.
  [MinVersion=2] bool has_frame_id = false;
};

// Contains one stride value per image plane. Stride means the number of bytes
// per row. If the image format uses fewer than kMaxPlanes planes, the values
// for higher plane indices are ignored. For example, for a YUV format, plane
// index 0 corresponds to the Y plane, index 1 to the U plane, and index 2 to
// the V plane.
struct PlaneStrides {
  // Size must be kept in sync with media::VideoFrame::kMaxPlanes.
  array<uint32, 4> stride_by_plane;
};

// Represents information about a capture device.
// |device_id| represents a unique id of a physical device. Since the same
// physical device may be accessible through different APIs |capture_api|
// disambiguates the API.
[Stable]
struct VideoCaptureDeviceDescriptor {
  string display_name;
  string device_id;
  string model_id;
  VideoFacingMode facing_mode;
  VideoCaptureApi capture_api;
  VideoCaptureControlSupport control_support;
  VideoCaptureTransportType transport_type;
};

// Bundles a VideoCaptureDeviceDescriptor with corresponding supported
// video formats.
[Stable]
struct VideoCaptureDeviceInfo {
  VideoCaptureDeviceDescriptor descriptor;
  array<VideoCaptureFormat> supported_formats;
};

// The result of an attempt by the client to start/stop cropping.
// TODO(crbug.com/1264849): Remove kNotImplemented.
enum CropRequestResult {
  kSuccess,
  kErrorGeneric,
  kUnsupportedCaptureDevice,
  kNotImplemented,
  kNonIncreasingCropVersion,
  kInvalidCropTarget,
};

enum DeviceEnumerationResult {
  kSuccess,
  kUnknownError,
  kErrorCaptureServiceCrash
};
