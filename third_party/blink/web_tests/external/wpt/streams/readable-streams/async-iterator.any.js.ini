[async-iterator.any.html]
  [Acquiring a reader after exhaustively async-iterating a stream]
    expected: FAIL

  [Acquiring a reader after partially async-iterating a stream]
    expected: FAIL

  [Acquiring a reader after return()ing from a stream that errors]
    expected: FAIL

  [Acquiring a reader and reading the remaining chunks after partially async-iterating a stream with preventCancel = true]
    expected: FAIL

  [Async iterator instances should have the correct list of properties]
    expected: FAIL

  [Async-iterating a closed stream never executes the loop body, but works fine]
    expected: FAIL

  [Async-iterating a partially consumed stream]
    expected: FAIL

  [Async-iterating a pull source]
    expected: FAIL

  [Async-iterating a pull source manually]
    expected: FAIL

  [Async-iterating a pull source with undefined values]
    expected: FAIL

  [Async-iterating a push source]
    expected: FAIL

  [Async-iterating a push source with undefined values]
    expected: FAIL

  [Async-iterating an empty but not closed/errored stream never executes the loop body and stalls the async function]
    expected: FAIL

  [Async-iterating an errored stream throws]
    expected: FAIL

  [Cancellation behavior when breaking inside loop body; preventCancel = false]
    expected: FAIL

  [Cancellation behavior when breaking inside loop body; preventCancel = true]
    expected: FAIL

  [Cancellation behavior when manually calling return(); preventCancel = false]
    expected: FAIL

  [Cancellation behavior when manually calling return(); preventCancel = true]
    expected: FAIL

  [Cancellation behavior when returning inside loop body; preventCancel = false]
    expected: FAIL

  [Cancellation behavior when returning inside loop body; preventCancel = true]
    expected: FAIL

  [Cancellation behavior when throwing inside loop body; preventCancel = false]
    expected: FAIL

  [Cancellation behavior when throwing inside loop body; preventCancel = true]
    expected: FAIL

  [close() while next() is pending]
    expected: FAIL

  [next() rejects if the stream errors]
    expected: FAIL

  [next() that succeeds; next() that reports an error(); next() [no awaiting\]]
    expected: FAIL

  [next() that succeeds; next() that reports an error(); return()]
    expected: FAIL

  [next() that succeeds; next() that reports an error(); return() [no awaiting\]]
    expected: FAIL

  [next() that succeeds; next() that reports an error; next()]
    expected: FAIL

  [next() that succeeds; return()]
    expected: FAIL

  [next() that succeeds; return() [no awaiting\]]
    expected: FAIL

  [return() does not rejects if the stream has not errored yet]
    expected: FAIL

  [return() rejects if the stream has errored]
    expected: FAIL

  [return() should unlock the stream synchronously when preventCancel = false]
    expected: FAIL

  [return() should unlock the stream synchronously when preventCancel = true]
    expected: FAIL

  [return(); next()]
    expected: FAIL

  [return(); next() [no awaiting\]]
    expected: FAIL

  [return(); return()]
    expected: FAIL

  [return(); return() [no awaiting\]]
    expected: FAIL

  [values() throws if there's already a lock]
    expected: FAIL


[async-iterator.any.serviceworker.html]
  [Acquiring a reader after exhaustively async-iterating a stream]
    expected: FAIL

  [Acquiring a reader after partially async-iterating a stream]
    expected: FAIL

  [Acquiring a reader after return()ing from a stream that errors]
    expected: FAIL

  [Acquiring a reader and reading the remaining chunks after partially async-iterating a stream with preventCancel = true]
    expected: FAIL

  [Async iterator instances should have the correct list of properties]
    expected: FAIL

  [Async-iterating a closed stream never executes the loop body, but works fine]
    expected: FAIL

  [Async-iterating a partially consumed stream]
    expected: FAIL

  [Async-iterating a pull source]
    expected: FAIL

  [Async-iterating a pull source manually]
    expected: FAIL

  [Async-iterating a pull source with undefined values]
    expected: FAIL

  [Async-iterating a push source]
    expected: FAIL

  [Async-iterating a push source with undefined values]
    expected: FAIL

  [Async-iterating an empty but not closed/errored stream never executes the loop body and stalls the async function]
    expected: FAIL

  [Async-iterating an errored stream throws]
    expected: FAIL

  [Cancellation behavior when breaking inside loop body; preventCancel = false]
    expected: FAIL

  [Cancellation behavior when breaking inside loop body; preventCancel = true]
    expected: FAIL

  [Cancellation behavior when manually calling return(); preventCancel = false]
    expected: FAIL

  [Cancellation behavior when manually calling return(); preventCancel = true]
    expected: FAIL

  [Cancellation behavior when returning inside loop body; preventCancel = false]
    expected: FAIL

  [Cancellation behavior when returning inside loop body; preventCancel = true]
    expected: FAIL

  [Cancellation behavior when throwing inside loop body; preventCancel = false]
    expected: FAIL

  [Cancellation behavior when throwing inside loop body; preventCancel = true]
    expected: FAIL

  [close() while next() is pending]
    expected: FAIL

  [next() rejects if the stream errors]
    expected: FAIL

  [next() that succeeds; next() that reports an error(); next() [no awaiting\]]
    expected: FAIL

  [next() that succeeds; next() that reports an error(); return()]
    expected: FAIL

  [next() that succeeds; next() that reports an error(); return() [no awaiting\]]
    expected: FAIL

  [next() that succeeds; next() that reports an error; next()]
    expected: FAIL

  [next() that succeeds; return()]
    expected: FAIL

  [next() that succeeds; return() [no awaiting\]]
    expected: FAIL

  [return() does not rejects if the stream has not errored yet]
    expected: FAIL

  [return() rejects if the stream has errored]
    expected: FAIL

  [return() should unlock the stream synchronously when preventCancel = false]
    expected: FAIL

  [return() should unlock the stream synchronously when preventCancel = true]
    expected: FAIL

  [return(); next()]
    expected: FAIL

  [return(); next() [no awaiting\]]
    expected: FAIL

  [return(); return()]
    expected: FAIL

  [return(); return() [no awaiting\]]
    expected: FAIL

  [values() throws if there's already a lock]
    expected: FAIL


[async-iterator.any.sharedworker.html]
  [Acquiring a reader after exhaustively async-iterating a stream]
    expected: FAIL

  [Acquiring a reader after partially async-iterating a stream]
    expected: FAIL

  [Acquiring a reader after return()ing from a stream that errors]
    expected: FAIL

  [Acquiring a reader and reading the remaining chunks after partially async-iterating a stream with preventCancel = true]
    expected: FAIL

  [Async iterator instances should have the correct list of properties]
    expected: FAIL

  [Async-iterating a closed stream never executes the loop body, but works fine]
    expected: FAIL

  [Async-iterating a partially consumed stream]
    expected: FAIL

  [Async-iterating a pull source]
    expected: FAIL

  [Async-iterating a pull source manually]
    expected: FAIL

  [Async-iterating a pull source with undefined values]
    expected: FAIL

  [Async-iterating a push source]
    expected: FAIL

  [Async-iterating a push source with undefined values]
    expected: FAIL

  [Async-iterating an empty but not closed/errored stream never executes the loop body and stalls the async function]
    expected: FAIL

  [Async-iterating an errored stream throws]
    expected: FAIL

  [Cancellation behavior when breaking inside loop body; preventCancel = false]
    expected: FAIL

  [Cancellation behavior when breaking inside loop body; preventCancel = true]
    expected: FAIL

  [Cancellation behavior when manually calling return(); preventCancel = false]
    expected: FAIL

  [Cancellation behavior when manually calling return(); preventCancel = true]
    expected: FAIL

  [Cancellation behavior when returning inside loop body; preventCancel = false]
    expected: FAIL

  [Cancellation behavior when returning inside loop body; preventCancel = true]
    expected: FAIL

  [Cancellation behavior when throwing inside loop body; preventCancel = false]
    expected: FAIL

  [Cancellation behavior when throwing inside loop body; preventCancel = true]
    expected: FAIL

  [close() while next() is pending]
    expected: FAIL

  [next() rejects if the stream errors]
    expected: FAIL

  [next() that succeeds; next() that reports an error(); next() [no awaiting\]]
    expected: FAIL

  [next() that succeeds; next() that reports an error(); return()]
    expected: FAIL

  [next() that succeeds; next() that reports an error(); return() [no awaiting\]]
    expected: FAIL

  [next() that succeeds; next() that reports an error; next()]
    expected: FAIL

  [next() that succeeds; return()]
    expected: FAIL

  [next() that succeeds; return() [no awaiting\]]
    expected: FAIL

  [return() does not rejects if the stream has not errored yet]
    expected: FAIL

  [return() rejects if the stream has errored]
    expected: FAIL

  [return() should unlock the stream synchronously when preventCancel = false]
    expected: FAIL

  [return() should unlock the stream synchronously when preventCancel = true]
    expected: FAIL

  [return(); next()]
    expected: FAIL

  [return(); next() [no awaiting\]]
    expected: FAIL

  [return(); return()]
    expected: FAIL

  [return(); return() [no awaiting\]]
    expected: FAIL

  [values() throws if there's already a lock]
    expected: FAIL


[async-iterator.any.worker.html]
  [Acquiring a reader after exhaustively async-iterating a stream]
    expected: FAIL

  [Acquiring a reader after partially async-iterating a stream]
    expected: FAIL

  [Acquiring a reader after return()ing from a stream that errors]
    expected: FAIL

  [Acquiring a reader and reading the remaining chunks after partially async-iterating a stream with preventCancel = true]
    expected: FAIL

  [Async iterator instances should have the correct list of properties]
    expected: FAIL

  [Async-iterating a closed stream never executes the loop body, but works fine]
    expected: FAIL

  [Async-iterating a partially consumed stream]
    expected: FAIL

  [Async-iterating a pull source]
    expected: FAIL

  [Async-iterating a pull source manually]
    expected: FAIL

  [Async-iterating a pull source with undefined values]
    expected: FAIL

  [Async-iterating a push source]
    expected: FAIL

  [Async-iterating a push source with undefined values]
    expected: FAIL

  [Async-iterating an empty but not closed/errored stream never executes the loop body and stalls the async function]
    expected: FAIL

  [Async-iterating an errored stream throws]
    expected: FAIL

  [Cancellation behavior when breaking inside loop body; preventCancel = false]
    expected: FAIL

  [Cancellation behavior when breaking inside loop body; preventCancel = true]
    expected: FAIL

  [Cancellation behavior when manually calling return(); preventCancel = false]
    expected: FAIL

  [Cancellation behavior when manually calling return(); preventCancel = true]
    expected: FAIL

  [Cancellation behavior when returning inside loop body; preventCancel = false]
    expected: FAIL

  [Cancellation behavior when returning inside loop body; preventCancel = true]
    expected: FAIL

  [Cancellation behavior when throwing inside loop body; preventCancel = false]
    expected: FAIL

  [Cancellation behavior when throwing inside loop body; preventCancel = true]
    expected: FAIL

  [close() while next() is pending]
    expected: FAIL

  [next() rejects if the stream errors]
    expected: FAIL

  [next() that succeeds; next() that reports an error(); next() [no awaiting\]]
    expected: FAIL

  [next() that succeeds; next() that reports an error(); return()]
    expected: FAIL

  [next() that succeeds; next() that reports an error(); return() [no awaiting\]]
    expected: FAIL

  [next() that succeeds; next() that reports an error; next()]
    expected: FAIL

  [next() that succeeds; return()]
    expected: FAIL

  [next() that succeeds; return() [no awaiting\]]
    expected: FAIL

  [return() does not rejects if the stream has not errored yet]
    expected: FAIL

  [return() rejects if the stream has errored]
    expected: FAIL

  [return() should unlock the stream synchronously when preventCancel = false]
    expected: FAIL

  [return() should unlock the stream synchronously when preventCancel = true]
    expected: FAIL

  [return(); next()]
    expected: FAIL

  [return(); next() [no awaiting\]]
    expected: FAIL

  [return(); return()]
    expected: FAIL

  [return(); return() [no awaiting\]]
    expected: FAIL

  [values() throws if there's already a lock]
    expected: FAIL
