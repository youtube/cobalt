// Copyright 2020 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "remoting/protocol/webrtc_event_log_data.h"

#include <utility>

#include "base/logging.h"
#include "base/numerics/safe_conversions.h"
#include "base/strings/string_piece.h"

namespace remoting::protocol {

WebrtcEventLogData::WebrtcEventLogData() {
  // See the caveat for base::circular_deque::reserve(). Calling reserve() is
  // OK here, since items are never removed until the list reaches its maximum
  // allowed size.
  sections_.reserve(max_sections_);
}

WebrtcEventLogData::~WebrtcEventLogData() = default;

void WebrtcEventLogData::SetMaxSectionSizeForTest(int max_section_size) {
  max_section_size_ = max_section_size;
}

void WebrtcEventLogData::SetMaxSectionsForTest(int max_sections) {
  max_sections_ = max_sections;
  sections_.reserve(max_sections_);
}

base::circular_deque<WebrtcEventLogData::LogSection>
WebrtcEventLogData::TakeLogData() {
  auto result = std::move(sections_);

  // The |sections_| container is still valid but unspecified. Call Clear() to
  // be certain it is empty (and the correct capacity is reserved).
  Clear();
  return result;
}

void WebrtcEventLogData::Write(base::StringPiece log_event) {
  if (base::checked_cast<int>(log_event.size()) > max_section_size_) {
    LOG(WARNING) << "Oversized RTC log event: size = " << log_event.size();
  }

  if (NeedNewSection(log_event.size())) {
    CreateNewSection();
  }

  // Append the log_event to the end of the latest section.
  auto& section = sections_.back();
  section.insert(section.end(), log_event.begin(), log_event.end());
}

void WebrtcEventLogData::Clear() {
  sections_.clear();
  sections_.reserve(max_sections_);
}

bool WebrtcEventLogData::NeedNewSection(size_t log_event_size) const {
  if (sections_.empty()) {
    return true;
  }

  // The event log entries are packet headers generated by WebRTC, and it is
  // assumed that the sizes are small enough to prevent integer overflow.
  return base::checked_cast<int>(sections_.back().size() + log_event_size) >
         max_section_size_;
}

void WebrtcEventLogData::CreateNewSection() {
  if (static_cast<int>(sections_.size()) >= max_sections_) {
    // Discard oldest section to make room.
    sections_.pop_front();
  }
  sections_.emplace_back();
  sections_.back().reserve(max_section_size_);
}

}  // namespace remoting::protocol
