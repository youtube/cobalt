// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "base/check.h"
#include "base/files/file_path.h"
#include "base/logging.h"
#include "base/strings/string_util.h"
#include "base/strings/utf_string_conversions.h"
#include "third_party/protobuf/src/google/protobuf/compiler/code_generator.h"
#include "third_party/protobuf/src/google/protobuf/compiler/importer.h"
#include "third_party/protobuf/src/google/protobuf/compiler/plugin.h"
#include "third_party/protobuf/src/google/protobuf/descriptor.h"
#include "third_party/protobuf/src/google/protobuf/io/printer.h"

namespace {

using google::protobuf::Descriptor;
using google::protobuf::FieldDescriptor;
using google::protobuf::FileDescriptor;
using google::protobuf::compiler::GeneratorContext;
using google::protobuf::io::Printer;
using google::protobuf::io::ZeroCopyOutputStream;

class ToValueGenerator : public google::protobuf::compiler::CodeGenerator {
 public:
  ToValueGenerator() = default;
  ~ToValueGenerator() override = default;

  bool Generate(const FileDescriptor* file,
                const std::string& options,
                GeneratorContext* context,
                std::string* error) const override {
    base::FilePath base_file_path = ToValueFilePath(file->name());
    base::FilePath h_file_path =
        base_file_path.AddExtension(FILE_PATH_LITERAL("to_value.h"));
    base::FilePath cc_file_path =
        base_file_path.AddExtension(FILE_PATH_LITERAL("to_value.cc"));

    const std::unique_ptr<ZeroCopyOutputStream> h_stream(
        context->Open(h_file_path.AsUTF8Unsafe()));
    const std::unique_ptr<ZeroCopyOutputStream> cc_stream(
        context->Open(cc_file_path.AsUTF8Unsafe()));

    Printer h_printer(h_stream.get(), Printer::Options{'$', nullptr});
    Printer cc_printer(cc_stream.get(), Printer::Options{'$', nullptr});

    std::string include_guard =
        base::ToUpperASCII(h_file_path.AsUTF8Unsafe()) + "_";
    CHECK(base::ReplaceChars(include_guard, ".-/\\", "_", &include_guard));

    std::string kHeader =
        "// Generated by the proto to value plugin.  DO NOT EDIT!\n\n";
    h_printer.Print(kHeader);
    h_printer.Print("#ifndef $g$\n#define $g$\n\n", "g", include_guard);
    h_printer.Print("#include \"base/values.h\"\n\n");
    h_printer.Print("#include \"$f$\"\n\n", "f",
                    base_file_path.BaseName()
                        .AddExtension(FILE_PATH_LITERAL("pb.h"))
                        .AsUTF8Unsafe());
    h_printer.Print("namespace proto_to_value {\n\n");
    for (int i = 0; i < file->message_type_count(); i++) {
      if (!PrintFunctionDeclarations(*file->message_type(i), &h_printer,
                                     error)) {
        return false;
      }
    }

    h_printer.Print("}  // namespace proto_to_value\n\n");
    h_printer.Print("\n#endif  // $g$\n", "g", include_guard);

    cc_printer.Print(kHeader);
    cc_printer.Print("#include \"base/base64.h\"\n");
    cc_printer.Print("#include \"$p$\"\n\n", "p", h_file_path.AsUTF8Unsafe());

    for (int i = 0; i < file->dependency_count(); i++) {
      base::FilePath include_path =
          ToValueFilePath(file->dependency(i)->name())
              .AddExtension(FILE_PATH_LITERAL("to_value.h"));
      cc_printer.Print("#include \"$p$\"\n", "p", include_path.AsUTF8Unsafe());
    }
    cc_printer.Print("\n");

    cc_printer.Print("namespace proto_to_value {\n\n");
    for (int i = 0; i < file->message_type_count(); i++) {
      if (!PrintFunctionDefinition(*file->message_type(i), &cc_printer,
                                   error)) {
        return false;
      }
    }

    cc_printer.Print("}  // namespace proto_to_value\n\n");

    return true;
  }

 private:
  base::FilePath ToValueFilePath(std::string_view file_name) const {
#if BUILDFLAG(IS_WIN)
    return base::FilePath(base::ASCIIToWide(file_name)).RemoveExtension();
#else
    return base::FilePath(file_name).RemoveExtension();
#endif
  }

  std::string CppFullName(std::string_view full_name) const {
    std::string ret;
    CHECK(base::ReplaceChars(full_name, ".", "::", &ret));
    return ret;
  }

  bool PrintFunctionDeclarations(const Descriptor& message,
                                 Printer* printer,
                                 std::string* error) const {
    std::string message_type = CppFullName(message.full_name());
    printer->Print("base::Value::Dict Serialize(const $m$& message);\n", "m",
                   message_type);

    for (int i = 0; i < message.nested_type_count(); i++) {
      if (!PrintFunctionDeclarations(*message.nested_type(i), printer, error)) {
        return false;
      }
    }

    return true;
  }

  bool PrintFunctionDefinition(const Descriptor& message,
                               Printer* printer,
                               std::string* error) const {
    std::string message_type = CppFullName(message.full_name());
    printer->Print("base::Value::Dict Serialize(const $m$& message) {\n", "m",
                   message_type);
    printer->Indent();
    printer->Print("base::Value::Dict dict;\n\n");
    for (int j = 0; j < message.field_count(); j++) {
      const FieldDescriptor* field = message.field(j);
      std::string field_name(field->lowercase_name());
      if (field->is_repeated()) {
        printer->Print("if (!message.$f$().empty()) {\n", "f", field_name);
        printer->Indent();
        printer->Print("base::Value::List list;\n");
        printer->Print("for (const auto& value : message.$f$()) {\n", "f",
                       field_name);
        printer->Indent();
        printer->Print("list.Append(");
        PrintFieldToValue(*field, printer);
        printer->Print("(value));\n");
        printer->Outdent();
        printer->Print("}\n");
        printer->Print("dict.Set(\"$f$\", std::move(list));\n", "f",
                       field_name);
        printer->Outdent();
        printer->Print("}\n");
      } else if (field->has_presence()) {
        printer->Print("if (message.has_$f$()) {\n", "f", field_name);
        printer->Indent();
        printer->Print("dict.Set(\"$f$\", ", "f", field_name);
        PrintFieldToValue(*field, printer);
        printer->Print("(message.$f$()));\n", "f", field_name);
        printer->Outdent();
        printer->Print("}\n");
      } else if (field->type() == FieldDescriptor::Type::TYPE_STRING ||
                 field->type() == FieldDescriptor::Type::TYPE_BYTES) {
        printer->Print("if (!message.$f$().empty()) {\n", "f", field_name);
        printer->Indent();
        printer->Print("dict.Set(\"$f$\", ", "f", field_name);
        PrintFieldToValue(*field, printer);
        printer->Print("(message.$f$()));\n", "f", field_name);
        printer->Outdent();
        printer->Print("}\n");
      } else {
        printer->Print("dict.Set(\"$f$\", ", "f", field_name);
        PrintFieldToValue(*field, printer);
        printer->Print("(message.$f$()));\n", "f", field_name);
      }
    }
    printer->Print("return dict;\n");
    printer->Outdent();
    printer->Print("}\n");

    for (int i = 0; i < message.nested_type_count(); i++) {
      if (!PrintFunctionDefinition(*message.nested_type(i), printer, error)) {
        return false;
      }
    }

    return true;
  }

  void PrintFieldToValue(const FieldDescriptor& field, Printer* printer) const {
    using enum FieldDescriptor::Type;
    switch (field.type()) {
      case TYPE_DOUBLE:
      case TYPE_FLOAT:
        printer->Print("static_cast<double>");
        break;
      case TYPE_INT64:
      case TYPE_INT32:
      case TYPE_UINT64:
      case TYPE_UINT32:
      case TYPE_FIXED64:
      case TYPE_FIXED32:
      case TYPE_SFIXED64:
      case TYPE_SFIXED32:
      case TYPE_SINT64:
      case TYPE_SINT32:
        printer->Print("static_cast<int>");
        break;
      case TYPE_BOOL:
        printer->Print("static_cast<bool>");
        break;
      case TYPE_STRING:
        printer->Print("static_cast<std::string>");
        break;
      case TYPE_BYTES:
        printer->Print("base::Base64Encode");
        break;
      case TYPE_ENUM:
        printer->Print("$t$_Name", "t",
                       CppFullName(field.enum_type()->full_name()));
        break;
      case TYPE_MESSAGE:
      case TYPE_GROUP:
        printer->Print("Serialize");
        break;
    }
  }
};

}  // namespace

int main(int argc, char** argv) {
  ToValueGenerator generator;
  return google::protobuf::compiler::PluginMain(argc, argv, &generator);
}
