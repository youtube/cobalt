// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_AUTOFILL_CORE_BROWSER_DATA_MODEL_ENTITY_TYPE_H_
#define COMPONENTS_AUTOFILL_CORE_BROWSER_DATA_MODEL_ENTITY_TYPE_H_

#include <ostream>
#include <string_view>

#include "base/containers/span.h"
#include "components/autofill/core/browser/data_model/entity_type_names.h"
#include "components/autofill/core/browser/field_types.h"
#include "components/autofill/core/common/dense_set.h"

namespace autofill {

// Entity and attribute types are blueprints for entity and attribute instances.
//
// For example, "passport" is an entity type and its attribute types include
// "name", "country", "issue date", "expiry date", etc.
//
// A specific passport is an entity instance, which has attribute instances with
// values such "John Doe", "USA", "05/2019", "04/2029", etc.
//
// Entity types are generated at compile time from the schema definition in
// entity_schema.json.
class EntityType;
class AttributeType;

// An attribute type is the blueprint for an attribute instance, which in turn
// represents a string value with additional metadata.
//
// An AttributeType is uniquely identified by its AttributeTypeName from
// entity_type_names.h generated by transpile_entity_schema.py. AttributeType is
// merely a thin wrapper with member functions.
class AttributeType final {
 public:
  // Comparator that ranks types by their priority for disambiguating different
  // instances of the same entity type, as specified in the schema.
  // `DisambiguationOrder(x, y) == true` means `x` has higher priority than `y`.
  //
  // For example, when disambiguating different passport instances, the name and
  // country should likely take precedence over the passport number.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  static bool DisambiguationOrder(const AttributeType& lhs,
                                  const AttributeType& rhs);

  // Maps each Autofill AI `FieldType` to the corresponding AttributeType.
  static std::optional<AttributeType> FromFieldType(FieldType type);

  constexpr explicit AttributeType(AttributeTypeName n) : name_(n) {}

  constexpr AttributeType(const AttributeType&) = default;
  constexpr AttributeType& operator=(const AttributeType&) = default;
  constexpr AttributeType(AttributeType&&) = default;
  constexpr AttributeType& operator=(AttributeType&&) = default;

  constexpr AttributeTypeName name() const { return name_; }

  EntityType entity_type() const;

  // Maps this AttributeType to the corresponding Autofill AI `FieldType`.
  constexpr FieldType field_type() const;

  // Returns whether the corresponding type has a non-trivial structure (e.g.
  // Name, Address) or whether the structure is trivial.
  constexpr bool is_structured_type() const;

  // The string representation of the name. This is unique among all attribute
  // types of the associated entity type. (It is not globally unique!)
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  std::string_view name_as_string() const;

  // The i18n string representation of the name.
  std::u16string GetNameForI18n() const;

  friend constexpr bool operator==(const AttributeType& lhs,
                                   const AttributeType& rhs) = default;

  friend constexpr auto operator<=>(const AttributeType& lhs,
                                    const AttributeType& rhs) = default;

 private:
  AttributeTypeName name_{};
};

constexpr FieldType AttributeType::field_type() const {
  switch (name_) {
    case AttributeTypeName::kPassportName:
      return PASSPORT_NAME_TAG;
    case AttributeTypeName::kPassportNumber:
      return PASSPORT_NUMBER;
    case AttributeTypeName::kPassportCountry:
      return PASSPORT_ISSUING_COUNTRY_TAG;
    case AttributeTypeName::kPassportExpiryDate:
      return PASSPORT_EXPIRATION_DATE_TAG;
    case AttributeTypeName::kPassportIssueDate:
      return PASSPORT_ISSUE_DATE_TAG;
    case AttributeTypeName::kLoyaltyCardProgram:
      return LOYALTY_MEMBERSHIP_PROGRAM;
    case AttributeTypeName::kLoyaltyCardProvider:
      return LOYALTY_MEMBERSHIP_PROVIDER;
    case AttributeTypeName::kLoyaltyCardMemberId:
      return LOYALTY_MEMBERSHIP_ID;
    case AttributeTypeName::kVehicleOwner:
      return VEHICLE_OWNER_TAG;
    case AttributeTypeName::kVehicleLicensePlate:
      return VEHICLE_LICENSE_PLATE;
    case AttributeTypeName::kVehicleVin:
      return VEHICLE_VIN;
    case AttributeTypeName::kVehicleMake:
      return VEHICLE_MAKE;
    case AttributeTypeName::kVehicleModel:
      return VEHICLE_MODEL;
    case AttributeTypeName::kDriversLicenseName:
      return DRIVERS_LICENSE_NAME_TAG;
    case AttributeTypeName::kDriversLicenseRegion:
      return DRIVERS_LICENSE_REGION;
    case AttributeTypeName::kDriversLicenseNumber:
      return DRIVERS_LICENSE_NUMBER;
    case AttributeTypeName::kDriversLicenseExpirationDate:
      return DRIVERS_LICENSE_EXPIRATION_DATE_TAG;
    case AttributeTypeName::kDriversLicenseIssueDate:
      return DRIVERS_LICENSE_ISSUE_DATE_TAG;
  }
  NOTREACHED();
}

constexpr bool AttributeType::is_structured_type() const {
  switch (name_) {
    case AttributeTypeName::kPassportName:
    case AttributeTypeName::kDriversLicenseName:
    case AttributeTypeName::kPassportCountry:
    case AttributeTypeName::kDriversLicenseRegion:
      return true;
    case AttributeTypeName::kPassportExpiryDate:
    case AttributeTypeName::kPassportIssueDate:
    case AttributeTypeName::kDriversLicenseExpirationDate:
    case AttributeTypeName::kDriversLicenseIssueDate:
      // TODO(crbug.com/389625753): Add special support for date types.
      return false;
    case AttributeTypeName::kPassportNumber:
    case AttributeTypeName::kLoyaltyCardProgram:
    case AttributeTypeName::kLoyaltyCardProvider:
    case AttributeTypeName::kLoyaltyCardMemberId:
    case AttributeTypeName::kVehicleOwner:
    case AttributeTypeName::kVehicleLicensePlate:
    case AttributeTypeName::kVehicleVin:
    case AttributeTypeName::kVehicleMake:
    case AttributeTypeName::kVehicleModel:
    case AttributeTypeName::kDriversLicenseNumber:
      return false;
  }
  NOTREACHED();
}

template <>
struct DenseSetTraits<AttributeType> {
  using T = AttributeType;
  using N = AttributeTypeName;
  using UnderlyingType = std::underlying_type_t<N>;

  static constexpr T from_underlying(UnderlyingType x) {
    return T(static_cast<N>(x));
  }
  static constexpr UnderlyingType to_underlying(T x) {
    return base::to_underlying(x.name());
  }

  static constexpr auto kMinValue = T(static_cast<N>(0));
  static constexpr auto kMaxValue = T(N::kMaxValue);
  static constexpr bool kPacked = false;
};

// An entity type is the blueprint for an entity instance. It defines the
// available attributes and additional metadata.
//
// An EntityType is uniquely identified by its EntityTypeName from
// entity_type_names.h generated by transpile_entity_schema.py. EntityType is
// merely a thin wrapper with member functions.
class EntityType final {
 public:
  constexpr explicit EntityType(EntityTypeName n) : name_(n) {}

  constexpr EntityType(const EntityType&) = default;
  constexpr EntityType& operator=(const EntityType&) = default;
  constexpr EntityType(EntityType&&) = default;
  constexpr EntityType& operator=(EntityType&&) = default;

  // Comparator that ranks types by their priority for import on form
  // submission.
  // `ImportOrder(x, y) == true` means `x` has higher priority than `y`.
  static bool ImportOrder(const EntityType& lhs, const EntityType& rhs);

  constexpr EntityTypeName name() const { return name_; }

  // The string representation of the name. This is unique among all entity
  // types.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  std::string_view name_as_string() const;

  // The i18n string representation of the name.
  std::u16string GetNameForI18n() const;

  // The attributes supported by this entity type, as specified in the schema.
  // An instance of this entity may define values for some or all of these
  // attributes.
  //
  // For example, for a passport entity this may be the number, the name, the
  // country etc.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  DenseSet<AttributeType> attributes() const;

  // An import constraint is a precondition for importing an EntityInstance on
  // form submission: it is a set of attributes all of which the instance must
  // set.
  // At least one of the import constraints must be satisfied.
  //
  // For example, for a passport the import constraints may be {number} and
  // {name, country}. Then it suffices for an instances to define either the
  // number or both the name and country.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  base::span<const DenseSet<AttributeType>> import_constraints() const;

  // A merge constraint is a precondition for merging two EntityInstances: it is
  // a set of attributes which both instances must agree on, i.e., they must set
  // it to the same value.
  // At least one of the merge constraints must be satisfied.
  //
  // Intuitively, the attributes of a merge constraint uniquely identify an
  // entity instances.
  //
  // For example, for a passport the two alternative constraints may be {number}
  // and {name, country, issue date} because passport numbers generally serve
  // as unique identifiers and also a single user usually only has one passport
  // per name, country, and date.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  base::span<const DenseSet<AttributeType>> merge_constraints() const;

  // Indicates if instances of this type may be synced, as specified in the
  // schema.
  //
  // Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
  bool syncable() const;

  friend constexpr bool operator==(const EntityType& lhs,
                                   const EntityType& rhs) = default;

  friend constexpr auto operator<=>(const EntityType& lhs,
                                    const EntityType& rhs) = default;

 private:
  EntityTypeName name_{};
};

template <>
struct DenseSetTraits<EntityType> {
  using T = EntityType;
  using N = EntityTypeName;
  using UnderlyingType = std::underlying_type_t<N>;

  static constexpr T from_underlying(UnderlyingType x) {
    return T(static_cast<N>(x));
  }
  static constexpr UnderlyingType to_underlying(T x) {
    return base::to_underlying(x.name());
  }

  static constexpr auto kMinValue = T(static_cast<N>(0));
  static constexpr auto kMaxValue = T(N::kMaxValue);
  static constexpr bool kPacked = false;
};

class EntityTable;

// Defined in entity_type_funcs.cc generated by transpile_entity_schema.py.
std::optional<EntityType> StringToEntityType(
    base::PassKey<EntityTable> pass_key,
    std::string_view entity_type_name);
std::optional<AttributeType> StringToAttributeType(
    base::PassKey<EntityTable> pass_key,
    EntityType entity_type,
    std::string_view attribute_type_name);

std::ostream& operator<<(std::ostream& os, AttributeType a);
std::ostream& operator<<(std::ostream& os, EntityType t);

}  // namespace autofill

#endif  // COMPONENTS_AUTOFILL_CORE_BROWSER_DATA_MODEL_ENTITY_TYPE_H_
