// Copyright 2024 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/ui/views/bookmarks/bookmark_button.h"

#include "base/metrics/histogram_functions.h"
#include "chrome/browser/browser_features.h"
#include "chrome/browser/predictors/loading_predictor.h"
#include "chrome/browser/predictors/loading_predictor_config.h"
#include "chrome/browser/predictors/loading_predictor_factory.h"
#include "chrome/browser/preloading/chrome_preloading.h"
#include "chrome/browser/preloading/prerender/prerender_manager.h"
#include "chrome/browser/ui/browser.h"
#include "chrome/browser/ui/layout_constants.h"
#include "chrome/browser/ui/ui_features.h"
#include "chrome/browser/ui/views/bookmarks/bookmark_bar_view.h"
#include "chrome/browser/ui/views/bookmarks/bookmark_button_util.h"
#include "chrome/browser/ui/views/event_utils.h"
#include "chrome/browser/ui/views/toolbar/toolbar_ink_drop_util.h"
#include "chrome/grit/generated_resources.h"
#include "content/public/browser/navigation_handle.h"
#include "ui/base/l10n/l10n_util.h"
#include "ui/base/ui_base_features.h"
#include "ui/views/accessibility/view_accessibility.h"
#include "ui/views/widget/tooltip_manager.h"

// These values are persisted to logs. Entries should not be renumbered and
// numeric values should never be reused.
enum class PreloadBookmarkMetricsEvent {
  kMouseOver = 0,
  kMouseDown = 1,
  kMouseClick = 2,
  kMaxValue = kMouseClick,
};

// These are used as control the behavior of kBookmarkTriggerForPrerender2.
const base::FeatureParam<int> kPreconnectStartDelayOnMouseHoverByMiliseconds{
    &features::kBookmarkTriggerForPrerender2,
    "preconnect_start_delay_on_mouse_hover_ms", 100};
const base::FeatureParam<int> kPrerenderStartDelayOnMouseHoverByMiliseconds{
    &features::kBookmarkTriggerForPrerender2,
    "prerender_start_delay_on_mouse_hover_ms", 300};
const base::FeatureParam<bool> kPrerenderBookmarkBarOnMousePressedTrigger{
    &features::kBookmarkTriggerForPrerender2,
    "prerender_bookmarkbar_on_mouse_pressed_trigger", true};
// The hover trigger is not enabled as we are aware that this negatively
// affects other navigations like Omnibox search.
const base::FeatureParam<bool> kPrerenderBookmarkBarOnMouseHoverTrigger{
    &features::kBookmarkTriggerForPrerender2,
    "prerender_bookmarkbar_on_mouse_hover_trigger", false};

// BookmarkButtonBase -----------------------------------------------

// Base class for non-menu hosting buttons used on the bookmark bar.

BookmarkButtonBase::BookmarkButtonBase(PressedCallback callback,
                                       const std::u16string& title)
    : LabelButton(std::move(callback), title) {
  ConfigureInkDropForToolbar(this);

  SetImageLabelSpacing(
      GetLayoutConstant(BOOKMARK_BAR_BUTTON_IMAGE_LABEL_PADDING));

  views::InstallPillHighlightPathGenerator(this);

  SetFocusBehavior(FocusBehavior::ACCESSIBLE_ONLY);
  views::FocusRing::Get(this)->SetOutsetFocusRingDisabled(true);
  SetHideInkDropWhenShowingContextMenu(false);

  show_animation_ = std::make_unique<gfx::SlideAnimation>(this);
  if (!BookmarkBarView::GetAnimationsEnabled()) {
    // For some reason during testing the events generated by animating
    // throw off the test. So, don't animate while testing.
    show_animation_->Reset(1);
  } else {
    show_animation_->Show();
  }
  GetViewAccessibility().SetRoleDescription(
      l10n_util::GetStringUTF8(IDS_ACCNAME_BOOKMARK_BUTTON_ROLE_DESCRIPTION));
}

BookmarkButtonBase::~BookmarkButtonBase() = default;

views::View* BookmarkButtonBase::GetTooltipHandlerForPoint(
    const gfx::Point& point) {
  return HitTestPoint(point) && GetCanProcessEventsWithinSubtree() ? this
                                                                   : nullptr;
}

bool BookmarkButtonBase::IsTriggerableEvent(const ui::Event& e) {
  return e.type() == ui::EventType::kGestureTap ||
         e.type() == ui::EventType::kGestureTapDown ||
         event_utils::IsPossibleDispositionEvent(e);
}

std::unique_ptr<views::LabelButtonBorder>
BookmarkButtonBase::CreateDefaultBorder() const {
  return bookmark_button_util::CreateBookmarkButtonBorder();
}

BEGIN_METADATA(BookmarkButtonBase)
END_METADATA
// BookmarkButton -------------------------------------------------------------

// Buttons used for the bookmarks on the bookmark bar.
BookmarkButton::BookmarkButton(PressedCallback callback,
                               const GURL& url,
                               const std::u16string& title,
                               const raw_ptr<Browser> browser)
    : BookmarkButtonBase(base::BindRepeating(&BookmarkButton::OnButtonPressed,
                                             base::Unretained(this)),
                         title),
      callback_(std::move(callback)),
      url_(url),
      browser_(browser) {}

BookmarkButton::~BookmarkButton() = default;

std::u16string BookmarkButton::GetTooltipText(const gfx::Point& p) const {
  const views::TooltipManager* tooltip_manager =
      GetWidget()->GetTooltipManager();
  gfx::Point location(p);
  ConvertPointToScreen(this, &location);
  // Also update when the maximum width for tooltip has changed because the
  // it may be elided differently.
  int max_tooltip_width = tooltip_manager->GetMaxWidth(location);
  if (tooltip_text_.empty() || max_tooltip_width != max_tooltip_width_) {
    max_tooltip_width_ = max_tooltip_width;
    tooltip_text_ = BookmarkBarView::CreateToolTipForURLAndTitle(
        max_tooltip_width_, tooltip_manager->GetFontList(), *url_, GetText());
  }
  return tooltip_text_;
}

void BookmarkButton::AdjustAccessibleName(std::u16string& new_name,
                                          ax::mojom::NameFrom& name_from) {
  if (new_name.empty()) {
    new_name = l10n_util::GetStringFUTF16(
        IDS_UNNAMED_BOOKMARK_BUTTON_ACCESSIBLE_NAME,
        url_formatter::FormatUrl(
            url_.get(), url_formatter::kFormatUrlOmitDefaults,
            base::UnescapeRule::NORMAL, nullptr, nullptr, nullptr));
    name_from = ax::mojom::NameFrom::kContents;
  }
}

void BookmarkButton::SetText(const std::u16string& text) {
  BookmarkButtonBase::SetText(text);
  tooltip_text_.clear();
}

void BookmarkButton::OnMouseEntered(const ui::MouseEvent& event) {
  // Reset source information for taking metrics for following mouse events.

  BookmarkButtonBase::OnMouseEntered(event);

  if (base::FeatureList::IsEnabled(features::kBookmarkTriggerForPrerender2) &&
      kPrerenderBookmarkBarOnMouseHoverTrigger.Get()) {
    preloading_timer_.Start(
        FROM_HERE,
        base::Milliseconds(
            kPreconnectStartDelayOnMouseHoverByMiliseconds.Get()),
        base::BindRepeating(&BookmarkButton::StartPreconnecting,
                            base::Unretained(this), *url_));
    // Now we should register the callback function that will be used to
    // compute the preloading recall.
    if (auto* web_contents =
            browser_->tab_strip_model()->GetActiveWebContents()) {
      content::PreloadingData* preloading_data =
          content::PreloadingData::GetOrCreateForWebContents(web_contents);
      preloading_data->SetIsNavigationInDomainCallback(
          chrome_preloading_predictor::kMouseHoverOrMouseDownOnBookmarkBar,
          base::BindRepeating(
              [](content::NavigationHandle* navigation_handle) -> bool {
                return ui::PageTransitionCoreTypeIs(
                           navigation_handle->GetPageTransition(),
                           ui::PAGE_TRANSITION_AUTO_BOOKMARK) &&
                       ui::PageTransitionIsNewNavigation(
                           navigation_handle->GetPageTransition());
              }));
    }
  }
}

void BookmarkButton::OnMouseExited(const ui::MouseEvent& event) {
  BookmarkButtonBase::OnMouseExited(event);
  if (base::FeatureList::IsEnabled(features::kBookmarkTriggerForPrerender2)) {
    preloading_timer_.Stop();
    if (prerender_web_contents_) {
      auto* prerender_manager =
          PrerenderManager::FromWebContents(&(*prerender_web_contents_));
      prerender_manager->StopPrerenderBookmark(prerender_handle_);
      prerender_handle_ = nullptr;
      prerender_web_contents_ = nullptr;
    }
  }
}

bool BookmarkButton::OnMousePressed(const ui::MouseEvent& event) {
  bool result = BookmarkButtonBase::OnMousePressed(event);
  if (GetState() == ButtonState::STATE_PRESSED) {
    base::UmaHistogramEnumeration("Prerender.Experimental.BookmarkMetrics",
                                  PreloadBookmarkMetricsEvent::kMouseDown);
  }
  if (event.IsOnlyLeftMouseButton() &&
      base::FeatureList::IsEnabled(features::kBookmarkTriggerForPrerender2) &&
      kPrerenderBookmarkBarOnMousePressedTrigger.Get()) {
    StartPrerendering(*url_);
  }
  return result;
}

void BookmarkButton::OnMouseMoved(const ui::MouseEvent& event) {
  return BookmarkButtonBase::OnMouseMoved(event);
}

void BookmarkButton::StartPreconnecting(GURL url) {
  CHECK(base::FeatureList::IsEnabled(features::kBookmarkTriggerForPrerender2));
  if (prerender_handle_) {
    return;
  }

  // Directly start prerendering to avoid timer overhead.
  if (kPrerenderStartDelayOnMouseHoverByMiliseconds.Get() -
          kPreconnectStartDelayOnMouseHoverByMiliseconds.Get() <=
      0) {
    StartPrerendering(url);
  } else {
    auto* loading_predictor =
        predictors::LoadingPredictorFactory::GetForProfile(browser_->profile());
    if (loading_predictor) {
      loading_predictor->PrepareForPageLoad(
          /*initiator_origin=*/std::nullopt, url,
          predictors::HintOrigin::BOOKMARK_BAR, true);
    }

    preloading_timer_.Start(
        FROM_HERE,
        base::Milliseconds(
            kPrerenderStartDelayOnMouseHoverByMiliseconds.Get() -
            kPreconnectStartDelayOnMouseHoverByMiliseconds.Get()),
        base::BindRepeating(&BookmarkButton::StartPrerendering,
                            base::Unretained(this), url));
  }
}

void BookmarkButton::StartPrerendering(GURL url) {
  CHECK(base::FeatureList::IsEnabled(features::kBookmarkTriggerForPrerender2));
  if (prerender_handle_) {
    return;
  }
  auto* active_web_contents =
      browser_->tab_strip_model()->GetActiveWebContents();
  if (!active_web_contents) {
    return;
  }

  prerender_web_contents_ = active_web_contents->GetWeakPtr();
  PrerenderManager::CreateForWebContents(prerender_web_contents_.get());
  auto* prerender_manager =
      PrerenderManager::FromWebContents(prerender_web_contents_.get());
  prerender_handle_ = prerender_manager->StartPrerenderBookmark(url);
}

BEGIN_METADATA(BookmarkButton)
END_METADATA
