// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// This file is auto-generated from
// ui/gl/generate_bindings.py
// It's formatted by clang-format using chromium coding style:
//    clang-format -i -style=chromium filename
// DO NOT EDIT!

#include "ui/gl/gl_stub_api_base.h"

namespace gl {

GLenum GLStubApiBase::glCheckFramebufferStatusEXTFn(GLenum target) {
  return 0;
}

GLenum GLStubApiBase::glClientWaitSyncFn(GLsync sync,
                                         GLbitfield flags,
                                         GLuint64 timeout) {
  return 0;
}

GLenum GLStubApiBase::glClientWaitSyncAPPLEFn(GLsync sync,
                                              GLbitfield flags,
                                              GLuint64 timeout) {
  return 0;
}

GLuint GLStubApiBase::glCreateProgramFn() {
  return 0;
}

GLuint GLStubApiBase::glCreateShaderFn(GLenum type) {
  return 0;
}

GLuint GLStubApiBase::glCreateShaderProgramvFn(GLenum type,
                                               GLsizei count,
                                               const char* const* strings) {
  return 0;
}

GLsync GLStubApiBase::glFenceSyncFn(GLenum condition, GLbitfield flags) {
  return 0;
}

GLsync GLStubApiBase::glFenceSyncAPPLEFn(GLenum condition, GLbitfield flags) {
  return 0;
}

GLuint GLStubApiBase::glGenPathsNVFn(GLsizei range) {
  return 0;
}

GLuint GLStubApiBase::glGenProgramPipelinesFn(GLsizei n, GLuint* pipelines) {
  return 0;
}

GLint GLStubApiBase::glGetAttribLocationFn(GLuint program, const char* name) {
  return 0;
}

GLuint GLStubApiBase::glGetDebugMessageLogFn(GLuint count,
                                             GLsizei bufSize,
                                             GLenum* sources,
                                             GLenum* types,
                                             GLuint* ids,
                                             GLenum* severities,
                                             GLsizei* lengths,
                                             char* messageLog) {
  return 0;
}

GLenum GLStubApiBase::glGetErrorFn() {
  return 0;
}

GLint GLStubApiBase::glGetFragDataIndexFn(GLuint program, const char* name) {
  return 0;
}

GLint GLStubApiBase::glGetFragDataLocationFn(GLuint program, const char* name) {
  return 0;
}

GLenum GLStubApiBase::glGetGraphicsResetStatusARBFn() {
  return 0;
}

GLuint GLStubApiBase::glGetProgramResourceIndexFn(GLuint program,
                                                  GLenum programInterface,
                                                  const GLchar* name) {
  return 0;
}

GLint GLStubApiBase::glGetProgramResourceLocationFn(GLuint program,
                                                    GLenum programInterface,
                                                    const char* name) {
  return 0;
}

const GLubyte* GLStubApiBase::glGetStringFn(GLenum name) {
  return 0;
}

const GLubyte* GLStubApiBase::glGetStringiFn(GLenum name, GLuint index) {
  return 0;
}

GLuint GLStubApiBase::glGetUniformBlockIndexFn(GLuint program,
                                               const char* uniformBlockName) {
  return 0;
}

GLint GLStubApiBase::glGetUniformLocationFn(GLuint program, const char* name) {
  return 0;
}

GLboolean GLStubApiBase::glIsBufferFn(GLuint buffer) {
  return 0;
}

GLboolean GLStubApiBase::glIsEnabledFn(GLenum cap) {
  return 0;
}

GLboolean GLStubApiBase::glIsEnablediOESFn(GLenum target, GLuint index) {
  return 0;
}

GLboolean GLStubApiBase::glIsFenceAPPLEFn(GLuint fence) {
  return 0;
}

GLboolean GLStubApiBase::glIsFenceNVFn(GLuint fence) {
  return 0;
}

GLboolean GLStubApiBase::glIsFramebufferEXTFn(GLuint framebuffer) {
  return 0;
}

GLboolean GLStubApiBase::glIsPathNVFn(GLuint path) {
  return 0;
}

GLboolean GLStubApiBase::glIsProgramFn(GLuint program) {
  return 0;
}

GLboolean GLStubApiBase::glIsProgramPipelineFn(GLuint pipeline) {
  return 0;
}

GLboolean GLStubApiBase::glIsQueryFn(GLuint query) {
  return 0;
}

GLboolean GLStubApiBase::glIsRenderbufferEXTFn(GLuint renderbuffer) {
  return 0;
}

GLboolean GLStubApiBase::glIsSamplerFn(GLuint sampler) {
  return 0;
}

GLboolean GLStubApiBase::glIsShaderFn(GLuint shader) {
  return 0;
}

GLboolean GLStubApiBase::glIsSyncFn(GLsync sync) {
  return 0;
}

GLboolean GLStubApiBase::glIsSyncAPPLEFn(GLsync sync) {
  return 0;
}

GLboolean GLStubApiBase::glIsTextureFn(GLuint texture) {
  return 0;
}

GLboolean GLStubApiBase::glIsTransformFeedbackFn(GLuint id) {
  return 0;
}

GLboolean GLStubApiBase::glIsVertexArrayOESFn(GLuint array) {
  return 0;
}

void* GLStubApiBase::glMapBufferFn(GLenum target, GLenum access) {
  return 0;
}

void* GLStubApiBase::glMapBufferRangeFn(GLenum target,
                                        GLintptr offset,
                                        GLsizeiptr length,
                                        GLbitfield access) {
  return 0;
}

GLboolean GLStubApiBase::glTestFenceAPPLEFn(GLuint fence) {
  return 0;
}

GLboolean GLStubApiBase::glTestFenceNVFn(GLuint fence) {
  return 0;
}

GLboolean GLStubApiBase::glUnmapBufferFn(GLenum target) {
  return 0;
}

}  // namespace gl
