// Copyright 2012 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "content/public/test/mock_render_thread.h"

#include <memory>
#include <tuple>

#include "base/logging.h"
#include "base/task/single_thread_task_runner.h"
#include "base/unguessable_token.h"
#include "build/build_config.h"
#include "content/common/associated_interfaces.mojom.h"
#include "content/common/frame.mojom.h"
#include "content/common/render_message_filter.mojom.h"
#include "content/public/renderer/render_thread_observer.h"
#include "content/renderer/render_thread_impl.h"
#include "content/test/test_render_frame.h"
#include "ipc/ipc_message_utils.h"
#include "ipc/ipc_sync_message.h"
#include "ipc/message_filter.h"
#include "mojo/public/cpp/bindings/pending_remote.h"
#include "services/network/public/mojom/attribution.mojom.h"
#include "testing/gtest/include/gtest/gtest.h"
#include "third_party/blink/public/common/dom_storage/session_storage_namespace_id.h"
#include "third_party/blink/public/common/user_agent/user_agent_metadata.h"
#include "third_party/blink/public/mojom/page/widget.mojom.h"
#include "third_party/blink/public/mojom/widget/platform_widget.mojom.h"

namespace content {

namespace {

// Some tests hard-code small numbers for routing IDs, so make reasonably sure
// that the IDs generated by MockRenderThread will not clash.
constexpr int32_t kFirstGeneratedRoutingId = 313337000;

static const blink::UserAgentMetadata kUserAgentMetadata;

class MockRenderMessageFilterImpl : public mojom::RenderMessageFilter {
 public:
  MockRenderMessageFilterImpl() = default;
  ~MockRenderMessageFilterImpl() override = default;

  // mojom::RenderMessageFilter:
  void GenerateRoutingID(GenerateRoutingIDCallback callback) override {
    std::move(callback).Run(RenderThread::Get()->GenerateRoutingID());
  }

  void GenerateFrameRoutingID(
      GenerateFrameRoutingIDCallback callback) override {
    int routing_id;
    blink::LocalFrameToken frame_token;
    base::UnguessableToken devtools_frame_token;
    blink::DocumentToken document_token;
    RenderThread::Get()->GenerateFrameRoutingID(
        routing_id, frame_token, devtools_frame_token, document_token);
    std::move(callback).Run(routing_id, frame_token, devtools_frame_token,
                            document_token);
  }

  void HasGpuProcess(HasGpuProcessCallback callback) override {
    std::move(callback).Run(false);
  }

#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
  void SetThreadType(int32_t platform_thread_id,
                     base::ThreadType thread_type) override {}
#endif
};

}  // namespace

MockRenderThread::MockRenderThread()
    : next_routing_id_(kFirstGeneratedRoutingId),
      mock_render_message_filter_(new MockRenderMessageFilterImpl()) {
  RenderThreadImpl::SetRenderMessageFilterForTesting(
      mock_render_message_filter_.get());
}

MockRenderThread::~MockRenderThread() {
  while (!filters_.empty()) {
    scoped_refptr<IPC::MessageFilter> filter = filters_.back();
    filters_.pop_back();
    filter->OnFilterRemoved();
  }
}

// Called by the Widget. Used to send messages to the browser.
// We short-circuit the mechanism and handle the messages right here on this
// class.
bool MockRenderThread::Send(IPC::Message* msg) {
  // We need to simulate a synchronous channel, thus we are going to receive
  // through this function messages, messages with reply and reply messages.
  // We can only handle one synchronous message at a time.
  if (msg->is_reply()) {
    if (reply_deserializer_) {
      reply_deserializer_->SerializeOutputParameters(*msg);
      reply_deserializer_.reset();
    }
  } else {
    if (msg->is_sync()) {
      // We actually need to handle deleting the reply deserializer for sync
      // messages.
      reply_deserializer_ =
          static_cast<IPC::SyncMessage*>(msg)->TakeReplyDeserializer();
    }
    if (msg->routing_id() == MSG_ROUTING_CONTROL)
      OnControlMessageReceived(*msg);
    else
      OnMessageReceived(*msg);
  }
  delete msg;
  return true;
}

IPC::SyncChannel* MockRenderThread::GetChannel() {
  return nullptr;
}

std::string MockRenderThread::GetLocale() {
  return "en-US";
}

IPC::SyncMessageFilter* MockRenderThread::GetSyncMessageFilter() {
  return nullptr;
}

scoped_refptr<base::SingleThreadTaskRunner>
MockRenderThread::GetIOTaskRunner() {
  return io_task_runner_;
}

void MockRenderThread::BindHostReceiver(mojo::GenericPendingReceiver receiver) {
}

void MockRenderThread::AddRoute(int32_t routing_id, IPC::Listener* listener) {}

void MockRenderThread::AttachTaskRunnerToRoute(
    int32_t routing_id,
    scoped_refptr<base::SingleThreadTaskRunner> task_runner) {}

void MockRenderThread::RemoveRoute(int32_t routing_id) {}

int MockRenderThread::GenerateRoutingID() {
  return GetNextRoutingID();
}

bool MockRenderThread::GenerateFrameRoutingID(
    int32_t& routing_id,
    blink::LocalFrameToken& frame_token,
    base::UnguessableToken& devtools_frame_token,
    blink::DocumentToken& document_token) {
  routing_id = GetNextRoutingID();
  frame_token = blink::LocalFrameToken();
  devtools_frame_token = base::UnguessableToken::Create();
  document_token = blink::DocumentToken();
  return true;
}

void MockRenderThread::AddFilter(IPC::MessageFilter* filter) {
  filter->OnFilterAdded(&sink());
  // Add this filter to a vector so the MockRenderThread::RemoveFilter function
  // can check if this filter is added.
  filters_.push_back(base::WrapRefCounted(filter));
}

void MockRenderThread::RemoveFilter(IPC::MessageFilter* filter) {
  // Emulate the IPC::ChannelProxy::OnRemoveFilter function.
  for (size_t i = 0; i < filters_.size(); ++i) {
    if (filters_[i].get() == filter) {
      filter->OnFilterRemoved();
      filters_.erase(filters_.begin() + i);
      return;
    }
  }
  NOTREACHED() << "filter to be removed not found";
}

void MockRenderThread::AddObserver(RenderThreadObserver* observer) {
  observers_.AddObserver(observer);
}

void MockRenderThread::RemoveObserver(RenderThreadObserver* observer) {
  observers_.RemoveObserver(observer);
}

void MockRenderThread::RecordAction(const base::UserMetricsAction& action) {
}

void MockRenderThread::RecordComputedAction(const std::string& action) {
}

int MockRenderThread::PostTaskToAllWebWorkers(base::RepeatingClosure closure) {
  return 0;
}

base::WaitableEvent* MockRenderThread::GetShutdownEvent() {
  return nullptr;
}

int32_t MockRenderThread::GetClientId() {
  return 1;
}

void MockRenderThread::SetRendererProcessType(
    blink::scheduler::WebRendererProcessType type) {}

blink::WebString MockRenderThread::GetUserAgent() {
  return blink::WebString();
}

blink::WebString MockRenderThread::GetFullUserAgent() {
  return blink::WebString();
}

blink::WebString MockRenderThread::GetReducedUserAgent() {
  return blink::WebString();
}

const blink::UserAgentMetadata& MockRenderThread::GetUserAgentMetadata() {
  return kUserAgentMetadata;
}

#if BUILDFLAG(IS_WIN)
void MockRenderThread::PreCacheFont(const LOGFONT& log_font) {
}

void MockRenderThread::ReleaseCachedFonts() {
}
#endif

void MockRenderThread::SetFieldTrialGroup(const std::string& trial_name,
                                          const std::string& group_name) {}

void MockRenderThread::WriteIntoTrace(
    perfetto::TracedProto<perfetto::protos::pbzero::RenderProcessHost> proto) {
  // Unlike RenderThreadImpl, MockRenderThread is not aware of its render
  // process ID.
}

int32_t MockRenderThread::GetNextRoutingID() {
  return next_routing_id_++;
}

mojo::PendingReceiver<blink::mojom::BrowserInterfaceBroker>
MockRenderThread::TakeInitialBrowserInterfaceBrokerReceiverForFrame(
    int32_t routing_id) {
  mojo::PendingReceiver<blink::mojom::BrowserInterfaceBroker>
      broker_from_create_child_frame_request;
  auto it = frame_routing_id_to_initial_browser_brokers_.find(routing_id);
  if (it != frame_routing_id_to_initial_browser_brokers_.end()) {
    broker_from_create_child_frame_request = std::move(it->second);
    frame_routing_id_to_initial_browser_brokers_.erase(it);
  }
  return broker_from_create_child_frame_request;
}

void MockRenderThread::OnCreateChildFrame(
    int32_t child_routing_id,
    mojo::PendingAssociatedRemote<mojom::Frame> frame_remote,
    mojo::PendingReceiver<blink::mojom::BrowserInterfaceBroker>
        browser_interface_broker) {
  frame_routing_id_to_initial_browser_brokers_.emplace(
      child_routing_id, std::move(browser_interface_broker));
}

bool MockRenderThread::OnControlMessageReceived(const IPC::Message& msg) {
  for (auto& observer : observers_) {
    if (observer.OnControlMessageReceived(msg))
      return true;
  }
  return OnMessageReceived(msg);
}

bool MockRenderThread::OnMessageReceived(const IPC::Message& msg) {
  // Save the message in the sink.
  sink_.OnMessageReceived(msg);
  return false;
}

// The View expects to be returned a valid route_id different from its own.
void MockRenderThread::OnCreateWindow(
    const mojom::CreateNewWindowParams& params,
    mojom::CreateNewWindowReply* reply) {
  reply->frame = TestRenderFrame::CreateStubFrameReceiver();
  reply->main_frame_route_id = GetNextRoutingID();
  frame_routing_id_to_initial_browser_brokers_.emplace(
      reply->main_frame_route_id,
      reply->main_frame_interface_broker.InitWithNewPipeAndPassReceiver());
  reply->associated_interface_provider =
      TestRenderFrame::CreateStubAssociatedInterfaceProviderRemote();
  reply->cloned_session_storage_namespace_id =
      blink::AllocateSessionStorageNamespaceId();

  auto widget_params = mojom::CreateFrameWidgetParams::New();
  widget_params->routing_id = GetNextRoutingID();
  mojo::AssociatedRemote<blink::mojom::FrameWidget> blink_frame_widget;
  mojo::PendingAssociatedReceiver<blink::mojom::FrameWidget>
      blink_frame_widget_receiver =
          blink_frame_widget.BindNewEndpointAndPassDedicatedReceiver();
  mojo::AssociatedRemote<blink::mojom::FrameWidgetHost> blink_frame_widget_host;
  std::ignore =
      blink_frame_widget_host.BindNewEndpointAndPassDedicatedReceiver();
  mojo::AssociatedRemote<blink::mojom::Widget> blink_widget;
  mojo::PendingAssociatedReceiver<blink::mojom::Widget> blink_widget_receiver =
      blink_widget.BindNewEndpointAndPassDedicatedReceiver();
  mojo::AssociatedRemote<blink::mojom::WidgetHost> blink_widget_host;
  std::ignore = blink_widget_host.BindNewEndpointAndPassDedicatedReceiver();

  widget_params->frame_widget = std::move(blink_frame_widget_receiver);
  widget_params->frame_widget_host = blink_frame_widget_host.Unbind();
  widget_params->widget = std::move(blink_widget_receiver);
  widget_params->widget_host = blink_widget_host.Unbind();
  widget_params->visual_properties.screen_infos =
      display::ScreenInfos(display::ScreenInfo());
  reply->widget_params = std::move(widget_params);

  mojo::AssociatedRemote<blink::mojom::PageBroadcast> page_broadcast;
  reply->page_broadcast =
      page_broadcast.BindNewEndpointAndPassDedicatedReceiver();
  page_broadcasts_.push_back(std::move(page_broadcast));
}

void MockRenderThread::ReleaseAllWebViews() {
  page_broadcasts_.clear();
}

network::mojom::AttributionSupport
MockRenderThread::GetAttributionReportingSupport() {
  return network::mojom::AttributionSupport::kWeb;
}

}  // namespace content
