{{+bindTo:partials.standard_nacl_api}}
<h1>pp::CompletionCallback Class Reference</h1>
<div id="doxygen-ref">
{{- dummy div to appease doxygen -}}
  <div>
<!-- Generated by Doxygen 1.7.6.1 -->



</div>
<!--header-->
<div class="contents">
<!-- doxytag: class="pp::CompletionCallback" --><div class="dynheader">
Inheritance diagram for pp::CompletionCallback:</div>
<div class="dyncontent">
<div class="center"><img src="classpp_1_1_completion_callback__inherit__graph.png" border="0" usemap="#pp_1_1_completion_callback_inherit__map" alt="Inheritance graph" /></div>
<map name="pp_1_1_completion_callback_inherit__map" id="pp_1_1_completion_callback_inherit__map">
<area shape="rect" id="node2" href="classpp_1_1_completion_callback_with_output.html" title="A CompletionCallbackWithOutput defines a completion callback that additionally stores a pointer to so..." alt="" coords="5,80,285,107"></area></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<p><a href="classpp_1_1_completion_callback-members.html">List of all members.</a></p>
<h2>
Public Member Functions</h2><table class="memberdecls">

<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback.html#a2dae27f9f015c3b9342a4a65f05bd356">CompletionCallback</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback.html#afe88416d324795a748d5112e197b0131">CompletionCallback</a> (PP_CompletionCallback_Func func, void *user_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback.html#a14fd9478ff007a91a3cdfa397c8e6e56">CompletionCallback</a> (PP_CompletionCallback_Func func, void *user_data, int32_t <a class="el" href="classpp_1_1_completion_callback.html#a60e466572fe7de362969dd41179c971f">flags</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback.html#a89fb884e8af572e9bf38fb880e132438">set_flags</a> (int32_t <a class="el" href="classpp_1_1_completion_callback.html#a60e466572fe7de362969dd41179c971f">flags</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback.html#a7795404cc15a4f96523c28db21d364c4">Run</a> (int32_t result)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback.html#a2996ca2f2b640c7da6da9016a5b0cd16">RunAndClear</a> (int32_t result)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback.html#a6ce66ec2655c9157cab494f248551b5f">IsOptional</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const PP_CompletionCallback &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback.html#ada943a747c94eebb1e32dbd6914c2526">pp_completion_callback</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback.html#a60e466572fe7de362969dd41179c971f">flags</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback.html#a24d1648d1a92a5c36894ce081457e603">MayForce</a> (int32_t result) const </td></tr>
</table><h2>
Protected Attributes</h2><table class="memberdecls">
<tr><td class="memItemLeft" align="right" valign="top">PP_CompletionCallback&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_completion_callback.html#af071c756ff3eb007dfbea3f50df74111">cc_</a></td></tr>
</table>
<hr /><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This API enables you to implement and receive callbacks when Pepper operations complete asynchronously. </p>
<p>You can create these objects yourself, but it is most common to use the <a class="el" href="classpp_1_1_completion_callback_factory.html" title="CompletionCallbackFactory&lt;T&gt; may be used to create CompletionCallback objects that are bound to membe...">CompletionCallbackFactory</a> to allow the callbacks to call class member functions. </p>
</div><hr /><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2dae27f9f015c3b9342a4a65f05bd356"></a><!-- doxytag: member="pp::CompletionCallback::CompletionCallback" ref="a2dae27f9f015c3b9342a4a65f05bd356" args="()" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback.html#a2dae27f9f015c3b9342a4a65f05bd356">pp::CompletionCallback::CompletionCallback</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>The default constructor will create a blocking <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> that can be passed to a method to indicate that the calling thread should be blocked until the asynchronous operation corresponding to the method completes. </p>
<p><b>Note:</b> Blocking completion callbacks are only allowed from from background threads. </p>
</div>
</div>
<a class="anchor" id="afe88416d324795a748d5112e197b0131"></a><!-- doxytag: member="pp::CompletionCallback::CompletionCallback" ref="afe88416d324795a748d5112e197b0131" args="(PP_CompletionCallback_Func func, void *user_data)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback.html#a2dae27f9f015c3b9342a4a65f05bd356">pp::CompletionCallback::CompletionCallback</a> </td>
<td>(</td>
<td class="paramtype">PP_CompletionCallback_Func&#160;</td>
<td class="paramname"><em>func</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void *&#160;</td>
<td class="paramname"><em>user_data</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>A constructor for creating a <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function to be called on completion. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>The user data to be passed to the callback function. This is optional and is typically used to help track state in case of multiple pending callbacks. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a14fd9478ff007a91a3cdfa397c8e6e56"></a><!-- doxytag: member="pp::CompletionCallback::CompletionCallback" ref="a14fd9478ff007a91a3cdfa397c8e6e56" args="(PP_CompletionCallback_Func func, void *user_data, int32_t flags)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_completion_callback.html#a2dae27f9f015c3b9342a4a65f05bd356">pp::CompletionCallback::CompletionCallback</a> </td>
<td>(</td>
<td class="paramtype">PP_CompletionCallback_Func&#160;</td>
<td class="paramname"><em>func</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void *&#160;</td>
<td class="paramname"><em>user_data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>flags</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>A constructor for creating a <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> with specified flags. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function to be called on completion. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>The user data to be passed to the callback function. This is optional and is typically used to help track state in case of multiple pending callbacks. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Bit field combination of <code>PP_CompletionCallback_Flag</code> flags used to control how non-NULL callbacks are scheduled by asynchronous methods. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<hr /><h2>Member Function Documentation</h2>
<a class="anchor" id="a60e466572fe7de362969dd41179c971f"></a><!-- doxytag: member="pp::CompletionCallback::flags" ref="a60e466572fe7de362969dd41179c971f" args="() const " -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_completion_callback.html#a60e466572fe7de362969dd41179c971f">pp::CompletionCallback::flags</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const<code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>The <a class="el" href="classpp_1_1_completion_callback.html#a60e466572fe7de362969dd41179c971f" title="The flags() function returns flags used to control how non-NULL callbacks are scheduled by asynchrono...">flags()</a> function returns flags used to control how non-NULL callbacks are scheduled by asynchronous methods. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing a bit field combination of <code>PP_CompletionCallback_Flag</code> flags. </dd></dl>
</div>
</div>
<a class="anchor" id="a6ce66ec2655c9157cab494f248551b5f"></a><!-- doxytag: member="pp::CompletionCallback::IsOptional" ref="a6ce66ec2655c9157cab494f248551b5f" args="() const " -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool <a class="el" href="classpp_1_1_completion_callback.html#a6ce66ec2655c9157cab494f248551b5f">pp::CompletionCallback::IsOptional</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const<code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_completion_callback.html#a6ce66ec2655c9157cab494f248551b5f" title="IsOptional() is used to determine the setting of the PP_COMPLETIONCALLBACK_FLAG_OPTIONAL flag...">IsOptional()</a> is used to determine the setting of the <code>PP_COMPLETIONCALLBACK_FLAG_OPTIONAL</code> flag. </p>
<p>This flag allows any method taking such callback to complete synchronously and not call the callback if the operation would not block. This is useful when performance is an issue, and the operation bandwidth should not be limited to the processing speed of the message loop.</p>
<p>On synchronous method completion, the completion result will be returned by the method itself. Otherwise, the method will return PP_OK_COMPLETIONPENDING, and the callback will be invoked asynchronously on the same thread where the PPB method was invoked.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if this callback is optional, otherwise false. </dd></dl>
</div>
</div>
<a class="anchor" id="a24d1648d1a92a5c36894ce081457e603"></a><!-- doxytag: member="pp::CompletionCallback::MayForce" ref="a24d1648d1a92a5c36894ce081457e603" args="(int32_t result) const " -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_completion_callback.html#a24d1648d1a92a5c36894ce081457e603">pp::CompletionCallback::MayForce</a> </td>
<td>(</td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>result</em></td><td>)</td>
<td> const<code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_completion_callback.html#a24d1648d1a92a5c36894ce081457e603" title="MayForce() is used when implementing functions taking callbacks.">MayForce()</a> is used when implementing functions taking callbacks. </p>
<p>If the callback is required and <code>result</code> indicates that it has not been scheduled, it will be forced on the main thread.</p>
<p><b>Example:</b></p>
<div class="fragment"><pre class="fragment"> int32_t OpenURL(<a class="code" href="classpp_1_1_u_r_l_loader.html" title="URLLoader provides an API for loading URLs.">pp::URLLoader</a>* loader,
                 <a class="code" href="classpp_1_1_u_r_l_request_info.html" title="URLRequestInfo provides an API for creating and manipulating URL requests.">pp::URLRequestInfo</a>* url_request_info,
                 <span class="keyword">const</span> <a class="code" href="classpp_1_1_completion_callback.html#a2dae27f9f015c3b9342a4a65f05bd356" title="The default constructor will create a blocking CompletionCallback that can be passed to a method to i...">CompletionCallback</a>&amp; cc) {
   <span class="keywordflow">if</span> (loader == NULL || url_request_info == NULL)
     <span class="keywordflow">return</span> cc.MayForce(PP_ERROR_BADRESOURCE);
   <span class="keywordflow">return</span> loader-&gt;<a class="code" href="classpp_1_1_u_r_l_loader.html#afb72f38f30b94a2d5494225e364395b8" title="This function begins loading the URLRequestInfo.">Open</a>(*loader, *url_request_info, cc);
 }
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>PP_OK_COMPLETIONPENDING or the result of the completed operation to be passed to the callback function. PP_OK_COMPLETIONPENDING indicates that the callback has already been scheduled. Other non-positive values correspond to error codes from <code>pp_errors.h</code>. Positive values indicate additional information such as bytes read.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>PP_OK_COMPLETIONPENDING</code> if the callback has been forced, result parameter otherwise. </dd></dl>
</div>
</div>
<a class="anchor" id="ada943a747c94eebb1e32dbd6914c2526"></a><!-- doxytag: member="pp::CompletionCallback::pp_completion_callback" ref="ada943a747c94eebb1e32dbd6914c2526" args="() const " -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">const PP_CompletionCallback&amp; <a class="el" href="classpp_1_1_completion_callback.html#ada943a747c94eebb1e32dbd6914c2526">pp::CompletionCallback::pp_completion_callback</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const<code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>The <a class="el" href="classpp_1_1_completion_callback.html#ada943a747c94eebb1e32dbd6914c2526" title="The pp_completion_callback() function returns the underlying PP_CompletionCallback">pp_completion_callback()</a> function returns the underlying <code>PP_CompletionCallback</code> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>PP_CompletionCallback</code>. </dd></dl>
</div>
</div>
<a class="anchor" id="a7795404cc15a4f96523c28db21d364c4"></a><!-- doxytag: member="pp::CompletionCallback::Run" ref="a7795404cc15a4f96523c28db21d364c4" args="(int32_t result)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void <a class="el" href="classpp_1_1_completion_callback.html#a7795404cc15a4f96523c28db21d364c4">pp::CompletionCallback::Run</a> </td>
<td>(</td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>result</em></td><td>)</td>
<td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_completion_callback.html#a7795404cc15a4f96523c28db21d364c4" title="Run() is used to run the CompletionCallback.">Run()</a> is used to run the <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code>. </p>
<p>Normally, the system runs a <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> after an asynchronous operation completes, but programs may wish to run the <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> manually in order to reuse the same code paths.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>The result of the operation to be passed to the callback function. Non-positive values correspond to the error codes from <code>pp_errors.h</code> (excluding <code>PP_OK_COMPLETIONPENDING</code>). Positive values indicate additional information such as bytes read. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a2996ca2f2b640c7da6da9016a5b0cd16"></a><!-- doxytag: member="pp::CompletionCallback::RunAndClear" ref="a2996ca2f2b640c7da6da9016a5b0cd16" args="(int32_t result)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void <a class="el" href="classpp_1_1_completion_callback.html#a2996ca2f2b640c7da6da9016a5b0cd16">pp::CompletionCallback::RunAndClear</a> </td>
<td>(</td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>result</em></td><td>)</td>
<td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_completion_callback.html#a2996ca2f2b640c7da6da9016a5b0cd16" title="RunAndClear() is used to run the CompletionCallback and clear out the callback so that it cannot be r...">RunAndClear()</a> is used to run the <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> and clear out the callback so that it cannot be run a second time. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>The result of the operation to be passed to the callback function. Non-positive values correspond to the error codes from <code>pp_errors.h</code> (excluding <code>PP_OK_COMPLETIONPENDING</code>). Positive values indicate additional information such as bytes read. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a89fb884e8af572e9bf38fb880e132438"></a><!-- doxytag: member="pp::CompletionCallback::set_flags" ref="a89fb884e8af572e9bf38fb880e132438" args="(int32_t flags)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void <a class="el" href="classpp_1_1_completion_callback.html#a89fb884e8af572e9bf38fb880e132438">pp::CompletionCallback::set_flags</a> </td>
<td>(</td>
<td class="paramtype">int32_t&#160;</td>
<td class="paramname"><em>flags</em></td><td>)</td>
<td><code> [inline]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>The <a class="el" href="classpp_1_1_completion_callback.html#a89fb884e8af572e9bf38fb880e132438" title="The set_flags() function is used to set the flags used to control how non-NULL callbacks are schedule...">set_flags()</a> function is used to set the flags used to control how non-NULL callbacks are scheduled by asynchronous methods. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Bit field combination of <code>PP_CompletionCallback_Flag</code> flags used to control how non-NULL callbacks are scheduled by asynchronous methods. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<hr /><h2>Member Data Documentation</h2>
<a class="anchor" id="af071c756ff3eb007dfbea3f50df74111"></a><!-- doxytag: member="pp::CompletionCallback::cc_" ref="af071c756ff3eb007dfbea3f50df74111" args="" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">PP_CompletionCallback <a class="el" href="classpp_1_1_completion_callback.html#af071c756ff3eb007dfbea3f50df74111">pp::CompletionCallback::cc_</a><code> [protected]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
</div>
</div>
<hr />The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="completion__callback_8h.html">completion_callback.h</a></li>
</ul>
</div><!-- contents -->
</div>
{{/partials.standard_nacl_api}}
