// This file was generated by
//     //third_party/jni_zero/jni_zero.py
// For
//     J.module_N

#ifndef TEMP_DIR_HEADER_
#define TEMP_DIR_HEADER_

#include <iterator>

#include "third_party/jni_zero/jni_zero_internal.h"


// Forward declarations (methods).

JNI_POSSIBLE_BOUNDARY_EXPORT jboolean Java_J_module_1N_MejItBT4(
    JNIEnv* env,
    jclass jcaller,
    jboolean a);
JNI_POSSIBLE_BOUNDARY_EXPORT void Java_J_module_1N_MqDgXQiH(
    JNIEnv* env,
    jclass jcaller);

// Helper Methods.

namespace {

bool RegisterNative_J_module_1N(JNIEnv* env) {
  static const JNINativeMethod kMethods[] = {
    { "MejItBT4", "(Z)Z", reinterpret_cast<void*>(Java_J_module_1N_MejItBT4) },
    { "MqDgXQiH", "()V", reinterpret_cast<void*>(Java_J_module_1N_MqDgXQiH) },

  };

  jni_zero::ScopedJavaLocalRef<jclass> native_clazz =
      jni_zero::GetClass(env, "J/module_N");
  if (env->RegisterNatives(native_clazz.obj(), kMethods, std::size(kMethods)) < 0) {
    jni_zero::internal::HandleRegistrationError(env, native_clazz.obj(), __FILE__);
    return false;
  }

  return true;
}

}  // namespace

// Main Register Function.

namespace {

bool RegisterNatives(JNIEnv* env) {
  // Register natives in a proxy.
  if (!RegisterNative_J_module_1N(env)) {
    return false;
  }

  return true;
}

}  // namespace

#endif  // TEMP_DIR_HEADER_
