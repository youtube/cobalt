// Copyright 2025 The Cobalt Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <cstdlib>
#include <limits>
#include <set>
#include <thread>
#include <vector>

#include "testing/gtest/include/gtest/gtest.h"

namespace starboard {
namespace nplb {
namespace {

// Test class for the rand_r() function.
class PosixRandrTest : public ::testing::Test {
 protected:
  // No specific setup needed.
};

// Test to ensure rand_r() returns a value within [0, RAND_MAX].
TEST_F(PosixRandrTest, ReturnsValueWithinRange) {
  unsigned int seed = 123;  // Initial seed
  for (int i = 0; i < 100; ++i) {
    int random_value = rand_r(&seed);
    ASSERT_GE(random_value, 0);
    ASSERT_LE(random_value, RAND_MAX);
  }
}

// Test that RAND_MAX is at least 32767 as per POSIX.
TEST_F(PosixRandrTest, RandMaxIsAtLeast32767) {
  ASSERT_GE(RAND_MAX, 32767);  // POSIX minimum
}

// Test that different initial seeds produce different sequences.
TEST_F(PosixRandrTest, DifferentInitialSeedsProduceDifferentSequences) {
  unsigned int seed1 = 1;
  unsigned int seed2 = 2;

  int rand_val1_seq1 = rand_r(&seed1);
  int rand_val2_seq1 = rand_r(&seed1);

  int rand_val1_seq2 = rand_r(&seed2);
  int rand_val2_seq2 = rand_r(&seed2);

  EXPECT_NE(rand_val1_seq1, rand_val1_seq2);
  EXPECT_NE(rand_val2_seq1, rand_val2_seq2);
}

// Test that the same initial seed produces a repeatable sequence.
TEST_F(PosixRandrTest, SameInitialSeedProducesRepeatableSequence) {
  unsigned int seed_orig = 123;
  unsigned int seed1 = seed_orig;
  unsigned int seed2 = seed_orig;

  int seq1_val1 = rand_r(&seed1);
  int seq1_val2 = rand_r(&seed1);
  int seq1_val3 = rand_r(&seed1);

  int seq2_val1 = rand_r(&seed2);
  int seq2_val2 = rand_r(&seed2);
  int seq2_val3 = rand_r(&seed2);

  ASSERT_EQ(seq1_val1, seq2_val1);
  ASSERT_EQ(seq1_val2, seq2_val2);
  ASSERT_EQ(seq1_val3, seq2_val3);
}

// Test that multiple calls without re-seeding produce different values.
TEST_F(PosixRandrTest, MultipleCallsProduceDifferentValues) {
  unsigned int seed =
      static_cast<unsigned int>(time(NULL));  // Seed with current time
  int val1 = rand_r(&seed);
  int val2 = rand_r(&seed);
  int val3 = rand_r(&seed);

  EXPECT_NE(val1, val2);
  EXPECT_NE(val2, val3);
  EXPECT_NE(val1, val3);
}

// Test for thread safety: multiple threads using rand_r with their own seeds.
TEST_F(PosixRandrTest, ThreadSafety) {
  const int num_threads = 5;           // Number of concurrent threads
  const int numbers_per_thread = 100;  // Numbers generated by each thread
  std::vector<std::thread> threads;
  std::vector<std::vector<int>> results(num_threads);

  for (int i = 0; i < num_threads; ++i) {
    threads.emplace_back([i, &results]() {
      unsigned int seed =
          static_cast<unsigned int>(i + 1);  // Unique seed for each thread
      for (int j = 0; j < numbers_per_thread; ++j) {
        results[i].push_back(rand_r(&seed));
      }
    });
  }

  for (auto& t : threads) {
    t.join();
  }

  // Verify that each thread generated distinct sequences (highly probable).
  // Also, verify that values are within range for all generated numbers.
  for (int i = 0; i < num_threads; ++i) {
    ASSERT_EQ(results[i].size(), numbers_per_thread);
    std::set<int> unique_numbers(results[i].begin(), results[i].end());
    // For a good PRNG, the number of unique numbers should be close to
    // numbers_per_thread. This is a weak check, but better than nothing for
    // non-cryptographic PRNGs.
    EXPECT_GT(unique_numbers.size(),
              numbers_per_thread /
                  2);  // Expect at least half unique for basic sanity

    for (int val : results[i]) {
      ASSERT_GE(val, 0);
      ASSERT_LE(val, RAND_MAX);
    }
  }

  // Optionally, verify inter-thread non-correlation (more complex and depends
  // on PRNG quality). For simplicity, we just ensure each thread's generation
  // seems reasonable.
}

// No error tests are included as POSIX specifies that rand_r()
// does not set errno or return error codes for any input.
// The only parameter is a pointer to an unsigned int, and dereferencing
// a null pointer would be undefined behavior, not an error returned by rand_r.
// Therefore, specific error tests are not applicable.

}  // namespace
}  // namespace nplb
}  // namespace starboard
