// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Definitions that allow for DRM support, common between Player and Decoder
// interfaces.

#ifndef STARBOARD_DRM_H_
#define STARBOARD_DRM_H_

#include "starboard/export.h"
#include "starboard/types.h"

#ifdef __cplusplus
extern "C" {
#endif

// --- Types -----------------------------------------------------------------

// Possibly supported DRM Key Systems.
typedef enum SbDrmKeySystem {
  kSbDrmKeySystemNone,

  kSbDrmKeySystemPlayReady,
  kSbDrmKeySystemWidevine,
} SbDrmKeySystem;

// Status of a particular media key.
// https://w3c.github.io/encrypted-media/#idl-def-MediaKeyStatus
typedef enum SbDrmKeyStatus {
  kSbDrmKeyStatusUsable,
  kSbDrmKeyStatusExpired,
  kSbDrmKeyStatusReleased,
  kSbDrmKeyStatusRestricted,
  kSbDrmKeyStatusDownscaled,
  kSbDrmKeyStatusPending,
  kSbDrmKeyStatusError,
} SbDrmKeyStatus;

// A mapping of clear and encrypted bytes for a single subsample. All
// subsamples within a sample must be encrypted with the same encryption
// parameters. The clear bytes always appear first in the sample.
typedef struct SbDrmSubSampleMapping {
  // How many bytes of the corresponding subsample are not encrypted
  int32_t clear_byte_count;

  // How many bytes of the corresponding subsample are encrypted.
  int32_t encrypted_byte_count;
} SbDrmSubSampleMapping;

// All the optional information needed per sample for encrypted samples.
typedef struct SbDrmSampleInfo {
  // The Initialization Vector needed to decrypt this sample.
  uint8_t initialization_vector[16];

  // The ID of the license (or key) required to decrypt this sample. For
  // PlayReady, this is the license GUID in packed little-endian binary form.
  uint8_t identifier[16];

  // The number of subsamples in this sample, must be at least 1.
  int32_t subsample_count;

  // The clear/encrypted mapping of each subsample in this sample. This must be
  // an array of |subsample_count| mappings.
  SbDrmSubSampleMapping* subsample_mapping;
} SbDrmSampleInfo;

// A handle to a DRM session which can be used with either an SbDecoder or a
// SbPlayer.
typedef struct SbDrmSessionPrivate* SbDrmSession;

// A key request or renewal generated by the key system. This should be
// sufficient information for a client to make a request to the license server,
// and get a license response that will then be passed to SbDrmAddKey().
//
// Generated key requests are owned by the SbDrmSession, and are kept in memory
// until SbDrmAddKey() is called with the corresponding response,
// SbDrmRemoveAllKeys() is called on the session, or the DRM session is
// destroyed.
typedef struct SbDrmKeyRequest {
  // The DRM session that generated this key request.
  SbDrmSession drm;

  // The key system used by the DRM session.
  SbDrmKeySystem system;

  // A buffer with the session ID unique to this key request.
  void* session_id;

  // The size of |session|, in bytes.
  int session_id_size;

  // A buffer with the generated key request to send to the license server.
  void* request;

  // The size of |request|, in bytes.
  int request_size;
} SbDrmKeyRequest;

// A callback that will receive generated SbDrmKeyRequests when requested from a
// SbDrmSession. |drm| will be the DRM session that SbDrmGenerateKeyRequest()
// was called on. |context| will be the same context passed into that call to
// SbDrmGenerateKeyRequest(). |request| will be a fully populated and allocated
// SbDrmKeyRequest, or NULL if there was an error generating the request.
typedef void (*SbDrmKeyRequestFunc)(SbDrmSession drm,
                                    void* context,
                                    SbDrmKeyRequest* request);

// A callback that will receive generated SbDrmKeyRequests when the SbDrmSession
// needs to renew an expired key. |drm| will be the DRM session created by
// SbDrmCreateSession() which had the callback passed in as the
// |renewal_callback|. |request| will be a fully populated and allocated
// SbDrmKeyRequest.
typedef void (*SbDrmKeyRenewalFunc)(SbDrmSession drm, SbDrmKeyRequest* request);

// A callback for notifications that a key has been added, and subsequent
// encrypted samples are actively ready to be decoded. |drm| will be the DRM
// session that SbDrmAddKey() was called on. |context| will be the same context
// passed into that call to SbDrmAddKey(). |succeeded| is whether the key was
// successfully added or not.
typedef void (*SbDrmKeyAddedFunc)(SbDrmSession drm,
                                  void* context,
                                  bool succeeded);

// --- Constants -------------------------------------------------------------

// The value to pass into SbDrmCreateSession's |drm_header| argument for cases
// where the DRM does not require a header.
#define SB_DRM_NO_HEADER NULL

// The value to pass into SbDrmCreateSession's |drm_header_length| argument for
// cases where the DRM does not require a header.
#define SB_DRM_NO_HEADER_LENGTH 0

// An invalid SbDrmSession.
#define SB_DRM_INVALID_SESSION (SbDrmSession) NULL

// --- Functions -------------------------------------------------------------

// Returns whether the |drm| is a valid SbDrmSession.
static SB_C_FORCE_INLINE bool SbDrmIsValidSession(SbDrmSession drm) {
  return drm != SB_DRM_INVALID_SESSION;
}

// Creates a new |key_system| DRM session that can be used when constructing an
// SbPlayer or an SbDecoder.
//
// If the key system requires a header (e.g. WRMHEADER), then |drm_header| must
// not be NULL, |drm_header_length| must be > 0, and |drm_header| must contain
// the DRM header extracted from the media (or an appropriate substitute).
//
// If specified, |renewal_callback| will be called if an already added key has
// expired, or will expire soon, and a license renewal must be performed to
// continue to decrypt the associated content.
//
// Returns SB_DRM_INVALID_SESSION if the |key_system| is unsupported, or if the
// key system requires a DRM header, and one is not provided.
SB_EXPORT SbDrmSession SbDrmCreateSession(SbDrmKeySystem key_system,
                                          void* drm_header,
                                          int drm_header_length,
                                          SbDrmKeyRenewalFunc renewal_callback);

// Asynchronously generates a key request payload for |initialization_data|, of
// |initialization_data_size|, extracted from the media stream, in |drm|'s key
// system. Calls |callback| with |context| and either a populated request, or
// NULL if an error occured.  |context| may be used to distinguish callbacks
// from multiple concurrent calls to SbDrmGenerateKeyRequest(), and/or to route
// callbacks back to an object instance.
//
// |callback| may called from another thread or from the current thread before
// this function returns. Since it can be called from another thread, it may
// have been dispatched after SbDrmRemoveAllKeys() or SbDrmDestroySession() has
// been called. So, |callback| should always post a task back to the thread that
// called SbDrmGenerateKeyRequest(), and then decide to ignore the callback if
// the request is stale.
SB_EXPORT void SbDrmGenerateKeyRequest(SbDrmSession drm,
                                       void* context,
                                       void* initialization_data,
                                       int initialization_data_size,
                                       SbDrmKeyRequestFunc callback);

// Adds |key|, in |drm|'s key system, from the license server response.
// |request| must be the corresponding returned request from
// SbDrmGenerateKeyRequest(). Calls |callback| with |context| and whether the
// add succeeded. |context| may be used to distinguish callbacks from multiple
// concurrent calls to SbDrmAddKey(), and/or to route callbacks back to an
// object instance.
//
// Once a key is successfully installed into a DRM session, an SbPlayer or
// SbDecoder associated with that session will be able to decrypt samples
// encrypted with that key.
//
// |request| will always be invalidated upon the return of this function.
//
// |callback| may called from another thread or from the current thread before
// this function returns. Since it can be called from another thread, it may
// have been dispatched after SbDrmRemoveAllKeys() or SbDrmDestroySession() has
// been called. So, |callback| should always post a task back to the thread that
// called SbDrmAddKey(), and then decide to ignore the callback if the request
// is stale.
SB_EXPORT void SbDrmAddKey(SbDrmSession drm,
                           void* context,
                           SbDrmKeyRequest* request,
                           void* key,
                           int key_size,
                           SbDrmKeyAddedFunc callback);

// Gets the number of keys installed in the given |drm| session.
SB_EXPORT int SbDrmGetKeyCount(SbDrmSession drm);

// Gets the |out_key|, |out_key_size|, and |out_status| for key with |index| in
// the given |drm| session. Returns whether a key is installed at |index|. If
// not, the output parameters, which all must not be NULL, will not be modified.
SB_EXPORT bool SbDrmGetKeyStatus(SbDrmSession drm,
                                 int index,
                                 void** out_key,
                                 int* out_key_size,
                                 SbDrmKeyStatus* out_status);

// Removes all installed keys for |drm|. Any outstanding SbDrmKeyRequests will
// be invalidated.
//
// Because callbacks may happen on another thread, they may be in-flight when
// |drm| is destroyed, so it is up to the client to detect this case and ignore
// stale callbacks.
SB_EXPORT void SbDrmRemoveAllKeys(SbDrmSession drm);

// Destroys |drm|, which implicitly removes all keys installed in it, and
// invalidates all outstanding SbDrmKeyRequests. A DRM session cannot be
// destroyed unless any associated SbPlayer or SbDecoder has first been
// destroyed.
//
// Because callbacks may happen on another thread, they may be in-flight when
// |drm| is destroyed, so it is up to the client to detect this case and ignore
// stale callbacks.
SB_EXPORT bool SbDrmDestroySession(SbDrmSession drm);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif  // STARBOARD_DRM_H_
