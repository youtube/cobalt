// Copyright 2024 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/ui/views/profiles/avatar_toolbar_button.h"

#include <optional>
#include <string>

#include "base/functional/bind.h"
#include "base/functional/callback_helpers.h"
#include "base/run_loop.h"
#include "base/scoped_observation.h"
#include "base/strings/utf_string_conversions.h"
#include "base/test/bind.h"
#include "base/test/scoped_feature_list.h"
#include "base/test/with_feature_override.h"
#include "base/time/time.h"
#include "base/timer/timer.h"
#include "chrome/browser/browser_process.h"
#include "chrome/browser/enterprise/util/managed_browser_utils.h"
#include "chrome/browser/profiles/keep_alive/profile_keep_alive_types.h"
#include "chrome/browser/profiles/keep_alive/scoped_profile_keep_alive.h"
#include "chrome/browser/profiles/profile.h"
#include "chrome/browser/profiles/profile_attributes_entry.h"
#include "chrome/browser/profiles/profile_attributes_storage.h"
#include "chrome/browser/profiles/profile_avatar_icon_util.h"
#include "chrome/browser/profiles/profile_manager.h"
#include "chrome/browser/profiles/profiles_state.h"
#include "chrome/browser/signin/identity_manager_factory.h"
#include "chrome/browser/sync/sync_service_factory.h"
#include "chrome/browser/themes/theme_service.h"
#include "chrome/browser/themes/theme_service_factory.h"
#include "chrome/browser/ui/browser.h"
#include "chrome/browser/ui/browser_finder.h"
#include "chrome/browser/ui/profiles/profile_colors_util.h"
#include "chrome/browser/ui/ui_features.h"
#include "chrome/browser/ui/views/frame/browser_view.h"
#include "chrome/browser/ui/views/toolbar/toolbar_view.h"
#include "chrome/common/pref_names.h"
#include "chrome/grit/branded_strings.h"
#include "chrome/test/base/in_process_browser_test.h"
#include "chrome/test/base/profile_destruction_waiter.h"
#include "components/keep_alive_registry/keep_alive_types.h"
#include "components/keep_alive_registry/scoped_keep_alive.h"
#include "components/policy/core/browser/browser_policy_connector.h"
#include "components/policy/core/common/management/management_service.h"
#include "components/policy/core/common/mock_configuration_policy_provider.h"
#include "components/policy/core/common/policy_map.h"
#include "components/policy/policy_constants.h"
#include "components/signin/public/base/consent_level.h"
#include "components/signin/public/base/signin_metrics.h"
#include "components/signin/public/base/signin_switches.h"
#include "components/signin/public/identity_manager/account_info.h"
#include "components/signin/public/identity_manager/accounts_mutator.h"
#include "components/signin/public/identity_manager/identity_manager.h"
#include "components/signin/public/identity_manager/identity_test_utils.h"
#include "components/signin/public/identity_manager/primary_account_mutator.h"
#include "components/sync/service/sync_service.h"
#include "components/sync/test/test_sync_service.h"
#include "content/public/browser/browser_context.h"
#include "content/public/test/browser_test.h"
#include "content/public/test/test_utils.h"
#include "google_apis/gaia/core_account_id.h"
#include "testing/gtest/include/gtest/gtest.h"
#include "third_party/skia/include/core/SkColor.h"
#include "ui/base/mojom/themes.mojom.h"
#include "ui/base/ui_base_features.h"
#include "ui/gfx/image/image.h"
#include "ui/gfx/image/image_skia.h"
#include "ui/gfx/image/image_unittest_util.h"

#if BUILDFLAG(IS_CHROMEOS)
#include "ash/constants/ash_switches.h"
#include "chrome/common/chrome_switches.h"
#include "chrome/test/base/testing_profile.h"
#include "components/user_manager/user_names.h"
#endif

namespace {
ui::mojom::BrowserColorVariant kColorVariant =
    ui::mojom::BrowserColorVariant::kTonalSpot;

const gfx::Image kSignedInImage = gfx::test::CreateImage(20, 20, SK_ColorBLUE);
const char kSignedInImageUrl[] = "SIGNED_IN_IMAGE_URL";

enum class ColorThemeType { kAutogeneratedTheme, kUserColor };

std::unique_ptr<KeyedService> TestingSyncFactoryFunction(
    content::BrowserContext* context) {
  return std::make_unique<syncer::TestSyncService>();
}

class ProfileLoader {
 public:
  Profile* LoadFirstAndOnlyProfile() {
    auto* profile_manager = g_browser_process->profile_manager();
    auto& storage = profile_manager->GetProfileAttributesStorage();
    EXPECT_EQ(1U, storage.GetNumberOfProfiles());

    profile_manager->LoadProfileByPath(
        storage.GetAllProfilesAttributes()[0]->GetPath(), /*incognito=*/false,
        base::BindRepeating(&ProfileLoader::OnProfileLoaded,
                            base::Unretained(this)));

    profile_loading_run_loop_.Run();
    return profile_;
  }

 private:
  void OnProfileLoaded(Profile* profile) {
    profile_ = profile;
    profile_loading_run_loop_.Quit();
  }

  raw_ptr<Profile> profile_ = nullptr;
  base::RunLoop profile_loading_run_loop_;
};

}  // namespace

class AvatarToolbarButtonBrowserTest : public InProcessBrowserTest {
 public:
  AvatarToolbarButtonBrowserTest()
      : dependency_manager_subscription_(
            BrowserContextDependencyManager::GetInstance()
                ->RegisterCreateServicesCallbackForTesting(base::BindRepeating(
                    &AvatarToolbarButtonBrowserTest::SetTestingFactories,
                    base::Unretained(this)))) {
    // By default make all delays infinite to avoid flakiness. The tests that
    // needs to test bypass the delay effects will have to enforce timing out
    // the delays using
    // `AvatarToolbarButton::TriggerTimeoutForTesting()`. This allows to
    // properly test the behavior pre/post delay without being time dependent.
    SetInfiniteAvatarDelay(AvatarDelayType::kNameGreeting);
    SetInfiniteAvatarDelay(AvatarDelayType::kSigninPendingText);
  }

  AvatarToolbarButtonBrowserTest(const AvatarToolbarButtonBrowserTest&) =
      delete;
  AvatarToolbarButtonBrowserTest& operator=(
      const AvatarToolbarButtonBrowserTest&) = delete;
  ~AvatarToolbarButtonBrowserTest() override = default;

  AvatarToolbarButton* GetAvatarToolbarButton(Browser* browser) {
    return BrowserView::GetBrowserViewForBrowser(browser)->toolbar()->avatar_;
  }

  // Allows overriding the delay of different events that have a timing
  // duration. Sets the delay to infinite in order to be able to test the
  // behavior while the delay is happening. In order to stop the delay, use
  // `AvatarToolbarButton::TriggerTimeoutForTesting()` at any point.
  void SetInfiniteAvatarDelay(AvatarDelayType delay_type) {
    delay_type_resets_.insert_or_assign(
        delay_type,
        AvatarToolbarButton::CreateScopedInfiniteDelayOverrideForTesting(
            delay_type));
  }

  // Special override for the `AvatarDelayType::kSigninPendingText` delay to set
  // it to 0 given that the start time is stored as a ProfileUserData, which can
  // remain even if no browser exist. Setting it to 0 allows testing the
  // behavior where the delay is elapsed and then opening a new browser (while
  // no browser existed already).
  void SetZeroAvatarDelayForSigninPendingText() {
    delay_type_resets_.insert_or_assign(
        AvatarDelayType::kSigninPendingText,
        AvatarToolbarButton::
            CreateScopedZeroDelayOverrideSigninPendingTextForTesting());
  }

  // Returns the window count in avatar button text, if it exists.
  std::optional<int> GetWindowCountInAvatarButtonText(
      AvatarToolbarButton* avatar_button) {
    std::u16string button_text = avatar_button->GetText();

    size_t before_number = button_text.find('(');
    if (before_number == std::string::npos) {
      return std::optional<int>();
    }

    size_t after_number = button_text.find(')');
    EXPECT_NE(std::string::npos, after_number);

    std::u16string number_text =
        button_text.substr(before_number + 1, after_number - before_number - 1);
    int window_count;
    return base::StringToInt(number_text, &window_count)
               ? std::optional<int>(window_count)
               : std::optional<int>();
  }

  ProfileAttributesEntry* GetProfileAttributesEntry(Profile* profile) {
    ProfileAttributesEntry* entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath());
    CHECK(entry);
    return entry;
  }

  // - Helper functions

  signin::IdentityManager* GetIdentityManager() {
    return IdentityManagerFactory::GetForProfile(browser()->profile());
  }

  // Make account primary account with `consent_level` set and sets the account
  // name to `name`.
  AccountInfo MakePrimaryAccountAvailableWithName(
      signin::ConsentLevel consent_level,
      const std::u16string& email,
      const std::u16string& name) {
    AccountInfo account_info = signin::MakePrimaryAccountAvailable(
        GetIdentityManager(), base::UTF16ToUTF8(email), consent_level);
    EXPECT_FALSE(account_info.IsEmpty());

    account_info.given_name = base::UTF16ToUTF8(name);
    account_info.full_name = base::UTF16ToUTF8(name);
    account_info.picture_url = "SOME_FAKE_URL";
    account_info.hosted_domain = kNoHostedDomainFound;
    account_info.locale = "en";

    // Make sure account is valid so that all changes are persisted properly.
    CHECK(account_info.IsValid());

    signin::UpdateAccountInfoForAccount(GetIdentityManager(), account_info);

    GetTestSyncService()->SetSignedIn(consent_level, account_info);

    return account_info;
  }

  // Signs in to Chrome with `email` and set the `name` to the account name.
  AccountInfo Signin(const std::u16string& email, const std::u16string& name) {
    return MakePrimaryAccountAvailableWithName(signin::ConsentLevel::kSignin,
                                               email, name);
  }

  // Make sure `image_url` is different for each new image in order for the
  // changes to reflect into the profile as well.
  void AddAccountImage(CoreAccountId account_id,
                       gfx::Image image,
                       const std::string& image_url) {
    signin::SimulateAccountImageFetch(GetIdentityManager(), account_id,
                                      image_url, image);
  }

  // Sets `kSignedInImage` by default as the account image. This will allow to
  // show the name greeting.
  void AddSignedInImage(CoreAccountId account_id) {
    AddAccountImage(account_id, kSignedInImage, kSignedInImageUrl);
  }

  // Checks that the current image on the avtar button is the added account
  // image. Uses `kSignedInImage` by default.
  bool IsSignedInImageUsed(gfx::Image account_image = kSignedInImage) {
    AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
    gfx::Image current_avatar_icon = gfx::Image(
        avatar_button->GetImage(views::Button::ButtonState::STATE_NORMAL));
    gfx::Image adapted_signed_in_image = profiles::GetSizedAvatarIcon(
        account_image, avatar_button->GetIconSize(),
        avatar_button->GetIconSize(), profiles::SHAPE_CIRCLE);
    return gfx::test::AreImagesEqual(current_avatar_icon,
                                     adapted_signed_in_image);
  }

  // Sign in with an image should show the greeting name.
  AccountInfo SigninWithImage(const std::u16string& email,
                              const std::u16string& name = u"account_name") {
    AccountInfo account_info = Signin(email, name);
    AddSignedInImage(account_info.account_id);
    return account_info;
  }

  // Sign in with the full account information that triggers the name greeting,
  // but force timing it out right away to clear the animation.
  AccountInfo SigninWithImageAndClearGreeting(
      AvatarToolbarButton* avatar,
      const std::u16string& email,
      const std::u16string& name = u"account_name") {
    AccountInfo account_info = SigninWithImage(email, name);
    avatar->TriggerTimeoutForTesting(AvatarDelayType::kNameGreeting);
    return account_info;
  }

#if !BUILDFLAG(IS_CHROMEOS)
  void Signout() {
    ASSERT_TRUE(
        GetIdentityManager()->HasPrimaryAccount(signin::ConsentLevel::kSignin));

    GetIdentityManager()->GetPrimaryAccountMutator()->ClearPrimaryAccount(
        signin_metrics::ProfileSignout::kTest);

    ASSERT_FALSE(
        GetIdentityManager()->HasPrimaryAccount(signin::ConsentLevel::kSignin));
  }
#endif

  void SimulateSigninError(bool web_sign_out) {
    ASSERT_TRUE(
        GetIdentityManager()->HasPrimaryAccount(signin::ConsentLevel::kSignin));

    signin_metrics::SourceForRefreshTokenOperation token_operation_source =
        web_sign_out ? signin_metrics::SourceForRefreshTokenOperation::
                           kDiceResponseHandler_Signout
                     : signin_metrics::SourceForRefreshTokenOperation::kUnknown;

    signin::SetInvalidRefreshTokenForPrimaryAccount(GetIdentityManager(),
                                                    token_operation_source);
  }

  void ClearSigninError() {
    ASSERT_TRUE(
        GetIdentityManager()->HasPrimaryAccount(signin::ConsentLevel::kSignin));

    signin::SetRefreshTokenForPrimaryAccount(GetIdentityManager());
  }

  // Enables sync for account with `email` and set the `name` to the account
  // name.
  AccountInfo EnableSync(const std::u16string& email,
                         const std::u16string name) {
    return MakePrimaryAccountAvailableWithName(signin::ConsentLevel::kSync,
                                               email, name);
  }

  // Enables Sync with image should attempt to show the name greeting.
  AccountInfo EnableSyncWithImage(const std::u16string& email) {
    // Using a default name, this function is not expected to be used if we care
    // about the name.
    AccountInfo account_info = EnableSync(email, u"account_name");
    AddSignedInImage(account_info.account_id);
    return account_info;
  }

  // Enables sync with the full account information that triggers the name
  // greeting, but force timing it out right away to clear the animation.
  AccountInfo EnableSyncWithImageAndClearGreeting(AvatarToolbarButton* avatar,
                                                  const std::u16string& email) {
    AccountInfo account_info = EnableSyncWithImage(email);
    avatar->TriggerTimeoutForTesting(AvatarDelayType::kNameGreeting);
    return account_info;
  }

  void SimulateSyncPaused() {
    ASSERT_TRUE(
        GetIdentityManager()->HasPrimaryAccount(signin::ConsentLevel::kSync));

    // Simulates Sync Paused.
    GetTestSyncService()->SetPersistentAuthError();
    GetTestSyncService()->FireStateChanged();
  }

  void ClearSyncPaused() {
    ASSERT_TRUE(
        GetIdentityManager()->HasPrimaryAccount(signin::ConsentLevel::kSync));

    // Clear Sync Paused introduced in `SimulateSyncPaused()`.
    GetTestSyncService()->ClearAuthError();
    GetTestSyncService()->FireStateChanged();
  }

  void ExpectSyncPaused(AvatarToolbarButton* avatar_button) {
    EXPECT_EQ(avatar_button->GetText(), l10n_util::GetStringUTF16(
#if !BUILDFLAG(IS_CHROMEOS)
                                            IDS_AVATAR_BUTTON_SYNC_PAUSED
#else
                                            IDS_AVATAR_BUTTON_SYNC_ERROR
#endif
                                            ));
  }

  void SimulateSyncError() {
    ASSERT_TRUE(
        GetIdentityManager()->HasPrimaryAccount(signin::ConsentLevel::kSync));

    // Triggers Sync Error.
    GetTestSyncService()->SetTrustedVaultKeyRequired(true);
    GetTestSyncService()->FireStateChanged();
  }

  void ClearSyncError() {
    ASSERT_TRUE(
        GetIdentityManager()->HasPrimaryAccount(signin::ConsentLevel::kSync));

    // Clear Sync Error introduces in `SimulateSyncError()`.
    GetTestSyncService()->SetTrustedVaultKeyRequired(false);
    GetTestSyncService()->FireStateChanged();
  }

  // Waits for `time`.
  void WaitForTime(base::TimeDelta time) {
    base::RunLoop waiting_run_loop;
    base::OneShotTimer timer;
    timer.Start(FROM_HERE, time, waiting_run_loop.QuitClosure());
    waiting_run_loop.Run();
  }

  void SimulateDisableSyncByPolicyWithError() {
    GetTestSyncService()->SetAllowedByEnterprisePolicy(false);
    // Disabling sync by policy resets the sync setup.
    GetTestSyncService()->SetInitialSyncFeatureSetupComplete(false);
    GetTestSyncService()->FireStateChanged();
  }

  void SimulatePassphraseError() {
    GetTestSyncService()->SetPassphraseRequired();
    GetTestSyncService()->FireStateChanged();
  }

  void SimulateUpgradeClientError() {
    syncer::SyncStatus sync_status;
    sync_status.sync_protocol_error.action = syncer::UPGRADE_CLIENT;
    GetTestSyncService()->SetDetailedSyncStatus(true, sync_status);
    GetTestSyncService()->FireStateChanged();
    ASSERT_TRUE(GetTestSyncService()->RequiresClientUpgrade());
  }

 private:
  void SetTestingFactories(content::BrowserContext* context) {
    SyncServiceFactory::GetInstance()->SetTestingFactoryAndUse(
        context, base::BindRepeating(&TestingSyncFactoryFunction));
  }

  syncer::TestSyncService* GetTestSyncService() {
    return static_cast<syncer::TestSyncService*>(
        SyncServiceFactory::GetForProfile(browser()->profile()));
  }

  base::CallbackListSubscription dependency_manager_subscription_;
  std::map<AvatarDelayType, base::AutoReset<std::optional<base::TimeDelta>>>
      delay_type_resets_;
};

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, IncognitoWindowCount) {
  Profile* profile = browser()->profile();
  Browser* browser1 = CreateIncognitoBrowser(profile);
  AvatarToolbarButton* avatar_button1 = GetAvatarToolbarButton(browser1);
  EXPECT_TRUE(avatar_button1->GetEnabled());
  EXPECT_TRUE(avatar_button1->GetVisible());
  EXPECT_FALSE(GetWindowCountInAvatarButtonText(avatar_button1).has_value());

  Browser* browser2 = CreateIncognitoBrowser(profile);
  AvatarToolbarButton* avatar_button2 = GetAvatarToolbarButton(browser2);
  EXPECT_EQ(2, *GetWindowCountInAvatarButtonText(avatar_button1));
  EXPECT_EQ(2, *GetWindowCountInAvatarButtonText(avatar_button2));

  CloseBrowserSynchronously(browser2);
  EXPECT_FALSE(GetWindowCountInAvatarButtonText(avatar_button1).has_value());
}

#if !BUILDFLAG(IS_CHROMEOS)
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, GuestWindowCount) {
  Browser* browser1 = CreateGuestBrowser();
  AvatarToolbarButton* avatar_button1 = GetAvatarToolbarButton(browser1);
  EXPECT_TRUE(avatar_button1->GetEnabled());
  EXPECT_TRUE(avatar_button1->GetVisible());
  EXPECT_FALSE(GetWindowCountInAvatarButtonText(avatar_button1).has_value());

  Browser* browser2 = CreateGuestBrowser();
  AvatarToolbarButton* avatar_button2 = GetAvatarToolbarButton(browser2);
  EXPECT_EQ(2, *GetWindowCountInAvatarButtonText(avatar_button1));
  EXPECT_EQ(2, *GetWindowCountInAvatarButtonText(avatar_button2));

  CloseBrowserSynchronously(browser2);
  EXPECT_FALSE(GetWindowCountInAvatarButtonText(avatar_button1).has_value());
}
#endif

#if BUILDFLAG(IS_CHROMEOS)
class AvatarToolbarButtonAshBrowserTest
    : public AvatarToolbarButtonBrowserTest {
 protected:
  void SetUpCommandLine(base::CommandLine* command_line) override {
    // Adding these command lines simulates Ash in Guest mode.
    command_line->AppendSwitch(ash::switches::kGuestSession);
    command_line->AppendSwitchASCII(ash::switches::kLoginUser,
                                    user_manager::kGuestUserName);
    command_line->AppendSwitchASCII(ash::switches::kLoginProfile,
                                    TestingProfile::kTestUserProfileDir);
    command_line->AppendSwitch(switches::kIncognito);
  }
};

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonAshBrowserTest, GuestSession) {
  Profile* guest_profile = browser()->profile();
  ASSERT_TRUE(guest_profile->IsGuestSession());

  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  EXPECT_TRUE(avatar_button->GetVisible());
  EXPECT_FALSE(avatar_button->GetEnabled());

  EXPECT_EQ(avatar_button->GetText(),
            l10n_util::GetPluralStringFUTF16(IDS_AVATAR_BUTTON_GUEST, 1));

  Browser* browser_2 = CreateBrowser(guest_profile);
  AvatarToolbarButton* avatar_button_2 = GetAvatarToolbarButton(browser_2);
  EXPECT_TRUE(avatar_button_2->GetVisible());
  EXPECT_FALSE(avatar_button_2->GetEnabled());

  // Browser count is not taken into consideration on purpose for Ash Guest
  // windows since the button is not enabled, both buttons still show the same
  // text as if it was a single window, which is different from other platforms.
  EXPECT_EQ(avatar_button->GetText(),
            l10n_util::GetPluralStringFUTF16(IDS_AVATAR_BUTTON_GUEST, 1));
  EXPECT_EQ(avatar_button_2->GetText(),
            l10n_util::GetPluralStringFUTF16(IDS_AVATAR_BUTTON_GUEST, 1));
}
#endif

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, DefaultBrowser) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  ASSERT_TRUE(avatar);
#if BUILDFLAG(IS_CHROMEOS)
  // No avatar button is shown in normal Ash windows.
  EXPECT_FALSE(avatar->GetVisible());
#else
  EXPECT_TRUE(avatar->GetVisible());
  EXPECT_TRUE(avatar->GetEnabled());
#endif
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, IncognitoBrowser) {
  Browser* browser1 = CreateIncognitoBrowser(browser()->profile());
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser1);
  ASSERT_TRUE(avatar);
  // Incognito browsers always show an enabled avatar button.
  EXPECT_TRUE(avatar->GetVisible());
  EXPECT_TRUE(avatar->GetEnabled());
}

#if BUILDFLAG(IS_CHROMEOS)
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, SigninBrowser) {
  // Create an Incognito browser first.
  CreateIncognitoBrowser(browser()->profile());
  // Create a portal signin browser which will not be the Incognito browser.
  Profile::OTRProfileID profile_id(
      Profile::OTRProfileID::CreateUniqueForCaptivePortal());
  Browser* browser1 = Browser::Create(Browser::CreateParams(
      browser()->profile()->GetOffTheRecordProfile(profile_id,
                                                   /*create_if_needed=*/true),
      true));
  AddBlankTabAndShow(browser1);
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser1);
  ASSERT_TRUE(avatar);
  // On ChromeOS, captive portal signin windows show a
  // disabled avatar button to indicate that the window is incognito.
  EXPECT_TRUE(avatar->GetVisible());
  EXPECT_FALSE(avatar->GetEnabled());
}
#endif

class AvatarToolbarButtonBrowserTestWithExplicitBrowserSignin
    : public base::test::WithFeatureOverride,
      public AvatarToolbarButtonBrowserTest {
 public:
  AvatarToolbarButtonBrowserTestWithExplicitBrowserSignin()
      : base::test::WithFeatureOverride(
            switches::kExplicitBrowserSigninUIOnDesktop) {}

  bool is_explicit_browser_signin() const { return IsParamFeatureEnabled(); }
};

// TODO(b/331746545): Check flaky test issue on windows.
#if BUILDFLAG(IS_WIN)
#define MAYBE_ShowNameOnSigninThenSync DISABLED_ShowNameOnSigninThenSync
#else
#define MAYBE_ShowNameOnSigninThenSync ShowNameOnSigninThenSync
#endif
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonBrowserTestWithExplicitBrowserSignin,
                       MAYBE_ShowNameOnSigninThenSync) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  // Normal state.
  ASSERT_TRUE(avatar->GetText().empty());

  std::u16string email(u"test@gmail.com");
  std::u16string name(u"TestName");
  AccountInfo account_info = Signin(email, name);
  // The button is in a waiting for image state, the name is not yet displayed.
  EXPECT_EQ(avatar->GetText(), std::u16string());

  // The greeting will only show when the image is loaded.
  AddSignedInImage(account_info.account_id);
  EXPECT_EQ(avatar->GetText(),
            is_explicit_browser_signin()
                ? l10n_util::GetStringFUTF16(IDS_AVATAR_BUTTON_GREETING, name)
                : name);

  avatar->TriggerTimeoutForTesting(AvatarDelayType::kNameGreeting);
  // Once the name is not shown anymore, we expect no text.
  EXPECT_EQ(avatar->GetText(), std::u16string());

  // Enabling Sync after already being signed in does not show the name again.
  EnableSync(email, name);
  EXPECT_EQ(avatar->GetText(), std::u16string());
}

// TODO(b/331746545): Check flaky test issue on windows.
#if BUILDFLAG(IS_WIN)
#define MAYBE_ShowNameOnSync DISABLED_ShowNameOnSync
#else
#define MAYBE_ShowNameOnSync ShowNameOnSync
#endif
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonBrowserTestWithExplicitBrowserSignin,
                       MAYBE_ShowNameOnSync) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  // Normal state.
  ASSERT_TRUE(avatar->GetText().empty());

  std::u16string email(u"test@gmail.com");
  std::u16string name(u"TestName");
  AccountInfo account_info = EnableSync(email, name);
  // The button is in a waiting for image state, the name is not yet displayed.
  EXPECT_EQ(avatar->GetText(), std::u16string());

  // The greeting will only show when the image is loaded.
  AddSignedInImage(account_info.account_id);
  EXPECT_EQ(avatar->GetText(),
            is_explicit_browser_signin()
                ? l10n_util::GetStringFUTF16(IDS_AVATAR_BUTTON_GREETING, name)
                : name);

  avatar->TriggerTimeoutForTesting(AvatarDelayType::kNameGreeting);
  // Once the name is not shown anymore, we expect no text.
  EXPECT_EQ(avatar->GetText(), std::u16string());
}

// Check www.crbug.com/331499330: This test makes sure that no states attempt to
// request an update during their construction. But rather do so after all the
// states are created and the view is added to the Widget.
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonBrowserTestWithExplicitBrowserSignin,
                       OpenNewBrowserWhileNameIsShown) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  // Normal state.
  ASSERT_TRUE(avatar->GetText().empty());

  std::u16string name(u"TestName");
  AccountInfo account_info = Signin(u"test@gmail.com", name);
  // Make a second account available so that the name is shown on browser
  // startup.
  signin::MakeAccountAvailable(GetIdentityManager(), "test2@gmail.com");

  // The button is in a waiting for image state, the name is not yet displayed.
  EXPECT_EQ(avatar->GetText(), std::u16string());

  // The greeting will only show when the image is loaded.
  AddSignedInImage(account_info.account_id);
  EXPECT_EQ(avatar->GetText(),
            is_explicit_browser_signin()
                ? l10n_util::GetStringFUTF16(IDS_AVATAR_BUTTON_GREETING, name)
                : name);

  ASSERT_TRUE(GetIdentityManager()->AreRefreshTokensLoaded());

  // Creating a new browser while the refresh tokens are already loaded and the
  // name showing should not break/crash.
  Browser* new_browser = CreateBrowser(browser()->profile());
  AvatarToolbarButton* new_avatar_button = GetAvatarToolbarButton(new_browser);
  // Name is expected to be shown while it is still shown on the first browser.
  ASSERT_EQ(avatar->GetText(),
            is_explicit_browser_signin()
                ? l10n_util::GetStringFUTF16(IDS_AVATAR_BUTTON_GREETING, name)
                : name);
  EXPECT_EQ(new_avatar_button->GetText(),
            is_explicit_browser_signin()
                ? l10n_util::GetStringFUTF16(IDS_AVATAR_BUTTON_GREETING, name)
                : name);
}

INSTANTIATE_FEATURE_OVERRIDE_TEST_SUITE(
    AvatarToolbarButtonBrowserTestWithExplicitBrowserSignin);

// TODO(b/331746545): Check flaky test issue on windows.
#if BUILDFLAG(IS_WIN)
#define MAYBE_ShowNameDoesNotAppearOnNewBrowserIfNotShowing \
  DISABLED_ShowNameDoesNotAppearOnNewBrowserIfNotShowing
#else
#define MAYBE_ShowNameDoesNotAppearOnNewBrowserIfNotShowing \
  ShowNameDoesNotAppearOnNewBrowserIfNotShowing
#endif
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       MAYBE_ShowNameDoesNotAppearOnNewBrowserIfNotShowing) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  // Name is shown and force clearing.
  SigninWithImageAndClearGreeting(avatar, u"test@gmail.com", u"account_name");
  ASSERT_EQ(avatar->GetText(), std::u16string());

  Browser* new_browser = CreateBrowser(browser()->profile());
  AvatarToolbarButton* new_avatar_button = GetAvatarToolbarButton(new_browser);

  // During test setup, number of profiles may differ per platform.
  size_t number_of_profiles =
      g_browser_process->profile_manager()->GetNumberOfProfiles();
#if BUILDFLAG(IS_CHROMEOS)
  // In Ash tests setup creates more than 1 profile. When there is more than 1
  // profile (not Ash specific logic), the name is always shown on browser that
  // are signed in to show the greenting by default.
  ASSERT_GT(number_of_profiles, 1u);
  EXPECT_EQ(new_avatar_button->GetText(), u"account_name");
#else
  ASSERT_EQ(number_of_profiles, 1u);
  // Name is not expected to be shown since it was already shown and cleared on
  // the first browser.
  EXPECT_EQ(new_avatar_button->GetText(), std::u16string());
#endif
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, SyncPaused) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  // Normal state.
  ASSERT_TRUE(avatar_button->GetText().empty());

  AccountInfo account_info =
      EnableSyncWithImageAndClearGreeting(avatar_button, u"test@gmail.com");
  SimulateSyncPaused();
  ExpectSyncPaused(avatar_button);

  ClearSyncPaused();
  EXPECT_EQ(avatar_button->GetText(), std::u16string());
}

// Checks that "Sync paused" has higher priority than passphrase errors.
// Regression test for https://crbug.com/368997513
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       SyncPausedWithPassphraseError) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  ASSERT_TRUE(avatar_button->GetText().empty());

  AccountInfo account_info =
      EnableSyncWithImageAndClearGreeting(avatar_button, u"test@gmail.com");
  SimulatePassphraseError();
  SimulateSyncPaused();
  ExpectSyncPaused(avatar_button);
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, SyncError) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  // Normal state.
  ASSERT_TRUE(avatar_button->GetText().empty());

  EnableSyncWithImageAndClearGreeting(avatar_button, u"test@gmail.com");
  SimulateSyncError();
  EXPECT_EQ(avatar_button->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SYNC_ERROR));

  ClearSyncError();
  EXPECT_EQ(avatar_button->GetText(), std::u16string());
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       SyncPausedThenExplicitText) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  // Normal state.
  ASSERT_TRUE(avatar_button->GetText().empty());

  EnableSyncWithImageAndClearGreeting(avatar_button, u"test@gmail.com");
  SimulateSyncPaused();
  ExpectSyncPaused(avatar_button);

  std::u16string profile_switch_text(u"Profile Switch?");
  base::ScopedClosureRunner hide_callback = avatar_button->ShowExplicitText(
      profile_switch_text, /*accessibility_label=*/std::nullopt);
  EXPECT_EQ(avatar_button->GetText(), profile_switch_text);

  // Clearing explicit text should go back to Sync Pause.
  hide_callback.RunAndReset();
  ExpectSyncPaused(avatar_button);
}

// Explicit text over sync paused/error.
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       ExplicitTextThenSyncPause) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  // Normal state.
  ASSERT_TRUE(avatar_button->GetText().empty());

  EnableSyncWithImageAndClearGreeting(avatar_button, u"test@gmail.com");
  std::u16string profile_switch_text(u"Profile Switch?");
  base::ScopedClosureRunner hide_callback = avatar_button->ShowExplicitText(
      profile_switch_text, /*accessibility_label=*/std::nullopt);
  EXPECT_EQ(avatar_button->GetText(), profile_switch_text);

  SimulateSyncPaused();
  // Explicit text should still be shown even if Sync is now Paused.
  EXPECT_EQ(avatar_button->GetText(), profile_switch_text);

  // Clearing explicit text should go back to Sync Pause.
  hide_callback.RunAndReset();
  ExpectSyncPaused(avatar_button);
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       ShowExplicitTextAndHide) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  ASSERT_EQ(avatar->GetText(), std::u16string());

  std::u16string new_text(u"Some New Text");
  base::ScopedClosureRunner hide_callback =
      avatar->ShowExplicitText(new_text, /*accessibility_label=*/std::nullopt);

  EXPECT_EQ(avatar->GetText(), new_text);
  hide_callback.RunAndReset();
  EXPECT_EQ(avatar->GetText(), std::u16string());
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       ShowExplicitTextAndDefaultHide) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  ASSERT_EQ(avatar->GetText(), std::u16string());

  // Simulates a stack that enforces the change of text, but never explicitly
  // call the hide callback. It should still be done on explicitly destroying
  // the caller.
  {
    std::u16string new_text(u"Some New Text");
    base::ScopedClosureRunner hide_callback = avatar->ShowExplicitText(
        new_text, /*accessibility_label=*/std::nullopt);
    EXPECT_EQ(avatar->GetText(), new_text);
  }

  EXPECT_EQ(avatar->GetText(), std::u16string());
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       ShowExplicitTextTwiceAndHide) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  ASSERT_EQ(avatar->GetText(), std::u16string());

  std::u16string initial_new_text(u"Some New Text");
  base::ScopedClosureRunner initial_hide_callback = avatar->ShowExplicitText(
      initial_new_text, /*accessibility_label=*/std::nullopt);

  EXPECT_EQ(avatar->GetText(), initial_new_text);

  std::u16string override_new_text(u"Some New Override Text");
  base::ScopedClosureRunner override_hide_callback = avatar->ShowExplicitText(
      override_new_text, /*accessibility_label=*/std::nullopt);

  EXPECT_EQ(avatar->GetText(), override_new_text);

  // Attempting to reset the initial text should have no effect.
  initial_hide_callback.RunAndReset();
  EXPECT_EQ(avatar->GetText(), override_new_text);

  // Resetting the last text should work fine.
  override_hide_callback.RunAndReset();
  EXPECT_EQ(avatar->GetText(), std::u16string());
}

// Avatar button is not shown on Ash. No need to perform those tests as the info
// checked might not be adapted.
#if !BUILDFLAG(IS_CHROMEOS)
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, SignInOutIconEffect) {
  ASSERT_FALSE(IsSignedInImageUsed());

  SigninWithImage(u"test@gmail.com");
  EXPECT_TRUE(IsSignedInImageUsed());

  Signout();
  EXPECT_FALSE(IsSignedInImageUsed());
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, SignedInChangeIcon) {
  ASSERT_FALSE(IsSignedInImageUsed());

  AccountInfo account_info = SigninWithImage(u"test@gmail.com");
  EXPECT_TRUE(IsSignedInImageUsed());

  // Same image but different color as `kSignedInImage`.
  gfx::Image updated_image = gfx::test::CreateImage(20, 20, SK_ColorGREEN);
  AddAccountImage(account_info.account_id, updated_image,
                  "UPDATED_IMAGE_FAKE_URL");

  EXPECT_TRUE(IsSignedInImageUsed(updated_image));
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       PRE_SignedInWithNewSessionKeepIcon) {
  ASSERT_FALSE(IsSignedInImageUsed());

  SigninWithImage(u"test@gmail.com");
  EXPECT_TRUE(IsSignedInImageUsed());
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       SignedInWithNewSessionKeepIcon) {
  signin::WaitForRefreshTokensLoaded(GetIdentityManager());
  ASSERT_TRUE(
      GetIdentityManager()->HasPrimaryAccount(signin::ConsentLevel::kSignin));
  // Previously added image on signin should still be shown in the new session.
  EXPECT_TRUE(IsSignedInImageUsed());
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, TooltipText) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  ASSERT_EQ(avatar->GetText(), std::u16string());

  const std::u16string account_name(u"Account name");
  AccountInfo account_info = Signin(u"test@gmail.com", account_name);

  AddSignedInImage(account_info.account_id);

  EXPECT_EQ(avatar->GetTooltipText(gfx::Point()), account_name);

  avatar->TriggerTimeoutForTesting(AvatarDelayType::kNameGreeting);

  // Tooltip is the same after hiding the name.
  EXPECT_EQ(avatar->GetTooltipText(gfx::Point()), account_name);
}

// TODO(b/331746545): Check flaky test issue on windows.
#if BUILDFLAG(IS_WIN)
#define MAYBE_EnableSyncWithSyncDisabled DISABLED_EnableSyncWithSyncDisabled
#else
#define MAYBE_EnableSyncWithSyncDisabled EnableSyncWithSyncDisabled
#endif
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       MAYBE_EnableSyncWithSyncDisabled) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  ASSERT_EQ(avatar->GetText(), std::u16string());

  EnableSyncWithImageAndClearGreeting(avatar, u"test@gmail.com");
  EXPECT_EQ(avatar->GetText(), std::u16string());

  SimulateDisableSyncByPolicyWithError();

  EXPECT_EQ(avatar->GetText(), std::u16string());

  Browser* new_browser = CreateBrowser(browser()->profile());
  AvatarToolbarButton* new_avatar = GetAvatarToolbarButton(new_browser);
  EXPECT_EQ(new_avatar->GetText(), std::u16string());
}

#endif

// Test suite for testing `AvatarToolbarButton`'s responsibility of updating
// color information in `ProfileAttributesStorage`.
class AvatarToolbarButtonProfileColorBrowserTest
    : public AvatarToolbarButtonBrowserTest,
      public testing::WithParamInterface<ColorThemeType> {
 public:
  AvatarToolbarButtonProfileColorBrowserTest() = default;

  void SetUpOnMainThread() override {
    AvatarToolbarButtonBrowserTest::SetUpOnMainThread();
    theme_service(browser()->profile())
        ->SetBrowserColorScheme(ThemeService::BrowserColorScheme::kLight);
  }

  void SetColorTheme(Profile* profile, SkColor color) {
    ThemeService* service = theme_service(profile);
    switch (GetParam()) {
      case ColorThemeType::kAutogeneratedTheme:
        service->BuildAutogeneratedThemeFromColor(color);
        break;
      case ColorThemeType::kUserColor:
        service->SetUserColorAndBrowserColorVariant(color, kColorVariant);
        service->UseDeviceTheme(false);
        break;
    }
  }

  void SetDefaultTheme(Profile* profile) {
    ThemeService* service = theme_service(profile);
    switch (GetParam()) {
      case ColorThemeType::kAutogeneratedTheme:
        service->UseDefaultTheme();
        break;
      case ColorThemeType::kUserColor:
        service->SetUserColorAndBrowserColorVariant(SK_ColorTRANSPARENT,
                                                    kColorVariant);
        service->UseDeviceTheme(false);
        break;
    }
  }

  ThemeService* theme_service(Profile* profile) {
    return ThemeServiceFactory::GetForProfile(profile);
  }

  ProfileThemeColors ComputeProfileThemeColorsForBrowser(
      Browser* target_browser = nullptr) {
    target_browser = target_browser ? target_browser : browser();
    return GetCurrentProfileThemeColors(
        *target_browser->window()->GetColorProvider(),
        *ThemeServiceFactory::GetForProfile(target_browser->profile()));
  }
};

// Tests that the profile theme colors are updated when an autogenerated theme
// is set up.
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonProfileColorBrowserTest,
                       PRE_AutogeneratedTheme) {
  Profile* profile = browser()->profile();
  ProfileAttributesEntry* entry = GetProfileAttributesEntry(profile);
  SetDefaultTheme(profile);
  EXPECT_EQ(entry->GetProfileThemeColors(),
            ComputeProfileThemeColorsForBrowser());

  SetColorTheme(profile, SK_ColorGREEN);
  ProfileThemeColors theme_colors = entry->GetProfileThemeColors();
  EXPECT_EQ(theme_colors, ComputeProfileThemeColorsForBrowser());

  // Check that a switch to another autogenerated theme updates the colors.
  SetColorTheme(profile, SK_ColorMAGENTA);
  ProfileThemeColors theme_colors2 = entry->GetProfileThemeColors();
  EXPECT_NE(theme_colors, theme_colors2);
  EXPECT_NE(theme_colors2, GetDefaultProfileThemeColors());
  EXPECT_EQ(theme_colors2, ComputeProfileThemeColorsForBrowser());

  // Reset the cached colors to test that they're recreated on the next startup.
  entry->SetProfileThemeColors(std::nullopt);
  EXPECT_EQ(entry->GetProfileThemeColors(), GetDefaultProfileThemeColors());
}

// Tests that the profile theme colors are updated to reflect the autogenerated
// colors on startup.
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonProfileColorBrowserTest,
                       AutogeneratedTheme) {
  EXPECT_EQ(
      GetProfileAttributesEntry(browser()->profile())->GetProfileThemeColors(),
      ComputeProfileThemeColorsForBrowser());
}

// Tests that switching to the default theme updates profile colors.
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonProfileColorBrowserTest,
                       DefaultTheme) {
  Profile* profile = browser()->profile();
  ProfileAttributesEntry* entry = GetProfileAttributesEntry(profile);

  SetColorTheme(profile, SK_ColorGREEN);
  ProfileThemeColors theme_colors = entry->GetProfileThemeColors();
  EXPECT_EQ(theme_colors, ComputeProfileThemeColorsForBrowser());

  SetDefaultTheme(profile);
  ProfileThemeColors theme_colors2 = entry->GetProfileThemeColors();
  EXPECT_NE(theme_colors, theme_colors2);
  EXPECT_EQ(theme_colors2, ComputeProfileThemeColorsForBrowser());
}

// Tests that a theme is updated after opening a browser.
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonProfileColorBrowserTest,
                       UpdateThemeOnBrowserUpdate) {
  Profile* profile = browser()->profile();
  // Keeps the browser process and the profile alive while a browser window is
  // closed.
  ScopedKeepAlive keep_alive(KeepAliveOrigin::BROWSER,
                             KeepAliveRestartOption::DISABLED);
  ScopedProfileKeepAlive profile_keep_alive(
      profile, ProfileKeepAliveOrigin::kBackgroundMode);
  SetDefaultTheme(profile);
  ProfileAttributesEntry* entry = GetProfileAttributesEntry(profile);
  ProfileThemeColors theme_colors = entry->GetProfileThemeColors();
  CloseBrowserSynchronously(browser());

  SetColorTheme(profile, SK_ColorGREEN);
  // Colors haven't been changed yet because the profile has no active browsers.
  EXPECT_EQ(theme_colors, entry->GetProfileThemeColors());

  auto* target_browser = CreateBrowser(profile);
  ProfileThemeColors theme_colors2 = entry->GetProfileThemeColors();
  EXPECT_EQ(theme_colors2, ComputeProfileThemeColorsForBrowser(target_browser));
}

// Tests profile colors are updated when the browser's color scheme has changed.
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonProfileColorBrowserTest,
                       ProfileColorsUpdateOnColorSchemeChange) {
  theme_service(browser()->profile())
      ->SetBrowserColorScheme(ThemeService::BrowserColorScheme::kDark);
  Profile* profile = browser()->profile();
  ProfileAttributesEntry* entry = GetProfileAttributesEntry(profile);

  SetDefaultTheme(profile);
  ProfileThemeColors theme_colors = entry->GetProfileThemeColors();
  EXPECT_EQ(theme_colors, ComputeProfileThemeColorsForBrowser());

  theme_service(browser()->profile())
      ->SetBrowserColorScheme(ThemeService::BrowserColorScheme::kLight);
  ProfileThemeColors theme_colors2 = entry->GetProfileThemeColors();
  EXPECT_NE(theme_colors, theme_colors2);
  EXPECT_EQ(theme_colors2, ComputeProfileThemeColorsForBrowser());
}

INSTANTIATE_TEST_SUITE_P(,
                         AvatarToolbarButtonProfileColorBrowserTest,
                         testing::Values(ColorThemeType::kAutogeneratedTheme,
                                         ColorThemeType::kUserColor),
                         [](const auto& info) {
                           switch (info.param) {
                             case ColorThemeType::kAutogeneratedTheme:
                               return "AutogeneratedTheme";
                             case ColorThemeType::kUserColor:
                               return "UserColor";
                           }
                         });

#if BUILDFLAG(ENABLE_DICE_SUPPORT)
class AvatarToolbarButtonEnterpriseBadgingBrowserTest
    : public AvatarToolbarButtonBrowserTest {
 public:
  void SetUpInProcessBrowserTestFixture() override {
    provider_.SetDefaultReturns(
        true /* is_initialization_complete_return */,
        true /* is_first_policy_load_complete_return */);
    policy::BrowserPolicyConnector::SetPolicyProviderForTesting(&provider_);
  }

  void SetUpOnMainThread() override {
    AvatarToolbarButtonBrowserTest::SetUpOnMainThread();
  }

 protected:
  testing::NiceMock<policy::MockConfigurationPolicyProvider> provider_;
  base::test::ScopedFeatureList scoped_feature_list_{
      features::kEnterpriseProfileBadgingForAvatar};
};

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       WorkProfileTextBadging) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  // Ensure enterprise badging can be shown.
  std::u16string work_label = u"Work";

  {
    enterprise_util::SetUserAcceptedAccountManagement(browser()->profile(),
                                                      true);
    EXPECT_EQ(avatar_button->GetText(), work_label);
    auto clear_closure = avatar_button->ShowExplicitText(
        u"Explicit text", /*accessibility_label=*/std::nullopt);
    EXPECT_NE(avatar_button->GetText(), work_label);
    clear_closure.RunAndReset();
    EXPECT_EQ(avatar_button->GetText(), work_label);
  }

  {
    enterprise_util::SetUserAcceptedAccountManagement(browser()->profile(),
                                                      false);
    EXPECT_NE(avatar_button->GetText(), work_label);
    auto clear_closure = avatar_button->ShowExplicitText(
        u"Explicit text", /*accessibility_label=*/std::nullopt);
    EXPECT_NE(avatar_button->GetText(), work_label);
    clear_closure.RunAndReset();
    EXPECT_NE(avatar_button->GetText(), work_label);
  }
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       DefaultBadgeDisabledbyPolicy) {
  std::u16string work_label = u"Work";
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  browser()->profile()->GetPrefs()->SetInteger(
      prefs::kEnterpriseProfileBadgeToolbarSettings, 1);

  enterprise_util::SetUserAcceptedAccountManagement(browser()->profile(), true);

  // There should be no text because the policy fully disables badging.
  EXPECT_EQ(avatar_button->GetText(), std::u16string());
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       CustomBadgeDisabledbyPolicy) {
  browser()->profile()->GetPrefs()->SetString(
      prefs::kEnterpriseCustomLabelForProfile, "Custom Label");
  browser()->profile()->GetPrefs()->SetInteger(
      prefs::kEnterpriseProfileBadgeToolbarSettings, 1);

  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());

  enterprise_util::SetUserAcceptedAccountManagement(browser()->profile(), true);

  // There should be no text because the policy fully disables badging.
  EXPECT_EQ(avatar_button->GetText(), std::u16string());
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       CustomBadgeLengthLimited) {
  browser()->profile()->GetPrefs()->SetString(
      prefs::kEnterpriseCustomLabelForProfile,
      "Custom Label Can Be Max 16 Characters");

  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());

  enterprise_util::SetUserAcceptedAccountManagement(browser()->profile(), true);

  // The text should be tuncated to 16 characters followed by "...".
  EXPECT_EQ(avatar_button->GetText(), u"Custom Label Canâ€¦");
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       WorkNewBrowserShowsBadgeWithCustomLabel) {
  browser()->profile()->GetPrefs()->SetString(
      prefs::kEnterpriseCustomLabelForProfile, "Custom Label");
  enterprise_util::SetUserAcceptedAccountManagement(browser()->profile(), true);

  Browser* second_browser = CreateBrowser(browser()->profile());
  AvatarToolbarButton* second_browser_avatar_button =
      GetAvatarToolbarButton(second_browser);
  EXPECT_EQ(second_browser_avatar_button->GetText(), u"Custom Label");

  browser()->profile()->GetPrefs()->SetString(
      prefs::kEnterpriseCustomLabelForProfile, "Updated Label");
  EXPECT_EQ(second_browser_avatar_button->GetText(), u"Updated Label");
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       WorkNewBrowserShowsBadge) {
  std::u16string work_label = u"Work";
  enterprise_util::SetUserAcceptedAccountManagement(browser()->profile(), true);

  Browser* second_browser = CreateBrowser(browser()->profile());
  AvatarToolbarButton* second_browser_avatar_button =
      GetAvatarToolbarButton(second_browser);
  EXPECT_EQ(second_browser_avatar_button->GetText(), work_label);
}

// Sync Pause/Error has priority over WorkBadge.
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       WorkBadgeAndSyncPaused) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  ASSERT_TRUE(avatar_button->GetText().empty());

  std::u16string work_label = u"Work";
  enterprise_util::SetUserAcceptedAccountManagement(browser()->profile(), true);
  EXPECT_EQ(avatar_button->GetText(), work_label);

  EnableSyncWithImageAndClearGreeting(avatar_button, u"work@managed.com");
  SimulateSyncPaused();
  // Sync Paused has priority over the Work badge.
  ExpectSyncPaused(avatar_button);

  ClearSyncPaused();
  // Non transient mode should permanently show the work badge by default.
  // TODO(b/324018028): This test result might change with the ongoing changes.
  // At the end, the exact behavior could be set again. To review.
  EXPECT_EQ(avatar_button->GetText(), work_label);
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       DecliningManagementShouldRemoveWorkBadge) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  ASSERT_TRUE(avatar_button->GetText().empty());

  std::u16string work_label = u"Work";
  enterprise_util::SetUserAcceptedAccountManagement(browser()->profile(), true);
  EXPECT_EQ(avatar_button->GetText(), work_label);

  enterprise_util::SetUserAcceptedAccountManagement(browser()->profile(),
                                                    false);
  EXPECT_EQ(avatar_button->GetText(), std::u16string());
}

class AvatarToolbarButtonWithExplicitBrowserSigninBrowserTest
    : public AvatarToolbarButtonBrowserTest {
 private:
  base::test::ScopedFeatureList scoped_feature_list_{
      switches::kExplicitBrowserSigninUIOnDesktop};
};

// TODO(b/331746545): Check flaky test issue on windows.
#if BUILDFLAG(IS_WIN)
#define MAYBE_SigninPausedFromExternalErrorThenReauth \
  DISABLED_SigninPausedFromExternalErrorThenReauth
#else
#define MAYBE_SigninPausedFromExternalErrorThenReauth \
  SigninPausedFromExternalErrorThenReauth
#endif
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonWithExplicitBrowserSigninBrowserTest,
                       MAYBE_SigninPausedFromExternalErrorThenReauth) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  SigninWithImageAndClearGreeting(avatar, u"test@gmail.com");
  ASSERT_EQ(avatar->GetText(), std::u16string());

  // Browser opened before the error.
  Browser* opened_browser = CreateBrowser(browser()->profile());
  AvatarToolbarButton* opened_browser_avatar_button =
      GetAvatarToolbarButton(opened_browser);
  ASSERT_EQ(opened_browser_avatar_button->GetText(), std::u16string());

  SimulateSigninError(/*web_sign_out=*/false);
  EXPECT_EQ(avatar->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SIGNIN_PAUSED));
  EXPECT_EQ(opened_browser_avatar_button->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SIGNIN_PAUSED));

  // New browser opened after the error -- error should be shown directly.
  Browser* new_browser = CreateBrowser(browser()->profile());
  AvatarToolbarButton* new_browser_avatar_button =
      GetAvatarToolbarButton(new_browser);
  EXPECT_EQ(new_browser_avatar_button->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SIGNIN_PAUSED));

  ClearSigninError();
  EXPECT_EQ(avatar->GetText(), std::u16string());
  EXPECT_EQ(opened_browser_avatar_button->GetText(), std::u16string());
  EXPECT_EQ(new_browser_avatar_button->GetText(), std::u16string());
}

// TODO(b/331746545): Check flaky test issue on windows.
#if BUILDFLAG(IS_WIN)
#define MAYBE_SigninPausedFromWebSignout DISABLED_SigninPausedFromWebSignout
#else
#define MAYBE_SigninPausedFromWebSignout SigninPausedFromWebSignout
#endif
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonWithExplicitBrowserSigninBrowserTest,
                       MAYBE_SigninPausedFromWebSignout) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());

  SigninWithImageAndClearGreeting(avatar, u"test@gmail.com");
  ASSERT_EQ(avatar->GetText(), std::u16string());

  // Browser opened before the error.
  Browser* opened_browser = CreateBrowser(browser()->profile());
  AvatarToolbarButton* opened_browser_avatar_button =
      GetAvatarToolbarButton(opened_browser);
  ASSERT_EQ(opened_browser_avatar_button->GetText(), std::u16string());

  SimulateSigninError(/*web_sign_out=*/true);
  // Text does not appear directly after a web sign out, a timer is started.
  EXPECT_EQ(avatar->GetText(), std::u16string());
  EXPECT_EQ(opened_browser_avatar_button->GetText(), std::u16string());

  // New browser opened after the error and before timer ends -- error is not
  // shown directly.
  Browser* new_browser = CreateBrowser(browser()->profile());
  AvatarToolbarButton* new_browser_avatar_button =
      GetAvatarToolbarButton(new_browser);
  EXPECT_EQ(new_browser_avatar_button->GetText(), std::u16string());

  // Simulate all the timer ends.
  avatar->TriggerTimeoutForTesting(AvatarDelayType::kSigninPendingText);
  opened_browser_avatar_button->TriggerTimeoutForTesting(
      AvatarDelayType::kSigninPendingText);
  new_browser_avatar_button->TriggerTimeoutForTesting(
      AvatarDelayType::kSigninPendingText);

  EXPECT_EQ(avatar->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SIGNIN_PAUSED));
  EXPECT_EQ(opened_browser_avatar_button->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SIGNIN_PAUSED));
  EXPECT_EQ(new_browser_avatar_button->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SIGNIN_PAUSED));

  ClearSigninError();
  EXPECT_EQ(avatar->GetText(), std::u16string());
  EXPECT_EQ(opened_browser_avatar_button->GetText(), std::u16string());
  EXPECT_EQ(new_browser_avatar_button->GetText(), std::u16string());
}

// TODO(crbug.com/360106845): Fix flaky test and re-enable.
#if BUILDFLAG(IS_WIN)
#define MAYBE_SigninPausedFromWebSignoutThenRestartChrome \
  DISABLED_SigninPausedFromWebSignoutThenRestartChrome
#else
#define MAYBE_SigninPausedFromWebSignoutThenRestartChrome \
  SigninPausedFromWebSignoutThenRestartChrome
#endif
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonWithExplicitBrowserSigninBrowserTest,
                       MAYBE_SigninPausedFromWebSignoutThenRestartChrome) {
  // Needed because the current profile will be destroyed.
  ScopedKeepAlive keep_alive(KeepAliveOrigin::SESSION_RESTORE,
                             KeepAliveRestartOption::DISABLED);
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  SigninWithImageAndClearGreeting(avatar, u"test@gmail.com");

  SimulateSigninError(/*web_sign_out=*/true);
  ASSERT_EQ(avatar->GetText(), std::u16string());

  ProfileDestructionWaiter destruction_waiter(browser()->profile());
  // Closing the browser will destroy profile from the memory.
  CloseAllBrowsers();
  destruction_waiter.Wait();

  // Load the profile again to open a new browser and check the button state.
  Profile* loaded_profile = ProfileLoader().LoadFirstAndOnlyProfile();
  Browser* new_browser = CreateBrowser(loaded_profile);
  AvatarToolbarButton* new_avatar = GetAvatarToolbarButton(new_browser);
  // The error text is expected to be shown even if the error delay has not
  // reached yet.
  EXPECT_EQ(new_avatar->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SIGNIN_PAUSED));
}

// Regression test for https://crbug.com/348587566
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonWithExplicitBrowserSigninBrowserTest,
                       SigninPausedDelayEndedNoBrowser) {
  ASSERT_EQ(1u, chrome::GetTotalBrowserCount());
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());

  SigninWithImageAndClearGreeting(avatar, u"test@gmail.com", u"TestName");
  SimulateSigninError(/*web_sign_out=*/true);
  ASSERT_TRUE(avatar->GetText().empty());
  Profile* profile = browser()->profile();

  // Close the browser before the delay ends, but keep the profile and Chrome
  // alive by opening an incognito browser.
  CreateIncognitoBrowser(profile);
  CloseBrowserSynchronously(browser());

  // This simulates the delay expiry for the next browser. Instead of advancing
  // time, we set the expected delay to 0, making the elapsed time greater than
  // the delay for sure - simulating the delay expiry.
  SetZeroAvatarDelayForSigninPendingText();

  // Open a new browser, this should not crash.
  Browser* new_browser = CreateBrowser(profile);
  EXPECT_EQ(GetAvatarToolbarButton(new_browser)->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SIGNIN_PAUSED));
}

// TODO(b/331746545): Check flaky test issue on windows.
#if BUILDFLAG(IS_WIN)
#define MAYBE_SigninPausedThenSignout DISABLED_SigninPausedThenSignout
#else
#define MAYBE_SigninPausedThenSignout SigninPausedThenSignout
#endif
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonWithExplicitBrowserSigninBrowserTest,
                       MAYBE_SigninPausedThenSignout) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  SigninWithImageAndClearGreeting(avatar, u"test@gmail.com");
  ASSERT_EQ(avatar->GetText(), std::u16string());

  SimulateSigninError(/*web_sign_out=*/false);

  EXPECT_EQ(avatar->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SIGNIN_PAUSED));

  Signout();

  EXPECT_EQ(avatar->GetText(), std::u16string());
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonWithExplicitBrowserSigninBrowserTest,
                       AccessibilityLabels) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());

  const std::u16string profile_name(u"new_profile_name");
  profiles::UpdateProfileName(browser()->profile(), profile_name);

  const views::ViewAccessibility& accessibility =
      avatar->GetViewAccessibility();

  EXPECT_EQ(accessibility.GetCachedName(), profile_name);
  EXPECT_EQ(accessibility.GetCachedDescription(), std::u16string());

  const std::u16string account_name(u"Test Name");
  SigninWithImageAndClearGreeting(avatar, u"test@gmail.com", account_name);

  const std::u16string expected_profile_name_with_account =
      account_name + u" (" + profile_name + u")";
  EXPECT_EQ(accessibility.GetCachedName(), expected_profile_name_with_account);
  EXPECT_EQ(accessibility.GetCachedDescription(), std::u16string());

  // Explicit text with accessibility text
  const std::u16string explicit_text(u"explicit_text");
  const std::u16string explicit_accessibility_text(u"explicit_text_acc");
  base::ScopedClosureRunner clear_explicit_text_callback =
      avatar->ShowExplicitText(explicit_text, explicit_accessibility_text);

  EXPECT_EQ(accessibility.GetCachedName(), explicit_text);
  EXPECT_EQ(accessibility.GetCachedDescription(), explicit_accessibility_text);

  clear_explicit_text_callback.RunAndReset();

  EXPECT_EQ(accessibility.GetCachedName(), expected_profile_name_with_account);
  EXPECT_EQ(accessibility.GetCachedDescription(), std::u16string());

  // Explicit text without accessibility text
  base::ScopedClosureRunner clear_explicit_text_without_accessibility_callback =
      avatar->ShowExplicitText(explicit_text, std::nullopt);

  EXPECT_EQ(accessibility.GetCachedName(), explicit_text);
  EXPECT_EQ(accessibility.GetCachedDescription(),
            expected_profile_name_with_account);

  clear_explicit_text_without_accessibility_callback.RunAndReset();

  EXPECT_EQ(accessibility.GetCachedName(), expected_profile_name_with_account);
  EXPECT_EQ(accessibility.GetCachedDescription(), std::u16string());

  // This will trigger the immediate button content text change. Accessibility
  // text should adapt as well.
  SimulateSigninError(/*web_sign_out=*/false);

  EXPECT_EQ(accessibility.GetCachedName(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SIGNIN_PAUSED));
  EXPECT_EQ(accessibility.GetCachedDescription(),
            l10n_util::GetStringUTF16(
                IDS_AVATAR_BUTTON_SIGNIN_PENDING_ACCESSIBILITY_LABEL));

  ClearSigninError();

  EXPECT_EQ(accessibility.GetCachedName(), expected_profile_name_with_account);
  EXPECT_EQ(accessibility.GetCachedDescription(), std::u16string());

  // This will not trigger the immediate button content text change.
  // Accessibility text should adapt as well.
  SimulateSigninError(/*web_sign_out=*/true);

  EXPECT_EQ(accessibility.GetCachedName(),
            l10n_util::GetStringUTF16(
                IDS_AVATAR_BUTTON_SIGNIN_PENDING_ACCESSIBILITY_LABEL));
  EXPECT_EQ(accessibility.GetCachedDescription(),
            expected_profile_name_with_account);

  ClearSigninError();

  EXPECT_EQ(accessibility.GetCachedName(), expected_profile_name_with_account);
  EXPECT_EQ(accessibility.GetCachedDescription(), std::u16string());

  Signout();

  EXPECT_EQ(accessibility.GetCachedName(), profile_name);
  EXPECT_EQ(accessibility.GetCachedDescription(), std::u16string());
}

class AvatarToolbarButtonWithImprovedSigninUIBrowserTest
    : public AvatarToolbarButtonWithExplicitBrowserSigninBrowserTest {
 private:
  base::test::ScopedFeatureList scoped_feature_list_{
      switches::kImprovedSigninUIOnDesktop};
};

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonWithImprovedSigninUIBrowserTest,
                       PassphraseErrorSignedIn) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  SigninWithImageAndClearGreeting(avatar, u"test@gmail.com");
  ASSERT_EQ(avatar->GetText(), std::u16string());
  SimulatePassphraseError();
  EXPECT_EQ(avatar->GetText(), l10n_util::GetStringUTF16(
                                   IDS_SYNC_ERROR_USER_MENU_PASSPHRASE_BUTTON));
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonWithImprovedSigninUIBrowserTest,
                       PassphraseErrorSyncing) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  EnableSyncWithImageAndClearGreeting(avatar, u"test@gmail.com");
  ASSERT_EQ(avatar->GetText(), std::u16string());
  SimulatePassphraseError();
  EXPECT_EQ(avatar->GetText(), l10n_util::GetStringUTF16(
                                   IDS_SYNC_ERROR_USER_MENU_PASSPHRASE_BUTTON));
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonWithImprovedSigninUIBrowserTest,
                       UpgradeClientError) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  EnableSyncWithImageAndClearGreeting(avatar, u"test@gmail.com");
  ASSERT_EQ(avatar->GetText(), std::u16string());
  SimulateUpgradeClientError();
  EXPECT_EQ(avatar->GetText(),
            l10n_util::GetStringUTF16(IDS_SYNC_ERROR_USER_MENU_UPGRADE_BUTTON));
}

#endif  // BUILDFLAG(ENABLE_DICE_SUPPORT)
