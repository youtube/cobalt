// Copyright 2018 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module blink.mojom;

import "mojo/public/mojom/base/file_path.mojom";
import "mojo/public/mojom/base/read_only_file.mojom";
import "mojo/public/mojom/base/shared_memory.mojom";
import "mojo/public/mojom/base/string16.mojom";

struct DWriteStringPair {
  mojo_base.mojom.String16 first;
  mojo_base.mojom.String16 second;
};

struct DWriteFontStyle {
  uint16 font_weight;
  uint8 font_slant;
  uint8 font_stretch;
};

struct FallbackFamilyAndStyle {
  string fallback_family_name;
  uint16 weight;
  uint8 width;
  uint8 slant;
};

struct MapCharactersResult {
  uint32 family_index;
  mojo_base.mojom.String16 family_name;
  uint32 mapped_length;
  float scale;
  DWriteFontStyle font_style;
};

interface DWriteFontProxy {
  // Locates the index of the specified font family within the system
  // collection.
  [Sync]
  FindFamily(mojo_base.mojom.String16 family_name) => (uint32 out_index);

  // Returns the number of font families in the system collection.
  [Sync]
  GetFamilyCount() => (uint32 out_count);

  // Returns the list of locale and family name pairs for the font family at the
  // specified index.
  [Sync]
  GetFamilyNames(uint32 family_index)
      => (array<DWriteStringPair> out_family_names);

  // Returns the list of font file handles in the system font directory and
  // other locations that contain font data for the font family at the specified
  // index.
  [Sync]
  GetFontFileHandles(uint32 family_index)
     => (array<mojo_base.mojom.ReadOnlyFile> file_handles);

  // Matches a unique PostScript or full font name against the installed fonts
  // using DirectWrite API. Returns a pre-opened file handle and ttc_index from
  // which the unique font can be instantiated. Returns null handle and 0 ttc
  // index if no font is found.
  [Sync]
  MatchUniqueFont(mojo_base.mojom.String16 font_unique_name)
      => (mojo_base.mojom.ReadOnlyFile? file_handle, uint32 ttc_index);

  // Locates a font family that is able to render the specified text using the
  // specified style. If successful, the family_index and family_name will
  // indicate which family in the system font collection can render the
  // requested text and the mapped_length will indicate how many characters can
  // be rendered. If no font exists that can render the text, family_index will
  // be UINT32_MAX and mapped_length will indicate how many characters cannot be
  // rendered by any installed font.
  [Sync]
  MapCharacters(mojo_base.mojom.String16 text,
                DWriteFontStyle font_style,
                mojo_base.mojom.String16 locale_name,
                uint32 reading_direction,
                mojo_base.mojom.String16 base_family_name)
      => (MapCharactersResult out);

  // For a given base family name, bcp47 language tag, and codepoint to look up,
  // return a font family name that is available on the system to display the
  // given codepoint. This internally calls Skia's
  // SkFontMgr_DirectWrite::matchFamilyStyleCharacter which executes
  // IDWriteTextLayout based fallback code, which cannot be run in the renderer
  // due triggering loading the DWrite system font collection.
  // Use only on Windows 8.0 and earlier - otherwise better fallback API is
  // available through using a proxies IDWriteFontFallback.
  [Sync]
  FallbackFamilyAndStyleForCodepoint(string base_family_name,
                                     string bcp47_language_tag,
                                     uint32 codepoint)
      => (FallbackFamilyAndStyle fallback_result);
};
