name: 'Gemini Commit Message Generator'

# This workflow is triggered when a new comment is created on a Pull Request.
on:
  issue_comment:
    types: [created]

# This block defines the job that will run.
jobs:
  generate_commit_message:
    # This condition ensures the workflow only runs if the comment is on a PR
    # and the comment body is exactly '/generate-commit-message'.
    if: github.event.issue.pull_request && github.event.comment.body == '/generate-commit-message'

    # The workflow will run on the latest version of Ubuntu.
    runs-on: ubuntu-latest

    # We need to grant the workflow permission to write comments on pull requests.
    permissions:
      pull-requests: write
      contents: read

    steps:
      # Step 0: Check if the PR targets the main branch.
      - name: 'Check PR Base Branch'
        id: check_branch
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          base_branch=$(gh pr view ${{ github.event.issue.number }} --json baseRefName -q .baseRefName)
          if [[ "$base_branch" != "main" ]]; then
            echo "PR does not target main branch. Skipping."
            echo "run_workflow=false" >> $GITHUB_OUTPUT
          else
            echo "run_workflow=true" >> $GITHUB_OUTPUT
          fi

      # Step 1: Get the code changes (the "diff") from the pull request.
      - name: 'Get PR Diff'
        if: steps.check_branch.outputs.run_workflow == 'true'
        id: diff
        run: |
          set -eux
          # Fetch the diff content directly from the PR's diff URL.
          diff_content=$(curl -fsSL -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -H "Accept: application/vnd.github.v3.diff" ${{ github.event.issue.pull_request.url }})

          # The following lines save the diff content into a GitHub Actions output variable.
          echo "diff_content<<EOF" >> $GITHUB_OUTPUT
          echo "$diff_content" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Step 2: Call the Gemini API directly with a detailed prompt.
      # This approach avoids third-party actions and gives us full control over the request.
      - name: 'Generate Commit Message with Gemini'
        if: steps.check_branch.outputs.run_workflow == 'true'
        id: gemini
        env:
          # Store the multiline prompt in an environment variable to handle special characters safely.
          PROMPT: |
            Act as an expert software engineer specializing in the Cobalt codebase, which is a fork of Chromium. Your task is to generate a professional and informative Git commit message based on the provided pull request details. The final output should be only the commit message itself, without any extra conversational text or markdown formatting. Do not use backticks (`) in your response.

            You must strictly adhere to the following rules:

            **Commit Message Structure:**
            1.  **Tag Prefix:** The subject line MUST be prefixed with a tag followed by a colon (e.g., "media: Add support for AV1"). Prefer component tags over type tags.
            2.  **Subject:** Capitalize the subject line, use the imperative mood, limit it to 50 characters, and do not end it with a period.
            3.  **Body:** Separate the subject from the body with a blank line. The body should explain the 'what' and 'why' of the change, not the 'how', and wrap at 72 characters.

            **Tag Selection (Prefix the subject line with one of these):**
            * **Component Tags (Preferred):**
                * `android`: Android-specific changes.
                * `tvos`: tvOS-specific changes.
                * `build`: Changes to the build system (GN files, build scripts).
                * `cobalt`: Changes specific to the Cobalt browser logic.
                * `evergreen`: For Evergreen-specific changes.
                * `linux`: Linux-specific changes.
                * `media`: Changes related to the media pipeline (player, demuxer, etc.).
                * `net`: For networking changes (e.g., QUIC, sockets).
                * `posix`: POSIX-related changes.
                * `starboard`: Changes to the Starboard abstraction layer.
            * **Type Tags (Use if no component tag applies):**
                * `ci`: Changes to CI/CD workflows.
                * `cleanup`: Code cleanup (e.g., removing unused code, style fixes).
                * `docs`: Documentation updates.
                * `feat`: A new feature.
                * `fix`: A bug fix.
                * `refactor`: Code refactoring without changing functionality.
                * `revert`: Reverting a previous commit.
                * `test`: For changes to tests (e.g., nplb, unit tests).

            Given your expertise with Cobalt/Chromium, infer the context of the changes to select the most relevant tag.

            **Analyze the following pull request information and generate the commit message:**

            **Pull Request URL:** ${{ github.event.issue.html_url }}
            **Pull Request Title:** ${{ github.event.issue.title }}
            **Original PR Description:**
            ${{ github.event.issue.body }}

            **Code Diff to Analyze:**
            ${{ steps.diff.outputs.diff_content }}
        run: |
          set -eux
          # Use jq to safely construct the JSON payload, reading the prompt from the environment variable.
          json_payload=$(jq -n --arg prompt "$PROMPT" '{ "contents": [ { "parts": [ { "text": $prompt } ] } ] }')

          # Make the API call to the Gemini model using curl.
          api_response=$(curl -s -X POST \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${{ secrets.GEMINI_ACTIONS_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d "$json_payload")

          # Extract only the text content from the API's JSON response using jq.
          # The 'jq -r' command outputs the raw string without quotes.
          # The fallback message provides clearer error handling if the response is unexpected.
          gemini_text_response=$(echo "$api_response" | jq -r '.candidates[0].content.parts[0].text // "Error: Could not parse a valid response from the Gemini API. Please check the API response logs in the workflow run."')

          # Set the final text as an output variable for the next step to use.
          echo "response<<EOF" >> $GITHUB_OUTPUT
          echo "$gemini_text_response" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Step 3: Post Gemini's generated commit message back to the PR.
      # This step now uses the direct response from the Gemini step.
      - name: 'Post Commit Message as Comment'
        if: steps.check_branch.outputs.run_workflow == 'true'
        uses: actions/github-script@v7
        env:
          COMMENT_BODY: |
            ### ðŸ¤– Gemini Suggested Commit Message

            ---

            ```
            ${{ steps.gemini.outputs.response }}
            ```
        with:
          script: |
            const body = process.env.COMMENT_BODY;
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });
