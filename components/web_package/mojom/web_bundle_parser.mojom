// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module web_package.mojom;

import "mojo/public/mojom/base/read_only_file.mojom";
import "url/mojom/url.mojom";

// Factory interface to create WebBundleParser for the passed |file|
// or |data_source| that provides application/webbundle data.
interface WebBundleParserFactory {
  // Constructs a parser for the passed |file|.
  GetParserForFile(pending_receiver<WebBundleParser> receiver,
                   url.mojom.Url? base_url,
                   mojo_base.mojom.ReadOnlyFile file);

  // Constructs a parser for the passed |data_source|.
  GetParserForDataSource(pending_receiver<WebBundleParser> receiver,
                         url.mojom.Url? base_url,
                         pending_remote<BundleDataSource> data_source);
};

// Parser interface to obtain metadata and multiple responses from the bound
// application/webbundle data provided on the construction at the factory above.
interface WebBundleParser {
  // Parses bundle's integrity block, if it exists.
  ParseIntegrityBlock() => (BundleIntegrityBlock? Result,
                            BundleIntegrityBlockParseError? error);

  // Parses bundle's metadata. If `offset` is >= 0, parsing will begin at the
  // indicated offset, and the `length` field of the web bundle will be ignored.
  // If `offset` is -1, and the bundle is read in a random-access context, then
  // the `length` field of the bundle will be used to determine the offset.
  ParseMetadata(int64 offset)
      => (BundleMetadata? Result, BundleMetadataParseError? error);

  // Parses a response from the range
  // |[response_offset, response_offset + response_length)|.
  ParseResponse(uint64 response_offset,
                uint64 response_length)
      => (BundleResponse? Result, BundleResponseParseError? error);
};

// Data source that provides application/webbundle data to the parser.
interface BundleDataSource {
  // Reads up to |length| bytes starting with |offset|. Returns a non-null
  // buffer shorter than |length| iff the end of the stream is reached.
  Read(uint64 offset, uint64 length) => (array<uint8>? buffer);

  // Returns the length of the stream if it is known, or a negative value on
  // error.
  Length() => (int64 length);

  // Checks whether the stream is backed by a random-access context.
  IsRandomAccessContext() => (bool is_random_access);
};

enum BundleParseErrorType {
  kParserInternalError,
  kFormatError,
  kVersionError,
};

struct BundleIntegrityBlockParseError {
  BundleParseErrorType type;
  string message;
};

struct BundleMetadataParseError {
  BundleParseErrorType type;
  string message;
};

struct BundleResponseParseError {
  BundleParseErrorType type;
  string message;
};

struct BundleIntegrityBlock {
  // If size is 0, then no integrity block was found.
  uint64 size;
  array<BundleIntegrityBlockSignatureStackEntry> signature_stack;
};

// Mapped to `web_package::Ed25519PublicKey`
struct Ed25519PublicKey {
  array<uint8, 32> bytes;
};

// Mapped to `web_package::Ed25519Signature`
struct Ed25519Signature {
  array<uint8, 64> bytes;
};

struct BundleIntegrityBlockSignatureStackEntry {
  // The CBOR of this signature stack entry.
  // This is needed for verification of more than one signature later, because
  // to verify the n+1th signature, the CBOR of the signature stack entries of
  // all n previous signatures is needed (crbug.com/1366303).
  array<uint8> complete_entry_cbor;
  // The CBOR of the attributes of this signature stack entry.
  array<uint8> attributes_cbor;
  // The public key of this signature stack entry.
  Ed25519PublicKey public_key;
  // The signature of this signature stack entry.
  Ed25519Signature signature;
};

// Bundle's metadata, i.e. information in sections other than "responses".
struct BundleMetadata {
  BundleFormatVersion version;
  url.mojom.Url? primary_url;
  map<url.mojom.Url, BundleResponseLocation> requests;
};

// WebBundle format version. Corresponds to a specific draft of
// https://wpack-wg.github.io/bundled-responses/draft-ietf-wpack-bundled-responses.html
enum BundleFormatVersion {
  kB1,  // Corresponds to draft-00
  kB2,  // Corresponds to draft-02
};

// Offset (within the webbundle file) and length of a response.
struct BundleResponseLocation {
  uint64 offset;
  uint64 length;
};

// Contains response headers and payload location.
struct BundleResponse {
  int32 response_code;
  map<string, string> response_headers;

  // Payload offset and length within the webbundle file.
  uint64 payload_offset;
  uint64 payload_length;
};
