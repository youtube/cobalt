// Copyright 2022 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/ui/color/new_tab_page_color_mixer.h"

#include "base/logging.h"
#include "chrome/browser/ui/color/chrome_color_id.h"
#include "chrome/browser/ui/color/chrome_color_provider_utils.h"
#include "chrome/common/themes/autogenerated_theme_util.h"
#include "components/search/ntp_features.h"
#include "third_party/skia/include/core/SkColor.h"
#include "ui/base/ui_base_features.h"
#include "ui/color/color_id.h"
#include "ui/color/color_mixer.h"
#include "ui/color/color_provider.h"
#include "ui/color/color_provider_utils.h"
#include "ui/color/color_recipe.h"
#include "ui/color/color_transform.h"
#include "ui/gfx/color_palette.h"
#include "ui/gfx/color_utils.h"

namespace {

constexpr float kNtpElementLuminosityChangeForLightBackgroundParam = 0.1f;
constexpr float kNtpElementLuminosityChangeForDarkBackgroundParam = 0.2f;

ui::ColorTransform GetContrastingColorTransform(
    ui::ColorTransform input_transform,
    absl::optional<float> luminosity_change = absl::nullopt) {
  const auto generator = [](ui::ColorTransform input_transform,
                            const absl::optional<float> luminosity_change,
                            SkColor input_color, const ui::ColorMixer& mixer) {
    const SkColor color = input_transform.Run(input_color, mixer);
    const float default_luminosity_change =
        color_utils::IsDark(color)
            ? kNtpElementLuminosityChangeForDarkBackgroundParam
            : kNtpElementLuminosityChangeForLightBackgroundParam;
    return GetContrastingColor(
        color, luminosity_change.value_or(default_luminosity_change));
  };

  return base::BindRepeating(generator, std::move(input_transform),
                             std::move(luminosity_change));
}

ui::ColorTransform IncreaseLightness(ui::ColorTransform input_transform,
                                     double percent) {
  const auto generator = [](ui::ColorTransform input_transform, double percent,
                            SkColor input_color, const ui::ColorMixer& mixer) {
    const SkColor color = input_transform.Run(input_color, mixer);
    color_utils::HSL result;
    color_utils::SkColorToHSL(color, &result);
    result.l += (1 - result.l) * percent;
    const SkColor result_color =
        color_utils::HSLToSkColor(result, SkColorGetA(color));
    DVLOG(2) << "ColorTransform IncreaseLightness:"
             << " Percent: " << percent
             << " Transform Color: " << ui::SkColorName(color)
             << " Result Color: " << ui::SkColorName(result_color);
    return result_color;
  };
  return base::BindRepeating(generator, std::move(input_transform), percent);
}

ui::ColorTransform SelectBasedOnNtpBackground(
    ui::ColorTransform output_transform_for_white_input,
    ui::ColorTransform output_transform_for_black_input,
    ui::ColorTransform default_output_transform_for_input) {
  const auto generator =
      [](ui::ColorTransform output_transform_for_white_input,
         ui::ColorTransform output_transform_for_black_input,
         ui::ColorTransform default_output_transform_for_input,
         SkColor input_color, const ui::ColorMixer& mixer) {
        const ui::ColorTransform input_transform = {kColorNewTabPageBackground};
        const SkColor color = input_transform.Run(input_color, mixer);
        const auto& output_transform =
            (color == SK_ColorWHITE)
                ? output_transform_for_white_input
                : ((color == SK_ColorBLACK)
                       ? output_transform_for_black_input
                       : default_output_transform_for_input);
        const SkColor result_color = output_transform.Run(input_color, mixer);
        DVLOG(2) << "ColorTransform SelectBasedOnNtpBackground:"
                 << " Input Color: " << ui::SkColorName(input_color)
                 << " Input Transform: " << ui::SkColorName(color)
                 << " IsWhite: " << (color == SK_ColorWHITE ? "true" : "false")
                 << " IsBlack: " << (color == SK_ColorBLACK ? "true" : "false")
                 << " Result Color: " << ui::SkColorName(result_color);
        return result_color;
      };
  return base::BindRepeating(generator,
                             std::move(output_transform_for_white_input),
                             std::move(output_transform_for_black_input),
                             std::move(default_output_transform_for_input));
}

ui::ColorTransform SelectBasedOnWhiteInput(
    const ui::ColorTransform input_transform,
    ui::ColorTransform output_transform_for_white_input,
    ui::ColorTransform output_transform_for_non_white_input) {
  const auto generator =
      [](ui::ColorTransform input_transform,
         ui::ColorTransform output_transform_for_white_input,
         ui::ColorTransform output_transform_for_non_white_input,
         SkColor input_color, const ui::ColorMixer& mixer) {
        const SkColor color = input_transform.Run(input_color, mixer);
        const auto& output_transform =
            (color == SK_ColorWHITE) ? output_transform_for_white_input
                                     : output_transform_for_non_white_input;
        const SkColor result_color = output_transform.Run(input_color, mixer);
        DVLOG(2) << "ColorTransform SelectBasedOnWhiteInput:"
                 << " Input Color: " << ui::SkColorName(input_color)
                 << " Input Transform: " << ui::SkColorName(color)
                 << " IsWhite: " << (color == SK_ColorWHITE ? "true" : "false")
                 << " Result Color: " << ui::SkColorName(result_color);
        return result_color;
      };
  return base::BindRepeating(generator, std::move(input_transform),
                             std::move(output_transform_for_white_input),
                             std::move(output_transform_for_non_white_input));
}

ui::ColorTransform SelectBasedOnWhiteNtpBackground(
    ui::ColorTransform output_transform_for_white_input,
    ui::ColorTransform output_transform_for_non_white_input) {
  return SelectBasedOnWhiteInput({kColorNewTabPageBackground},
                                 output_transform_for_white_input,
                                 output_transform_for_non_white_input);
}

// Comprehensive theming colors follow two different color conventions depending
// on the background color. On white backgrounds, we theme a few select
// elements with an accent color, while, on non-white background colors we
// compute appropriate contrasting background and foreground element colors and
// use these to style elements.
void AddGeneratedThemeComprehensiveColors(ui::ColorMixer& mixer) {
  ui::ColorTransform element_background_color =
      base::FeatureList::IsEnabled(ntp_features::kNtpModulesRedesigned)
          ? SelectBasedOnNtpBackground(
                kColorNewTabPageBackground, {gfx::kGoogleGrey900},
                GetContrastingColorTransform(kColorNewTabPageBackground))
          : SelectBasedOnWhiteNtpBackground(
                kColorNewTabPageBackground,
                GetContrastingColorTransform(kColorNewTabPageBackground));

  ui::ColorTransform primary_foreground_color =
      ui::GetColorWithMaxContrast(element_background_color);
  ui::ColorTransform themed_foreground_color = SelectBasedOnWhiteNtpBackground(
      gfx::kGoogleBlue600,
      ui::PickGoogleColor(element_background_color, element_background_color,
                          color_utils::kMinimumReadableContrastRatio));
  const ui::ColorTransform select_topmost_element_background_color =
      themed_foreground_color;
  const ui::ColorTransform select_topmost_element_foreground_color =
      GetColorWithMaxContrast(select_topmost_element_background_color);

  mixer[kColorNewTabPageActionButtonBackground] =
      select_topmost_element_background_color;
  mixer[kColorNewTabPageActionButtonForeground] =
      select_topmost_element_foreground_color;
  mixer[kColorNewTabPageBorder] = SelectBasedOnWhiteNtpBackground(
      gfx::kGoogleGrey300, element_background_color);
  mixer[kColorNewTabPageChipBackground] = element_background_color;
  mixer[kColorNewTabPageButtonBackground] = element_background_color;
  mixer[kColorNewTabPageButtonBackgroundHovered] = {
      kColorNewTabPageControlBackgroundHovered};
  mixer[kColorNewTabPageButtonForeground] = themed_foreground_color;
  mixer[kColorNewTabPageCartModuleDiscountChipBackground] =
      SelectBasedOnDarkInput(element_background_color, gfx::kGoogleGrey800,
                             gfx::kGoogleGreen050);
  mixer[kColorNewTabPageCartModuleDiscountChipForeground] =
      SelectBasedOnDarkInput(element_background_color, gfx::kGoogleGreen300,
                             gfx::kGoogleGreen700);
  mixer[kColorNewTabPageControlBackgroundHovered] = SelectBasedOnDarkInput(
      element_background_color,
      ui::SetAlpha(SK_ColorWHITE,
                   /* 10% opacity */ 0.1 * SK_AlphaOPAQUE),
      ui::SetAlpha(gfx::kGoogleGrey900,
                   /* 10% opacity */ 0.1 * SK_AlphaOPAQUE));
  mixer[kColorNewTabPageFocusRing] = ui::PickGoogleColorTwoBackgrounds(
      ui::kColorFocusableBorderFocused, element_background_color,
      kColorNewTabPageBackground, color_utils::kMinimumVisibleContrastRatio);

  mixer[kColorNewTabPageLogo] = element_background_color;
  mixer[kColorNewTabPageLink] = themed_foreground_color;
  mixer[kColorNewTabPageFirstRunBackground] = {kColorNewTabPageBackground};

  mixer[kColorNewTabPageChipBackground] =
      select_topmost_element_background_color;
  mixer[kColorNewTabPageChipForeground] =
      select_topmost_element_foreground_color;

  if (base::FeatureList::IsEnabled(ntp_features::kNtpModulesRedesigned)) {
    mixer[kColorNewTabPageModuleBackground] =
        SelectBasedOnWhiteInput({kColorNewTabPageBackground},
                                gfx::kGoogleGrey100, element_background_color);
  } else {
    mixer[kColorNewTabPageModuleBackground] = element_background_color;
  }
  mixer[kColorNewTabPageModuleItemBackground] = {kColorNewTabPageBackground};

  mixer[kColorNewTabPageHistoryClustersModuleItemBackground] =
      SelectBasedOnWhiteInput(element_background_color, gfx::kGoogleGrey100,
                              kColorNewTabPageBackground);

  mixer[kColorNewTabPageModuleControlBorder] = SelectBasedOnWhiteNtpBackground(
      gfx::kGoogleGrey300, kColorNewTabPageBackground);
  mixer[kColorNewTabPageModuleElementDivider] = {
      kColorNewTabPageModuleBackground};
  mixer[kColorNewTabPageMostVisitedForeground] = SelectBasedOnDarkInput(
      element_background_color, SK_ColorWHITE, gfx::kGoogleGrey800);
  mixer[kColorNewTabPageMostVisitedTileBackground] =
      SelectBasedOnWhiteNtpBackground(gfx::kGoogleGrey100,
                                      element_background_color);
  mixer[kColorNewTabPageMostVisitedTileBackgroundThemed] = {
      element_background_color};
  mixer[kColorNewTabPageOnThemeForeground] = themed_foreground_color;
  mixer[kColorNewTabPagePrimaryForeground] = primary_foreground_color;
  mixer[kColorNewTabPagePromoBackground] = element_background_color;
  mixer[kColorNewTabPagePromoImageBackground] = SelectBasedOnDarkInput(
      element_background_color, gfx::kGoogleGrey200, SK_ColorWHITE);
  mixer[kColorNewTabPageSecondaryForeground] = SelectBasedOnDarkInput(
      element_background_color,
      ui::PickGoogleColor(gfx::kGoogleGrey700, element_background_color,
                          color_utils::kMinimumReadableContrastRatio),
      ui::PickGoogleColor(gfx::kGoogleGrey500, element_background_color,
                          color_utils::kMinimumReadableContrastRatio));

  mixer[kColorNewTabPageTagBackground] =
      ui::SetAlpha(element_background_color,
                   /* 90% opacity */ 0.9 * SK_AlphaOPAQUE);
  mixer[kColorNewTabPageText] = SelectBasedOnDarkInput(
      element_background_color, gfx::kGoogleGrey200, gfx::kGoogleGrey900);

  if (base::FeatureList::IsEnabled(
          ntp_features::kNtpComprehensiveThemeRealbox)) {
    ui::ColorTransform background_color =
        ui::GetColorWithMaxContrast(primary_foreground_color);
    mixer[kColorRealboxBackground] = element_background_color;
    mixer[kColorRealboxBackgroundHovered] = {
        kColorToolbarBackgroundSubtleEmphasisHovered};
    mixer[kColorRealboxForeground] = primary_foreground_color;
    const ui::ColorTransform secondary_foreground_color =
        SelectBasedOnWhiteNtpBackground(gfx::kGoogleGrey700,
                                        primary_foreground_color);
    mixer[kColorRealboxPlaceholder] = secondary_foreground_color;
  }
}

// Dialog colors currently track the native theme and not the browser theme.
void AddNewTabPageDialogColors(ui::ColorMixer& mixer, bool dark_mode) {
  // TODO(crbug.com/1376226): Colors defined below should come from core color
  // mixer definitions to be inline with how other browser surfaces look. For
  // now, until 'Customize Chrome' UI is refined, we rely on colors that match
  // other WebUI surfaces.
  const SkColor accent_color =
      dark_mode ? gfx::kGoogleBlue300 : gfx::kGoogleBlue600;
  const SkColor background_inverse =
      dark_mode ? gfx::kGoogleGrey200 : gfx::kGoogleGrey900;
  const SkColor border_color =
      dark_mode ? gfx::kGoogleGrey700 : gfx::kGoogleGrey300;

  mixer[kColorNewTabPageActionButtonBorder] = {border_color};
  mixer[kColorNewTabPageActionButtonBorderHovered] = {
      dark_mode ? gfx::kGoogleGrey700 : gfx::kGoogleBlue100};
  mixer[kColorNewTabPageControlBackgroundSelected] =
      ui::SetAlpha(accent_color,
                   /* 24% opacity */ 0.24 * SK_AlphaOPAQUE);
  mixer[kColorNewTabPageDialogBackgroundActive] =
      ui::SetAlpha(background_inverse,
                   /* 16% opacity */ 0.16 * SK_AlphaOPAQUE);
  mixer[kColorNewTabPageDialogBackground] = {
      kColorNewTabPageBackgroundOverride};
  mixer[kColorNewTabPageDialogBorder] = {border_color};
  mixer[kColorNewTabPageDialogBorderSelected] = {accent_color};
  mixer[kColorNewTabPageDialogControlBackgroundHovered] =
      ui::SetAlpha(background_inverse,
                   /* 10% opacity */ 0.1 * SK_AlphaOPAQUE);
  mixer[kColorNewTabPageDialogForeground] = {dark_mode ? gfx::kGoogleGrey200
                                                       : gfx::kGoogleGrey900};
  mixer[kColorNewTabPageDialogSecondaryForeground] = {
      dark_mode ? gfx::kGoogleGrey500 : gfx::kGoogleGrey700};
  mixer[kColorNewTabPageSelectedBackground] =
      ui::SetAlpha(dark_mode ? gfx::kGoogleBlue300 : gfx::kGoogleBlue700,
                   /* 16% opacity */ 0.16 * SK_AlphaOPAQUE);
  mixer[kColorNewTabPageSelectedForeground] = {dark_mode ? gfx::kGoogleBlue300
                                                         : gfx::kGoogleBlue700};
}

}  // namespace

void AddNewTabPageColorMixer(ui::ColorProvider* provider,
                             const ui::ColorProviderKey& key) {
  using ThemeType = ui::ColorProviderKey::ThemeInitializerSupplier::ThemeType;
  const bool dark_mode =
      key.color_mode == ui::ColorProviderKey::ColorMode::kDark;

  // Non-native surfaces in GM3 rely on a prominent color that may or may not
  // match the accent color.
  const SkColor prominent_color =
      dark_mode ? gfx::kGoogleBlue300 : gfx::kGoogleBlue600;

  ui::ColorMixer& mixer = provider->AddMixer();
  mixer[kColorNewTabPageActionButtonBackground] = {prominent_color};
  mixer[kColorNewTabPageActionButtonForeground] =
      ui::GetColorWithMaxContrast(kColorNewTabPageActionButtonBackground);
  mixer[kColorNewTabPageBackground] = {kColorToolbar};
  mixer[kColorNewTabPageHeader] = {SkColorSetRGB(0x96, 0x96, 0x96)};
  mixer[kColorNewTabPageLogoUnthemedDark] = {gfx::kGoogleGrey700};
  mixer[kColorNewTabPageLogoUnthemedLight] = {SkColorSetRGB(0xEE, 0xEE, 0xEE)};

  // See GM2 spec (go/google-material) for shadow color and elevation details.
  ui::ColorTransform menu_shadow_color = ui::SelectBasedOnDarkInput(
      kColorNewTabPageBackground, SK_ColorBLACK, gfx::kGoogleGrey800);
  mixer[kColorNewTabPageMenuInnerShadow] =
      ui::SetAlpha(menu_shadow_color, /* 30% opacity */ 0.3 * SK_AlphaOPAQUE);
  mixer[kColorNewTabPageMenuOuterShadow] =
      ui::SetAlpha(menu_shadow_color, /* 15% opacity */ 0.15 * SK_AlphaOPAQUE);

  if (key.custom_theme) {
    mixer[kColorNewTabPageMostVisitedTileBackground] =
        SelectBasedOnWhiteNtpBackground(
            kColorNewTabPageMostVisitedTileBackgroundUnthemed,
            GetContrastingColorTransform(kColorNewTabPageBackground, 0.2f));
  } else if (dark_mode) {
    mixer[kColorNewTabPageMostVisitedTileBackground] = {gfx::kGoogleGrey900};
  } else {
    mixer[kColorNewTabPageMostVisitedTileBackground] = {
        kColorNewTabPageMostVisitedTileBackgroundUnthemed};
  }

  mixer[kColorNewTabPageAddShortcutBackground] = {
      kColorNewTabPageMostVisitedTileBackground};
  mixer[kColorNewTabPageAddShortcutForeground] =
      ui::SelectBasedOnDarkInput(kColorNewTabPageAddShortcutBackground,
                                 SK_ColorWHITE, gfx::kGoogleGrey900);

  mixer[kColorNewTabPageMostVisitedTileBackgroundUnthemed] = {
      gfx::kGoogleGrey100};
  mixer[kColorNewTabPageSectionBorder] =
      ui::SetAlpha(kColorNewTabPageHeader, 0x50);
  mixer[kColorNewTabPageTextUnthemed] = {gfx::kGoogleGrey050};
  mixer[kColorNewTabPageTextLight] =
      IncreaseLightness(kColorNewTabPageText, 0.40);

  mixer[kColorRealboxBackground] = {SK_ColorWHITE};
  mixer[kColorRealboxBackgroundHovered] = {SK_ColorWHITE};
  mixer[kColorRealboxBorder] = {
      key.contrast_mode == ui::ColorProviderKey::ContrastMode::kHigh
          ? kColorLocationBarBorder
          : gfx::kGoogleGrey300};
  mixer[kColorRealboxForeground] = {SK_ColorBLACK};
  mixer[kColorRealboxPlaceholder] = {gfx::kGoogleGrey700};
  mixer[kColorRealboxResultsBackground] = {SK_ColorWHITE};
  mixer[kColorRealboxResultsBackgroundHovered] =
      ui::SetAlpha(gfx::kGoogleGrey900,
                   /* 10% opacity */ 0.1 * SK_AlphaOPAQUE);
  mixer[kColorRealboxResultsControlBackgroundHovered] =
      ui::SetAlpha(gfx::kGoogleGrey900, /* 10% opacity */ 0.1 * SK_AlphaOPAQUE);

  mixer[kColorRealboxResultsDimSelected] = {gfx::kGoogleGrey700};
  mixer[kColorRealboxResultsForeground] = {SK_ColorBLACK};
  mixer[kColorRealboxResultsForegroundDimmed] = {gfx::kGoogleGrey700};
  mixer[kColorRealboxResultsIconSelected] = {gfx::kGoogleGrey700};
  mixer[kColorRealboxResultsUrl] = {gfx::kGoogleBlue700};
  mixer[kColorRealboxResultsUrlSelected] = {gfx::kGoogleBlue700};
  mixer[kColorRealboxSearchIconBackground] = {gfx::kGoogleGrey700};
  mixer[kColorRealboxResultsIcon] = {gfx::kGoogleGrey700};
  mixer[kColorRealboxResultsIconFocusedOutline] = {gfx::kGoogleBlue600};
  mixer[kColorRealboxShadow] =
      ui::SetAlpha(gfx::kGoogleGrey900,
                   (dark_mode ? /* % opacity */ 0.32 : 0.28) * SK_AlphaOPAQUE);

  if (base::FeatureList::IsEnabled(
          ntp_features::kNtpComprehensiveThemeRealbox)) {
    if (dark_mode) {
      mixer[kColorRealboxBackground] = {kColorToolbarBackgroundSubtleEmphasis};
      mixer[kColorRealboxBackgroundHovered] = {
          kColorToolbarBackgroundSubtleEmphasisHovered};
    }

    mixer[kColorRealboxForeground] = {ui::kColorTextfieldForeground};
    mixer[kColorRealboxPlaceholder] = {kColorOmniboxTextDimmed};
    mixer[kColorRealboxResultsBackground] = {kColorOmniboxResultsBackground};
    mixer[kColorRealboxResultsBackgroundHovered] = {
        kColorOmniboxResultsBackgroundHovered};
    mixer[kColorRealboxResultsControlBackgroundHovered] = ui::SetAlpha(
        ui::SelectBasedOnDarkInput(kColorRealboxBackground, gfx::kGoogleGrey200,
                                   gfx::kGoogleGrey900),
        /* 10% opacity */ 0.1 * SK_AlphaOPAQUE);
    mixer[kColorRealboxResultsDimSelected] = {
        kColorOmniboxResultsTextDimmedSelected};
    mixer[kColorRealboxResultsForeground] = {kColorOmniboxText};
    mixer[kColorRealboxResultsForegroundDimmed] = {
        kColorOmniboxResultsTextDimmed};
    mixer[kColorRealboxResultsIcon] = {kColorOmniboxResultsIcon};
    mixer[kColorRealboxResultsIconSelected] = {
        kColorOmniboxResultsIconSelected};
    mixer[kColorRealboxResultsUrl] = {kColorOmniboxResultsUrl};
    mixer[kColorRealboxResultsUrlSelected] = {kColorOmniboxResultsUrlSelected};
    mixer[kColorRealboxSearchIconBackground] = {kColorOmniboxResultsIcon};
  }

  AddWebThemeNewTabPageColors(mixer, dark_mode);

  if (key.custom_theme &&
      (key.custom_theme->get_theme_type() == ThemeType::kAutogenerated ||
       features::IsChromeWebuiRefresh2023())) {
    AddGeneratedThemeComprehensiveColors(mixer);
  } else {
    const SkColor border_color =
        dark_mode ? gfx::kGoogleGrey700 : gfx::kGoogleGrey300;
    mixer[kColorNewTabPageBorder] = {border_color};
    mixer[kColorNewTabPageLogo] = {kColorNewTabPageLogoUnthemedLight};
    mixer[kColorNewTabPageModuleControlBorder] = {border_color};
    mixer[kColorNewTabPageMostVisitedForeground] = {
        dark_mode ? SK_ColorWHITE : gfx::kGoogleGrey800};
    mixer[kColorNewTabPageText] = {dark_mode ? gfx::kGoogleGrey200
                                             : SK_ColorBLACK};
  }
}

void AddWebThemeNewTabPageColors(ui::ColorMixer& mixer, bool dark_mode) {
  // TODO(crbug.com/1375876): Once the NTP Comprehensive Theming feature has
  // fully launched, remove these variables used to preserve the current GTK+
  // 'Customize Chrome" appearance and instead use core mixer colors.
  const SkColor accent_color =
      dark_mode ? gfx::kGoogleBlue300 : gfx::kGoogleBlue600;
  const SkColor primary_foreground_color =
      dark_mode ? gfx::kGoogleGrey200 : gfx::kGoogleGrey900;
  const SkColor secondary_foreground_color =
      dark_mode ? gfx::kGoogleGrey500 : gfx::kGoogleGrey700;

  mixer[kColorNewTabPageAttributionForeground] = {
      dark_mode ? SK_ColorWHITE : gfx::kGoogleGrey800};
  mixer[kColorNewTabPageActiveBackground] =
      ui::SetAlpha(dark_mode ? gfx::kGoogleGrey200 : gfx::kGoogleGrey900,
                   /* 16% opacity */ 0.16 * SK_AlphaOPAQUE);
  mixer[kColorNewTabPageBackgroundOverride] = {dark_mode ? gfx::kGoogleGrey900
                                                         : SK_ColorWHITE};
  mixer[kColorNewTabPageButtonBackground] = {
      kColorNewTabPageBackgroundOverride};
  // Matches the button hover background colors defined in
  // cr_elements/cr_button/cr_button.html
  mixer[kColorNewTabPageButtonBackgroundHovered] =
      dark_mode ? ui::SetAlpha(gfx::kGoogleBlue300,
                               /* 8% opacity */ 0.08 * SK_AlphaOPAQUE)
                : ui::SetAlpha(gfx::kGoogleBlue500,
                               /* 4% opacity */ 0.04 * SK_AlphaOPAQUE);
  mixer[kColorNewTabPageButtonForeground] = {accent_color};
  mixer[kColorNewTabPageCartModuleDiscountChipBackground] = {
      dark_mode ? gfx::kGoogleGrey800 : gfx::kGoogleGreen050};
  mixer[kColorNewTabPageCartModuleDiscountChipForeground] = {
      dark_mode ? gfx::kGoogleGreen300 : gfx::kGoogleGreen700};
  mixer[kColorNewTabPageChipBackground] = {accent_color};
  mixer[kColorNewTabPageChipForeground] = {kColorNewTabPageBackgroundOverride};
  mixer[kColorNewTabPageControlBackgroundHovered] =
      ui::SetAlpha(dark_mode ? gfx::kGoogleGrey200 : gfx::kGoogleGrey900,
                   /* 10% opacity */ 0.1 * SK_AlphaOPAQUE);
  mixer[kColorNewTabPageFirstRunBackground] = {
      kColorNewTabPageBackgroundOverride};
  mixer[kColorNewTabPageFocusRing] =
      dark_mode ? ui::SetAlpha(gfx::kGoogleBlue300,
                               /* 50% opacity */ 0.5 * SK_AlphaOPAQUE)
                : ui::SetAlpha(gfx::kGoogleBlue600,
                               /* 40% opacity */ 0.4 * SK_AlphaOPAQUE);
  mixer[kColorNewTabPagePromoBackground] = {dark_mode ? gfx::kGoogleGrey900
                                                      : SK_ColorWHITE};
  mixer[kColorNewTabPagePromoImageBackground] = {dark_mode ? gfx::kGoogleGrey200
                                                           : SK_ColorWHITE};
  mixer[kColorNewTabPageIconButtonBackground] = {
      dark_mode ? SK_ColorWHITE : gfx::kGoogleGrey600};
  mixer[kColorNewTabPageIconButtonBackgroundActive] = {
      dark_mode ? gfx::kGoogleGrey300 : gfx::kGoogleGrey700};
  mixer[kColorNewTabPageLink] = {dark_mode ? gfx::kGoogleBlue300
                                           : gfx::kGoogleBlue700};
  mixer[kColorNewTabPageMicBorderColor] = {dark_mode ? gfx::kGoogleGrey100
                                                     : gfx::kGoogleGrey300};
  mixer[kColorNewTabPageMicIconColor] = {dark_mode ? gfx::kGoogleGrey100
                                                   : gfx::kGoogleGrey700};

  if (base::FeatureList::IsEnabled(ntp_features::kNtpModulesRedesigned)) {
    if (dark_mode) {
      mixer[kColorNewTabPageModuleBackground] = {gfx::kGoogleGrey800};
    } else {
      mixer[kColorNewTabPageModuleBackground] = {gfx::kGoogleGrey100};
    }
    mixer[kColorNewTabPageModuleItemBackgroundHovered] = {
        kColorNewTabPageControlBackgroundHovered};
  } else {
    mixer[kColorNewTabPageModuleBackground] = {
        kColorNewTabPageBackgroundOverride};
  }

  mixer[kColorNewTabPageModuleContextMenuDivider] = {
      {dark_mode ? SK_ColorWHITE : gfx::kGoogleGrey600}};
  mixer[kColorNewTabPageModuleElementDivider] = {
      {dark_mode ? SK_ColorWHITE : gfx::kGoogleGrey600}};
  mixer[kColorNewTabPageModuleItemBackground] = {
      kColorNewTabPageBackgroundOverride};
  if (dark_mode) {
    mixer[kColorNewTabPageHistoryClustersModuleItemBackground] = {
        kColorNewTabPageBackground};
  } else {
    mixer[kColorNewTabPageHistoryClustersModuleItemBackground] = {
        gfx::kGoogleGrey100};
  }
  mixer[kColorNewTabPageModuleIconContainerBackground] =
      ui::SetAlpha(accent_color,
                   /* 24% opacity */ 0.24 * SK_AlphaOPAQUE);
  mixer[kColorNewTabPageModuleScrollButtonBackground] = {
      dark_mode ? gfx::kGoogleGrey700 : gfx::kGoogleGrey100};
  mixer[kColorNewTabPageModuleScrollButtonBackgroundHovered] = {
      dark_mode ? gfx::kGoogleGrey600 : gfx::kGoogleGrey300};
  mixer[kColorNewTabPagePrimaryForeground] = {primary_foreground_color};
  mixer[kColorNewTabPageSecondaryForeground] = {secondary_foreground_color};
  mixer[kColorNewTabPageOverlayBackground] = {
      kColorNewTabPageBackgroundOverride};
  mixer[kColorNewTabPageOverlayForeground] = {primary_foreground_color};
  mixer[kColorNewTabPageOverlaySecondaryForeground] = {
      secondary_foreground_color};
  mixer[kColorNewTabPageSelectedBorder] = {accent_color};
  mixer[kColorNewTabPageTagBackground] =
      ui::SetAlpha(kColorNewTabPageBackgroundOverride,
                   /* 90% opacity */ 0.9 * SK_AlphaOPAQUE);

  AddNewTabPageDialogColors(mixer, dark_mode);
}
