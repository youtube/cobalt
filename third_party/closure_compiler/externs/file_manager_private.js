// Copyright 2023 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// @ts-nocheck

// This file was generated by:
//   tools/json_schema_compiler/compiler.py.
// NOTE: The format of types has changed. 'FooType' is now
//   'chrome.fileManagerPrivate.FooType'.
// Please run the closure compiler before committing changes.
// See https://chromium.googlesource.com/chromium/src/+/main/docs/closure_compilation.md

/**
 * @fileoverview Externs generated from namespace: fileManagerPrivate
 * @externs
 */

/** @const */
chrome.fileManagerPrivate = {};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.VolumeType = {
  DRIVE: 'drive',
  DOWNLOADS: 'downloads',
  REMOVABLE: 'removable',
  ARCHIVE: 'archive',
  PROVIDED: 'provided',
  MTP: 'mtp',
  MEDIA_VIEW: 'media_view',
  CROSTINI: 'crostini',
  ANDROID_FILES: 'android_files',
  DOCUMENTS_PROVIDER: 'documents_provider',
  TESTING: 'testing',
  SMB: 'smb',
  SYSTEM_INTERNAL: 'system_internal',
  GUEST_OS: 'guest_os',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.DeviceType = {
  USB: 'usb',
  SD: 'sd',
  OPTICAL: 'optical',
  MOBILE: 'mobile',
  UNKNOWN: 'unknown',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.DeviceConnectionState = {
  OFFLINE: 'OFFLINE',
  ONLINE: 'ONLINE',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.DriveConnectionStateType = {
  OFFLINE: 'OFFLINE',
  METERED: 'METERED',
  ONLINE: 'ONLINE',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.DriveOfflineReason = {
  NOT_READY: 'NOT_READY',
  NO_NETWORK: 'NO_NETWORK',
  NO_SERVICE: 'NO_SERVICE',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.MountContext = {
  USER: 'user',
  AUTO: 'auto',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.MountCompletedEventType = {
  MOUNT: 'mount',
  UNMOUNT: 'unmount',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.MountError = {
  SUCCESS: 'success',
  IN_PROGRESS: 'in_progress',
  UNKNOWN_ERROR: 'unknown_error',
  INTERNAL_ERROR: 'internal_error',
  INVALID_ARGUMENT: 'invalid_argument',
  INVALID_PATH: 'invalid_path',
  PATH_ALREADY_MOUNTED: 'path_already_mounted',
  PATH_NOT_MOUNTED: 'path_not_mounted',
  DIRECTORY_CREATION_FAILED: 'directory_creation_failed',
  INVALID_MOUNT_OPTIONS: 'invalid_mount_options',
  INSUFFICIENT_PERMISSIONS: 'insufficient_permissions',
  MOUNT_PROGRAM_NOT_FOUND: 'mount_program_not_found',
  MOUNT_PROGRAM_FAILED: 'mount_program_failed',
  INVALID_DEVICE_PATH: 'invalid_device_path',
  UNKNOWN_FILESYSTEM: 'unknown_filesystem',
  UNSUPPORTED_FILESYSTEM: 'unsupported_filesystem',
  NEED_PASSWORD: 'need_password',
  CANCELLED: 'cancelled',
  BUSY: 'busy',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.FormatFileSystemType = {
  VFAT: 'vfat',
  EXFAT: 'exfat',
  NTFS: 'ntfs',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.TransferState = {
  IN_PROGRESS: 'in_progress',
  QUEUED: 'queued',
  COMPLETED: 'completed',
  FAILED: 'failed',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.InstallLinuxPackageResponse = {
  STARTED: 'started',
  FAILED: 'failed',
  INSTALL_ALREADY_ACTIVE: 'install_already_active',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.FileWatchEventType = {
  CHANGED: 'changed',
  ERROR: 'error',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.ChangeType = {
  ADD_OR_UPDATE: 'add_or_update',
  DELETE: 'delete',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.SearchType = {
  EXCLUDE_DIRECTORIES: 'EXCLUDE_DIRECTORIES',
  SHARED_WITH_ME: 'SHARED_WITH_ME',
  OFFLINE: 'OFFLINE',
  ALL: 'ALL',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.ZoomOperationType = {
  IN: 'in',
  OUT: 'out',
  RESET: 'reset',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.InspectionType = {
  NORMAL: 'normal',
  CONSOLE: 'console',
  ELEMENT: 'element',
  BACKGROUND: 'background',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.DeviceEventType = {
  DISABLED: 'disabled',
  REMOVED: 'removed',
  HARD_UNPLUGGED: 'hard_unplugged',
  FORMAT_START: 'format_start',
  FORMAT_SUCCESS: 'format_success',
  FORMAT_FAIL: 'format_fail',
  RENAME_START: 'rename_start',
  RENAME_SUCCESS: 'rename_success',
  RENAME_FAIL: 'rename_fail',
  PARTITION_START: 'partition_start',
  PARTITION_SUCCESS: 'partition_success',
  PARTITION_FAIL: 'partition_fail',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.DriveSyncErrorType = {
  DELETE_WITHOUT_PERMISSION: 'delete_without_permission',
  SERVICE_UNAVAILABLE: 'service_unavailable',
  NO_SERVER_SPACE: 'no_server_space',
  NO_SERVER_SPACE_ORGANIZATION: 'no_server_space_organization',
  NO_LOCAL_SPACE: 'no_local_space',
  NO_SHARED_DRIVE_SPACE: 'no_shared_drive_space',
  MISC: 'misc',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.DriveConfirmDialogType = {
  ENABLE_DOCS_OFFLINE: 'enable_docs_offline',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.DriveDialogResult = {
  NOT_DISPLAYED: 'not_displayed',
  ACCEPT: 'accept',
  REJECT: 'reject',
  DISMISS: 'dismiss',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.TaskResult = {
  OPENED: 'opened',
  MESSAGE_SENT: 'message_sent',
  FAILED: 'failed',
  EMPTY: 'empty',
  FAILED_PLUGIN_VM_DIRECTORY_NOT_SHARED: 'failed_plugin_vm_directory_not_shared',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.DriveShareType = {
  CAN_EDIT: 'can_edit',
  CAN_COMMENT: 'can_comment',
  CAN_VIEW: 'can_view',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.EntryPropertyName = {
  SIZE: 'size',
  MODIFICATION_TIME: 'modificationTime',
  MODIFICATION_BY_ME_TIME: 'modificationByMeTime',
  THUMBNAIL_URL: 'thumbnailUrl',
  CROPPED_THUMBNAIL_URL: 'croppedThumbnailUrl',
  IMAGE_WIDTH: 'imageWidth',
  IMAGE_HEIGHT: 'imageHeight',
  IMAGE_ROTATION: 'imageRotation',
  PINNED: 'pinned',
  PRESENT: 'present',
  HOSTED: 'hosted',
  AVAILABLE_OFFLINE: 'availableOffline',
  AVAILABLE_WHEN_METERED: 'availableWhenMetered',
  DIRTY: 'dirty',
  CUSTOM_ICON_URL: 'customIconUrl',
  CONTENT_MIME_TYPE: 'contentMimeType',
  SHARED_WITH_ME: 'sharedWithMe',
  SHARED: 'shared',
  STARRED: 'starred',
  EXTERNAL_FILE_URL: 'externalFileUrl',
  ALTERNATE_URL: 'alternateUrl',
  SHARE_URL: 'shareUrl',
  CAN_COPY: 'canCopy',
  CAN_DELETE: 'canDelete',
  CAN_RENAME: 'canRename',
  CAN_ADD_CHILDREN: 'canAddChildren',
  CAN_SHARE: 'canShare',
  CAN_PIN: 'canPin',
  IS_MACHINE_ROOT: 'isMachineRoot',
  IS_EXTERNAL_MEDIA: 'isExternalMedia',
  IS_ARBITRARY_SYNC_FOLDER: 'isArbitrarySyncFolder',
  SYNC_STATUS: 'syncStatus',
  PROGRESS: 'progress',
  SHORTCUT: 'shortcut',
  SYNC_COMPLETED_TIME: 'syncCompletedTime',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.Source = {
  FILE: 'file',
  DEVICE: 'device',
  NETWORK: 'network',
  SYSTEM: 'system',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.SourceRestriction = {
  ANY_SOURCE: 'any_source',
  NATIVE_SOURCE: 'native_source',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.FileCategory = {
  ALL: 'all',
  AUDIO: 'audio',
  IMAGE: 'image',
  VIDEO: 'video',
  DOCUMENT: 'document',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.CrostiniEventType = {
  ENABLE: 'enable',
  DISABLE: 'disable',
  SHARE: 'share',
  UNSHARE: 'unshare',
  DROP_FAILED_PLUGIN_VM_DIRECTORY_NOT_SHARED: 'drop_failed_plugin_vm_directory_not_shared',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.ProviderSource = {
  FILE: 'file',
  DEVICE: 'device',
  NETWORK: 'network',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.SharesheetLaunchSource = {
  CONTEXT_MENU: 'context_menu',
  SHARESHEET_BUTTON: 'sharesheet_button',
  UNKNOWN: 'unknown',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.IOTaskState = {
  QUEUED: 'queued',
  SCANNING: 'scanning',
  IN_PROGRESS: 'in_progress',
  PAUSED: 'paused',
  SUCCESS: 'success',
  ERROR: 'error',
  NEED_PASSWORD: 'need_password',
  CANCELLED: 'cancelled',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.IOTaskType = {
  COPY: 'copy',
  DELETE: 'delete',
  EMPTY_TRASH: 'empty_trash',
  EXTRACT: 'extract',
  MOVE: 'move',
  RESTORE: 'restore',
  RESTORE_TO_DESTINATION: 'restore_to_destination',
  TRASH: 'trash',
  ZIP: 'zip',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.PolicyErrorType = {
  DLP: 'dlp',
  ENTERPRISE_CONNECTORS: 'enterprise_connectors',
  DLP_WARNING_TIMEOUT: 'dlp_warning_timeout',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.PolicyDialogType = {
  WARNING: 'warning',
  ERROR: 'error',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.RecentDateBucket = {
  TODAY: 'today',
  YESTERDAY: 'yesterday',
  EARLIER_THIS_WEEK: 'earlier_this_week',
  EARLIER_THIS_MONTH: 'earlier_this_month',
  EARLIER_THIS_YEAR: 'earlier_this_year',
  OLDER: 'older',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.VmType = {
  TERMINA: 'termina',
  PLUGIN_VM: 'plugin_vm',
  BOREALIS: 'borealis',
  BRUSCHETTA: 'bruschetta',
  ARCVM: 'arcvm',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.UserType = {
  UNMANAGED: 'unmanaged',
  ORGANIZATION: 'organization',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.DlpLevel = {
  REPORT: 'report',
  WARN: 'warn',
  BLOCK: 'block',
  ALLOW: 'allow',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.SyncStatus = {
  NOT_FOUND: 'not_found',
  QUEUED: 'queued',
  IN_PROGRESS: 'in_progress',
  COMPLETED: 'completed',
  ERROR: 'error',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.PolicyDefaultHandlerStatus = {
  DEFAULT_HANDLER_ASSIGNED_BY_POLICY: 'default_handler_assigned_by_policy',
  INCORRECT_ASSIGNMENT: 'incorrect_assignment',
};

/**
 * @enum {string}
 */
chrome.fileManagerPrivate.BulkPinStage = {
  STOPPED: 'stopped',
  PAUSED_OFFLINE: 'paused_offline',
  PAUSED_BATTERY_SAVER: 'paused_battery_saver',
  GETTING_FREE_SPACE: 'getting_free_space',
  LISTING_FILES: 'listing_files',
  SYNCING: 'syncing',
  SUCCESS: 'success',
  NOT_ENOUGH_SPACE: 'not_enough_space',
  CANNOT_GET_FREE_SPACE: 'cannot_get_free_space',
  CANNOT_LIST_FILES: 'cannot_list_files',
  CANNOT_ENABLE_DOCS_OFFLINE: 'cannot_enable_docs_offline',
};

/**
 * @typedef {{
 *   appId: string,
 *   taskType: string,
 *   actionId: string
 * }}
 */
chrome.fileManagerPrivate.FileTaskDescriptor;

/**
 * @typedef {{
 *   descriptor: !chrome.fileManagerPrivate.FileTaskDescriptor,
 *   title: string,
 *   iconUrl: (string|undefined),
 *   isDefault: (boolean|undefined),
 *   isGenericFileHandler: (boolean|undefined),
 *   isDlpBlocked: (boolean|undefined)
 * }}
 */
chrome.fileManagerPrivate.FileTask;

/**
 * @typedef {{
 *   tasks: !Array<!chrome.fileManagerPrivate.FileTask>,
 *   policyDefaultHandlerStatus: (!chrome.fileManagerPrivate.PolicyDefaultHandlerStatus|undefined)
 * }}
 */
chrome.fileManagerPrivate.ResultingTasks;

/**
 * @typedef {{
 *   size: (number|undefined),
 *   modificationTime: (number|undefined),
 *   modificationByMeTime: (number|undefined),
 *   recentDateBucket: (!chrome.fileManagerPrivate.RecentDateBucket|undefined),
 *   thumbnailUrl: (string|undefined),
 *   croppedThumbnailUrl: (string|undefined),
 *   imageWidth: (number|undefined),
 *   imageHeight: (number|undefined),
 *   imageRotation: (number|undefined),
 *   pinned: (boolean|undefined),
 *   present: (boolean|undefined),
 *   hosted: (boolean|undefined),
 *   availableOffline: (boolean|undefined),
 *   availableWhenMetered: (boolean|undefined),
 *   dirty: (boolean|undefined),
 *   customIconUrl: (string|undefined),
 *   contentMimeType: (string|undefined),
 *   sharedWithMe: (boolean|undefined),
 *   shared: (boolean|undefined),
 *   starred: (boolean|undefined),
 *   externalFileUrl: (string|undefined),
 *   alternateUrl: (string|undefined),
 *   shareUrl: (string|undefined),
 *   canCopy: (boolean|undefined),
 *   canDelete: (boolean|undefined),
 *   canRename: (boolean|undefined),
 *   canAddChildren: (boolean|undefined),
 *   canShare: (boolean|undefined),
 *   canPin: (boolean|undefined),
 *   isMachineRoot: (boolean|undefined),
 *   isExternalMedia: (boolean|undefined),
 *   isArbitrarySyncFolder: (boolean|undefined),
 *   syncStatus: (!chrome.fileManagerPrivate.SyncStatus|undefined),
 *   progress: (number|undefined),
 *   syncCompletedTime: (number|undefined),
 *   shortcut: (boolean|undefined)
 * }}
 */
chrome.fileManagerPrivate.EntryProperties;

/**
 * @typedef {{
 *   totalSize: number,
 *   remainingSize: number
 * }}
 */
chrome.fileManagerPrivate.MountPointSizeStats;

/**
 * @typedef {{
 *   userType: !chrome.fileManagerPrivate.UserType,
 *   usedBytes: number,
 *   totalBytes: number,
 *   organizationLimitExceeded: boolean,
 *   organizationName: string
 * }}
 */
chrome.fileManagerPrivate.DriveQuotaMetadata;

/**
 * @typedef {{
 *   profileId: string,
 *   displayName: string,
 *   isCurrentProfile: boolean
 * }}
 */
chrome.fileManagerPrivate.ProfileInfo;

/**
 * @typedef {{
 *   icon16x16Url: (string|undefined),
 *   icon32x32Url: (string|undefined)
 * }}
 */
chrome.fileManagerPrivate.IconSet;

/**
 * @typedef {{
 *   volumeId: string,
 *   fileSystemId: (string|undefined),
 *   providerId: (string|undefined),
 *   source: !chrome.fileManagerPrivate.Source,
 *   volumeLabel: (string|undefined),
 *   profile: !chrome.fileManagerPrivate.ProfileInfo,
 *   sourcePath: (string|undefined),
 *   volumeType: !chrome.fileManagerPrivate.VolumeType,
 *   deviceType: (!chrome.fileManagerPrivate.DeviceType|undefined),
 *   devicePath: (string|undefined),
 *   isParentDevice: (boolean|undefined),
 *   isReadOnly: boolean,
 *   isReadOnlyRemovableDevice: boolean,
 *   hasMedia: boolean,
 *   configurable: boolean,
 *   watchable: boolean,
 *   mountCondition: (!chrome.fileManagerPrivate.MountError|undefined),
 *   mountContext: (!chrome.fileManagerPrivate.MountContext|undefined),
 *   diskFileSystemType: (string|undefined),
 *   iconSet: !chrome.fileManagerPrivate.IconSet,
 *   driveLabel: (string|undefined),
 *   remoteMountPath: (string|undefined),
 *   hidden: boolean,
 *   vmType: (!chrome.fileManagerPrivate.VmType|undefined)
 * }}
 */
chrome.fileManagerPrivate.VolumeMetadata;

/**
 * @typedef {{
 *   eventType: !chrome.fileManagerPrivate.MountCompletedEventType,
 *   status: !chrome.fileManagerPrivate.MountError,
 *   volumeMetadata: !chrome.fileManagerPrivate.VolumeMetadata,
 *   shouldNotify: boolean
 * }}
 */
chrome.fileManagerPrivate.MountCompletedEvent;

/**
 * @typedef {{
 *   fileUrl: string,
 *   transferState: !chrome.fileManagerPrivate.TransferState,
 *   processed: number,
 *   total: number,
 *   numTotalJobs: number,
 *   showNotification: boolean,
 *   hideWhenZeroJobs: boolean
 * }}
 */
chrome.fileManagerPrivate.FileTransferStatus;

/**
 * @typedef {{
 *   fileUrl: string,
 *   syncStatus: !chrome.fileManagerPrivate.SyncStatus,
 *   progress: number
 * }}
 */
chrome.fileManagerPrivate.SyncState;

/**
 * @typedef {{
 *   type: !chrome.fileManagerPrivate.DriveSyncErrorType,
 *   fileUrl: string,
 *   sharedDrive: (string|undefined)
 * }}
 */
chrome.fileManagerPrivate.DriveSyncErrorEvent;

/**
 * @typedef {{
 *   type: !chrome.fileManagerPrivate.DriveConfirmDialogType,
 *   fileUrl: string
 * }}
 */
chrome.fileManagerPrivate.DriveConfirmDialogEvent;

/**
 * @typedef {{
 *   url: string,
 *   changes: !Array<!chrome.fileManagerPrivate.ChangeType>
 * }}
 */
chrome.fileManagerPrivate.FileChange;

/**
 * @typedef {{
 *   eventType: !chrome.fileManagerPrivate.FileWatchEventType,
 *   entry: Entry,
 *   changedFiles: (!Array<!chrome.fileManagerPrivate.FileChange>|undefined)
 * }}
 */
chrome.fileManagerPrivate.FileWatchEvent;

/**
 * @typedef {{
 *   volumeId: string,
 *   writable: (boolean|undefined)
 * }}
 */
chrome.fileManagerPrivate.GetVolumeRootOptions;

/**
 * @typedef {{
 *   driveEnabled: boolean,
 *   driveSyncEnabledOnMeteredNetwork: boolean,
 *   searchSuggestEnabled: boolean,
 *   use24hourClock: boolean,
 *   timezone: string,
 *   arcEnabled: boolean,
 *   arcRemovableMediaAccessEnabled: boolean,
 *   folderShortcuts: !Array<string>,
 *   trashEnabled: boolean,
 *   officeFileMovedOneDrive: number,
 *   officeFileMovedGoogleDrive: number,
 *   driveFsBulkPinningEnabled: boolean
 * }}
 */
chrome.fileManagerPrivate.Preferences;

/**
 * @typedef {{
 *   driveSyncEnabledOnMeteredNetwork: (boolean|undefined),
 *   arcEnabled: (boolean|undefined),
 *   arcRemovableMediaAccessEnabled: (boolean|undefined),
 *   folderShortcuts: (!Array<string>|undefined),
 *   driveFsBulkPinningEnabled: (boolean|undefined)
 * }}
 */
chrome.fileManagerPrivate.PreferencesChange;

/**
 * @typedef {{
 *   query: string,
 *   category: (!chrome.fileManagerPrivate.FileCategory|undefined),
 *   modifiedTimestamp: (number|undefined),
 *   nextFeed: string
 * }}
 */
chrome.fileManagerPrivate.SearchParams;

/**
 * @typedef {{
 *   rootDir: (DirectoryEntry|undefined),
 *   query: string,
 *   types: !chrome.fileManagerPrivate.SearchType,
 *   maxResults: number,
 *   modifiedTimestamp: (number|undefined),
 *   category: (!chrome.fileManagerPrivate.FileCategory|undefined)
 * }}
 */
chrome.fileManagerPrivate.SearchMetadataParams;

/**
 * @typedef {{
 *   entry: Entry,
 *   highlightedBaseName: string,
 *   availableOffline: (boolean|undefined)
 * }}
 */
chrome.fileManagerPrivate.DriveMetadataSearchResult;

/**
 * @typedef {{
 *   type: !chrome.fileManagerPrivate.DriveConnectionStateType,
 *   reason: (!chrome.fileManagerPrivate.DriveOfflineReason|undefined)
 * }}
 */
chrome.fileManagerPrivate.DriveConnectionState;

/**
 * @typedef {{
 *   type: !chrome.fileManagerPrivate.DeviceEventType,
 *   devicePath: string,
 *   deviceLabel: string
 * }}
 */
chrome.fileManagerPrivate.DeviceEvent;

/**
 * @typedef {{
 *   providerId: string,
 *   iconSet: !chrome.fileManagerPrivate.IconSet,
 *   name: string,
 *   configurable: boolean,
 *   watchable: boolean,
 *   multipleMounts: boolean,
 *   source: !chrome.fileManagerPrivate.ProviderSource
 * }}
 */
chrome.fileManagerPrivate.Provider;

/**
 * @typedef {{
 *   id: string,
 *   title: (string|undefined)
 * }}
 */
chrome.fileManagerPrivate.FileSystemProviderAction;

/**
 * @typedef {{
 *   name: string,
 *   version: string,
 *   summary: (string|undefined),
 *   description: (string|undefined)
 * }}
 */
chrome.fileManagerPrivate.LinuxPackageInfo;

/**
 * @typedef {{
 *   eventType: !chrome.fileManagerPrivate.CrostiniEventType,
 *   vmName: string,
 *   containerName: string,
 *   entries: !Array<Entry>
 * }}
 */
chrome.fileManagerPrivate.CrostiniEvent;

/**
 * @typedef {{
 *   name: string,
 *   packageName: string,
 *   activityName: string,
 *   iconSet: (!chrome.fileManagerPrivate.IconSet|undefined)
 * }}
 */
chrome.fileManagerPrivate.AndroidApp;

/**
 * @typedef {{
 *   type: string,
 *   tags: Object
 * }}
 */
chrome.fileManagerPrivate.StreamInfo;

/**
 * @typedef {{
 *   data: string,
 *   type: string
 * }}
 */
chrome.fileManagerPrivate.AttachedImages;

/**
 * @typedef {{
 *   mimeType: string,
 *   height: (number|undefined),
 *   width: (number|undefined),
 *   duration: (number|undefined),
 *   rotation: (number|undefined),
 *   album: (string|undefined),
 *   artist: (string|undefined),
 *   comment: (string|undefined),
 *   copyright: (string|undefined),
 *   disc: (number|undefined),
 *   genre: (string|undefined),
 *   language: (string|undefined),
 *   title: (string|undefined),
 *   track: (number|undefined),
 *   rawTags: !Array<!chrome.fileManagerPrivate.StreamInfo>,
 *   attachedImages: !Array<!chrome.fileManagerPrivate.AttachedImages>
 * }}
 */
chrome.fileManagerPrivate.MediaMetadata;

/**
 * @typedef {{
 *   itemUrls: !Array<string>
 * }}
 */
chrome.fileManagerPrivate.HoldingSpaceState;

/**
 * @typedef {{
 *   currentDirectoryURL: (string|undefined),
 *   selectionURL: (string|undefined)
 * }}
 */
chrome.fileManagerPrivate.OpenWindowParams;

/**
 * @typedef {{
 *   destinationFolder: (DirectoryEntry|undefined),
 *   password: (string|undefined),
 *   showNotification: (boolean|undefined)
 * }}
 */
chrome.fileManagerPrivate.IOTaskParams;

/**
 * @typedef {{
 *   type: !chrome.fileManagerPrivate.PolicyErrorType,
 *   policyFileCount: number,
 *   fileName: string,
 *   alwaysShowReview: boolean
 * }}
 */
chrome.fileManagerPrivate.PolicyError;

/**
 * @typedef {{
 *   conflictName: (string|undefined),
 *   conflictIsDirectory: (boolean|undefined),
 *   conflictMultiple: (boolean|undefined),
 *   conflictTargetUrl: (string|undefined)
 * }}
 */
chrome.fileManagerPrivate.ConflictPauseParams;

/**
 * @typedef {{
 *   type: !chrome.fileManagerPrivate.PolicyErrorType,
 *   policyFileCount: number,
 *   fileName: string,
 *   alwaysShowReview: boolean
 * }}
 */
chrome.fileManagerPrivate.PolicyPauseParams;

/**
 * @typedef {{
 *   conflictParams: (!chrome.fileManagerPrivate.ConflictPauseParams|undefined),
 *   policyParams: (!chrome.fileManagerPrivate.PolicyPauseParams|undefined)
 * }}
 */
chrome.fileManagerPrivate.PauseParams;

/**
 * @typedef {{
 *   conflictResolve: (string|undefined),
 *   conflictApplyToAll: (boolean|undefined)
 * }}
 */
chrome.fileManagerPrivate.ConflictResumeParams;

/**
 * @typedef {{
 *   type: !chrome.fileManagerPrivate.PolicyErrorType
 * }}
 */
chrome.fileManagerPrivate.PolicyResumeParams;

/**
 * @typedef {{
 *   conflictParams: (!chrome.fileManagerPrivate.ConflictResumeParams|undefined),
 *   policyParams: (!chrome.fileManagerPrivate.PolicyResumeParams|undefined)
 * }}
 */
chrome.fileManagerPrivate.ResumeParams;

/**
 * @typedef {{
 *   type: !chrome.fileManagerPrivate.IOTaskType,
 *   state: !chrome.fileManagerPrivate.IOTaskState,
 *   policyError: (!chrome.fileManagerPrivate.PolicyError|undefined),
 *   sourceName: string,
 *   numRemainingItems: number,
 *   itemCount: number,
 *   destinationName: string,
 *   bytesTransferred: number,
 *   totalBytes: number,
 *   taskId: number,
 *   remainingSeconds: number,
 *   sourcesScanned: number,
 *   showNotification: boolean,
 *   errorName: string,
 *   pauseParams: (!chrome.fileManagerPrivate.PauseParams|undefined),
 *   outputs: (!Array<Entry>|undefined),
 *   destinationVolumeId: string
 * }}
 */
chrome.fileManagerPrivate.ProgressStatus;

/**
 * @typedef {{
 *   sourceUrl: string,
 *   isDlpRestricted: boolean,
 *   isRestrictedForDestination: boolean
 * }}
 */
chrome.fileManagerPrivate.DlpMetadata;

/**
 * @typedef {{
 *   level: !chrome.fileManagerPrivate.DlpLevel,
 *   urls: !Array<string>,
 *   components: !Array<!chrome.fileManagerPrivate.VolumeType>
 * }}
 */
chrome.fileManagerPrivate.DlpRestrictionDetails;

/**
 * @typedef {{
 *   url: (string|undefined),
 *   component: (!chrome.fileManagerPrivate.VolumeType|undefined)
 * }}
 */
chrome.fileManagerPrivate.DialogCallerInformation;

/**
 * @typedef {{
 *   id: number,
 *   displayName: string,
 *   vmType: !chrome.fileManagerPrivate.VmType
 * }}
 */
chrome.fileManagerPrivate.MountableGuest;

/**
 * @typedef {{
 *   restoreEntry: Entry,
 *   trashInfoFileName: string,
 *   deletionDate: number
 * }}
 */
chrome.fileManagerPrivate.ParsedTrashInfoFile;

/**
 * @typedef {{
 *   stage: !chrome.fileManagerPrivate.BulkPinStage,
 *   freeSpaceBytes: number,
 *   requiredSpaceBytes: number,
 *   bytesToPin: number,
 *   pinnedBytes: number,
 *   filesToPin: number,
 *   listedFiles: number,
 *   remainingSeconds: number,
 *   shouldPin: boolean,
 *   emptiedQueue: boolean
 * }}
 */
chrome.fileManagerPrivate.BulkPinProgress;

/**
 * Cancels file selection.
 */
chrome.fileManagerPrivate.cancelDialog = function() {};

/**
 * Executes file browser task over selected files. |descriptor| The unique
 * identifier of task to execute. |entries| Array of entries |callback|
 * @param {!chrome.fileManagerPrivate.FileTaskDescriptor} descriptor
 * @param {!Array<Entry>} entries
 * @param {function(!chrome.fileManagerPrivate.TaskResult): void} callback
 *     |result| Result of the task execution.
 */
chrome.fileManagerPrivate.executeTask = function(descriptor, entries, callback) {};

/**
 * Sets the default task for the supplied MIME types and path extensions. Lists
 * of MIME types and URLs may contain duplicates. Additionally, the list of MIME
 * types can be empty. |descriptor| The unique identifier of task to mark as
 * default. |entries| Array of selected entries to extract path extensions from.
 * |mimeTypes| Array of selected file MIME types. |callback|
 * @param {!chrome.fileManagerPrivate.FileTaskDescriptor} descriptor
 * @param {!Array<Entry>} entries
 * @param {!Array<string>} mimeTypes
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.setDefaultTask = function(descriptor, entries, mimeTypes, callback) {};

/**
 * Gets the list of tasks that can be performed over selected files. |entries|
 * Array of selected entries |dlpSourceUrls| Array of source URLs corresponding
 * to the entries, used to check Data Leak Prevention (DLP) restrictions
 * |callback|
 * @param {!Array<Entry>} entries
 * @param {!Array<string>} dlpSourceUrls
 * @param {function(!chrome.fileManagerPrivate.ResultingTasks): void} callback
 *     |resultingTasks| The list of matched file entries for this task.
 */
chrome.fileManagerPrivate.getFileTasks = function(entries, dlpSourceUrls, callback) {};

/**
 * Gets the MIME type of an entry. |entry| The entry to be checked. |callback|
 * @param {Entry} entry
 * @param {function(string): void} callback |result| Mime type of the file.
 */
chrome.fileManagerPrivate.getMimeType = function(entry, callback) {};

/**
 * Gets the content sniffed MIME type of a file. |fileEntry| The file entry to
 * be checked. |callback|
 * @param {FileEntry} fileEntry
 * @param {function(string): void} callback |result| Content sniffed mime type
 *     of the file.
 */
chrome.fileManagerPrivate.getContentMimeType = function(fileEntry, callback) {};

/**
 * Gets metadata from an Audio or Video file. |fileEntry| The file entry to be
 * checked. |mimeType| Content sniffed mimeType of the file. |includeImages|
 * False returns metadata tags only. True returns     metadata tags and metadata
 * (thumbnail) images. |callback|
 * @param {FileEntry} fileEntry
 * @param {string} mimeType
 * @param {boolean} includeImages
 * @param {function(!chrome.fileManagerPrivate.MediaMetadata): void} callback
 *     |result| Metadata of the Audio or Video file.
 */
chrome.fileManagerPrivate.getContentMetadata = function(fileEntry, mimeType, includeImages, callback) {};

/**
 * Gets localized strings and initialization data. |callback|
 * @param {function(Object): void} callback |result| Hash containing the string
 *     assets.
 */
chrome.fileManagerPrivate.getStrings = function(callback) {};

/**
 * Adds file watch. |entry| Entry to watch |callback|
 * @param {Entry} entry
 * @param {function((boolean|undefined)): void} callback |success| True when
 *     file watch is successfully added.
 */
chrome.fileManagerPrivate.addFileWatch = function(entry, callback) {};

/**
 * Removes file watch. |entry| Watched entry |callback|
 * @param {Entry} entry
 * @param {function((boolean|undefined)): void} callback |success| True when
 *     file watch is successfully removed.
 */
chrome.fileManagerPrivate.removeFileWatch = function(entry, callback) {};

/**
 * Enables the extenal file scheme necessary to initiate drags to the browser
 * window for files on the external backend.
 */
chrome.fileManagerPrivate.enableExternalFileScheme = function() {};

/**
 * Requests granting R/W permissions for the passed entries. It's a best effort
 * operation. Some files may not be granted access if the url is invalid or not
 * backed by the external file system. |entryUrls| Urls for the entries to be
 * accessed. |callback|
 * @param {!Array<string>} entryUrls
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.grantAccess = function(entryUrls, callback) {};

/**
 * Selects multiple files. |selectedPaths| Array of selected paths
 * |shouldReturnLocalPath| true if paths need to be resolved to local paths.
 * |callback|
 * @param {!Array<string>} selectedPaths
 * @param {boolean} shouldReturnLocalPath
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.selectFiles = function(selectedPaths, shouldReturnLocalPath, callback) {};

/**
 * Selects a file. |selectedPath| A selected path |index| Index of Filter
 * |forOpening| true if paths are selected for opening. false if for saving.
 * |shouldReturnLocalPath| true if paths need to be resolved to local paths.
 * |callback|
 * @param {string} selectedPath
 * @param {number} index
 * @param {boolean} forOpening
 * @param {boolean} shouldReturnLocalPath
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.selectFile = function(selectedPath, index, forOpening, shouldReturnLocalPath, callback) {};

/**
 * Requests additional properties for files. |entries| list of entries |names|
 * list of requested properties by their names. |callback| Completion callback.
 * May return less than requested properties     if some are not available. In
 * the same time, it can return properties     which were not requested (if it's
 * cheap to compute them).
 * @param {!Array<Entry>} entries
 * @param {!Array<!chrome.fileManagerPrivate.EntryPropertyName>} names
 * @param {function(!Array<!chrome.fileManagerPrivate.EntryProperties>): void}
 *     callback |entryProperties| A dictionary containing properties of the
 *     requested entries.
 */
chrome.fileManagerPrivate.getEntryProperties = function(entries, names, callback) {};

/**
 * Pins/unpins a Drive file in the cache. |entry| Entry to pin/unpin. |pin| Pass
 * true to pin the file. |callback| Completion callback.
 * $(ref:runtime.lastError) will be set if     there was an error.
 * @param {Entry} entry
 * @param {boolean} pin
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.pinDriveFile = function(entry, pin, callback) {};

/**
 * Resolves entries in the isolated file system and returns corresponding
 * entries in the external file system mounted to Chrome OS file manager
 * backend. If resolving entry fails, the entry will be just ignored and the
 * corresponding entry does not appear in the result.
 * @param {!Array<Entry>} entries
 * @param {function(!Array<Entry>): void} callback |entries| External entries.
 */
chrome.fileManagerPrivate.resolveIsolatedEntries = function(entries, callback) {};

/**
 * Mounts a resource or an archive. |fileUrl| Mount point source. |password|
 * Optional password to decrypt the archive. |callback| Callback called with the
 * source path of the mount.
 * @param {string} fileUrl
 * @param {?string|undefined} password
 * @param {function(string): void} callback |sourcePath| Source path of the
 *     mount.
 */
chrome.fileManagerPrivate.addMount = function(fileUrl, password, callback) {};

/**
 * Cancels an archive mounting operation. |fileUrl| Mount point source. Should
 * be same as the one passed to addMount. |callback|
 * @param {string} fileUrl
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.cancelMounting = function(fileUrl, callback) {};

/**
 * Unmounts a mounted resource. |volumeId| An ID of the volume.
 * @param {string} volumeId
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.removeMount = function(volumeId, callback) {};

/**
 * Get the list of mounted volumes. |callback|
 * @param {function(!Array<!chrome.fileManagerPrivate.VolumeMetadata>): void}
 *     callback |volumeMetadataList| The list of VolumeMetadata representing
 *     mounted volumes.
 */
chrome.fileManagerPrivate.getVolumeMetadataList = function(callback) {};

/**
 * Returns the list of files not allowed to be transfered. |entries| List of the
 * source entries to be transfered. |destinationEntry| Entry for the destination
 * (parent) directory. |isMove| True if the operation is move, false otherwise.
 * |callback| Result callback.
 * @param {!Array<Entry>} entries
 * @param {DirectoryEntry} destinationEntry
 * @param {boolean} isMove
 * @param {function(!Array<Entry>): void} callback |disallowedEntries| A list of
 *     files not allowed to be transfered.
 */
chrome.fileManagerPrivate.getDisallowedTransfers = function(entries, destinationEntry, isMove, callback) {};

/**
 * Returns the list of DlpMetadata containing DLP information about the entries.
 * |entries| List of the source entries to be checked. |callback| Result
 * callback.
 * @param {!Array<Entry>} entries
 * @param {function(!Array<!chrome.fileManagerPrivate.DlpMetadata>): void}
 *     callback |dlpMetadata| A list of DlpMetadata containing DLP information
 *     about the entries.
 */
chrome.fileManagerPrivate.getDlpMetadata = function(entries, callback) {};

/**
 * Retrieves Data Leak Prevention (DLP) restriction details. |sourceUrl| Source
 * URL of the Entry for which the details should be shown. |callback| Result
 * callback.
 * @param {string} sourceUrl
 * @param {function(!Array<!chrome.fileManagerPrivate.DlpRestrictionDetails>): void}
 *     callback |restrictionDetails| A list of DlpRestrictionDetails containing
 *     summarized restriction information about an entry.
 */
chrome.fileManagerPrivate.getDlpRestrictionDetails = function(sourceUrl, callback) {};

/**
 * Retrieves the list of components to which the transfer of an Entry is blocked
 * by Data Leak Prevention (DLP) policy. |sourceUrl| Source URL of the Entry
 * that should be checked. |callback| Result callback.
 * @param {string} sourceUrl
 * @param {function(!Array<!chrome.fileManagerPrivate.VolumeType>): void}
 *     callback |blockedComponents| A list of components (subset of VolumeType)
 *     to which transferring an Entry is blocked by Data Leak Prevention (DLP)
 *     policy.
 */
chrome.fileManagerPrivate.getDlpBlockedComponents = function(sourceUrl, callback) {};

/**
 * Retrieves the caller that created the dialog (Save As/File Picker).
 * |callback| Result callback.
 * @param {function(!chrome.fileManagerPrivate.DialogCallerInformation): void}
 *     callback |caller| Either the URL or a component (subset of VolumeType) of
 *     the caller that created the dialog (Save As/File Picker).
 */
chrome.fileManagerPrivate.getDialogCaller = function(callback) {};

/**
 * Retrieves total and remaining size of a mount point. |volumeId| ID of the
 * volume to be checked. |callback|
 * @param {string} volumeId
 * @param {function((!chrome.fileManagerPrivate.MountPointSizeStats|undefined)): void}
 *     callback |sizeStats| Name/value pairs of size stats. Will be undefined if
 *     stats could not be determined.
 */
chrome.fileManagerPrivate.getSizeStats = function(volumeId, callback) {};

/**
 * Retrieves metadata about the user's Drive volume's quota. |entry| If entry is
 * within a Shared Drive, then the applicable shared drive quota is returned,
 * else the overall Drive quota is returned. |callback|
 * @param {Entry} entry
 * @param {function((!chrome.fileManagerPrivate.DriveQuotaMetadata|undefined)): void}
 *     callback |driveQuotaMetadata| Name/value pairs of drive quota metadata.
 *     Will be undefined if quota metadata could not be determined.
 */
chrome.fileManagerPrivate.getDriveQuotaMetadata = function(entry, callback) {};

/**
 * Formats a mounted volume. |volumeId| ID of the volume to be formatted.
 * |filesystem| Filesystem type to be formatted to. |volumeLabel| Label of the
 * drive after formatting.
 * @param {string} volumeId
 * @param {!chrome.fileManagerPrivate.FormatFileSystemType} filesystem
 * @param {string} volumeLabel
 */
chrome.fileManagerPrivate.formatVolume = function(volumeId, filesystem, volumeLabel) {};

/**
 * Deletes partitions of removable device, creates a new partition and format
 * it. |deviceStoragePath| Storage path of the device to be formatted.
 * |filesystem| Filesystem type to be formatted to. |volumeLabel| Label of the
 * drive after formatting.
 * @param {string} deviceStoragePath
 * @param {!chrome.fileManagerPrivate.FormatFileSystemType} filesystem
 * @param {string} volumeLabel
 */
chrome.fileManagerPrivate.singlePartitionFormat = function(deviceStoragePath, filesystem, volumeLabel) {};

/**
 * Renames a mounted volume. |volumeId| ID of the volume to be renamed.
 * |newName| New name of the target volume.
 * @param {string} volumeId
 * @param {string} newName
 */
chrome.fileManagerPrivate.renameVolume = function(volumeId, newName) {};

/**
 * Retrieves file manager preferences. |callback|
 * @param {function(!chrome.fileManagerPrivate.Preferences): void} callback
 */
chrome.fileManagerPrivate.getPreferences = function(callback) {};

/**
 * Sets file manager preferences. |changeInfo|
 * @param {!chrome.fileManagerPrivate.PreferencesChange} changeInfo
 */
chrome.fileManagerPrivate.setPreferences = function(changeInfo) {};

/**
 * Performs drive content search. |searchParams| |callback|
 * @param {!chrome.fileManagerPrivate.SearchParams} searchParams
 * @param {function(!Array<Entry>, string): void} callback |entries| |nextFeed|
 *     ID of the feed that contains next chunk of the search result.     Should
 *     be sent to the next searchDrive request to perform     incremental
 *     search.
 */
chrome.fileManagerPrivate.searchDrive = function(searchParams, callback) {};

/**
 * Performs drive metadata search. |searchParams| |callback|
 * @param {!chrome.fileManagerPrivate.SearchMetadataParams} searchParams
 * @param {function(!Array<!chrome.fileManagerPrivate.DriveMetadataSearchResult>): void}
 *     callback
 */
chrome.fileManagerPrivate.searchDriveMetadata = function(searchParams, callback) {};

/**
 * Search files in the volume having |volumeId| by using |hashList|.
 * @param {string} volumeId
 * @param {!Array<string>} hashList
 * @param {function(Object): void} callback |paths| A map of hash to array of
 *     drive paths. The array can be empty if the corresponding file is not
 *     found. However, the array will only contain at most one path per hash.
 */
chrome.fileManagerPrivate.searchFilesByHashes = function(volumeId, hashList, callback) {};

/**
 * Search files in My Files.
 * @param {!chrome.fileManagerPrivate.SearchMetadataParams} searchParams
 * @param {function(!Array<Entry>): void} callback
 */
chrome.fileManagerPrivate.searchFiles = function(searchParams, callback) {};

/**
 * Retrieves the current device connection status. |callback|
 * @param {function(!chrome.fileManagerPrivate.DeviceConnectionState): void}
 *     callback
 */
chrome.fileManagerPrivate.getDeviceConnectionState = function(callback) {};

/**
 * Retrieves the state of the current drive connection. |callback|
 * @param {function(!chrome.fileManagerPrivate.DriveConnectionState): void}
 *     callback
 */
chrome.fileManagerPrivate.getDriveConnectionState = function(callback) {};

/**
 * Checks whether the path name length fits in the limit of the filesystem.
 * |parentEntry| The entry of the parent directory entry. |name| The name of the
 * file. |callback| Called back when the check is finished.
 * @param {DirectoryEntry} parentEntry
 * @param {string} name
 * @param {function(boolean): void} callback |result| true if the length is in
 *     the valid range, false otherwise.
 */
chrome.fileManagerPrivate.validatePathNameLength = function(parentEntry, name, callback) {};

/**
 * Changes the zoom factor of the Files app. |operation| Zooming mode.
 * @param {!chrome.fileManagerPrivate.ZoomOperationType} operation
 */
chrome.fileManagerPrivate.zoom = function(operation) {};

/**
 * Obtains a list of profiles that are logged-in.
 * @param {function(!Array<!chrome.fileManagerPrivate.ProfileInfo>, string, string): void}
 *     callback |profiles| List of profile information. |runningProfile| ID of
 *     the profile that runs the application instance. |showingProfile| ID of
 *     the profile that shows the application window.
 */
chrome.fileManagerPrivate.getProfiles = function(callback) {};

/**
 * Opens inspector window. |type| InspectionType which specifies how to open
 * inspector.
 * @param {!chrome.fileManagerPrivate.InspectionType} type
 */
chrome.fileManagerPrivate.openInspector = function(type) {};

/**
 * Opens page in Settings window. |sub_page| Name of a sub_page to show.
 * @param {string} sub_page
 */
chrome.fileManagerPrivate.openSettingsSubpage = function(sub_page) {};

/**
 * Computes an MD5 checksum for the given file. |entry| The entry of the file to
 * checksum. |callback|
 * @param {Entry} entry
 * @param {function(string): void} callback |checksum| Result checksum.
 */
chrome.fileManagerPrivate.computeChecksum = function(entry, callback) {};

/**
 * Returns list of available providers.
 * @param {function(!Array<!chrome.fileManagerPrivate.Provider>): void} callback
 *     |extensions| List of providers.
 */
chrome.fileManagerPrivate.getProviders = function(callback) {};

/**
 * Requests adding a new provided file system. On failure, sets
 * $(ref:runtime.lastError).
 * @param {string} providerId
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.addProvidedFileSystem = function(providerId, callback) {};

/**
 * Requests configuring an existing volume. On failure, sets
 * $(ref:runtime.lastError).
 * @param {string} volumeId
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.configureVolume = function(volumeId, callback) {};

/**
 * Requests list of custom actions for the specified entries. On failure, sets
 * $(ref:runtime.lastError).
 * @param {!Array<Entry>} entries
 * @param {function(!Array<!chrome.fileManagerPrivate.FileSystemProviderAction>): void}
 *     callback |actions| List of actions.
 */
chrome.fileManagerPrivate.getCustomActions = function(entries, callback) {};

/**
 * Executes a custom action for a set of entries. On failure, sets
 * $(ref:runtime.lastError).
 * @param {!Array<Entry>} entries
 * @param {string} actionId
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.executeCustomAction = function(entries, actionId, callback) {};

/**
 * Get the total size of a directory. |entry| Entry of the target directory.
 * |callback|
 * @param {DirectoryEntry} entry
 * @param {function(number): void} callback |size| result size.
 */
chrome.fileManagerPrivate.getDirectorySize = function(entry, callback) {};

/**
 * Gets recently modified files across file systems. |restriction| Flag to
 * restrict sources of recent files. |fileType| Requested file type to filter
 * recent files. |callback|
 * @param {!chrome.fileManagerPrivate.SourceRestriction} restriction
 * @param {string} query
 * @param {!chrome.fileManagerPrivate.FileCategory} fileCategory
 * @param {boolean} invalidateCache
 * @param {function(!Array<Entry>): void} callback |entries| Recently modified
 *     entries.
 */
chrome.fileManagerPrivate.getRecentFiles = function(
    restriction, query, fileCategory, invalidateCache, callback) {};

/**
 * Requests the root directory of the volume with the ID specified in
 * |options.volumeId|.
 * @param {!chrome.fileManagerPrivate.GetVolumeRootOptions} options
 * @param {function(DirectoryEntry): void} callback |rootDir| The root directory
 *     of the volume to which access was requested.
 */
chrome.fileManagerPrivate.getVolumeRoot = function(options, callback) {};

/**
 * Starts and mounts crostini container. |callback|
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.mountCrostini = function(callback) {};

/**
 * Shares paths with crostini container. |vmName| VM to share path with.
 * |entries| Entries of the files or directories to share. |persist| If true,
 * shares will persist across restarts. |callback|
 * @param {string} vmName
 * @param {!Array<Entry>} entries
 * @param {boolean} persist
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.sharePathsWithCrostini = function(vmName, entries, persist, callback) {};

/**
 * Unshares path with crostini container. |vmName| VM to unshare path from.
 * |entry| Entry of the file or directory to unshare. |callback|
 * @param {string} vmName
 * @param {Entry} entry
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.unsharePathWithCrostini = function(vmName, entry, callback) {};

/**
 * Returns list of paths shared with crostini container.
 * |observeFirstForSession| If true, callback provides whether this is the
 * |vmName| VM to get shared paths of. first time this function has been called
 * with observeFirstForSession true.
 * @param {boolean} observeFirstForSession
 * @param {string} vmName
 * @param {function(!Array<Entry>, boolean): void} callback |entries| Entries
 *     shared with crostini container. |firstForSession| true the first time
 *     this is called for the session.
 */
chrome.fileManagerPrivate.getCrostiniSharedPaths = function(observeFirstForSession, vmName, callback) {};

/**
 * Requests information about a Linux package. |entry| is a .deb file.
 * @param {Entry} entry
 * @param {function(!chrome.fileManagerPrivate.LinuxPackageInfo): void} callback
 *     |linux_package_info| Package info for the queried package.
 */
chrome.fileManagerPrivate.getLinuxPackageInfo = function(entry, callback) {};

/**
 * Starts installation of a Linux package.
 * @param {Entry} entry
 * @param {function(!chrome.fileManagerPrivate.InstallLinuxPackageResponse, string): void}
 *     callback |status| Result of starting the install |failure_reason| Reason
 *     for failure for a 'failed' status
 */
chrome.fileManagerPrivate.installLinuxPackage = function(entry, callback) {};

/**
 * Imports a Crostini Image File (.tini). This overrides the existing Linux apps
 * and files.
 * @param {Entry} entry
 */
chrome.fileManagerPrivate.importCrostiniImage = function(entry) {};

/**
 * Returns a list of Android picker apps to be shown in file selector.
 * @param {!Array<string>} extensions
 * @param {function(!Array<!chrome.fileManagerPrivate.AndroidApp>): void}
 *     callback |apps| List of Android picker apps.
 */
chrome.fileManagerPrivate.getAndroidPickerApps = function(extensions, callback) {};

/**
 * Called when the user selects an Android picker app in file selector.
 * @param {!chrome.fileManagerPrivate.AndroidApp} androidApp
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.selectAndroidPickerApp = function(androidApp, callback) {};

/**
 * Return true if sharesheet contains share targets for entries. |entries| Array
 * of selected entries |callback| is called with error in case of failure and
 * with no arguments if successfully launched the Sharesheet dialog, but before
 * user has finished the sharing.
 * @param {!Array<Entry>} entries
 * @param {function(boolean): void} callback |result| Boolean result returned by
 *     the invoked function.
 */
chrome.fileManagerPrivate.sharesheetHasTargets = function(entries, callback) {};

/**
 * Invoke Sharesheet for selected files. |entries| Array of selected entries.
 * |launchSource| Source from which sharesheet was invoked. |dlpSourceUrls|
 * Array of source URLs corresponding to the entries, used to check Data Leak
 * Prevention (DLP) restrictions |callback|
 * @param {!Array<Entry>} entries
 * @param {!chrome.fileManagerPrivate.SharesheetLaunchSource} launchSource
 * @param {!Array<string>} dlpSourceUrls
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.invokeSharesheet = function(entries, launchSource, dlpSourceUrls, callback) {};

/**
 * Adds or removes a list of entries to temporary holding space. Any entries
 * whose current holding space state matches the intended state will be skipped.
 * |entries| The list of entries whose holding space needs to be updated. |add|
 * Whether items should be added or removed from the holding space. |callback|
 * Completion callback.
 * @param {!Array<Entry>} entries
 * @param {boolean} added
 * @param {function(): void=} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.toggleAddedToHoldingSpace = function(entries, added, callback) {};

/**
 * Retrieves the current holding space state, for example the list of items the
 * holding space currently contains. |callback| The result callback.
 * @param {function(!chrome.fileManagerPrivate.HoldingSpaceState): void}
 *     callback |state| Describes the current holding space state.
 */
chrome.fileManagerPrivate.getHoldingSpaceState = function(callback) {};

/**
 * Returns true via `callback` if tablet mode is enabled, false otherwise.
 * @param {function(boolean): void} callback |result| Boolean result returned by
 *     the invoked function.
 */
chrome.fileManagerPrivate.isTabletModeEnabled = function(callback) {};

/**
 * Notifies the browser of the result of a dialog displayed earlier as a result
 * of the onDriveConfirmDialog event.
 * @param {!chrome.fileManagerPrivate.DriveDialogResult} result
 */
chrome.fileManagerPrivate.notifyDriveDialogResult = function(result) {};

/**
 * Opens a new browser tab and navigates to `url`.
 * @param {string} url
 */
chrome.fileManagerPrivate.openURL = function(url) {};

/**
 * Creates a new Files app window in the directory provided in `params`.
 * @param {!chrome.fileManagerPrivate.OpenWindowParams} params
 * @param {function(boolean): void} callback |result| Boolean result returned by
 *     the invoked function.
 */
chrome.fileManagerPrivate.openWindow = function(params, callback) {};

/**
 * Opens the feedback report window.
 */
chrome.fileManagerPrivate.sendFeedback = function() {};

/**
 * Starts an I/O task of type |type| on |entries|. Task type specific parameters
 * are passed via |params|.
 * @param {!chrome.fileManagerPrivate.IOTaskType} type
 * @param {!Array<Entry>} entries
 * @param {!chrome.fileManagerPrivate.IOTaskParams} params
 * @param {function(number): void=} callback |taskId| ID of the task that was
 *     started. Can be used to cancel ongoing task.
 */
chrome.fileManagerPrivate.startIOTask = function(type, entries, params, callback) {};

/**
 * Cancels an I/O task by id. Task ids are communicated to the Files App in each
 * I/O task's progress status.
 * @param {number} taskId
 */
chrome.fileManagerPrivate.cancelIOTask = function(taskId) {};

/**
 * Resumes an I/O task by id. Task ids are communicated to the Files App in each
 * I/O task's progress status.
 * @param {number} taskId
 * @param {!chrome.fileManagerPrivate.ResumeParams} params
 */
chrome.fileManagerPrivate.resumeIOTask = function(taskId, params) {};

/**
 * Notifies the browser that any info still stored about an already completed
 * I/O task identified by |taskId| can be cleared.
 * @param {number} taskId
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.dismissIOTask = function(taskId, callback) {};

/**
 * Shows a policy dialog for a task. Task ids are communicated to the Files App
 * in each I/O task's progress status.
 * @param {number} taskId
 * @param {!chrome.fileManagerPrivate.PolicyDialogType} type
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.showPolicyDialog = function(taskId, type, callback) {};

/**
 * Makes I/O tasks in state::PAUSED emit (broadcast) their current I/O task
 * progress status.
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.progressPausedTasks = function(callback) {};

/**
 * Lists mountable Guest OSs.
 * @param {function(!Array<!chrome.fileManagerPrivate.MountableGuest>): void}
 *     callback |guests| List of Guest OSs which have available mounts.
 */
chrome.fileManagerPrivate.listMountableGuests = function(callback) {};

/**
 * Starts and mounts the target Guest OS. |callback|
 * @param {number} id
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.mountGuest = function(id, callback) {};

/**
 * Tells DriveFS to update its cached pin states of hosted files (once).
 */
chrome.fileManagerPrivate.pollDriveHostedFilePinStates = function() {};

/**
 * Opens the dialog to manage the currently syncing folders.
 */
chrome.fileManagerPrivate.openManageSyncSettings = function() {};

/**
 * Validates and parses the supplied `entries` as .trashinfo files.
 * @param {!Array<Entry>} entries
 * @param {function(!Array<!chrome.fileManagerPrivate.ParsedTrashInfoFile>): void}
 *     callback
 */
chrome.fileManagerPrivate.parseTrashInfoFiles = function(entries, callback) {};

/**
 * Returns the current progress of the bulk pinning manager.
 * @param {function(!chrome.fileManagerPrivate.BulkPinProgress): void} callback
 */
chrome.fileManagerPrivate.getBulkPinProgress = function(callback) {};

/**
 * Starts calculating the space required to pin all the items in a users My
 * drive.
 * @param {function(): void} callback Callback that does not take arguments.
 */
chrome.fileManagerPrivate.calculateBulkPinRequiredSpace = function(callback) {};

/**
 * @type {!ChromeEvent}
 */
chrome.fileManagerPrivate.onMountCompleted;

/**
 * @type {!ChromeEvent}
 */
chrome.fileManagerPrivate.onFileTransfersUpdated;

/**
 * @type {!ChromeEvent}
 */
chrome.fileManagerPrivate.onPinTransfersUpdated;

/**
 * @type {!ChromeEvent}
 */
chrome.fileManagerPrivate.onIndividualFileTransfersUpdated;

/**
 * @type {!ChromeEvent}
 */
chrome.fileManagerPrivate.onDirectoryChanged;

/**
 * @type {!ChromeEvent}
 */
chrome.fileManagerPrivate.onPreferencesChanged;

/**
 * @type {!ChromeEvent}
 */
chrome.fileManagerPrivate.onDeviceConnectionStatusChanged;

/**
 * @type {!ChromeEvent}
 */
chrome.fileManagerPrivate.onDriveConnectionStatusChanged;

/**
 * @type {!ChromeEvent}
 */
chrome.fileManagerPrivate.onDeviceChanged;

/**
 * @type {!ChromeEvent}
 */
chrome.fileManagerPrivate.onDriveSyncError;

/**
 * @type {!ChromeEvent}
 */
chrome.fileManagerPrivate.onDriveConfirmDialog;

/**
 * @type {!ChromeEvent}
 */
chrome.fileManagerPrivate.onAppsUpdated;

/**
 * @type {!ChromeEvent}
 */
chrome.fileManagerPrivate.onCrostiniChanged;

/**
 * @type {!ChromeEvent}
 */
chrome.fileManagerPrivate.onTabletModeChanged;

/**
 * @type {!ChromeEvent}
 */
chrome.fileManagerPrivate.onIOTaskProgressStatus;

/**
 * Event broadcast when the list of Guest OSs that support Guest->Host file
 * sharing changes.
 * @type {!ChromeEvent}
 */
chrome.fileManagerPrivate.onMountableGuestsChanged;

/**
 * @type {!ChromeEvent}
 */
chrome.fileManagerPrivate.onBulkPinProgress;
