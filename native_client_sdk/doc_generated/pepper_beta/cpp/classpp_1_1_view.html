{{+bindTo:partials.standard_nacl_api}}
<h1>pp::View Class Reference</h1>
<div id="doxygen-ref">
{{- dummy div to appease doxygen -}}
  <div>
<!-- Generated by Doxygen 1.7.6.1 -->



</div>
<!--header-->
<div class="contents">
<!-- doxytag: class="pp::View" --><!-- doxytag: inherits="pp::Resource" --><div class="dynheader">
Inheritance diagram for pp::View:</div>
<div class="dyncontent">
<div class="center"><img src="classpp_1_1_view__inherit__graph.png" border="0" usemap="#pp_1_1_view_inherit__map" alt="Inheritance graph" /></div>
<map name="pp_1_1_view_inherit__map" id="pp_1_1_view_inherit__map">
<area shape="rect" id="node2" href="classpp_1_1_resource.html" title="A reference counted module resource." alt="" coords="5,5,109,32"></area></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<p><a href="classpp_1_1_view-members.html">List of all members.</a></p>
<h2>
Public Member Functions</h2><table class="memberdecls">

<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_view.html#aebcd4ab8818a6e1dfe68e2c435823ad9">View</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_view.html#a89cc79b6731f0e67d0821fe83b3e64fb">View</a> (PP_Resource view_resource)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpp_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_view.html#a37996c51fa6cc2dc25783461ecde0bb9">GetRect</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_view.html#a2ae3a19ade644199982a2d09c6dd5c11">IsFullscreen</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_view.html#aff1f9900e594167a276a624e52e5ac4c">IsVisible</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_view.html#a30a0919ba5e4209ef52207375c5fc5f6">IsPageVisible</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpp_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_view.html#aff9a53367325d9138ab7d9cd39e40ce2">GetClipRect</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_view.html#a52759c57da28a6c06a5da23d28519287">GetDeviceScale</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_view.html#a42d5b4ab4ffed3f020d3fd303a14a9dd">GetCSSScale</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpp_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_view.html#abdad2f4e5b9b07376d590785c91ea356">GetScrollOffset</a> () const </td></tr>
</table>
<hr /><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class represents the state of the view for an instance and contains functions for retrieving the current state of that view. </p>
</div><hr /><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aebcd4ab8818a6e1dfe68e2c435823ad9"></a><!-- doxytag: member="pp::View::View" ref="aebcd4ab8818a6e1dfe68e2c435823ad9" args="()" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_view.html#aebcd4ab8818a6e1dfe68e2c435823ad9">pp::View::View</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Default constructor for creating an <a class="el" href="classpp_1_1_resource.html#a859068e34cdc2dc0b78754c255323aa9" title="This functions determines if this resource is invalid or uninitialized.">is_null()</a> <code><a class="el" href="classpp_1_1_view.html" title="This class represents the state of the view for an instance and contains functions for retrieving the...">View</a></code> object. </p>
</div>
</div>
<a class="anchor" id="a89cc79b6731f0e67d0821fe83b3e64fb"></a><!-- doxytag: member="pp::View::View" ref="a89cc79b6731f0e67d0821fe83b3e64fb" args="(PP_Resource view_resource)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_view.html#aebcd4ab8818a6e1dfe68e2c435823ad9">pp::View::View</a> </td>
<td>(</td>
<td class="paramtype">PP_Resource&#160;</td>
<td class="paramname"><em>view_resource</em></td><td>)</td>
<td><code> [explicit]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Creates a <a class="el" href="classpp_1_1_view.html" title="This class represents the state of the view for an instance and contains functions for retrieving the...">View</a> resource, taking and holding an additional reference to the given resource handle. </p>
</div>
</div>
<hr /><h2>Member Function Documentation</h2>
<a class="anchor" id="aff9a53367325d9138ab7d9cd39e40ce2"></a><!-- doxytag: member="pp::View::GetClipRect" ref="aff9a53367325d9138ab7d9cd39e40ce2" args="() const " -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_rect.html">Rect</a> <a class="el" href="classpp_1_1_view.html#aff9a53367325d9138ab7d9cd39e40ce2">pp::View::GetClipRect</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_view.html#aff9a53367325d9138ab7d9cd39e40ce2" title="GetClipRect() returns the clip rectangle relative to the upper-left corner of the module instance...">GetClipRect()</a> returns the clip rectangle relative to the upper-left corner of the module instance. </p>
<p>This rectangle indicates the portions of the module instance that are scrolled into view.</p>
<p>If the module instance is scrolled off the view, the return value will be (0, 0, 0, 0). This clip rectangle does <em>not</em> take into account page visibility. Therefore, if the module instance is scrolled into view, but the page itself is on a tab that is not visible, the return rectangle will contain the visible rectangle as though the page were visible. Refer to <a class="el" href="classpp_1_1_view.html#a30a0919ba5e4209ef52207375c5fc5f6" title="IsPageVisible() determines if the page that contains the module instance is visible.">IsPageVisible()</a> and <a class="el" href="classpp_1_1_view.html#aff1f9900e594167a276a624e52e5ac4c" title="IsVisible() determines whether the module instance might be visible to the user.">IsVisible()</a> if you want to account for page visibility.</p>
<p>Most applications will not need to worry about the clip rectangle. The recommended behavior is to do full updates if the module instance is visible, as determined by <a class="el" href="classpp_1_1_view.html#aff1f9900e594167a276a624e52e5ac4c" title="IsVisible() determines whether the module instance might be visible to the user.">IsVisible()</a>, and do no updates if it is not visible.</p>
<p>However, if the cost for computing pixels is very high for your application, or the pages you're targeting frequently have very large module instances with small visible portions, you may wish to optimize further. In this case, the clip rectangle will tell you which parts of the module to update.</p>
<p>Note that painting of the page and sending of view changed updates happens asynchronously. This means when the user scrolls, for example, it is likely that the previous backing store of the module instance will be used for the first paint, and will be updated later when your application generates new content with the new clip. This may cause flickering at the boundaries when scrolling. If you do choose to do partial updates, you may want to think about what color the invisible portions of your backing store contain (be it transparent or some background color) or to paint a certain region outside the clip to reduce the visual distraction when this happens.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The rectangle representing the visible part of the module instance. If the resource is invalid, the empty rectangle is returned. </dd></dl>
</div>
</div>
<a class="anchor" id="a42d5b4ab4ffed3f020d3fd303a14a9dd"></a><!-- doxytag: member="pp::View::GetCSSScale" ref="a42d5b4ab4ffed3f020d3fd303a14a9dd" args="() const " -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">float <a class="el" href="classpp_1_1_view.html#a42d5b4ab4ffed3f020d3fd303a14a9dd">pp::View::GetCSSScale</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>GetCSSScale returns the scale factor between DIPs and CSS pixels. </p>
<p>This allows proper scaling between DIPs - as sent via the Pepper API - and CSS pixel coordinates used for Web content.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>float</code> value representing the number of DIPs per CSS pixel. </dd></dl>
</div>
</div>
<a class="anchor" id="a52759c57da28a6c06a5da23d28519287"></a><!-- doxytag: member="pp::View::GetDeviceScale" ref="a52759c57da28a6c06a5da23d28519287" args="() const " -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">float <a class="el" href="classpp_1_1_view.html#a52759c57da28a6c06a5da23d28519287">pp::View::GetDeviceScale</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>GetDeviceScale returns the scale factor between device pixels and DIPs (also known as logical pixels or UI pixels on some platforms). </p>
<p>This allows the developer to render their contents at device resolution, even as coordinates / sizes are given in DIPs through the API.</p>
<p>Note that the coordinate system for Pepper APIs is DIPs. Also note that one DIP might not equal one CSS pixel - when page scale/zoom is in effect.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>float</code> value representing the number of device pixels per DIP. </dd></dl>
</div>
</div>
<a class="anchor" id="a37996c51fa6cc2dc25783461ecde0bb9"></a><!-- doxytag: member="pp::View::GetRect" ref="a37996c51fa6cc2dc25783461ecde0bb9" args="() const " -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_rect.html">Rect</a> <a class="el" href="classpp_1_1_view.html#a37996c51fa6cc2dc25783461ecde0bb9">pp::View::GetRect</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_view.html#a37996c51fa6cc2dc25783461ecde0bb9" title="GetRect() retrieves the rectangle of the module instance associated with a view changed notification ...">GetRect()</a> retrieves the rectangle of the module instance associated with a view changed notification relative to the upper-left of the browser viewport. </p>
<p>This position changes when the page is scrolled.</p>
<p>The returned rectangle may not be inside the visible portion of the viewport if the module instance is scrolled off the page. Therefore, the position may be negative or larger than the size of the page. The size will always reflect the size of the module were it to be scrolled entirely into view.</p>
<p>In general, most modules will not need to worry about the position of the module instance in the viewport, and only need to use the size.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The rectangle of the instance. The default return value for an invalid <a class="el" href="classpp_1_1_view.html" title="This class represents the state of the view for an instance and contains functions for retrieving the...">View</a> is the empty rectangle. </dd></dl>
</div>
</div>
<a class="anchor" id="abdad2f4e5b9b07376d590785c91ea356"></a><!-- doxytag: member="pp::View::GetScrollOffset" ref="abdad2f4e5b9b07376d590785c91ea356" args="() const " -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_point.html">Point</a> <a class="el" href="classpp_1_1_view.html#abdad2f4e5b9b07376d590785c91ea356">pp::View::GetScrollOffset</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div>
<div class="memdoc">
<p>GetScrollOffset returns the scroll offset of the window containing the plugin. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="classpp_1_1_point.html" title="A 2 dimensional point with 0,0 being the upper-left starting coordinate.">Point</a></code> which is set to the value of the scroll offset in CSS pixels. </dd></dl>
</div>
</div>
<a class="anchor" id="a2ae3a19ade644199982a2d09c6dd5c11"></a><!-- doxytag: member="pp::View::IsFullscreen" ref="a2ae3a19ade644199982a2d09c6dd5c11" args="() const " -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool <a class="el" href="classpp_1_1_view.html#a2ae3a19ade644199982a2d09c6dd5c11">pp::View::IsFullscreen</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_view.html#a2ae3a19ade644199982a2d09c6dd5c11" title="IsFullscreen() returns whether the instance is currently displaying in fullscreen mode...">IsFullscreen()</a> returns whether the instance is currently displaying in fullscreen mode. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the instance is in full screen mode, or <code>false</code> if it's not or the resource is invalid. </dd></dl>
</div>
</div>
<a class="anchor" id="a30a0919ba5e4209ef52207375c5fc5f6"></a><!-- doxytag: member="pp::View::IsPageVisible" ref="a30a0919ba5e4209ef52207375c5fc5f6" args="() const " -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool <a class="el" href="classpp_1_1_view.html#a30a0919ba5e4209ef52207375c5fc5f6">pp::View::IsPageVisible</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_view.html#a30a0919ba5e4209ef52207375c5fc5f6" title="IsPageVisible() determines if the page that contains the module instance is visible.">IsPageVisible()</a> determines if the page that contains the module instance is visible. </p>
<p>The most common cause of invisible pages is that the page is in a background tab in the browser.</p>
<p>Most applications should use <a class="el" href="classpp_1_1_view.html#aff1f9900e594167a276a624e52e5ac4c" title="IsVisible() determines whether the module instance might be visible to the user.">IsVisible()</a> instead of this function since the module instance could be scrolled off of a visible page, and this function will still return true. However, depending on how your module interacts with the page, there may be certain updates that you may want to perform when the page is visible even if your specific module instance is not visible.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the instance might be visible to the user, <code>false</code> if it is definitely not visible. </dd></dl>
</div>
</div>
<a class="anchor" id="aff1f9900e594167a276a624e52e5ac4c"></a><!-- doxytag: member="pp::View::IsVisible" ref="aff1f9900e594167a276a624e52e5ac4c" args="() const " -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool <a class="el" href="classpp_1_1_view.html#aff1f9900e594167a276a624e52e5ac4c">pp::View::IsVisible</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="classpp_1_1_view.html#aff1f9900e594167a276a624e52e5ac4c" title="IsVisible() determines whether the module instance might be visible to the user.">IsVisible()</a> determines whether the module instance might be visible to the user. </p>
<p>For example, the Chrome window could be minimized or another window could be over it. In both of these cases, the module instance would not be visible to the user, but <a class="el" href="classpp_1_1_view.html#aff1f9900e594167a276a624e52e5ac4c" title="IsVisible() determines whether the module instance might be visible to the user.">IsVisible()</a> will return true.</p>
<p>Use the result to speed up or stop updates for invisible module instances.</p>
<p>This function performs the duties of <a class="el" href="classpp_1_1_view.html#a37996c51fa6cc2dc25783461ecde0bb9" title="GetRect() retrieves the rectangle of the module instance associated with a view changed notification ...">GetRect()</a> (determining whether the module instance is scrolled into view and the clip rectangle is nonempty) and <a class="el" href="classpp_1_1_view.html#a30a0919ba5e4209ef52207375c5fc5f6" title="IsPageVisible() determines if the page that contains the module instance is visible.">IsPageVisible()</a> (whether the page is visible to the user).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the instance might be visible to the user, <code>false</code> if it is definitely not visible. </dd></dl>
</div>
</div>
<hr />The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="view_8h.html">view.h</a></li>
</ul>
</div><!-- contents -->
</div>
{{/partials.standard_nacl_api}}
