{{+bindTo:partials.standard_nacl_api}}
<h1>PPB_Graphics2D Struct Reference</h1>
<div id="doxygen-ref">
{{- dummy div to appease doxygen -}}
  <div>
<!-- Generated by Doxygen 1.7.6.1 -->


</div>
<!--header-->
<div class="contents">
<!-- doxytag: class="PPB_Graphics2D" --><h2>
Data Fields</h2><table class="memberdecls">

<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a10e02f41b41c26bb88398b591f06ff12">Create</a> )(<a class="el" href="group___typedefs.html#ga89b662403e6a687bb914b80114c0d19d">PP_Instance</a> instance, const struct <a class="el" href="struct_p_p___size.html">PP_Size</a> *size, <a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a> is_always_opaque)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#acae7c38863e9997fc0eee88a54d3d60d">IsGraphics2D</a> )(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> resource)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a49dcb387e7e420bdd1c22344f3f35718">Describe</a> )(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> graphics_2d, struct <a class="el" href="struct_p_p___size.html">PP_Size</a> *size, <a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a> *is_always_opaque)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a20071a446e8d7695c697f81a449597fe">PaintImageData</a> )(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> graphics_2d, <a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> image_data, const struct <a class="el" href="struct_p_p___point.html">PP_Point</a> *top_left, const struct <a class="el" href="struct_p_p___rect.html">PP_Rect</a> *src_rect)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a3f87a2d280d6d4e6b9a2679787f5de1d">Scroll</a> )(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> graphics_2d, const struct <a class="el" href="struct_p_p___rect.html">PP_Rect</a> *clip_rect, const struct <a class="el" href="struct_p_p___point.html">PP_Point</a> *amount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a533a03163e1617692885aca78e72905a">ReplaceContents</a> )(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> graphics_2d, <a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> image_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a65dfb539bd057e33977a78537564885e">Flush</a> )(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> graphics_2d, struct <a class="el" href="struct_p_p___completion_callback.html">PP_CompletionCallback</a> callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a4b16d1210b49c45edfe477396934238a">SetScale</a> )(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> resource, float scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#aa2820c6356e60627a175942ddd265753">GetScale</a> )(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> resource)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#af7d4955738f54da9eda60e5c052bf361">SetLayerTransform</a> )(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> resource, float scale, const struct <a class="el" href="struct_p_p___point.html">PP_Point</a> *origin, const struct <a class="el" href="struct_p_p___point.html">PP_Point</a> *translate)</td></tr>
</table>
<hr /><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><code>PPB_Graphics2D</code> defines the interface for a 2D graphics context. </p>
</div><hr /><h2>Field Documentation</h2>
<a class="anchor" id="a10e02f41b41c26bb88398b591f06ff12"></a><!-- doxytag: member="PPB_Graphics2D::Create" ref="a10e02f41b41c26bb88398b591f06ff12" args=")(PP_Instance instance, const struct PP_Size *size, PP_Bool is_always_opaque)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a>(* <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a10e02f41b41c26bb88398b591f06ff12">PPB_Graphics2D::Create</a>)(<a class="el" href="group___typedefs.html#ga89b662403e6a687bb914b80114c0d19d">PP_Instance</a> instance, const struct <a class="el" href="struct_p_p___size.html">PP_Size</a> *size, <a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a> is_always_opaque)</td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a10e02f41b41c26bb88398b591f06ff12" title="Create() creates a 2D graphics context.">Create()</a> creates a 2D graphics context. </p>
<p>The returned graphics context will not be bound to the module instance on creation (call BindGraphics() on the module instance to bind the returned graphics context to the module instance).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>The module instance. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the graphic context. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">is_always_opaque</td><td>Set the <code>is_always_opaque</code> flag to <code>PP_TRUE</code> if you know that you will be painting only opaque data to this context. This option will disable blending when compositing the module with the web page, which might give higher performance on some computers.</td></tr>
</table>
</dd>
</dl>
<p>If you set <code>is_always_opaque</code>, your alpha channel should always be set to 0xFF or there may be painting artifacts. The alpha values overwrite the destination alpha values without blending when <code>is_always_opaque</code> is true.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>PP_Resource</code> containing the 2D graphics context if successful or 0 if unsuccessful. </dd></dl>
</div>
</div>
<a class="anchor" id="a49dcb387e7e420bdd1c22344f3f35718"></a><!-- doxytag: member="PPB_Graphics2D::Describe" ref="a49dcb387e7e420bdd1c22344f3f35718" args=")(PP_Resource graphics_2d, struct PP_Size *size, PP_Bool *is_always_opaque)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a>(* <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a49dcb387e7e420bdd1c22344f3f35718">PPB_Graphics2D::Describe</a>)(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> graphics_2d, struct <a class="el" href="struct_p_p___size.html">PP_Size</a> *size, <a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a> *is_always_opaque)</td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a49dcb387e7e420bdd1c22344f3f35718" title="Describe() retrieves the configuration for the given graphics context, filling the given values (whic...">Describe()</a> retrieves the configuration for the given graphics context, filling the given values (which must not be <code>NULL</code>). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">resource</td><td>The 2D Graphics resource. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">size</td><td>The size of the 2D graphics context in the browser. </td></tr>
<tr><td class="paramdir">[in,out]</td><td class="paramname">is_always_opaque</td><td>Identifies whether only opaque data will be painted.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>PP_TRUE</code> on success or <code>PP_FALSE</code> if the resource is invalid. The output parameters will be set to 0 on a <code>PP_FALSE</code>. </dd></dl>
</div>
</div>
<a class="anchor" id="a65dfb539bd057e33977a78537564885e"></a><!-- doxytag: member="PPB_Graphics2D::Flush" ref="a65dfb539bd057e33977a78537564885e" args=")(PP_Resource graphics_2d, struct PP_CompletionCallback callback)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t(* <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a65dfb539bd057e33977a78537564885e">PPB_Graphics2D::Flush</a>)(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> graphics_2d, struct <a class="el" href="struct_p_p___completion_callback.html">PP_CompletionCallback</a> callback)</td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a65dfb539bd057e33977a78537564885e" title="Flush() flushes any enqueued paint, scroll, and replace commands to the backing store.">Flush()</a> flushes any enqueued paint, scroll, and replace commands to the backing store. </p>
<p>This function actually executes the updates, and causes a repaint of the webpage, assuming this graphics context is bound to a module instance.</p>
<p><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a65dfb539bd057e33977a78537564885e" title="Flush() flushes any enqueued paint, scroll, and replace commands to the backing store.">Flush()</a> runs in asynchronous mode. Specify a callback function and the argument for that callback function. The callback function will be executed on the calling thread when the image has been painted to the screen. While you are waiting for a flush callback, additional calls to <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a65dfb539bd057e33977a78537564885e" title="Flush() flushes any enqueued paint, scroll, and replace commands to the backing store.">Flush()</a> will fail.</p>
<p>Because the callback is executed (or thread unblocked) only when the instance's image is actually on the screen, this function provides a way to rate limit animations. By waiting until the image is on the screen before painting the next frame, you can ensure you're not flushing 2D graphics faster than the screen can be updated.</p>
<p><b>Unbound contexts</b> If the context is not bound to a module instance, you will still get a callback. The callback will execute after <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a65dfb539bd057e33977a78537564885e" title="Flush() flushes any enqueued paint, scroll, and replace commands to the backing store.">Flush()</a> returns to avoid reentrancy. The callback will not wait until anything is painted to the screen because there will be nothing on the screen. The timing of this callback is not guaranteed and may be deprioritized by the browser because it is not affecting the user experience.</p>
<p><b>Off-screen instances</b> If the context is bound to an instance that is currently not visible (for example, scrolled out of view) it will behave like the "unbound context" case.</p>
<p><b>Detaching a context</b> If you detach a context from a module instance, any pending flush callbacks will be converted into the "unbound context" case.</p>
<p><b>Released contexts</b> A callback may or may not get called even if you have released all of your references to the context. This scenario can occur if there are internal references to the context suggesting it has not been internally destroyed (for example, if it is still bound to an instance) or due to other implementation details. As a result, you should be careful to check that flush callbacks are for the context you expect and that you're capable of handling callbacks for unreferenced contexts.</p>
<p><b>Shutdown</b> If a module instance is removed when a flush is pending, the callback will not be executed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graphics_2d</td><td>The 2D Graphics resource. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A <code>CompletionCallback</code> to be called when the image has been painted on the screen.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>PP_OK</code> on success or <code>PP_ERROR_BADRESOURCE</code> if the graphics context is invalid, <code>PP_ERROR_BADARGUMENT</code> if the callback is null and flush is being called from the main thread of the module, or <code>PP_ERROR_INPROGRESS</code> if a flush is already pending that has not issued its callback yet. In the failure case, nothing will be updated and no callback will be scheduled. </dd></dl>
</div>
</div>
<a class="anchor" id="aa2820c6356e60627a175942ddd265753"></a><!-- doxytag: member="PPB_Graphics2D::GetScale" ref="aa2820c6356e60627a175942ddd265753" args=")(PP_Resource resource)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">float(* <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#aa2820c6356e60627a175942ddd265753">PPB_Graphics2D::GetScale</a>)(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> resource)</td>
</tr>
</table>
</div>
<div class="memdoc">
</div>
</div>
<a class="anchor" id="acae7c38863e9997fc0eee88a54d3d60d"></a><!-- doxytag: member="PPB_Graphics2D::IsGraphics2D" ref="acae7c38863e9997fc0eee88a54d3d60d" args=")(PP_Resource resource)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a>(* <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#acae7c38863e9997fc0eee88a54d3d60d">PPB_Graphics2D::IsGraphics2D</a>)(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> resource)</td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#acae7c38863e9997fc0eee88a54d3d60d" title="IsGraphics2D() determines if the given resource is a valid Graphics2D.">IsGraphics2D()</a> determines if the given resource is a valid <code>Graphics2D</code>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">resource</td><td>A <code>Graphics2D</code> context resource.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PP_TRUE if the given resource is a valid <code>Graphics2D</code>, <code>PP_FALSE</code> if it is an invalid resource or is a resource of another type. </dd></dl>
</div>
</div>
<a class="anchor" id="a20071a446e8d7695c697f81a449597fe"></a><!-- doxytag: member="PPB_Graphics2D::PaintImageData" ref="a20071a446e8d7695c697f81a449597fe" args=")(PP_Resource graphics_2d, PP_Resource image_data, const struct PP_Point *top_left, const struct PP_Rect *src_rect)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void(* <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a20071a446e8d7695c697f81a449597fe">PPB_Graphics2D::PaintImageData</a>)(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> graphics_2d, <a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> image_data, const struct <a class="el" href="struct_p_p___point.html">PP_Point</a> *top_left, const struct <a class="el" href="struct_p_p___rect.html">PP_Rect</a> *src_rect)</td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a20071a446e8d7695c697f81a449597fe" title="PaintImageData() enqueues a paint of the given image into the context.">PaintImageData()</a> enqueues a paint of the given image into the context. </p>
<p>This function has no effect until you call <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a65dfb539bd057e33977a78537564885e" title="Flush() flushes any enqueued paint, scroll, and replace commands to the backing store.">Flush()</a> As a result, what counts is the contents of the bitmap when you call <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a65dfb539bd057e33977a78537564885e" title="Flush() flushes any enqueued paint, scroll, and replace commands to the backing store.">Flush()</a>, not when you call this function.</p>
<p>The provided image will be placed at <code>top_left</code> from the top left of the context's internal backing store. Then the pixels contained in <code>src_rect</code> will be copied into the backing store. This means that the rectangle being painted will be at <code>src_rect</code> offset by <code>top_left</code>.</p>
<p>The <code>src_rect</code> is specified in the coordinate system of the image being painted, not the context. For the common case of copying the entire image, you may specify an empty <code>src_rect</code>.</p>
<p>The painted area of the source bitmap must fall entirely within the context. Attempting to paint outside of the context will result in an error. However, the source bitmap may fall outside the context, as long as the <code>src_rect</code> subset of it falls entirely within the context.</p>
<p>There are two methods most modules will use for painting. The first method is to generate a new <code>ImageData</code> and then paint it. In this case, you'll set the location of your painting to <code>top_left</code> and set <code>src_rect</code> to <code>NULL</code>. The second is that you're generating small invalid regions out of a larger bitmap representing your entire instance. In this case, you would set the location of your image to (0,0) and then set <code>src_rect</code> to the pixels you changed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">resource</td><td>The 2D Graphics resource. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The <code>ImageData</code> to be painted. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">top_left</td><td>A <code>Point</code> representing the <code>top_left</code> location where the <code>ImageData</code> will be painted. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">src_rect</td><td>The rectangular area where the <code>ImageData</code> will be painted. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a533a03163e1617692885aca78e72905a"></a><!-- doxytag: member="PPB_Graphics2D::ReplaceContents" ref="a533a03163e1617692885aca78e72905a" args=")(PP_Resource graphics_2d, PP_Resource image_data)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void(* <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a533a03163e1617692885aca78e72905a">PPB_Graphics2D::ReplaceContents</a>)(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> graphics_2d, <a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> image_data)</td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a533a03163e1617692885aca78e72905a" title="ReplaceContents() provides a slightly more efficient way to paint the entire module's image...">ReplaceContents()</a> provides a slightly more efficient way to paint the entire module's image. </p>
<p>Normally, calling <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a20071a446e8d7695c697f81a449597fe" title="PaintImageData() enqueues a paint of the given image into the context.">PaintImageData()</a> requires that the browser copy the pixels out of the image and into the graphics context's backing store. This function replaces the graphics context's backing store with the given image, avoiding the copy.</p>
<p>The new image must be the exact same size as this graphics context. If the new image uses a different image format than the browser's native bitmap format (use <code><a class="el" href="struct_p_p_b___image_data__1__0.html#adba78e8f9e623809b6b23419dbce4d65" title="GetNativeImageDataFormat() returns the browser's preferred format for image data.">PPB_ImageData.GetNativeImageDataFormat()</a></code> to retrieve the format), then a conversion will be done inside the browser which may slow the performance a little bit.</p>
<p><b>Note:</b> The new image will not be painted until you call <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a65dfb539bd057e33977a78537564885e" title="Flush() flushes any enqueued paint, scroll, and replace commands to the backing store.">Flush()</a>.</p>
<p>After this call, you should take care to release your references to the image. If you paint to the image after <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a533a03163e1617692885aca78e72905a" title="ReplaceContents() provides a slightly more efficient way to paint the entire module's image...">ReplaceContents()</a>, there is the possibility of significant painting artifacts because the page might use partially-rendered data when copying out of the backing store.</p>
<p>In the case of an animation, you will want to allocate a new image for the next frame. It is best if you wait until the flush callback has executed before allocating this bitmap. This gives the browser the option of caching the previous backing store and handing it back to you (assuming the sizes match). In the optimal case, this means no bitmaps are allocated during the animation, and the backing store and "front buffer" (which the plugin is painting into) are just being swapped back and forth.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graphics_2d</td><td>The 2D Graphics resource. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The <code>ImageData</code> to be painted. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a3f87a2d280d6d4e6b9a2679787f5de1d"></a><!-- doxytag: member="PPB_Graphics2D::Scroll" ref="a3f87a2d280d6d4e6b9a2679787f5de1d" args=")(PP_Resource graphics_2d, const struct PP_Rect *clip_rect, const struct PP_Point *amount)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void(* <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a3f87a2d280d6d4e6b9a2679787f5de1d">PPB_Graphics2D::Scroll</a>)(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> graphics_2d, const struct <a class="el" href="struct_p_p___rect.html">PP_Rect</a> *clip_rect, const struct <a class="el" href="struct_p_p___point.html">PP_Point</a> *amount)</td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a3f87a2d280d6d4e6b9a2679787f5de1d" title="Scroll() enqueues a scroll of the context's backing store.">Scroll()</a> enqueues a scroll of the context's backing store. </p>
<p>This function has no effect until you call <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a65dfb539bd057e33977a78537564885e" title="Flush() flushes any enqueued paint, scroll, and replace commands to the backing store.">Flush()</a>. The data within the provided clipping rectangle will be shifted by (dx, dy) pixels.</p>
<p>This function will result in some exposed region which will have undefined contents. The module should call <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a20071a446e8d7695c697f81a449597fe" title="PaintImageData() enqueues a paint of the given image into the context.">PaintImageData()</a> on these exposed regions to give the correct contents.</p>
<p>The scroll can be larger than the area of the clipping rectangle, which means the current image will be scrolled out of the rectangle. This scenario is not an error but will result in a no-op.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graphics_2d</td><td>The 2D Graphics resource. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">clip</td><td>The clipping rectangle. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">amount</td><td>The amount the area in the clipping rectangle will shifted. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="af7d4955738f54da9eda60e5c052bf361"></a><!-- doxytag: member="PPB_Graphics2D::SetLayerTransform" ref="af7d4955738f54da9eda60e5c052bf361" args=")(PP_Resource resource, float scale, const struct PP_Point *origin, const struct PP_Point *translate)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a>(* <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#af7d4955738f54da9eda60e5c052bf361">PPB_Graphics2D::SetLayerTransform</a>)(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> resource, float scale, const struct <a class="el" href="struct_p_p___point.html">PP_Point</a> *origin, const struct <a class="el" href="struct_p_p___point.html">PP_Point</a> *translate)</td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#af7d4955738f54da9eda60e5c052bf361" title="SetLayerTransform() sets a transformation factor that will be applied for the current graphics contex...">SetLayerTransform()</a> sets a transformation factor that will be applied for the current graphics context displayed on the output device. </p>
<p>If both SetScale and SetLayerTransform will be used, they are going to get combined for the final result.</p>
<p>This function has no effect until you call <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a65dfb539bd057e33977a78537564885e" title="Flush() flushes any enqueued paint, scroll, and replace commands to the backing store.">Flush()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>The scale to be applied. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>The origin of the scale. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">translate</td><td>The translation to be applied.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>PP_TRUE</code> on success or <code>PP_FALSE</code> if the resource is invalid or the scale factor is 0 or less. </dd></dl>
</div>
</div>
<a class="anchor" id="a4b16d1210b49c45edfe477396934238a"></a><!-- doxytag: member="PPB_Graphics2D::SetScale" ref="a4b16d1210b49c45edfe477396934238a" args=")(PP_Resource resource, float scale)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="group___enums.html#ga4f272d99be14aacafe08dfd4ef830918">PP_Bool</a>(* <a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a4b16d1210b49c45edfe477396934238a">PPB_Graphics2D::SetScale</a>)(<a class="el" href="group___typedefs.html#gafdc3895ee80f4750d0d95ae1b677e9b7">PP_Resource</a> resource, float scale)</td>
</tr>
</table>
</div>
<div class="memdoc">
<p><a class="el" href="struct_p_p_b___graphics2_d__1__2.html#a4b16d1210b49c45edfe477396934238a" title="SetScale() sets the scale factor that will be applied when painting the graphics context onto the out...">SetScale()</a> sets the scale factor that will be applied when painting the graphics context onto the output device. </p>
<p>Typically, if rendering at device resolution is desired, the context would be created with the width and height scaled up by the view's GetDeviceScale and SetScale called with a scale of 1.0 / GetDeviceScale(). For example, if the view resource passed to DidChangeView has a rectangle of (w=200, h=100) and a device scale of 2.0, one would call Create with a size of (w=400, h=200) and then call SetScale with 0.5. One would then treat each pixel in the context as a single device pixel.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">resource</td><td>A <code>Graphics2D</code> context resource. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>The scale to apply when painting.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>PP_TRUE</code> on success or <code>PP_FALSE</code> if the resource is invalid or the scale factor is 0 or less. </dd></dl>
</div>
</div>
<hr />The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="ppb__graphics__2d_8h.html">ppb_graphics_2d.h</a></li>
</ul>
</div><!-- contents -->
</div>
{{/partials.standard_nacl_api}}
