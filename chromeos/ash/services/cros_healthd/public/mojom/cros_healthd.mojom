// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// API exposed by the cros_healthd daemon. This API is normally consumed by the
// browser and the telem and diag command-line tools.

// NOTE: This mojom should be kept in sync with the copy in Chromium OS's repo
// in src/platform2/diagnostics/mojom/public/cros_healthd.mojom.

module ash.cros_healthd.mojom;

import "chromeos/ash/services/cros_healthd/private/mojom/cros_healthd_internal.mojom";
import "chromeos/ash/services/cros_healthd/public/mojom/cros_healthd_diagnostics.mojom";
import "chromeos/ash/services/cros_healthd/public/mojom/cros_healthd_events.mojom";
import "chromeos/ash/services/cros_healthd/public/mojom/cros_healthd_exception.mojom";
import "chromeos/ash/services/cros_healthd/public/mojom/cros_healthd_probe.mojom";
import "chromeos/ash/services/cros_healthd/public/mojom/nullable_primitives.mojom";
import "chromeos/ash/services/cros_healthd/public/mojom/wilco_ec.mojom";
import "chromeos/services/network_health/public/mojom/network_diagnostics.mojom";
import "chromeos/services/network_health/public/mojom/network_health.mojom";

// Factory interface which allows remote ends to request implementations of the
// probe, diagnostics, or event services. Additionally, the browser can send
// network-related implementations to the cros_healthd daemon.
//
// NextMinVersion: 2, NextIndex: 7
interface CrosHealthdServiceFactory {
  // Returns a bound interface to the diagnostics service.
  GetDiagnosticsService@0(pending_receiver<CrosHealthdDiagnosticsService> service);
  // Returns a bound interface to the event service.
  GetEventService@1(pending_receiver<CrosHealthdEventService> service);
  // Returns a bound interface to the probe service.
  GetProbeService@2(pending_receiver<CrosHealthdProbeService> service);
  // Sends a bound interface to the Network Health service in Chrome.
  SendNetworkHealthService@3(
      pending_remote<
          chromeos.network_health.mojom.NetworkHealthService> remote);
  // Sends a NetworkDiagnosticsRoutines pending remote to the cros_healthd
  // daemon.
  SendNetworkDiagnosticsRoutines@4(
      pending_remote<
          chromeos.network_diagnostics.mojom.NetworkDiagnosticsRoutines>
              network_diagnostics_routines);
  // TODO(http://b/181133872): Move this service out of this interface
  // Returns a bound interface to the system service.
  GetSystemService@5(pending_receiver<CrosHealthdSystemService> service);
  // Sends a NetworkDiagnosticsRoutines pending remote to the cros_healthd
  // daemon.
  [MinVersion=1] SendChromiumDataCollector@6(
      pending_remote<
          ash.cros_healthd.internal.mojom.ChromiumDataCollector> remote);
};

// Diagnostics interface exposed by the cros_healthd daemon.
//
// NextMinVersion: 10, NextIndex: 45
[Stable]
interface CrosHealthdDiagnosticsService {
  // Returns an array of all diagnostic routines that the platform supports.
  GetAvailableRoutines@0()
      => (array<DiagnosticRoutineEnum> available_routines);

  // Sends commands to an existing routine. Also returns status information for
  // the routine.
  //
  // The request:
  // * |id| - specifies which routine the command will be sent to. This must be
  //          the same id that was returned from the RunSomeRoutine function
  //          call used to create the routine.
  // * |command| - command to send the routine.
  // * |include_output| - whether or not the response should include any output
  //                      accumulated from the routine.
  //
  // The response:
  // * |routine_update| - status information for the specified routine. See
  //                      cros_healthd_diagnostics.mojom for the structure.
  GetRoutineUpdate@1(int32 id, DiagnosticRoutineCommandEnum command,
                   bool include_output)
      => (RoutineUpdate routine_update);

  // Requests that the Urandom routine is created and started on the platform.
  // This routine attempts to continually read from /dev/urandom to stress the
  // cpu. The routine will pass iff all the reads from /dev/urandom succeed.
  // The availability of this routine can be determined by checking that
  // kUrandom is returned by GetAvailableRoutines.
  //
  // The request:
  // * |length_seconds| - length of time, in seconds, to run the urandom routine
  //                      for. If all reads from /dev/urandom for this length of
  //                      time are successful, then the test  will pass. This
  //                      parameter needs to be strictly greater than zero. If
  //                      not specified, the routine will default to 10 seconds.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunUrandomRoutine@2(NullableUint32? length_seconds)
      => (RunRoutineResponse response);

  // Requests that the BatteryCapacity routine is created and started on the
  // platform. This routine checks the battery's design capacity against inputs
  // configured in cros_config. If no configuration data is present in
  // cros_config, the routine will fall back to fleet-wide default values of
  // [1000, 10000]. The routine will pass iff the design capacity of the battery
  // read from the platform is inclusively within these bounds.
  // The availability of this routine can be determined by checking that
  // kBatteryCapacity is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunBatteryCapacityRoutine@3() => (RunRoutineResponse response);

  // Requests that the BatteryHealth routine is created and started on the
  // platform. This routine checks the cycle count and percent wear of the
  // battery against inputs configured in cros_config. If no configuration data
  // is present in cros_config, the routine will fall back to fleet-wide default
  // values of 1000 for the maximum allowable cycle count and 50% for maximum
  // battery wear percentage allowed.
  // The availability of this routine can be determined by checking that
  // kBatteryHealth is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunBatteryHealthRoutine@4() => (RunRoutineResponse response);

  // Requests that the SmartctlCheck routine is created and started on the
  // platform. This routine passes iff a NVMe drive's:
  // 1. Critical Warning == 0x00 (no warning)
  // 2. Available Spare >= Available Spare Threshold
  // 3. Percentage Used <= Percentage Used Threshold (from request)
  // In addition, above values are also returned in the output.
  // The availability of this routine can be determined by checking that
  // kSmartctlCheck (without |percentage_used_threshold|) or
  // kSmartctlCheckWithPercentageUsed (with |percentage_used_threshold|) is
  // returned by GetAvailableRoutines.
  //
  // The request:
  // * |percentage_used_threshold| - an optional threshold number in percentage,
  //                                 range [0, 255] inclusive, that the routine
  //                                 examines `percentage_used` against. If not
  //                                 specified, the routine will default to the
  //                                 max allowed value (255).
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunSmartctlCheckRoutine@5(
    [MinVersion=6] NullableUint32? percentage_used_threshold)
        => (RunRoutineResponse response);

  // Requests that the AcPower routine is created and started on the
  // platform. This routine checks the status of the power supply, and if
  // |expected_power_type| is specified, checks to see that
  // |expected_power_type| matches the type reported by the power supply.
  // The availability of this routine can be determined by checking that
  // kAcPower is returned by GetAvailableRoutines.
  //
  // The request:
  // * |expected_status| - whether or not the adapter is expected to be online.
  // * |expected_power_type| - if specified, must match the type of the power
  //                           supply for the routine to succeed.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunAcPowerRoutine@6(AcPowerStatusEnum expected_status,
                    string? expected_power_type)
      => (RunRoutineResponse response);

  // Requests that the CPU cache routine is created and started on the
  // platform. This routine runs the stressapptest to test the CPU caches.
  // The routine will pass if the stressapptest returns zero.
  // The availability of this routine can be determined by checking that
  // kCpuCache is returned by GetAvailableRoutines.
  //
  // The request:
  // * |length_seconds| - length of time, in seconds, to run the CPU cache
  //                      routine. This parameter needs to be strictly greater
  //                      than zero. If not specified, the routine will default
  //                      to 1 minute.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunCpuCacheRoutine@7(NullableUint32? length_seconds)
      => (RunRoutineResponse response);

  // Requests that the CPU stress routine is created and started on the
  // platform. This routine runs the stressapptest to stress test the CPU.
  // The routine will pass if the stressapptest returns zero.
  // The availability of this routine can be determined by checking that
  // kCpuStress is returned by GetAvailableRoutines.
  //
  // The request:
  // * |length_seconds| - length of time, in seconds, to run the CPU stress
  //                      routine. This parameter needs to be strictly greater
  //                      than zero. If not specified, the routine will default
  //                      to 1 minute.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunCpuStressRoutine@8(NullableUint32? length_seconds)
      => (RunRoutineResponse response);

  // Requests that the FloatingPointAccuracy routine is created and started
  // on the platform. This routine executes millions of floating-point
  // operations by SSE instructions for a specified amount of time. The routine
  // will pass if the result values of the operations and known accurate result
  // are the same.
  // The availability of this routine can be determined by checking that
  // kFloatingPointAccuracy is returned by GetAvailableRoutines.
  //
  // The request:
  // * |length_seconds| - length of time, in seconds, to run the floating-point
  //                      routine for. Test will executes millions of
  //                      floating-point operations in length seconds and get
  //                      the result to compare with known accurate results.
  //                      This parameter needs to be strictly greater than zero.
  //                      If not specified, the routine will default to
  //                      1 minute.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunFloatingPointAccuracyRoutine@9(NullableUint32? length_seconds)
      => (RunRoutineResponse response);

  // Requests that the NvmeWearLevel routine is created and started on the
  // platform. This routine examines wear level of NVMe against input
  // threshold.
  // The availability of this routine can be determined by checking that
  // kNvmeWearLevel is returned by GetAvailableRoutines.
  //
  // The request:
  // * |wear_level_threshold| - an optional threshold number in percentage which
  //                            routine examines wear level status against. If
  //                            not specified, the routine will read from
  //                            cros-config.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  DEPRECATED_RunNvmeWearLevelRoutine@10(uint32 wear_level_threshold)
      => (RunRoutineResponse response);

  [MinVersion=1] RunNvmeWearLevelRoutine@32(
      NullableUint32? wear_level_threshold)
      => (RunRoutineResponse response);

  // Requests that the NvmeSelfTest routine is created and started on the
  // platform. This routine launches the NVMe self-test, a tool to perform
  // necessary tests to observe the performance and the parameters.
  // The availability of this routine can be determined by checking that
  // kNvmeSelfTest is returned by GetAvailableRoutines.
  //
  // The request:
  // * |nvme_self_test_type| - specifies the type of test for short period or
  //                           extended version.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunNvmeSelfTestRoutine@11(NvmeSelfTestTypeEnum nvme_self_test_type)
      => (RunRoutineResponse response);

  // Requests that the DiskRead routine is created and started on the platform.
  // The routine will create a test file with md5 checksum, read the test file
  // either randomly or linearly, repeatedly for a dedicated duration. If the
  // md5 checksum of read back is validated, then the test will pass.
  // The availability of this routine can be determined by checking that
  // kDiskRead is returned by GetAvailableRoutines.
  //
  // The request:
  // * |type| - type of how disk reading is performed, either linear or random.
  //
  // * |length_seconds| - length of time, in seconds, to run the DiskRead
  //                      routine for. This parameter needs to be strictly
  //                      greater than zero.
  // * |file_size_mb| - test file size, in mega bytes, to test with DiskRead
  //                    routine
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunDiskReadRoutine@12(DiskReadRoutineTypeEnum type, uint32 length_seconds,
                     uint32 file_size_mb)
      => (RunRoutineResponse response);

  // Requests that the PrimeSearch routine is created and started on the
  // platform. Calculate prime numbers and verifies the calculation repeatedly
  // in a duration.
  // The availability of this routine can be determined by checking that
  // kPrimeSearch is returned by GetAvailableRoutines.
  //
  // The request:
  // * |length_seconds| - length of time, in seconds, to run the PrimeSearch
  //                      routine for. This parameter needs to be strictly
  //                      greater than zero. If not specified, the routine will
  //                      default to 1 minute.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunPrimeSearchRoutine@13(NullableUint32? length_seconds)
      => (RunRoutineResponse response);

  // Requests that the BatteryDischarge routine is created and started on the
  // platform. This routine checks the battery's discharge rate over a period of
  // time.
  // The availability of this routine can be determined by checking that
  // kBatteryDischarge is returned by GetAvailableRoutines.
  //
  // The request:
  // * |length_seconds| - length of time to run the routine for.
  // * |maximum_discharge_percent_allowed| - the routine will fail if the
  //                                         battery discharges by more than
  //                                         this percentage.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunBatteryDischargeRoutine@14(uint32 length_seconds,
                             uint32 maximum_discharge_percent_allowed)
      => (RunRoutineResponse response);

  // Requests that the BatteryCharge routine is created and started on the
  // platform. This routine checks the battery's charge rate over a period of
  // time.
  // The availability of this routine can be determined by checking that
  // kBatteryCharge is returned by GetAvailableRoutines.
  //
  // The request:
  // * |length_seconds| - length of time to run the routine for.
  // * |minimum_charge_percent_required| - the routine will fail if the battery
  //                                       charges by less than this percentage.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunBatteryChargeRoutine@15(uint32 length_seconds,
                          uint32 minimum_charge_percent_required)
      => (RunRoutineResponse response);

  // Requests that the Memory routine is created and started on the platform.
  // This routine checks that the device's memory is working correctly.
  // The availability of this routine can be determined by checking that
  // kMemory is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunMemoryRoutine@16() => (RunRoutineResponse response);

  // Requests that the LanConnectivity routine is created and started on the
  // platform. This routine checks whether the device is connected to a LAN.
  // The availability of this routine can be determined by checking that
  // kLanConnectivity is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunLanConnectivityRoutine@17() => (RunRoutineResponse response);

  // Requests that the SignalStrength routine is created and started on the
  // platform. This routine checks whether there is an acceptable signal
  // strength on wireless networks.
  // The availability of this routine can be determined by checking that
  // kSignalStrength is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunSignalStrengthRoutine@18() => (RunRoutineResponse response);

  // Requests that the GatewayCanBePinged routine is created and started on the
  // platform. This routine checks whether the gateway of connected networks is
  // pingable.
  // The availability of this routine can be determined by checking that
  // kGatewayCanBePinged is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunGatewayCanBePingedRoutine@19() => (RunRoutineResponse response);

  // Requests that the HasSecureWiFiConnection routine is created and started
  // on the platform. This routine checks whether the WiFi connection is
  // secure. Note that if WiFi is not connected, the routine will not run.
  // The availability of this routine can be determined by checking that
  // kHasSecureWiFiConnection is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunHasSecureWiFiConnectionRoutine@20() => (RunRoutineResponse response);

  // Requests that the DnsResolverPresent routine is created and started on the
  // platform. This routine checks whether a DNS resolver is available to the
  // browser.
  // The availability of this routine can be determined by checking that
  // kDnsResolverPresent is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunDnsResolverPresentRoutine@21() => (RunRoutineResponse response);

  // Requests that the DnsLatency routine is created and started on the
  // platform. This routine checks whether the DNS latency is below an
  // acceptable threshold.
  // The availability of this routine can be determined by checking that
  // kDnsLatency is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunDnsLatencyRoutine@22() => (RunRoutineResponse response);

  // Requests that the DnsResolution routine is created and started on the
  // platform. This routine checks whether a DNS resolution can be completed
  // successfully.
  // The availability of this routine can be determined by checking that
  // kDnsResolution is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunDnsResolutionRoutine@23() => (RunRoutineResponse response);

  // Requests that the CaptivePortal routine is created and started on the
  // platform. This routine checks whether the internet connection is behind a
  // captive portal.
  // The availability of this routine can be determined by checking that
  // kCaptivePortal is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunCaptivePortalRoutine@24() => (RunRoutineResponse response);

  // Requests that the HttpFirewall routine is created and started on the
  // platform. This routine checks whether a firewall is blocking HTTP port 80.
  // The availability of this routine can be determined by checking that
  // kHttpFirewall is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunHttpFirewallRoutine@25() => (RunRoutineResponse response);

  // Requests that the HttpsFirewall routine is created and started on the
  // platform. This routine checks whether a firewall is blocking HTTPS port
  // 443.
  // The availability of this routine can be determined by checking that
  // kHttpsFirewall is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunHttpsFirewallRoutine@26() => (RunRoutineResponse response);

  // Requests that the HttpsLatency routine is created and started on the
  // platform. This routine checks whether the HTTPS latency is within
  // established tolerance levels for the system.
  // The availability of this routine can be determined by checking that
  // kHttpsLatency is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunHttpsLatencyRoutine@27() => (RunRoutineResponse response);

  // Requests that the VideoConferencing routine is created and started on the
  // platform. This routine checks the device's video conferencing capabalities
  // by testing whether the device can:
  // (1) Contact either a default or specified STUN server via UDP.
  // (2) Contact either a default or specified STUN server via TCP.
  // (3) Reach common media endpoints.
  // The availability of this routine can be determined by checking that
  // kVideoConferencing is returned by GetAvailableRoutines.
  //
  // The request:
  // * |stun_server_hostname| - if specified, represents the custom STUN server
  //                            hostname.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunVideoConferencingRoutine@28(string? stun_server_hostname)
      => (RunRoutineResponse response);

  // Requests that the ArcHttp routine is created and started on the
  // platform. This routine checks whether the HTTP latency from inside ARC
  // is within established tolerance levels for the system.
  // The availability of this routine can be determined by checking that
  // kArcHttp is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunArcHttpRoutine@29() => (RunRoutineResponse response);

  // Requests that the ArcPing routine is created and started on the
  // platform. This routine checks whether the gateway of connected networks is
  // pingable inside ARC.
  // The availability of this routine can be determined by checking that
  // kArcPing is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunArcPingRoutine@30() => (RunRoutineResponse response);

  // Requests that the ArcDnsResolution routine is created and started on the
  // platform. This routine checks whether a DNS resolution can be completed
  // successfully inside ARC.
  // The availability of this routine can be determined by checking that
  // kDnsResolution is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  RunArcDnsResolutionRoutine@31() => (RunRoutineResponse response);

  // Requests that the SensitiveSensor routine is created and started on the
  // platform. This routine checks that the device's sensors are working
  // correctly by monitoring the sensor sample data without user interaction.
  // This routine only support sensitive sensors including accelerometers,
  // gyro sensors, gravity sensors and magnetometers.
  // The availability of this routine can be determined by checking that
  // kSensitiveSensor is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  [MinVersion=2] RunSensitiveSensorRoutine@33()
      => (RunRoutineResponse response);

  // Requests that the Fingerprint routine is created and started on the
  // platform. This routine checks whether the fingerprint module is healthy or
  // not.
  // The availability of this routine can be determined by checking that
  // kFingerprint is returned by GetAvailableRoutines.
  //
  // Note that this routine can be run ONLY when WP is off, so it'll only be
  // used in the RMA center or factory.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  [MinVersion=3] RunFingerprintRoutine@34() => (RunRoutineResponse response);

  // Requests that the FingerprintAlive routine is created and started on the
  // platform. This routine checks whether the fingerprint module is alive or
  // not. Alive means the sensor is responsive and the firmware version is RW.
  // The availability of this routine can be determined by checking that
  // kFingerprintAlive is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  [MinVersion=3] RunFingerprintAliveRoutine@35()
    => (RunRoutineResponse response);

  // Requests that the PrivacyScreen routine is created and started on the
  // platform. This routine checks whether the privacy screen is working as
  // expected. This routine is only available if GetAvailableRoutines returned
  // kPrivacyScreen.
  //
  // The request:
  // * |target_state| - privacy screen target state.
  [MinVersion=4] RunPrivacyScreenRoutine@36(bool target_state)
      => (RunRoutineResponse response);

  // Requests that the LedLitUp routine is created and started on the
  // platform. This routine lights up the target LED in the specified color and
  // requests the caller to verify the change.
  // The availability of this routine can be determined by checking that
  // kLedLitUp is returned by GetAvailableRoutines.
  //
  // The routine proceeds with the following steps:
  // 1. Set the specified LED with the specified color. If the LED name or color
  //    is not supported by EC, the routine fails at this step.
  // 2. Invoke the |GetColorMatched| method of |replier|. The method should
  //    return |true| if the actual color matches the specified color and
  //    |false|, otherwise. Notice that there is no timeout so it will wait
  //    indefinitely.
  // 3. After receiving the response from |replier|, the color of the LED will
  //    be reset (back the auto control). If the replier disconnects before
  //    the response is received, the LED will also be reset.
  // 4. The status of the routine is updated. The routine passes when the
  //    response is |true|. If the response is |false| or the disconnection
  //    occurs, the routine fails.
  //
  // Requirement:
  // * The LED name and color provided by the client must be valid. In other
  //   words, the specified LED must be installed and the specified color must
  //   be supported.
  //
  // The request:
  // * |name| - specifies the LED to be lit up.
  // * |color| - specifies the color to be lit up.
  // * |replier| - a replier that can answer whether the actual LED color
  //               matches the expected color.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  [MinVersion=5] RunLedLitUpRoutine@37(LedName name, LedColor color,
    pending_remote<LedLitUpRoutineReplier> replier)
        => (RunRoutineResponse response);

  // Requests that the EmmcLifetime routine is created and started on the
  // platform. This routine checks the lifetime of the eMMC drive. The routine
  // will pass if PRE_EOL_INFO is 0x01 (normal). In addition, the value of
  // DEVICE_LIFE_TIME_EST_TYP_A and DEVICE_LIFE_TIME_EST_TYP_B will be
  // included in the output.
  // The availability of this routine can be determined by checking that
  // kEmmcLifetime is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  [MinVersion=7] RunEmmcLifetimeRoutine@38() => (RunRoutineResponse response);

  // Requests that the AudioSetVolume routine is created and started on the
  // platform. This routine sets the audio |node_id| volume to |volume| and
  // checks if any error happens. This routine is only available if
  // GetAvailableRoutines returned kAudioSetVolume.
  //
  // The request:
  // * |node_id| - the id of node to be configured.
  // * |volume| - output node target volume in [0, 100], and we use 100 if
  //              the target value is greater than 100.
  // * |mute_on| - mute the output device or not.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  [MinVersion=8] RunAudioSetVolumeRoutine@39(uint64 node_id, uint8 volume,
                                             bool mute_on)
      => (RunRoutineResponse response);

  // Requests that the AudioSetGain routine is created and started on the
  // platform. This routine sets the audio |node_id| gain to |gain| and checks
  // if any error happens. This routine is only available if
  // GetAvailableRoutines returned kAudioSetGain.
  //
  // The request:
  // * |node_id| - the id of node to be configured.
  // * |gain| - input node target gain in [0, 100], and we use 100 if the target
  //            value is greater than 100.
  // * |mute_on| - mute the input device or not.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  [MinVersion=8] RunAudioSetGainRoutine@40(uint64 node_id, uint8 gain,
                                           bool mute_on)
      => (RunRoutineResponse response);

  // Requests that the BluetoothPower routine is created and started on the
  // platform. This routine checks whether the Bluetooth adapter can be powered
  // off/on and the powered status is consistent in both HCI and D-Bus levels.
  // The availability of this routine can be determined by checking that
  // kBluetoothPower is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  [MinVersion=9] RunBluetoothPowerRoutine@41()
      => (RunRoutineResponse response);

  // Requests that the BluetoothDiscovery routine is created and started on the
  // platform. This routine checks whether the Bluetooth adapter can start/stop
  // discovery mode and the discovering status is consistent in both HCI and
  // D-Bus levels.
  // The availability of this routine can be determined by checking that
  // kBluetoothDiscovery is returned by GetAvailableRoutines.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  [MinVersion=9] RunBluetoothDiscoveryRoutine@42()
      => (RunRoutineResponse response);

  // Requests that the BluetoothScanning routine is created and started on the
  // platform. This routine checks whether the Bluetooth adapter can scan nearby
  // Bluetooth peripherals and collect peripherals' information.
  // The availability of this routine can be determined by checking that
  // kBluetoothScanning is returned by GetAvailableRoutines.
  //
  // The request:
  // * |length_seconds| - length of time, in seconds, to run the Bluetooth
  //                      scanning routine for. This parameter needs to be
  //                      strictly greater than zero. If not specified, the
  //                      routine will default to 5 seconds.
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  [MinVersion=9] RunBluetoothScanningRoutine@43(NullableUint32? length_seconds)
      => (RunRoutineResponse response);

  // Requests that the BluetoothPairing routine is created and started on the
  // platform. This routine checks whether the adapter can find and pair with a
  // device with a specific peripheral id.
  // The availability of this routine can be determined by checking that
  // kBluetoothPairing is returned by GetAvailableRoutines.
  //
  // The request:
  // * |peripheral_id| - the unique id of the target peripheral device to test.
  //                     This id can be obtained from the output of the
  //                     Bluetooth scanning routine.
  //
  // The response:
  // * |response| - contains a unique identifier and status for the created
  //                routine.
  [MinVersion=9] RunBluetoothPairingRoutine@44(string peripheral_id)
      => (RunRoutineResponse response);
};

// Event interface exposed by the cros_healthd daemon.
//
// NextMinVersion: 4, NextIndex: 9
[Stable]
interface CrosHealthdEventService {
  // Adds an observer to be notified on Bluetooth events. The caller can remove
  // the observer created by this call by closing their end of the message pipe.
  //
  // The request:
  // * |observer| - Bluetooth observer to be added to cros_healthd.
  DEPRECATED_AddBluetoothObserver@0(
      pending_remote<CrosHealthdBluetoothObserver> observer);

  // Adds an observer to be notified on lid events. The caller can remove the
  // observer created by this call by closing their end of the message pipe.
  //
  // The request:
  // * |observer| - lid observer to be added to cros_healthd.
  DEPRECATED_AddLidObserver@1(pending_remote<CrosHealthdLidObserver> observer);

  // Adds an observer to be notified on power events. The caller can remove the
  // observer created by this call by closing their end of the message pipe.
  //
  // The request:
  // * |observer| - power observer to be added to cros_healthd.
  DEPRECATED_AddPowerObserver@2(
      pending_remote<CrosHealthdPowerObserver> observer);

  // Adds an observer to be notified on network events. The caller can remove
  // the observer created by this call by closing their end of the message pipe.
  //
  // The request:
  // * |observer| - network observer to be added to cros_healthd.
  AddNetworkObserver@3(
      pending_remote<
          chromeos.network_health.mojom.NetworkEventsObserver> observer);

  // Adds an observer to be notified on audio events. The caller can remove the
  // observer created by this call by closing their end of the message pipe.
  //
  // The request:
  // * |observer| - audio observer to be added to cros_healthd.
  DEPRECATED_AddAudioObserver@4(
      pending_remote<CrosHealthdAudioObserver> observer);

  // Adds an observer to be notified on Thunderbolt events. The caller can
  // remove the observer created by this call by closing their end of the
  // message pipe.
  //
  // The request:
  // * |observer| - Thunderbolt observer to be added to cros_healthd.
  DEPRECATED_AddThunderboltObserver@5(
      pending_remote<CrosHealthdThunderboltObserver> observer);

  // Adds an observer to be notified on USB events. The caller can remove the
  // observer created by this call by closing their end of the message pipe.
  //
  // The request:
  // * |observer| - USB observer to be added to cros_healthd.
  [MinVersion=1] DEPRECATED_AddUsbObserver@6(
      pending_remote<CrosHealthdUsbObserver> observer);

  // Adds an observer to be notified on events. The caller can remove the
  // observer created by this call by closing their end of the message pipe.
  //
  // The request:
  // * |category| - Event category.
  // * |observer| - Event observer to be added to cros_healthd.
  [MinVersion=2] AddEventObserver@7(
      EventCategoryEnum category,
      pending_remote<EventObserver> observer);

  // Checks whether an event is supported. It does the same support status check
  // as in `AddEventObserver()` and returns immediately after the check.
  //
  // The request:
  // * |category| - Event category to check.
  //
  // The response:
  // * |status| - See the documentation of `SupportStatus`.
  [MinVersion=3] IsEventSupported@8(
      EventCategoryEnum category) => (SupportStatus status);
};

// Probe interface exposed by the cros_healthd daemon.
//
// NextMinVersion: 2, NextIndex: 3
[Stable]
interface CrosHealthdProbeService {
  // Returns information about a specific process running on the device.
  //
  // The request:
  // * |process_id| - PID of the process whose information is requested.
  //
  // The response:
  // * |process_info| - Information about the requested process.
  ProbeProcessInfo@0(uint32 process_id) => (ProcessResult process_info);

  // Returns telemetry information for the desired categories.
  //
  // The request:
  // * |categories| - list of each of the categories that ProbeTelemetryInfo
  //                  should return information for.
  //
  // The response:
  // * |telemetry_info| - information for each of the requested categories. Only
  //                      the fields corresponding to the requested categories
  //                      will be non-null.
  ProbeTelemetryInfo@1(array<ProbeCategoryEnum> categories)
      => (TelemetryInfo telemetry_info);

  // Returns information about multiple specified or all processes running on
  // the device. Can ignore individual errors by request.
  //
  // The request:
  // * |process_ids| - List of PIDs of the processes whose information are
  //                   requested, leaving it null will return information of all
  //                   currently existing processes.
  // * |ignore_single_process_error| - Set to true if want to ignore individual
  //                                   errors occurred for single processes
  //                                   (e.g., parsing related errors). General
  //                                   errors (e.g., can't read /proc in the
  //                                   first place) won't be ignored despite
  //                                   setting this value to true.
  //
  // The response:
  // * |multiple_process_info| - Information about the requested processes and
  //                             errors if any occurred and not skipped.
  [MinVersion=1] ProbeMultipleProcessInfo@2(array<uint32>? process_ids,
                                            bool ignore_single_process_error)
    => (MultipleProcessResult multiple_process_info);
};

// Contains data about the current service instance of cros_healthd.
//
// NextMinVersion: 1, NextIndex: 2
[Stable]
struct ServiceStatus {
  // Boolean flag if the NetworkHealthService mojo remote has been sent from
  // Chrome and bound in cros_healthd.
  bool network_health_bound@0;
  // Boolean flag if the NetworkDiagnosticsService mojo remote has been sent
  // from Chrome and bound in cros_healthd.
  bool network_diagnostics_bound@1;
};

// Interface to query the status of the cros_healthd service.
//
// NextMinVersion: 1, NextIndex: 1
[Stable]
interface CrosHealthdSystemService {
  // Returns the status of the cros_healthd service and external mojo remotes.
  GetServiceStatus@0() => (ServiceStatus response);
};

// Wilco EC (embedded controller) interface exposed by the cros_healthd daemon.
// This is to be used by the wilco_dtc and wilco_dtc_supportd processes to
// interact with the cros_healthd ec_service, observe EC events, and request
// telemetry information.
// ChromeOS wilco_dtc_supportd will use this to capture EC events and telemetry
// to be communicated to the sandboxed wilco_dtc which uses external,
// proprietary code to communicate with Dell enterprise telemetry services
// through the browser.
// See go/wilco-ec for more information
//
// NextMinVersion: 1, NextIndex: 4
[Stable]
interface WilcoEcServiceController {
  // Adds an observer to be notified on EC events. The caller can remove the
  // observer created by this call by closing their end of the message pipe.
  //
  // The request:
  // * |observer| - EC observer to be added to cros_healthd.
  AddEcObserver@0(pending_remote<WilcoEcObserver> observer);

  // Returns EC telemetry
  //
  // The request:
  // * |payload_string| - a byte string produced by the wilco_dtc VM.
  //
  // The response:
  // * |response| - a structure containing a byte string and a status code.
  GetEcTelemetry@1(string payload_string) => (GetEcTelemetryResponse response);

  // Starts the Service.
  StartEcService@2();

  // Shuts down the Service.
  ShutdownEcService@3();
};
