<!DOCTYPE html>
<!--
Encodes two I420 frames and checks that output color space is changed to Rec709.
Then encodes two RGBA frame w/ Rec601 colors and checks that the output color
space is changed to Rec601, and that a key frame is generated alongside the
change. It then verifies the decoded bitstream has the proper color information.

The spec doesn't mandate any particular output color space, so this just checks
that our internal behavior is surfaced correctly. A key frame is expected when
color space changes to mirror the our decoder requirement to provide a key frame
whenever VideoDecoderConfig changes.
-->
<html>

<head>
  <title>Encode color space test</title>
  <script src="webcodecs_common.js"></script>
  <script type="text/javascript">
    'use strict';

    // Use 16x16 aligned resolution since some platforms require that.
    // See https://crbug.com/1084702.
    // Also, some platforms require a resolution that isn't tiny (e.g. 160) to
    // use hardware acceleration.
    const FRAME_WIDTH = 640;
    const FRAME_HEIGHT = 480;

    function isRec709(colorSpace) {
      return colorSpace.primaries === 'bt709' &&
          colorSpace.transfer === 'bt709' && colorSpace.matrix === 'bt709' &&
          colorSpace.fullRange === false;
    }

    function isSRGB(colorSpace) {
      return colorSpace.primaries === 'bt709' &&
          colorSpace.transfer === 'iec61966-2-1' &&
          colorSpace.matrix === 'rgb' && colorSpace.fullRange === true;
    }

    function isRec601(colorSpace) {
      return colorSpace.primaries === 'smpte170m' &&
          (colorSpace.transfer === 'smpte170m' ||
           colorSpace.transfer === 'bt709') &&
          colorSpace.matrix === 'smpte170m' && colorSpace.fullRange === false;
    }

    function makePixelArray(byteLength) {
      let data = new Uint8Array(byteLength);
      for (let i = 0; i < byteLength; i++) {
        data[i] = i;
      }
      return data;
    }

    function makeFrame(type, timestamp) {
      let init = {
        format: 'RGBA',
        timestamp: timestamp,
        codedWidth: FRAME_WIDTH,
        codedHeight: FRAME_HEIGHT
      };
      switch (type) {
        case 'I420': {
          const yuvByteLength = 1.5 * FRAME_WIDTH * FRAME_HEIGHT;
          let data = makePixelArray(yuvByteLength);
          return new VideoFrame(data, {...init, format: 'I420'});
        }
        case 'RGBA': {
          const rgbaByteLength = 4 * FRAME_WIDTH * FRAME_HEIGHT;
          let data = makePixelArray(rgbaByteLength);
          return new VideoFrame(data, {...init, format: 'RGBA'});
        }
      }
    }

    async function main(arg) {
      const encoderConfig = {
        codec: arg.codec,
        hardwareAcceleration: arg.acceleration,
        width: FRAME_WIDTH,
        height: FRAME_HEIGHT,
      };

      TEST.log('Starting test with arguments: ' + JSON.stringify(arg));
      let support = await VideoEncoder.isConfigSupported(encoderConfig);
      if (!support.supported) {
        TEST.skip('Unsupported codec: ' + arg.codec);
        return;
      }

      const frameDuration = 16666;
      let inputFrames = [
        // Use I420/BT.709 first since default macOS colorspace is sRGB.
        makeFrame('I420', 0 * frameDuration),
        makeFrame('I420', 1 * frameDuration),
        makeFrame('RGBA', 2 * frameDuration),
        makeFrame('RGBA', 3 * frameDuration),
      ];
      let outputChunks = [];
      let outputMetadata = [];
      let errors = 0;

      const init = {
        output(chunk, metadata) {
          outputChunks.push(chunk);
          outputMetadata.push(metadata);
        },
        error(e) {
          errors++;
          TEST.log(e);
        }
      };

      let encoder = new VideoEncoder(init);
      encoder.configure(encoderConfig);

      for (let frame of inputFrames) {
        encoder.encode(frame);
        await waitForNextFrame();
      }
      await encoder.flush();
      encoder.close();

      TEST.assert_eq(errors, 0, 'Encoding errors occurred during the test');
      TEST.assert_eq(outputChunks.length, 4, 'Unexpected number of outputs');
      TEST.assert_eq(
          outputMetadata.length, 4, 'Unexpected number of output metadata');

      // I420 passthrough should preserve default rec709 color space.
      TEST.assert_eq(inputFrames[0].format, 'I420', 'inputs[0] is I420');
      TEST.assert(isRec709(inputFrames[0].colorSpace), 'inputs[0] is rec709');
      TEST.assert_eq(outputChunks[0].type, 'key', 'outputs[0] is key');
      TEST.assert(
          'decoderConfig' in outputMetadata[0],
          'metadata[0] has decoderConfig');
      TEST.assert(
          isRec709(outputMetadata[0].decoderConfig.colorSpace),
          'metadata[0] is rec709');

      // Next output may or may not be a key frame w/ metadata (up to
      // encoder). Corresponding input is still I420 rec709, so if metadata is
      // given, we expect same colorSpace as for the previous frame.
      TEST.assert_eq(inputFrames[1].format, 'I420', 'inputs[1] is I420');
      TEST.assert(isRec709(inputFrames[1].colorSpace, 'inputs[1] is rec709'));
      if ('decoderConfig' in outputMetadata[1]) {
        TEST.assert(
            isRec709(outputMetadata[1].decoderConfig.colorSpace),
            'metadata[1] is rec709');
      }

      // Next output should be a key frame and have accompanying metadata
      // because the corresponding input format changed to RGBA, which means
      // we libyuv will convert to I420 w/ rec601 during encoding.
      TEST.assert_eq(inputFrames[2].format, 'RGBA', 'inputs[2] is RGBA');
      TEST.assert(isSRGB(inputFrames[2].colorSpace), 'inputs[2] is sRGB');

      // TODO(https://crbug.com/1241448): Uncomment the line below once android
      // reliably produces a key frame at the appropriate time. For now this
      // is covered by a DCHECK (excluding android) in video_encoder.cc.
      // TEST.assert(outputChunks[2].type == 'key', 'outputs[2] is key');

      TEST.assert(
          'decoderConfig' in outputMetadata[2],
          'metadata[2] has decoderConfig');
      TEST.assert(
          isRec601(outputMetadata[2].decoderConfig.colorSpace),
          'metadata[2] is rec601');

      // Next output may or may not be a key frame w/ metadata (up to
      // encoder). Corresponding input is still RGBA sRGB, so if metadata is
      // given, we expect same colorSpace as for the previous frame.
      TEST.assert_eq(inputFrames[3].format, 'RGBA', 'inputs[3] is RGBA');
      TEST.assert(isSRGB(inputFrames[3].colorSpace), 'inputs[3] is sRGB');
      if ('decoderConfig' in outputMetadata[3]) {
        TEST.assert(
            isRec601(outputMetadata[3].decoderConfig.colorSpace),
            'metadata[3] is rec601');
      }

      // Now decode the frames and ensure the encoder embedded the right color
      // space information in the bitstream.

      // VP8 doesn't have embedded color space information in the bitstream.
      if (arg.codec == 'vp8')
        return;

      let decodedFrames = [];
      const decoderInit = {
        output(frame) {
          decodedFrames.push(frame);
        },
        error(e) {
          errors++;
          TEST.log(e);
        }
      };

      let decoder = new VideoDecoder(decoderInit);
      for (var i = 0; i < outputChunks.length; ++i) {
        if ('decoderConfig' in outputMetadata[i]) {
          let config = {...outputMetadata[i].decoderConfig};

          // Removes the color space provided by the encoder so that color space
          // information in the underlying bitstream is exposed during decode.
          config.colorSpace = {};

          config.hardwareAcceleration = arg.acceleration;
          decoder.configure(config);
        }
        decoder.decode(outputChunks[i]);
        await waitForNextFrame();
      }
      await decoder.flush();
      decoder.close();

      TEST.assert_eq(
          errors, 0, 'Encoding errors occurred during the decoding test');
      TEST.assert_eq(
          decodedFrames.length, outputChunks.length,
          'Unexpected number of decoded outputs');

      let colorSpace = {};
      for (var i = 0; i < decodedFrames.length; ++i) {
        if ('decoderConfig' in outputMetadata[i])
          colorSpace = outputMetadata[i].decoderConfig.colorSpace;

        TEST.assert_eq(
            decodedFrames[i].colorSpace.primaries, colorSpace.primaries,
            `Frame ${i} color primaries mismatch`);
        TEST.assert_eq(
            decodedFrames[i].colorSpace.matrix, colorSpace.matrix,
            `Frame ${i} color matrix mismatch`);
        if (decodedFrames[i].colorSpace.transfer != colorSpace.transfer) {
          // Allow functionally equivalent matches.
          TEST.assert(
              colorSpace.transfer == 'smpte170m' &&
                  decodedFrames[i].colorSpace.transfer == 'bt709',
              `Frame ${i} color transfer mismatch`)
        } else {
          TEST.assert_eq(
              decodedFrames[i].colorSpace.transfer, colorSpace.transfer,
              `Frame ${i} color transfer mismatch`);
        }
        TEST.assert_eq(
            decodedFrames[i].colorSpace.fullRange, colorSpace.fullRange,
            `Frame ${i} color fullRange mismatch`);
      }
      TEST.log('Test completed');
    }
    addManualTestButton([
      {'codec': 'avc1.42001E', 'acceleration':'prefer-software'},
      {'codec': 'avc1.42001E', 'acceleration':'prefer-hardware'},
    ]);
  </script>
</head>

<body>
</body>

</html>
