<?xml version="1.0" encoding="UTF-8"?>
<protocol name="remote_shell_unstable_v2">

  <copyright>
    Copyright 2021 The Chromium Authors

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice (including the next
    paragraph) shall be included in all copies or substantial portions of the
    Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
  </copyright>

  <description summary="Create remote desktop-style surfaces">
    remote_shell allows clients to turn a wl_surface into a "real window"
    which can be stacked and activated by the user.

    Warning! The protocol described in this file is experimental and backward
    incompatible changes may be made. Backward compatible changes may be added
    together with the corresponding interface version bump. Backward
    incompatible changes are done by bumping the version number in the protocol
    and interface names and resetting the interface version. Once the protocol
    is to be declared stable, the 'z' prefix and the version number in the
    protocol and interface names are removed and the interface version number is
    reset.
  </description>

  <interface name="zcr_remote_shell_v2" version="6">
    <description summary="remote_shell">
      The global interface that allows clients to turn a wl_surface into a
      "real window" which is remotely managed but can be stacked, activated
      and made fullscreen by the user.
    </description>

    <enum name="error">
      <entry name="role" value="0" summary="given wl_surface has another role"/>
      <entry name="invalid_notification_key" value="1" summary="invalid notification key"/>
    </enum>

    <request name="destroy" type="destructor">
      <description summary="destroy remote_shell">
	Destroy this remote_shell object.

	Destroying a bound remote_shell object while there are surfaces
	still alive created by this remote_shell object instance is illegal
	and will result in a protocol error.
      </description>
    </request>

    <enum name="container">
      <description summary="containers for remote surfaces">
	Determine how a remote surface should be stacked relative to other
	shell surfaces.
      </description>
      <entry name="default" value="1" summary="default container"/>
      <entry name="overlay" value="2" summary="system modal container"/>
    </enum>

    <request name="get_remote_surface">
      <description summary="create a remote shell surface from a surface">
	This creates an remote_surface for the given surface and gives it the
	remote_surface role. A wl_surface can only be given a remote_surface
	role once. If get_remote_surface is called with a wl_surface that
	already has an active remote_surface associated with it, or if it had
	any other role, an error is raised.

	See the documentation of remote_surface for more details about what an
	remote_surface is and how it is used.
      </description>
      <arg name="id" type="new_id" interface="zcr_remote_surface_v2"/>
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="container" type="uint" enum="container"/>
    </request>

    <request name="get_notification_surface">
      <description summary="create a notification surface from a surface">
	Creates a notification_surface for the given surface, gives it the
	notification_surface role and associated it with a notification id.
      </description>
      <arg name="id" type="new_id" interface="zcr_notification_surface_v2"/>
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="notification_key" type="string"/>
    </request>

    <event name="default_device_scale_factor" since="1">
      <description summary="initialize scale configuration">
	Sends the default device scale factor.
      </description>
      <arg name="scale" type="int" summary="DP to pixels ratio, in 8.24 fixed point format"/>
    </event>

    <request name="get_input_method_surface" since="1">
      <description summary="Create a input method surface from a surface">
	Creates an input_method_surface for the given surface, gives it
	the input_method_surface role.
      </description>
      <arg name="id" type="new_id" interface="zcr_input_method_surface_v2"/>
      <arg name="surface" type="object" interface="wl_surface"/>
    </request>

    <request name="get_toast_surface" since="1">
      <description summary="Create a toast surface from a surface">
	Creates an toast_surface for the given surface, gives it
	the toast_surface role.
      </description>
      <arg name="id" type="new_id" interface="zcr_toast_surface_v2"/>
      <arg name="surface" type="object" interface="wl_surface"/>
    </request>

    <enum name="layout_mode">
      <description summary="the layout mode">
	Determine how a client should layout surfaces.
      </description>
      <entry name="windowed" value="1" summary="multiple windows"/>
      <entry name="tablet" value="2" summary="restricted mode for tablet"/>
    </enum>

    <event name="layout_mode" since="1">
      <description summary="sends the layout_mode">
	Sends the layout_mode used by the server.
      </description>
      <arg name="layout_mode" type="uint" enum="layout_mode"/>
    </event>

    <request name="get_remote_output" since="1">
      <description summary="extend output interface for remote shell">
	Instantiate an interface extension for the given wl_output to
	provide remote shell functionality.
      </description>
      <arg name="id" type="new_id" interface="zcr_remote_output_v2" summary="the new remote output interface id"/>
      <arg name="output" type="object" interface="wl_output"/>
    </request>

    <enum name="desktop_focus_state">
      <description summary="desktop foucs state">
	Desktop client window focus state.
      </description>
      <entry name="no_focus" value="1" summary="no window get focused"/>
      <entry name="client_focused" value="2" summary="client window get focused"/>
      <entry name="other_client_focused" value="3" summary="other client window get focused"/>
    </enum>

    <event name="desktop_focus_state_changed" since="1">
      <description summary="desktop window focus state change">
	Notifies client that the window focus state change.
      </description>
      <arg name="focus_state" type="uint" enum="desktop_focus_state"/>
    </event>

  </interface>

  <interface name="zcr_remote_surface_v2" version="6">
    <description summary="A desktop window">
      An interface that may be implemented by a wl_surface, for
      implementations that provide a desktop-style user interface
      and allows for remotely managed windows.

      It provides requests to treat surfaces like windows, allowing to set
      properties like app id and geometry.

      The client must call wl_surface.commit on the corresponding wl_surface
      for the remote_surface state to take effect.

      For a surface to be mapped by the compositor the client must have
      committed both an remote_surface state and a buffer.
    </description>

    <enum name="systemui_visibility_state">
      <description summary="systemui visibility behavior">
	Determine the visibility behavior of the system UI.
      </description>
      <entry name="visible" value="1" summary="system ui is visible"/>
      <entry name="autohide_non_sticky" value="2" summary="system ui autohides and is not sticky"/>
      <entry name="autohide_sticky" value="3" summary="system ui autohides and is sticky"/>
    </enum>

    <request name="destroy" type="destructor">
      <description summary="Destroy the remote_surface">
	Unmap and destroy the window. The window will be effectively
	hidden from the user's point of view, and all state will be lost.
      </description>
    </request>

    <request name="set_app_id">
      <description summary="set application ID">
	Set an application identifier for the surface.
      </description>
      <arg name="app_id" type="string"/>
    </request>

    <request name="set_title">
      <description summary="set surface title">
	Set a short title for the surface.

	This string may be used to identify the surface in a task bar,
	window list, or other user interface elements provided by the
	compositor.

	The string must be encoded in UTF-8.
      </description>
      <arg name="title" type="string"/>
    </request>

    <request name="set_top_inset">
      <description summary="set top inset for surface">
	Set distance from the top of the surface to the contents.

	This distance typically represents the size of the window caption.
      </description>
      <arg name="height" type="int"/>
    </request>

    <request name="maximize">
      <description summary="maximize">
	Request that surface is maximized. The window geometry will be updated
	to whatever the compositor finds appropriate for a maximized window.

	This is only a request that the window should be maximized. The
	compositor may choose to ignore this request. The client should
	listen to state_type_changed events to determine if the window was
	maximized or not.
      </description>
    </request>

    <request name="minimize">
      <description summary="minimize">
	Request that surface is minimized.

	This is only a request that the window should be minimized. The
	compositor may choose to ignore this request. The client should
	listen to state_type_changed events to determine if the window was
	minimized or not.
      </description>
    </request>

    <request name="restore">
      <description summary="restore">
	Request that surface is restored. This restores the window geometry
	to what it was before the window was minimized, maximized or made
	fullscreen.

	This is only a request that the window should be restored. The
	compositor may choose to ignore this request. The client should
	listen to state_type_changed events to determine if the window was restored
  or not.
      </description>
    </request>

    <request name="fullscreen">
      <description summary="fullscreen">
	Request that surface is made fullscreen.

	This is only a request that the window should be made fullscreen.
	The compositor may choose to ignore this request. The client should
	listen to set_fullscreen events to determine if the window was
	made fullscreen or not.
      </description>
    </request>

    <request name="pin">
      <description summary="pin">
	Request that surface is pinned.

	This is only a request that the window should be pinned.
	The compositor may choose to ignore this request. The client should
	listen to state_type_changed events to determine if the window was
	pinned or not. If trusted flag is non-zero, the app can prevent users
	from exiting the pinned mode.
      </description>
      <arg name="trusted" type="int"/>
    </request>

    <request name="unpin">
      <description summary="unpin">
	Request that surface is unpinned.

	This is only a request that the window should be unpinned.
	The compositor may choose to ignore this request. The client should
	listen to state_type_changed events to determine if the window was
	unpinned or not.
      </description>
    </request>

    <request name="set_system_modal">
      <description summary="suggests a re-layout of remote shell input area">
	Suggests a surface should become system modal.
      </description>
    </request>

    <request name="unset_system_modal">
      <description summary="suggests a re-layout of remote shell input area">
	Suggests a surface should become non system modal.
      </description>
    </request>

    <event name="close">
      <description summary="surface wants to be closed">
	The close event is sent by the compositor when the user
	wants the surface to be closed. This should be equivalent to
	the user clicking the close button in client-side decorations,
	if your application has any...

	This is only a request that the user intends to close your
	window. The client may choose to ignore this request, or show
	a dialog to ask the user to save their data...
      </description>
    </event>

    <enum name="state_type">
      <description summary="state types for remote surfaces">
	Defines common show states for shell surfaces.
      </description>
      <entry name="normal" value="1" summary="normal window state"/>
      <entry name="minimized" value="2" summary="minimized window state"/>
      <entry name="maximized" value="3" summary="maximized window state"/>
      <entry name="fullscreen" value="4" summary="fullscreen window state"/>
      <entry name="pinned" value="5" summary="pinned window state"/>
      <entry name="trusted_pinned" value="6" summary="trusted pinned window state"/>
      <entry name="moving" value="7" summary="moving window state"/>
      <entry name="resizing" value="8" summary="resizing window state"/>
      <entry name="left_snapped" value="9" summary="left snapped window state"/>
      <entry name="right_snapped" value="10" summary="right snapped window state"/>
      <entry name="pip" value="11" summary="pip window state"/>
    </enum>

    <event name="state_type_changed">
      <description summary="surface state type changed">
	The state_type_changed event is sent by the compositor when
	the surface state changed.

	This is an event to notify that the window state changed in compositor.
	The state change may be triggered by a client's request, or some user
	action directly handled by the compositor. The client may choose to
	ignore this event.
      </description>
      <arg name="state_type" type="uint" enum="state_type"/>
    </event>

    <request name="set_rectangular_surface_shadow" since="1">
      <description summary="set a rectangular shadow">
	Request that surface needs a rectangular shadow.

	This is only a request that the surface should have a rectangular
	shadow. The compositor may choose to ignore this request.

	The arguments are given in the remote surface coordinate space and
	specifies inner bounds of the shadow. Specifying zero width and height
	will disable the shadow.
      </description>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </request>

    <request name="set_systemui_visibility" since="1">
      <description summary="requests the system ui visibility behavior for the surface">
	Requests how the surface will change the visibility of the system UI when it is made active.
      </description>
      <arg name="visibility" type="uint" enum="systemui_visibility_state"/>
    </request>

    <request name="set_always_on_top" since="1">
      <description summary="set always on top">
	Request that surface is made to be always on top.

	This is only a request that the window should be always on top.
	The compositor may choose to ignore this request.

      </description>
    </request>

    <request name="unset_always_on_top" since="1">
      <description summary="unset always on top">
	Request that surface is made to be not always on top.

	This is only a request that the window should be not always on top.
	The compositor may choose to ignore this request.
      </description>
    </request>

    <enum name="orientation">
      <description summary="window orientation">
	The orientation of the window.
      </description>
      <entry name="portrait" value="1" summary="portrait"/>
      <entry name="landscape" value="2" summary="landscape"/>
    </enum>

    <request name="set_orientation" since="1">
      <description summary="set orientation">
	Set an orientation for the surface.
      </description>
      <arg name="orientation" type="int" enum="orientation"/>
    </request>

    <event name="window_geometry_changed" since="1">
      <description summary="announce window geometry commit">
	Notify the client of committed window geometry.

	The compositor sends this event when it commits window geometry. The
	client may use this information to convert coordinates of input events
	using the latest committed geometry.
      </description>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </event>

    <enum name="bounds_change_reason">
      <description summary="bounds_change_reason">
	Specifies the cause of the window bounds change event.
      </description>
      <entry name="drag_move" value="1" summary="the window is being moved by drag operation"/>
      <entry name="drag_resize" value="2" summary="the window is being resized by drag operation."/>
      <entry name="snap_to_left" value="3" summary="the window is resized to left snapped state"/>
      <entry name="snap_to_right" value="4" summary="the window is resized to right snapped state"/>
      <entry name="move" value="5" summary="the window bounds is moved due to other WM operations"/>
      <entry name="resize" value="6" summary="the window bounds is reiszed due to other WM operations"/>
      <entry name="pip" value="7" summary="the window bounds is resized or moved for PIP"/>
      <entry name="float" value="8" summary="the window bounds is resized or moved for float state" since="3"/>
    </enum>

    <event name="bounds_changed" since="1">
      <description summary="The compositor requested to change the bounds">
	The compositor requested to change its
	bounds. "bounds_change_reason" specifies the cause of the
	bounds change. The client may apply the different move/resize
	strategy depending on the reason.

	"display_id_hi", "display_id_lo" specifies in which workspace
	the surface should live in.

	The client responds with set_bounds_in_output request, with the
	bounds it is resized to (this may be different from the bounds
	requested).

	The client may ignore move request depending on the state,
	e.g, if it becomes resizable or other constrants.
      </description>
      <arg name="display_id_hi" type="uint"/>
      <arg name="display_id_lo" type="uint"/>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
      <arg name="bounds_change_reason" type="uint" enum="bounds_change_reason"/>
    </event>

    <request name="start_move" since="1">
      <description summary="start an interactive move">
	Request an interactive, user-driven move of the surface. "x"
	and "y" specifies the starting point of the pointer device
	that initiated the move.

	The compositor responds to this request with a drag_started
	event with "none" direction.  Please see drag_started event
	for more details.

	The compositor may ignore move requests depending on the state of the
	surface, e.g. fullscreen or maximized.
      </description>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
    </request>

    <enum name="resize_direction">
      <description summary="resize direction">
	The resize direction for drag operation
      </description>
      <entry name="none" value="0" summary="move only, no resize"/>
      <entry name="left" value="1" summary="resize to the left"/>
      <entry name="topleft" value="2" summary="resize to the top left"/>
      <entry name="top" value="3" summary="resize to the top"/>
      <entry name="topright" value="4" summary="resize to the top right"/>
      <entry name="right" value="5" summary="resize to the right"/>
      <entry name="bottomright" value="6" summary="resize to the buttom right"/>
      <entry name="bottom" value="7" summary="resize to the bottom"/>
      <entry name="bottomleft" value="8" summary="resize to the bottom left"/>
    </enum>

    <event name="drag_started" since="1">
      <description summary="Notifies that a drag to move/resize started.">
	Notifies a client that the compositor started drag
	operation. "direction" specifies which direction it is being
	resized. "none" direction means just move but not resize.

	This will be followed by series of the "bounds_changed" event
	with "drag_resize" or "drag_move" reasons to update the window
	bounds druing the drag operation.
      </description>
      <arg name="direction" type="uint" enum="resize_direction"/>
    </event>

    <event name="drag_finished" since="1">
      <description summary="Notifies that a drag operation has finished.">
	Called when the drag operation is finished.  "x" and "y"
	specifies the position of the pointer device used to drag.
	"canceled" is true if the drag operation is aborted during
	drag (e.g. by capture change or user action.)
      </description>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="canceled" type="int" summary="true if the operation was canceled"/>
    </event>

    <request name="set_can_maximize" since="1">
      <description summary="set can_maximize">
	Request that surface can be in maximzied state.
      </description>
    </request>

    <request name="unset_can_maximize" since="1">
      <description summary="unset can_maximize">
	Request that surface can not be in maximzied state.
      </description>
    </request>

    <request name="set_min_size" since="1">
      <description summary="set the minimum size">
	Set a minimum size of the surface.

	Values set in this way are double-buffered. They will get
	applied on the next commit.
      </description>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </request>

    <request name="set_max_size" since="1">
      <description summary="set the maximum size">
	Set a maximum size of the surface.

	Values set in this way are double-buffered. They will get
	applied on the next commit.

	Setting the same size as minimum size makes the surface
	unresizable.
      </description>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </request>

    <request name="set_snapped_to_left" since="1">
      <description summary="set the surface to left snapped">
	Request that surface is snapped to left.
      </description>
    </request>

    <request name="set_snapped_to_right" since="1">
      <description summary="set the surface to right snapped">
	Request that surface is snapped to right.
      </description>
    </request>

    <request name="start_resize" since="1">
      <description summary="start an interactive resize">
	Request to start an interactive, user-driven resize of the surface.
	"x" and "y" specifies the starting point of the pointer device
	that initiated the reize.

	The compositor responds to this request with a "drag_started"
	event, followed by "bounds_changed" events, and ends the
	resize operation with a "drag_finhsed" event. The compositor
	determines the new bounds using the resize_direction and the
	pointer event location.

	The compositor may ignore resize requests depending on the state of the
	surface, e.g. fullscreen or maximized, or no drag event is in pregress.
      </description>
      <arg name="resize_direction" type="uint" enum="resize_direction"/>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
    </request>

    <enum name="frame_type">
      <description summary="frame types">
	Frame type that can be used to decorate a surface.
      </description>
      <entry name="none" value="0" summary="no frame"/>
      <entry name="normal" value="1" summary="caption with shadow"/>
      <entry name="shadow" value="2" summary="shadow only"/>
      <entry name="autohide" value="3" summary="autohide frame with shadow"/>
      <entry name="overlay" value="4" summary="[Deprecated] overlay frame with shadow"/>
      <entry name="overlap" value="5" summary="overlap frame with the window" since="6"/>
    </enum>

    <request name="set_frame" since="1">
      <description summary="request a frame for surface">
	Enables compositor side frame decoration. |type|
	specifies the type of frame to use for the surface.
      </description>
      <arg name="type" type="uint" enum="frame_type"/>
    </request>

    <enum name="frame_button_type" bitfield="true">
      <description summary="frame button types">
	The mask that represents buttons on frame.
      </description>
      <entry name="back" value="1" summary="a button to naviate backwards"/>
      <entry name="minimize" value="2" summary="a button to minimize the window"/>
      <entry name="maximize_restore" value="4"
	     summary="a button to maximize or restore"/>
      <entry name="menu" value="8"
	     summary="a button to activate application's menu"/>
      <entry name="close" value="16" summary="a button to close the window"/>
      <entry name="zoom" value="32"
	     summary="a mask to turn the maximize_restore button to zoom button"/>
      <entry name="center" value="64"
	     summary="a customizable, center-aligned button"/>
      <entry name="float" value="128"
	     summary="a button to float a window without maximize or restore"/>
    </enum>

    <request name="set_frame_buttons" since="1">
      <description summary="updates buttons' state on frame">
	Updates the frame's button state. |visible_buttons| and |enabled_buttons|
	are the union of button mask defined in |frame_button_type| enum.

	The mask present in |enabled_buttons| but not in |visible_buttons| will
	be ignored.
      </description>
      <arg name="visible_buttons" type="uint"/>
      <arg name="enabled_buttons" type="uint"/>
    </request>

    <request name="set_extra_title" since="1">
      <description summary="set extra title string">
	The extra informational string about the surface. This can be
	used to show the debug information in the title bar, or log
	messages.

	This is different from "set_title" which is used to identify
	the surface.

	The string must be encoded in UTF-8.
      </description>
      <arg name="extra_title" type="string"/>
    </request>

    <enum name="orientation_lock">
      <description summary="orientation lock request for remote surfaces">
	Defines orientation request when a remote surface is in foreground.
      </description>
      <entry name="none" value="1" summary="no orientation lock"/>
      <entry name="portrait" value="2" summary="primary or secondary portrait"/>
      <entry name="landscape" value="3" summary="primary or secondary landscape"/>
      <entry name="current" value="4" summary="keep current orientation"/>
      <entry name="portrait_primary" value="5" summary="primary portrait"/>
      <entry name="landscape_primary" value="6" summary="primary landscape"/>
      <entry name="portrait_secondary" value="7" summary="secondary portrait"/>
      <entry name="landscape_secondary" value="8" summary="secondary landscape"/>
    </enum>

    <request name="set_orientation_lock" since="1">
      <description summary="set orientation lock for a remote surface">
	Request a specific orientation behavior when this surface is in foreground.
      </description>
      <arg name="orientation_lock" type="uint" enum="orientation_lock"/>
    </request>

    <request name="pip" since="1">
      <description summary="set pip for a remote surface">
	Request that surface is set to Picture-in-Picture (PIP).
      </description>
    </request>

    <request name="set_aspect_ratio" since="1">
      <description summary="set the maximum size">
	Set an aspect ratio of the surface.

	Values set in this way are double-buffered. They will get
	applied on the next commit.

	The ratio of the values is used for the ratio of width to height of the
  surface. The size of surface is restricted to the ratio. If any value is
  zero, the restriction on aspect ratio is unset.
      </description>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </request>

    <enum name="zoom_change">
      <description summary="zoom level change">
	Zoom level change.
      </description>
      <entry name="in" value="0" summary="zoom in"/>
      <entry name="out" value="1" summary="zoom out"/>
      <entry name="reset" value="2" summary="reset zoom level"/>
    </enum>

    <event name="change_zoom_level" since="1">
      <description summary="change zoom level">
	Request application zoom level change.
      </description>
      <arg name="change" type="int" enum="zoom_change"/>
    </event>

    <request name="set_accessibility_id" since="1">
      <description summary="set accessibility ID to the surface">
        [Deprecated] Use zaura_surface's set_accessibility_id instead.

        Set accessibility window ID to the surface. A negative number removes
        the existing accessibility ID from the surface.
      </description>
      <arg name="id" type="int" summary="Accessibility ID. Negative number removes existing accessibility ID from the surface."/>
    </request>

    <request name="set_pip_original_window" since="1">
      <description summary="set the pip original window">
        Set this surface the original window for the current PIP window.
      </description>
    </request>

    <request name="unset_pip_original_window" since="1">
      <description summary="unset the pip original window">
        Unset this surface the original window for the current PIP window.
      </description>
    </request>

    <request name="set_system_gesture_exclusion" since="1">
      <description summary="set system gesture exclusion">
        Set system gesture exclusion region in which system gestures e.g. back
        gesture should not be triggered.
      </description>
      <arg name="region" type="object" interface="wl_region" allow-null="true"/>
    </request>

    <request name="set_resize_lock" since="1">
      <description summary="set resize lock state">
          [Deprecated] Enable the resize lock and put restrictions related to resizing on
          the shell surface.

          The resize lock state is double buffered, and will be applied at the
          time wl_surface.commit of the corresponding wl_surface is called.
      </description>
    </request>

    <request name="unset_resize_lock" since="1">
      <description summary="unset resize lock state">
          [Deprecated] Disable the resize lock and allow the shell surface to be resized
          freely.

          The resize lock state is double buffered, and will be applied at the
          time wl_surface.commit of the corresponding wl_surface is called.
      </description>
    </request>

    <event name="bounds_changed_in_output" since="1">
      <description summary="The compositor requested to change the bounds">
	The compositor requested to change its
	bounds. "bounds_change_reason" specifies the cause of the
	bounds change. The client may apply the different move/resize
	strategy depending on the reason.

	The "output" specifies the wayland output in which the suface should live.

	The client responds with set_bounds_in_output request, with the
	bounds it is resized to (this may be different from the bounds
	requested).

	The client may ignore move request depending on the state,
	e.g, if it becomes resizable or other constrants.
      </description>
      <arg name="output" type="object" interface="wl_output"/>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
      <arg name="bounds_change_reason" type="uint" enum="bounds_change_reason"/>
    </event>

    <request name="set_bounds_in_output" since="1">
      <description summary="set window bounds">
	Set the "visible bounds" of a window from the user's perspective.
	Client-side decorations often have invisible portions like drop shadows
	which should be ignored for the purposes of aligning, placing and
	constraining windows.

	The bounds are double buffered, and will be applied at the
	time wl_surface.commit of the corresponding wl_surface is called.

	Once the bounds are set, it is not possible to unset them, and they will
	remain the same until set_bounds_in_output is called again, even if a new sub-
	surface or buffer is attached.

	If never set, the value is the surface content bounds. This updates
	dynamically on every commit.

	The bounds are relative to the given display. If the display is invalid,
	they are assumed to be relative to the primary display.

	The width and height must be greater than zero.
      </description>
      <arg name="output" type="object" interface="wl_output"/>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </request>

    <!-- Version 2 additions -->

    <enum name="resize_lock_type">
      <description summary="resize lock type">
  Resize lock type that can be used to put restrictions related to resizing.
      </description>
      <entry name="none" value="0" summary="follows normal resizeable policies"/>
      <entry name="resize_enabled_togglable" value="1" summary="resizing is enabled and resize lock type is togglable" />
      <entry name="resize_disabled_togglable" value="2" summary="resizing is disabled and resize lock type is togglable" />
      <entry name="resize_disalbed_nontoggleable" value="3" summary="resizing is disabled and resize lock type is not togglable"/>
    </enum>

    <request name="set_resize_lock_type" since="2">
      <description summary="set resize lock type">
  Set resize lock type and put restrictions related to resizing on the shell surface.

  The resize lock type is double buffered, and will be applied at the
  time wl_surface.commit of the corresponding wl_surface is called.
      </description>
      <arg name="type" type="uint" enum="resize_lock_type" summary="resize lock type"/>
    </request>

    <request name="set_float" since="3">
      <description summary="set the surface to be floated">
	Request that surface is floated.
      </description>
    </request>

    <!-- Version 4 additions -->
    <request name="set_scale_factor" since="4">
      <description summary="Allows the client to set the scale factor for the future buffer commits.">
        The client has a 32-bit float scale factor that is associated with each
        remote surface. This scale factor must be propagated exactly to exo. To
        do so we reinterpret_cast into a 32-bit uint and later cast back into a
        float. This is because wayland does not support native transport of
        floats. As different CPU architectures may use different endian
        representations for IEEE 754 floats, this protocol implicitly assumes
        that the caller and receiver are the same machine.
        This is double buffered state and will be applied in the next commit.
      </description>
      <arg name="scale_factor_as_uint" type="uint"/>
    </request>

     <!-- Version 5 additions -->
    <request name="set_window_corner_radii" since="5">
      <description summary="Request to apply rounded corners to the window of the surface.">
        The client specifies the radius of each corner to be applied to the
        window in DPs (device independent pixels).

        The window radius is double buffered, and will be applied at the
        time wl_surface.commit of the corresponding wl_surface is called.

        Note: Rounded corner radii affects the wl_surface tree, including
        subsurfaces. Once this protocol is called, surfaces cannot set
        their own rounded corner bounds because rounded window bounds will be
        applied to the whole surface tree.
      </description>
      <arg name="upper_left_radius" type="uint"/>
      <arg name="upper_right_radius" type="uint"/>
      <arg name="lower_right_radius" type="uint"/>
      <arg name="lower_left_radius" type="uint"/>
    </request>

    <!-- Version 6 additions -->
    <request name="set_shadow_corner_radii" since="6">
      <description summary="Request to apply rounded corners to the shadow of the surface.">
        The client specifies the radius of each corner to be applied to the shadow
        associated with the aura toplevel surface in device independent pixels (DPs).

        The shadow radius is double buffered, and will be applied at the
        time wl_surface.commit of the corresponding wl_surface is called.
      </description>
      <arg name="upper_left_radius" type="uint"/>
      <arg name="upper_right_radius" type="uint"/>
      <arg name="lower_right_radius" type="uint"/>
      <arg name="lower_left_radius" type="uint"/>
    </request>
  </interface>

  <interface name="zcr_notification_surface_v2" version="1">
    <description summary="A notification window">
      An interface that may be implemented by a wl_surface to host
      notification contents.
    </description>

    <request name="destroy" type="destructor">
      <description summary="Destroy the notification_surface">
	Unmap and destroy the notification surface.
      </description>
    </request>

    <request name="set_app_id" since="1">
      <description summary="set application ID">
	Set an application identifier for the notification surface.
      </description>
      <arg name="app_id" type="string"/>
    </request>
  </interface>

  <interface name="zcr_input_method_surface_v2" version="1">
    <description summary="An input method window">
      An interface that may be implemented by a wl_surface to host IME contents.
    </description>

    <request name="destroy" type="destructor">
      <description summary="Destroy the ime_surface">
	Unmap and destroy the input mtehod surface.
      </description>
    </request>

    <request name="set_bounds_in_output" since="1">
      <description summary="set window bounds">
	Set the "visible bounds" of a window from the user's perspective.

	The bounds are double buffered, and will be applied at the
	time wl_surface.commit of the corresponding wl_surface is called.

	Once the bounds are set, it is not possible to unset them, and they will
	remain the same until set_bounds_in_output is called again, even if a new sub-
	surface or buffer is attached.

	If never set, the value is the surface content bounds. This updates
	dynamically on every commit.

	The bounds are relative to the given display. If the display is invalid,
	they are assumed to be relative to the primary display.

	The width and height must be greater than zero.
      </description>
      <arg name="output" type="object" interface="wl_output"/>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </request>
  </interface>

  <interface name="zcr_toast_surface_v2" version="2">
    <description summary="A toast window">
      An interface that may be implemented by a wl_surface to host
      toast contents.
    </description>

    <request name="destroy" type="destructor">
      <description summary="Destroy the toast_surface">
	Unmap and destroy the toast surface.
      </description>
    </request>

    <request name="set_bounds_in_output" since="1">
      <description summary="set toast bounds position">
	Set the bounds of a toast window from the user's perspective.

	The bounds are double buffered, and will be applied at the
	time wl_surface.commit of the corresponding wl_surface is called.

	Once the bounds are set, it is not possible to unset them, and they will
	remain the same until set_bounds is called again, even if a new sub-
	surface or buffer is attached.

	If never set, the compositor will determine the toast position.

	The bounds are relative to the given display. If the display is invalid,
	they are assumed to be relative to the primary display.
      </description>
      <arg name="output" type="object" interface="wl_output"/>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
    </request>

    <!-- Version 2 additions -->
    <request name="set_scale_factor" since="2">
      <description summary="Allows the client to set the scale factor for the future buffer commits.">
        The client has a 32-bit float scale factor that is associated with each
        remote surface. This scale factor must be propagated exactly to exo. To
        do so we reinterpret_cast into a 32-bit uint and later cast back into a
        float. This is because wayland does not support native transport of
        floats. As different CPU architectures may use different endian
        representations for IEEE 754 floats, this protocol implicitly assumes
        that the caller and receiver are the same machine.
        This is double buffered state and will be applied in the next commit.
      </description>
      <arg name="scale_factor_as_uint" type="uint"/>
    </request>
  </interface>

  <interface name="zcr_remote_output_v2" version="1">
    <description summary="remote shell interface to a wl_output">
	An additional interface to a wl_output object, which allows the
	client to access additional functionality for output.
    </description>

    <request name="destroy" type="destructor" since="1">
      <description summary="destroy remote_output">
	Destroy this remote_output object.
      </description>
    </request>

    <event name="display_id" since="1">
      <description summary="the identifier for the display">
	[Deprecated] Sends the display identifier used by the server for the display.
      </description>
      <arg name="display_id_hi" type="uint"/>
      <arg name="display_id_lo" type="uint"/>
    </event>

    <event name="port" since="1">
      <description summary="the port of the display">
	Sends the port to which the display is connected for the server.
      </description>
      <arg name="port" type="uint"/>
    </event>

    <event name="identification_data" since="1">
      <description summary="the identification data for the display">
	Sends the identification data for the display, typically in the EDID format.
      </description>
      <arg name="identification_data" type="array"/>
    </event>

    <event name="insets" since="1">
      <description summary="insets for the display in pixels">
	Sends inset information about a particular display in the display's native coordinates.
      </description>
      <arg name="inset_left" type="int"/>
      <arg name="inset_top" type="int"/>
      <arg name="inset_right" type="int"/>
      <arg name="inset_bottom" type="int"/>
    </event>

    <event name="stable_insets" since="1">
      <description summary="stable insets for a display in pixels">
	Sends stable inset information about a particular display in the display's native
	coordinates.
      </description>
      <arg name="stable_inset_left" type="int"/>
      <arg name="stable_inset_top" type="int"/>
      <arg name="stable_inset_right" type="int"/>
      <arg name="stable_inset_bottom" type="int"/>
    </event>

    <enum name="systemui_behavior">
      <description summary="systemui behavior">
	Determine the behavior of the system UI.
      </description>
      <entry name="visible" value="1" summary="system ui is visible"/>
      <entry name="hidden" value="2" summary="system ui is autohide or hidden"/>
    </enum>

    <event name="systemui_behavior" since="1">
      <description summary="systemui_behavior_state for a display">
	Sends information about whether the systemui behavior is auto hide.
	The "systemui_behavior" value is of enum type "systemui_behavior".
      </description>
      <arg name="systemui_behavior" type="int" enum="systemui_behavior"/>
    </event>

 </interface>

</protocol>
