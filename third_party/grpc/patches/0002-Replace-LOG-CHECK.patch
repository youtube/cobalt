From aef5e9d494520e87816e9945ebc0cd3d068f40c5 Mon Sep 17 00:00:00 2001
From: Victor Hugo Vianna Silva <victorvianna@google.com>
Date: Mon, 17 Feb 2025 13:47:05 +0000
Subject: [PATCH] Replace LOG/CHECK with ABSL_* counterparts

Chromium cannot use absl's LOG()/CHECK() as they conflict with the
macros in //base. This was generated with the following script.

find third_party/grpc/source -type f | while read file; do
  sed -Ei '
  s/absl\/log\/check.h/absl\/log\/absl_check.h/g;
  s/ CHECK\(/ ABSL_CHECK\(/g;
  s/ QCHECK\(/ ABSL_QCHECK\(/g;
  s/ PCHECK\(/ ABSL_PCHECK\(/g;
  s/ DCHECK\(/ ABSL_DCHECK\(/g;
  s/ CHECK_EQ\(/ ABSL_CHECK_EQ\(/g;
  s/ CHECK_NE\(/ ABSL_CHECK_NE\(/g;
  s/ CHECK_LE\(/ ABSL_CHECK_LE\(/g;
  s/ CHECK_LT\(/ ABSL_CHECK_LT\(/g;
  s/ CHECK_GE\(/ ABSL_CHECK_GE\(/g;
  s/ CHECK_GT\(/ ABSL_CHECK_GT\(/g;
  s/ QCHECK_EQ\(/ ABSL_QCHECK_EQ\(/g;
  s/ QCHECK_NE\(/ ABSL_QCHECK_NE\(/g;
  s/ QCHECK_LE\(/ ABSL_QCHECK_LE\(/g;
  s/ QCHECK_LT\(/ ABSL_QCHECK_LT\(/g;
  s/ QCHECK_GE\(/ ABSL_QCHECK_GE\(/g;
  s/ QCHECK_GT\(/ ABSL_QCHECK_GT\(/g;
  s/ DCHECK_EQ\(/ ABSL_DCHECK_EQ\(/g;
  s/ DCHECK_NE\(/ ABSL_DCHECK_NE\(/g;
  s/ DCHECK_LE\(/ ABSL_DCHECK_LE\(/g;
  s/ DCHECK_LT\(/ ABSL_DCHECK_LT\(/g;
  s/ DCHECK_GE\(/ ABSL_DCHECK_GE\(/g;
  s/ DCHECK_GT\(/ ABSL_DCHECK_GT\(/g;
  s/ CHECK_OK\(/ ABSL_CHECK_OK\(/g;
  s/ QCHECK_OK\(/ ABSL_QCHECK_OK\(/g;
  s/ DCHECK_OK\(/ ABSL_DCHECK_OK\(/g;
  s/ CHECK_STREQ\(/ ABSL_CHECK_STREQ\(/g;
  s/ CHECK_STRNE\(/ ABSL_CHECK_STRNE\(/g;
  s/ CHECK_STRCASEEQ\(/ ABSL_CHECK_STRCASEEQ\(/g;
  s/ CHECK_STRCASENE\(/ ABSL_CHECK_STRCASENE\(/g;
  s/ QCHECK_STREQ\(/ ABSL_QCHECK_STREQ\(/g;
  s/ QCHECK_STRNE\(/ ABSL_QCHECK_STRNE\(/g;
  s/ QCHECK_STRCASEEQ\(/ ABSL_QCHECK_STRCASEEQ\(/g;
  s/ QCHECK_STRCASENE\(/ ABSL_QCHECK_STRCASENE\(/g;
  s/ DCHECK_STREQ\(/ ABSL_DCHECK_STREQ\(/g;
  s/ DCHECK_STRNE\(/ ABSL_DCHECK_STRNE\(/g;
  s/ DCHECK_STRCASEEQ\(/ ABSL_DCHECK_STRCASEEQ\(/g;
  s/ DCHECK_STRCASENE\(/ ABSL_DCHECK_STRCASENE\(/g;
  s/absl\/log\/log.h/absl\/log\/absl_log.h/g;
  s/ LOG\(/ ABSL_LOG\(/g;
  s/ PLOG\(/ ABSL_PLOG\(/g;
  s/ DLOG\(/ ABSL_DLOG\(/g;
  s/ VLOG\(/ ABSL_VLOG\(/g;
  s/ DVLOG\(/ ABSL_DVLOG\(/g;
  s/ LOG_IF\(/ ABSL_LOG_IF\(/g;
  s/ PLOG_IF\(/ ABSL_PLOG_IF\(/g;
  s/ DLOG_IF\(/ ABSL_DLOG_IF\(/g;
  s/ LOG_EVERY_N\(/ ABSL_LOG_EVERY_N\(/g;
  s/ LOG_FIRST_N\(/ ABSL_LOG_FIRST_N\(/g;
  s/ LOG_EVERY_POW_2\(/ ABSL_LOG_EVERY_POW_2\(/g;
  s/ LOG_EVERY_N_SEC\(/ ABSL_LOG_EVERY_N_SEC\(/g;
  s/ PLOG_EVERY_N\(/ ABSL_PLOG_EVERY_N\(/g;
  s/ PLOG_FIRST_N\(/ ABSL_PLOG_FIRST_N\(/g;
  s/ PLOG_EVERY_POW_2\(/ ABSL_PLOG_EVERY_POW_2\(/g;
  s/ PLOG_EVERY_N_SEC\(/ ABSL_PLOG_EVERY_N_SEC\(/g;
  s/ DLOG_EVERY_N\(/ ABSL_DLOG_EVERY_N\(/g;
  s/ DLOG_FIRST_N\(/ ABSL_DLOG_FIRST_N\(/g;
  s/ DLOG_EVERY_POW_2\(/ ABSL_DLOG_EVERY_POW_2\(/g;
  s/ DLOG_EVERY_N_SEC\(/ ABSL_DLOG_EVERY_N_SEC\(/g;
  s/ VLOG_EVERY_N\(/ ABSL_VLOG_EVERY_N\(/g;
  s/ VLOG_FIRST_N\(/ ABSL_VLOG_FIRST_N\(/g;
  s/ VLOG_EVERY_POW_2\(/ ABSL_VLOG_EVERY_POW_2\(/g;
  s/ VLOG_EVERY_N_SEC\(/ ABSL_VLOG_EVERY_N_SEC\(/g;
  s/ LOG_IF_EVERY_N\(/ ABSL_LOG_IF_EVERY_N\(/g;
  s/ LOG_IF_FIRST_N\(/ ABSL_LOG_IF_FIRST_N\(/g;
  s/ LOG_IF_EVERY_POW_2\(/ ABSL_LOG_IF_EVERY_POW_2\(/g;
  s/ LOG_IF_EVERY_N_SEC\(/ ABSL_LOG_IF_EVERY_N_SEC\(/g;
  s/ PLOG_IF_EVERY_N\(/ ABSL_PLOG_IF_EVERY_N\(/g;
  s/ PLOG_IF_FIRST_N\(/ ABSL_PLOG_IF_FIRST_N\(/g;
  s/ PLOG_IF_EVERY_POW_2\(/ ABSL_PLOG_IF_EVERY_POW_2\(/g;
  s/ PLOG_IF_EVERY_N_SEC\(/ ABSL_PLOG_IF_EVERY_N_SEC\(/g;
  s/ DLOG_IF_EVERY_N\(/ ABSL_DLOG_IF_EVERY_N\(/g;
  s/ DLOG_IF_FIRST_N\(/ ABSL_DLOG_IF_FIRST_N\(/g;
  s/ DLOG_IF_EVERY_POW_2\(/ ABSL_DLOG_IF_EVERY_POW_2\(/g;
  s/ DLOG_IF_EVERY_N_SEC\(/ ABSL_DLOG_IF_EVERY_N_SEC\(/g;' $file
done

---
 .../source/src/core/call/request_buffer.cc    |  10 +-
 .../grpc/source/src/core/channelz/channelz.cc |   6 +-
 .../src/core/channelz/channelz_registry.cc    |  10 +-
 .../src/core/client_channel/backup_poller.cc  |   4 +-
 .../src/core/client_channel/client_channel.cc |  26 +--
 .../client_channel/client_channel_filter.cc   |  74 ++++----
 .../client_channel/client_channel_internal.h  |   4 +-
 .../src/core/client_channel/config_selector.h |   6 +-
 .../core/client_channel/dynamic_filters.cc    |  10 +-
 .../src/core/client_channel/lb_metadata.cc    |   4 +-
 .../load_balanced_call_destination.cc         |  10 +-
 .../client_channel/local_subchannel_pool.cc   |   8 +-
 .../src/core/client_channel/retry_filter.h    |   6 +-
 .../retry_filter_legacy_call_data.cc          |  16 +-
 .../core/client_channel/retry_interceptor.cc  |   2 +-
 .../core/client_channel/retry_interceptor.h   |   2 +-
 .../client_channel/retry_service_config.cc    |   4 +-
 .../src/core/client_channel/subchannel.cc     |  24 +--
 .../subchannel_stream_client.cc               |  34 ++--
 .../src/core/config/core_configuration.cc     |   6 +-
 .../src/core/config/core_configuration.h      |   6 +-
 .../source/src/core/config/load_config.cc     |   4 +-
 .../backend_metrics/backend_metric_filter.cc  |   2 +-
 .../fault_injection/fault_injection_filter.cc |   2 +-
 .../gcp_authentication_filter.cc              |   2 +-
 .../message_compress/compression_filter.cc    |  12 +-
 .../filters/http/server/http_server_filter.cc |   2 +-
 .../server_load_reporting_filter.cc           |   8 +-
 .../ext/filters/logging/logging_filter.cc     |   6 +-
 .../message_size/message_size_filter.cc       |   2 +-
 .../stateful_session_filter.cc                |  14 +-
 .../chaotic_good/chaotic_good_transport.h     |   2 +-
 .../client/chaotic_good_connector.cc          |   8 +-
 .../chaotic_good/client_transport.cc          |  10 +-
 .../core/ext/transport/chaotic_good/config.h  |   2 +-
 .../chaotic_good/control_endpoint.cc          |   2 +-
 .../transport/chaotic_good/data_endpoints.cc  |  10 +-
 .../core/ext/transport/chaotic_good/frame.cc  |  20 +--
 .../core/ext/transport/chaotic_good/frame.h   |   8 +-
 .../chaotic_good/message_reassembly.h         |   6 +-
 .../server/chaotic_good_server.cc             |  40 ++---
 .../chaotic_good/server/chaotic_good_server.h |   2 +-
 .../chaotic_good/server_transport.cc          |  12 +-
 .../core/ext/transport/chttp2/alpn/alpn.cc    |   4 +-
 .../chttp2/client/chttp2_connector.cc         |  20 +--
 .../transport/chttp2/server/chttp2_server.cc  |  36 ++--
 .../transport/chttp2/transport/bin_decoder.cc |  28 +--
 .../transport/chttp2/transport/bin_encoder.cc |  12 +-
 .../chttp2/transport/chttp2_transport.cc      | 122 ++++++-------
 .../chttp2/transport/flow_control.cc          |   8 +-
 .../transport/chttp2/transport/flow_control.h |   6 +-
 .../ext/transport/chttp2/transport/frame.cc   |   6 +-
 .../transport/chttp2/transport/frame_data.cc  |   4 +-
 .../chttp2/transport/frame_goaway.cc          |   8 +-
 .../transport/chttp2/transport/frame_ping.cc  |   8 +-
 .../chttp2/transport/frame_rst_stream.cc      |   6 +-
 .../chttp2/transport/frame_settings.cc        |   4 +-
 .../chttp2/transport/frame_window_update.cc   |   6 +-
 .../chttp2/transport/hpack_encoder.cc         |  10 +-
 .../chttp2/transport/hpack_encoder.h          |   4 +-
 .../chttp2/transport/hpack_encoder_table.cc   |  16 +-
 .../chttp2/transport/hpack_parse_result.cc    |   4 +-
 .../chttp2/transport/hpack_parse_result.h     |   4 +-
 .../chttp2/transport/hpack_parser.cc          |  50 +++---
 .../chttp2/transport/hpack_parser_table.cc    |  10 +-
 .../ext/transport/chttp2/transport/internal.h |   2 +-
 .../ext/transport/chttp2/transport/parsing.cc |  32 ++--
 .../chttp2/transport/ping_callbacks.cc        |   4 +-
 .../chttp2/transport/stream_lists.cc          |  18 +-
 .../ext/transport/chttp2/transport/varint.h   |   4 +-
 .../chttp2/transport/write_size_policy.cc     |   4 +-
 .../ext/transport/chttp2/transport/writing.cc |  18 +-
 .../client/secure/cronet_channel_create.cc    |   4 +-
 .../cronet/transport/cronet_api_phony.cc      |  20 +--
 .../cronet/transport/cronet_transport.cc      |  22 +--
 .../ext/transport/inproc/inproc_transport.cc  |   6 +-
 .../inproc/legacy_inproc_transport.cc         |  14 +-
 .../source/src/core/handshaker/handshaker.cc  |   8 +-
 .../http_connect/http_connect_handshaker.cc   |   8 +-
 .../http_connect/http_proxy_mapper.cc         |  30 ++--
 .../http_connect/xds_http_proxy_mapper.cc     |   6 +-
 .../handshaker/security/secure_endpoint.cc    |  18 +-
 .../security/security_handshaker.cc           |   6 +-
 .../tcp_connect/tcp_connect_handshaker.cc     |   6 +-
 .../core/lib/address_utils/parse_address.cc   |  46 ++---
 .../core/lib/address_utils/sockaddr_utils.cc  |  30 ++--
 .../src/core/lib/channel/channel_args.cc      |  26 +--
 .../src/core/lib/channel/channel_stack.cc     |  14 +-
 .../src/core/lib/channel/connected_channel.cc |   4 +-
 .../core/lib/channel/promise_based_filter.cc  | 114 ++++++------
 .../core/lib/channel/promise_based_filter.h   |  64 +++----
 .../lib/compression/compression_internal.cc   |   4 +-
 .../core/lib/compression/message_compress.cc  |  26 +--
 .../grpc/source/src/core/lib/debug/trace.cc   |  10 +-
 .../source/src/core/lib/debug/trace_impl.h    |   8 +-
 .../core/lib/event_engine/ares_resolver.cc    |  36 ++--
 .../lib/event_engine/cf_engine/cf_engine.cc   |   8 +-
 .../cf_engine/dns_service_resolver.cc         |   4 +-
 .../cf_engine/dns_service_resolver.h          |   4 +-
 .../src/core/lib/event_engine/forkable.cc     |  10 +-
 .../posix_engine/ev_epoll1_linux.cc           |  26 +--
 .../posix_engine/ev_poll_posix.cc             |  20 +--
 .../posix_engine/internal_errqueue.cc         |   6 +-
 .../posix_engine/lockfree_event.cc            |   4 +-
 .../posix_engine/posix_endpoint.cc            |  66 +++----
 .../posix_engine/posix_endpoint.h             |  26 +--
 .../event_engine/posix_engine/posix_engine.cc |  24 +--
 .../posix_engine/posix_engine_listener.cc     |  18 +-
 .../posix_engine_listener_utils.cc            |  28 +--
 .../posix_engine/tcp_socket_utils.cc          |  14 +-
 .../posix_engine/tcp_socket_utils.h           |   4 +-
 .../posix_engine/timer_manager.cc             |  10 +-
 .../posix_engine/traced_buffer_list.cc        |   4 +-
 .../core/lib/event_engine/resolved_address.cc |   6 +-
 .../source/src/core/lib/event_engine/slice.cc |   4 +-
 .../core/lib/event_engine/tcp_socket_utils.cc |  30 ++--
 .../event_engine/thread_pool/thread_count.cc  |   2 +-
 .../thread_pool/work_stealing_thread_pool.cc  |  22 +--
 .../windows/grpc_polled_fd_windows.cc         |  58 +++----
 .../src/core/lib/event_engine/windows/iocp.cc |  16 +-
 .../lib/event_engine/windows/win_socket.cc    |  14 +-
 .../event_engine/windows/windows_endpoint.cc  |  24 +--
 .../event_engine/windows/windows_engine.cc    |  22 +--
 .../event_engine/windows/windows_listener.cc  |  24 +--
 .../source/src/core/lib/experiments/config.cc |  16 +-
 .../source/src/core/lib/iomgr/buffer_list.cc  |   6 +-
 .../src/core/lib/iomgr/call_combiner.cc       |   8 +-
 .../source/src/core/lib/iomgr/call_combiner.h |   2 +-
 .../src/core/lib/iomgr/cfstream_handle.cc     |   6 +-
 .../grpc/source/src/core/lib/iomgr/closure.h  |   6 +-
 .../source/src/core/lib/iomgr/combiner.cc     |  12 +-
 .../src/core/lib/iomgr/endpoint_cfstream.cc   |  26 +--
 .../src/core/lib/iomgr/endpoint_pair_posix.cc |  10 +-
 .../core/lib/iomgr/endpoint_pair_windows.cc   |  22 +--
 .../grpc/source/src/core/lib/iomgr/error.cc   |   8 +-
 .../grpc/source/src/core/lib/iomgr/error.h    |   4 +-
 .../src/core/lib/iomgr/ev_epoll1_linux.cc     |  42 ++---
 .../src/core/lib/iomgr/ev_poll_posix.cc       |  22 +--
 .../source/src/core/lib/iomgr/ev_posix.cc     |   2 +-
 .../lib/iomgr/event_engine_shims/closure.cc   |   2 +-
 .../lib/iomgr/event_engine_shims/endpoint.cc  |  14 +-
 .../source/src/core/lib/iomgr/exec_ctx.cc     |  10 +-
 .../grpc/source/src/core/lib/iomgr/exec_ctx.h |   6 +-
 .../source/src/core/lib/iomgr/executor.cc     |  12 +-
 .../source/src/core/lib/iomgr/fork_posix.cc   |   8 +-
 .../source/src/core/lib/iomgr/fork_windows.cc |   4 +-
 .../src/core/lib/iomgr/internal_errqueue.cc   |   6 +-
 .../source/src/core/lib/iomgr/iocp_windows.cc |  20 +--
 .../grpc/source/src/core/lib/iomgr/iomgr.cc   |  10 +-
 .../src/core/lib/iomgr/iomgr_windows.cc       |   6 +-
 .../src/core/lib/iomgr/lockfree_event.cc      |   6 +-
 .../src/core/lib/iomgr/polling_entity.cc      |   8 +-
 .../core/lib/iomgr/sockaddr_utils_posix.cc    |   4 +-
 .../lib/iomgr/socket_utils_common_posix.cc    |  12 +-
 .../src/core/lib/iomgr/socket_windows.cc      |  16 +-
 .../src/core/lib/iomgr/tcp_client_cfstream.cc |   2 +-
 .../src/core/lib/iomgr/tcp_client_posix.cc    |  14 +-
 .../src/core/lib/iomgr/tcp_client_windows.cc  |   8 +-
 .../source/src/core/lib/iomgr/tcp_posix.cc    | 106 ++++++------
 .../src/core/lib/iomgr/tcp_server_posix.cc    |  58 +++----
 .../iomgr/tcp_server_utils_posix_common.cc    |  16 +-
 .../iomgr/tcp_server_utils_posix_ifaddrs.cc   |  12 +-
 .../src/core/lib/iomgr/tcp_server_windows.cc  |  42 ++---
 .../source/src/core/lib/iomgr/tcp_windows.cc  |  24 +--
 .../src/core/lib/iomgr/timer_generic.cc       |  12 +-
 .../src/core/lib/iomgr/timer_manager.cc       |  10 +-
 .../src/core/lib/iomgr/unix_sockets_posix.cc  |   4 +-
 .../core/lib/iomgr/unix_sockets_posix_noop.cc |   4 +-
 .../src/core/lib/iomgr/wakeup_fd_pipe.cc      |   4 +-
 .../source/src/core/lib/promise/activity.cc   |   4 +-
 .../source/src/core/lib/promise/activity.h    |  12 +-
 .../source/src/core/lib/promise/context.h     |   4 +-
 .../src/core/lib/promise/detail/join_state.h  |  36 ++--
 .../src/core/lib/promise/detail/seq_state.h   |  52 +++---
 .../src/core/lib/promise/detail/status.h      |   4 +-
 .../promise/event_engine_wakeup_scheduler.h   |   4 +-
 .../source/src/core/lib/promise/for_each.h    |  12 +-
 .../core/lib/promise/inter_activity_latch.h   |   2 +-
 .../src/core/lib/promise/interceptor_list.h   |   6 +-
 .../grpc/source/src/core/lib/promise/latch.h  |  16 +-
 .../source/src/core/lib/promise/map_pipe.h    |   2 +-
 .../grpc/source/src/core/lib/promise/mpsc.h   |   8 +-
 .../source/src/core/lib/promise/observable.h  |   8 +-
 .../grpc/source/src/core/lib/promise/party.cc |  36 ++--
 .../grpc/source/src/core/lib/promise/party.h  |  18 +-
 .../grpc/source/src/core/lib/promise/pipe.h   |  28 +--
 .../grpc/source/src/core/lib/promise/poll.h   |   8 +-
 .../src/core/lib/promise/promise_mutex.h      |  12 +-
 .../source/src/core/lib/promise/status_flag.h |  14 +-
 .../source/src/core/lib/promise/try_join.h    |   4 +-
 .../source/src/core/lib/promise/try_seq.h     |   4 +-
 .../src/core/lib/resource_quota/arena.cc      |   4 +-
 .../src/core/lib/resource_quota/arena.h       |   2 +-
 .../lib/resource_quota/connection_quota.cc    |   8 +-
 .../core/lib/resource_quota/memory_quota.cc   |  22 +--
 .../core/lib/resource_quota/memory_quota.h    |   8 +-
 .../core/lib/resource_quota/thread_quota.cc   |   4 +-
 .../security/authorization/audit_logging.cc   |  10 +-
 .../authorization/cel_authorization_engine.cc |   8 +-
 .../security/authorization/evaluate_args.cc   |  10 +-
 .../grpc_authorization_engine.cc              |   4 +-
 .../grpc_authorization_policy_provider.cc     |  16 +-
 .../authorization/grpc_server_authz_filter.cc |   2 +-
 .../lib/security/authorization/matchers.cc    |   4 +-
 .../security/authorization/rbac_translator.cc |   6 +-
 .../security/authorization/stdout_logger.cc   |   6 +-
 .../certificate_provider_registry.cc          |   8 +-
 .../lib/security/context/security_context.cc  |  12 +-
 .../credentials/alts/check_gcp_environment.cc |   4 +-
 .../alts/check_gcp_environment_no_op.cc       |   4 +-
 .../grpc_alts_credentials_client_options.cc   |   4 +-
 .../alts/grpc_alts_credentials_options.cc     |   4 +-
 .../security/credentials/call_creds_util.cc   |  10 +-
 .../composite/composite_credentials.cc        |  14 +-
 .../lib/security/credentials/credentials.cc   |  10 +-
 .../lib/security/credentials/credentials.h    |   6 +-
 .../aws_external_account_credentials.cc       |   6 +-
 .../external/external_account_credentials.cc  |  10 +-
 .../url_external_account_credentials.cc       |   2 +-
 ...cp_service_account_identity_credentials.cc |   2 +-
 .../google_default/credentials_generic.cc     |   4 +-
 .../google_default_credentials.cc             |  14 +-
 .../credentials/iam/iam_credentials.cc        |   8 +-
 .../security/credentials/jwt/json_token.cc    |  30 ++--
 .../credentials/jwt/jwt_credentials.cc        |  12 +-
 .../security/credentials/jwt/jwt_verifier.cc  | 102 +++++------
 .../credentials/oauth2/oauth2_credentials.cc  |  42 ++---
 .../credentials/plugin/plugin_credentials.cc  |   8 +-
 .../credentials/ssl/ssl_credentials.cc        |  46 ++---
 .../credentials/ssl/ssl_credentials.h         |   4 +-
 .../tls/grpc_tls_certificate_distributor.cc   |  48 +++---
 .../tls/grpc_tls_certificate_provider.cc      |  30 ++--
 .../tls/grpc_tls_certificate_provider.h       |   4 +-
 .../tls/grpc_tls_certificate_verifier.cc      |   4 +-
 .../tls/grpc_tls_certificate_verifier.h       |   4 +-
 .../tls/grpc_tls_credentials_options.cc       |  40 ++---
 .../credentials/tls/grpc_tls_crl_provider.cc  |   4 +-
 .../credentials/tls/tls_credentials.cc        |  18 +-
 .../lib/security/credentials/tls/tls_utils.cc |   8 +-
 .../credentials/xds/xds_credentials.cc        |  10 +-
 .../alts/alts_security_connector.cc           |  30 ++--
 .../fake/fake_security_connector.cc           |  14 +-
 .../insecure/insecure_security_connector.cc   |   6 +-
 .../load_system_roots_supported.cc            |   8 +-
 .../local/local_security_connector.cc         |  24 +--
 .../security_connector/security_connector.cc  |  14 +-
 .../ssl/ssl_security_connector.cc             |  26 +--
 .../security/security_connector/ssl_utils.cc  |  30 ++--
 .../tls/tls_security_connector.cc             |  54 +++---
 .../security/transport/server_auth_filter.cc  |   8 +-
 .../src/core/lib/slice/percent_encoding.cc    |   4 +-
 .../grpc/source/src/core/lib/slice/slice.cc   |  18 +-
 .../grpc/source/src/core/lib/slice/slice.h    |   6 +-
 .../source/src/core/lib/slice/slice_buffer.cc |  26 +--
 .../src/core/lib/slice/slice_internal.h       |   4 +-
 .../core/lib/surface/byte_buffer_reader.cc    |   4 +-
 .../grpc/source/src/core/lib/surface/call.cc  |  22 +--
 .../grpc/source/src/core/lib/surface/call.h   |   2 +-
 .../src/core/lib/surface/call_log_batch.cc    |   2 +-
 .../source/src/core/lib/surface/call_utils.cc |   8 +-
 .../source/src/core/lib/surface/call_utils.h  |   4 +-
 .../source/src/core/lib/surface/channel.cc    |   8 +-
 .../src/core/lib/surface/channel_create.cc    |   4 +-
 .../src/core/lib/surface/channel_init.cc      |  30 ++--
 .../src/core/lib/surface/channel_init.h       |  14 +-
 .../src/core/lib/surface/client_call.cc       |   8 +-
 .../src/core/lib/surface/completion_queue.cc  |  60 +++----
 .../lib/surface/completion_queue_factory.cc   |  12 +-
 .../src/core/lib/surface/filter_stack_call.cc |  24 +--
 .../src/core/lib/surface/filter_stack_call.h  |   6 +-
 .../grpc/source/src/core/lib/surface/init.cc  |  14 +-
 .../src/core/lib/surface/legacy_channel.cc    |  20 +--
 .../src/core/lib/surface/server_call.cc       |   8 +-
 .../source/src/core/lib/surface/server_call.h |   2 +-
 .../src/core/lib/surface/validate_metadata.h  |   4 +-
 .../src/core/lib/transport/bdp_estimator.cc   |   6 +-
 .../src/core/lib/transport/bdp_estimator.h    |   8 +-
 .../src/core/lib/transport/call_destination.h |   2 +-
 .../src/core/lib/transport/call_filters.cc    |  10 +-
 .../src/core/lib/transport/call_filters.h     |  66 +++----
 .../src/core/lib/transport/call_spine.cc      |   4 +-
 .../src/core/lib/transport/call_spine.h       |  10 +-
 .../src/core/lib/transport/call_state.h       |  70 ++++----
 .../core/lib/transport/connectivity_state.cc  |   2 +-
 .../core/lib/transport/interception_chain.h   |   2 +-
 .../src/core/lib/transport/metadata_batch.h   |   6 +-
 .../core/lib/transport/promise_endpoint.cc    |   6 +-
 .../src/core/lib/transport/promise_endpoint.h |  20 +--
 .../core/lib/transport/timeout_encoding.cc    |   8 +-
 .../source/src/core/lib/transport/transport.h |   4 +-
 .../load_balancing/child_policy_handler.cc    |  28 +--
 .../src/core/load_balancing/endpoint_list.cc  |   8 +-
 .../src/core/load_balancing/grpclb/grpclb.cc  |  78 ++++-----
 .../grpclb/load_balancer_api.cc               |   4 +-
 .../load_balancing/health_check_client.cc     |   8 +-
 .../core/load_balancing/lb_policy_registry.cc |   8 +-
 .../core/load_balancing/oob_backend_metric.cc |   8 +-
 .../outlier_detection/outlier_detection.cc    |  14 +-
 .../load_balancing/pick_first/pick_first.cc   |  64 +++----
 .../core/load_balancing/priority/priority.cc  |  10 +-
 .../load_balancing/ring_hash/ring_hash.cc     |  14 +-
 .../source/src/core/load_balancing/rls/rls.cc |  32 ++--
 .../load_balancing/round_robin/round_robin.cc |  26 +--
 .../static_stride_scheduler.cc                |   6 +-
 .../weighted_round_robin.cc                   |  26 +--
 .../weighted_target/weighted_target.cc        |  14 +-
 .../source/src/core/load_balancing/xds/cds.cc |  14 +-
 .../load_balancing/xds/xds_cluster_impl.cc    |  14 +-
 .../load_balancing/xds/xds_cluster_manager.cc |   2 +-
 .../load_balancing/xds/xds_override_host.cc   |  12 +-
 .../load_balancing/xds/xds_wrr_locality.cc    |   6 +-
 .../resolver/dns/c_ares/dns_resolver_ares.cc  |   4 +-
 .../dns/c_ares/grpc_ares_ev_driver_posix.cc   |   4 +-
 .../dns/c_ares/grpc_ares_ev_driver_windows.cc |  62 +++----
 .../resolver/dns/c_ares/grpc_ares_wrapper.cc  |  34 ++--
 .../resolver/dns/c_ares/grpc_ares_wrapper.h   |   2 +-
 .../core/resolver/dns/dns_resolver_plugin.cc  |  10 +-
 .../event_engine_client_channel_resolver.cc   |   8 +-
 .../core/resolver/dns/native/dns_resolver.cc  |   6 +-
 .../src/core/resolver/endpoint_addresses.cc   |   6 +-
 .../src/core/resolver/fake/fake_resolver.cc   |   4 +-
 .../google_c2p/google_c2p_resolver.cc         |  12 +-
 .../src/core/resolver/polling_resolver.cc     |  32 ++--
 .../src/core/resolver/resolver_registry.cc    |  14 +-
 .../resolver/sockaddr/sockaddr_resolver.cc    |   4 +-
 .../resolver/xds/xds_dependency_manager.cc    |   6 +-
 .../src/core/resolver/xds/xds_resolver.cc     |  22 +--
 .../grpc/source/src/core/server/server.cc     |  74 ++++----
 .../server/server_config_selector_filter.cc   |   4 +-
 .../core/server/xds_server_config_fetcher.cc  |  34 ++--
 .../service_config_channel_arg_filter.cc      |   4 +-
 .../core/service_config/service_config_impl.h |   4 +-
 .../service_config/service_config_parser.cc   |   4 +-
 .../source/src/core/telemetry/call_tracer.cc  |   8 +-
 .../grpc/source/src/core/telemetry/metrics.cc |   4 +-
 .../frame_protector/alts_frame_protector.cc   |  24 +--
 .../tsi/alts/frame_protector/frame_handler.cc |   8 +-
 .../alts/handshaker/alts_handshaker_client.cc | 122 ++++++-------
 .../alts/handshaker/alts_shared_resource.cc   |   6 +-
 .../alts/handshaker/alts_tsi_handshaker.cc    | 104 +++++------
 .../tsi/alts/handshaker/alts_tsi_utils.cc     |  10 +-
 .../transport_security_common_api.cc          |  18 +-
 ...lts_grpc_integrity_only_record_protocol.cc |  22 +--
 ..._grpc_privacy_integrity_record_protocol.cc |  14 +-
 .../alts_grpc_record_protocol_common.cc       |  20 +--
 .../alts_zero_copy_grpc_protector.cc          |  18 +-
 .../src/core/tsi/fake_transport_security.cc   |  20 +--
 .../src/core/tsi/local_transport_security.cc  |  10 +-
 .../tsi/ssl/key_logging/ssl_key_logging.cc    |  14 +-
 .../ssl/session_cache/ssl_session_cache.cc    |  24 +--
 .../ssl/session_cache/ssl_session_openssl.cc  |   6 +-
 .../src/core/tsi/ssl_transport_security.cc    | 162 +++++++++---------
 .../core/tsi/ssl_transport_security_utils.cc  |  46 ++---
 .../grpc/source/src/core/util/alloc.cc        |   4 +-
 .../source/src/core/util/chunked_vector.h     |   8 +-
 .../grpc/source/src/core/util/crash.cc        |   4 +-
 .../grpc/source/src/core/util/down_cast.h     |   4 +-
 .../source/src/core/util/dual_ref_counted.h   |  40 ++---
 .../grpc/source/src/core/util/dump_args.cc    |   4 +-
 .../grpc/source/src/core/util/dump_args.h     |   2 +-
 .../grpc/source/src/core/util/event_log.cc    |   4 +-
 .../src/core/util/gcp_metadata_query.cc       |   6 +-
 .../grpc/source/src/core/util/gpr_time.cc     |  18 +-
 .../core/util/grpc_if_nametoindex_posix.cc    |   4 +-
 .../util/grpc_if_nametoindex_unsupported.cc   |   4 +-
 .../grpc/source/src/core/util/host_port.cc    |  10 +-
 .../src/core/util/http_client/httpcli.cc      |   6 +-
 .../http_client/httpcli_security_connector.cc |  10 +-
 .../src/core/util/http_client/parser.cc       |  10 +-
 .../source/src/core/util/json/json_reader.cc  |   6 +-
 .../grpc/source/src/core/util/latent_see.cc   |   2 +-
 .../grpc/source/src/core/util/latent_see.h    |   8 +-
 .../grpc/source/src/core/util/linux/cpu.cc    |  10 +-
 third_party/grpc/source/src/core/util/log.cc  |  34 ++--
 .../grpc/source/src/core/util/lru_cache.h     |   8 +-
 third_party/grpc/source/src/core/util/mpscq.h |   6 +-
 .../grpc/source/src/core/util/posix/cpu.cc    |   4 +-
 .../grpc/source/src/core/util/posix/stat.cc   |  10 +-
 .../grpc/source/src/core/util/posix/sync.cc   |  48 +++---
 .../grpc/source/src/core/util/posix/thd.cc    |  24 +--
 .../grpc/source/src/core/util/posix/time.cc   |  14 +-
 .../source/src/core/util/posix/tmpfile.cc     |  10 +-
 .../grpc/source/src/core/util/ref_counted.h   |  24 +--
 .../source/src/core/util/single_set_ptr.h     |   4 +-
 .../source/src/core/util/status_helper.cc     |   4 +-
 .../source/src/core/util/subprocess_posix.cc  |  18 +-
 .../src/core/util/subprocess_windows.cc       |   4 +-
 third_party/grpc/source/src/core/util/sync.cc |   8 +-
 third_party/grpc/source/src/core/util/sync.h  |   8 +-
 .../grpc/source/src/core/util/tdigest.cc      |  28 +--
 third_party/grpc/source/src/core/util/thd.h   |  12 +-
 third_party/grpc/source/src/core/util/time.cc |  14 +-
 third_party/grpc/source/src/core/util/time.h  |   2 +-
 .../grpc/source/src/core/util/time_precise.cc |   6 +-
 .../grpc/source/src/core/util/time_util.cc    |   6 +-
 .../src/core/util/unique_ptr_with_bitset.h    |  10 +-
 third_party/grpc/source/src/core/util/uri.cc  |   4 +-
 .../grpc/source/src/core/util/useful.h        |   2 +-
 .../source/src/core/util/validation_errors.cc |   4 +-
 .../src/core/util/wait_for_single_owner.h     |   4 +-
 .../grpc/source/src/core/util/windows/stat.cc |  10 +-
 .../grpc/source/src/core/util/windows/sync.cc |   4 +-
 .../grpc/source/src/core/util/windows/thd.cc  |  12 +-
 .../grpc/source/src/core/util/windows/time.cc |   6 +-
 .../source/src/core/util/work_serializer.cc   |   6 +-
 .../xds/grpc/certificate_provider_store.cc    |   4 +-
 ...le_watcher_certificate_provider_factory.cc |   4 +-
 .../core/xds/grpc/xds_certificate_provider.cc |   6 +-
 .../src/core/xds/grpc/xds_client_grpc.cc      |   2 +-
 .../src/core/xds/grpc/xds_cluster_parser.cc   |  12 +-
 .../xds/grpc/xds_cluster_specifier_plugin.cc  |   4 +-
 .../src/core/xds/grpc/xds_endpoint_parser.cc  |  12 +-
 .../core/xds/grpc/xds_http_filter_registry.cc |   6 +-
 .../src/core/xds/grpc/xds_listener_parser.cc  |  14 +-
 .../source/src/core/xds/grpc/xds_metadata.cc  |   6 +-
 .../src/core/xds/grpc/xds_metadata_parser.cc  |   4 +-
 .../core/xds/grpc/xds_route_config_parser.cc  |  26 +--
 .../source/src/core/xds/grpc/xds_routing.cc   |   6 +-
 .../src/core/xds/grpc/xds_transport_grpc.cc   |  20 +--
 .../src/core/xds/xds_client/lrs_client.cc     |  26 +--
 .../src/core/xds/xds_client/xds_client.cc     |  30 ++--
 .../source/src/cpp/client/call_credentials.cc |   4 +-
 .../grpc/source/src/cpp/client/channel_cc.cc  |   4 +-
 .../source/src/cpp/client/client_context.cc   |  12 +-
 .../src/cpp/client/global_callback_hook.cc    |   6 +-
 .../src/cpp/client/secure_credentials.cc      |  10 +-
 .../source/src/cpp/client/xds_credentials.cc  |   6 +-
 .../grpc/source/src/cpp/common/alarm.cc       |  12 +-
 .../grpc/source/src/cpp/common/alts_util.cc   |  10 +-
 .../src/cpp/common/channel_arguments.cc       |  10 +-
 .../src/cpp/common/completion_queue_cc.cc     |  12 +-
 .../cpp/common/tls_certificate_provider.cc    |   8 +-
 .../cpp/common/tls_certificate_verifier.cc    |  14 +-
 .../src/cpp/common/tls_credentials_options.cc |  14 +-
 .../src/cpp/ext/csm/csm_observability.cc      |   4 +-
 .../src/cpp/ext/csm/metadata_exchange.cc      |   4 +-
 .../cpp/ext/filters/census/client_filter.cc   |   6 +-
 .../src/cpp/ext/gcp/environment_autodetect.cc |  14 +-
 .../cpp/ext/gcp/observability_logging_sink.cc |  10 +-
 .../src/cpp/ext/otel/key_value_iterable.h     |   4 +-
 .../cpp/ext/otel/otel_client_call_tracer.cc   |   4 +-
 .../source/src/cpp/ext/otel/otel_plugin.cc    |  82 ++++-----
 .../src/cpp/server/backend_metric_recorder.cc |   4 +-
 .../external_connection_acceptor_impl.cc      |  16 +-
 .../health/default_health_check_service.cc    |  22 +--
 .../get_cpu_stats_unsupported.cc              |   4 +-
 .../server/load_reporter/load_data_store.cc   |  48 +++---
 .../cpp/server/load_reporter/load_reporter.cc |  42 ++---
 .../load_reporter_async_service_impl.cc       |  38 ++--
 .../load_reporter_async_service_impl.h        |   6 +-
 .../src/cpp/server/load_reporter/util.cc      |   4 +-
 .../src/cpp/server/orca/orca_service.cc       |  10 +-
 .../source/src/cpp/server/server_builder.cc   |  24 +--
 .../grpc/source/src/cpp/server/server_cc.cc   |  44 ++---
 .../source/src/cpp/server/server_context.cc   |  16 +-
 .../src/cpp/server/xds_server_credentials.cc  |   6 +-
 .../src/cpp/thread_manager/thread_manager.cc  |  10 +-
 .../grpc_observability/observability_util.cc  |   2 +-
 458 files changed, 3471 insertions(+), 3471 deletions(-)

diff --git a/third_party/grpc/source/src/core/call/request_buffer.cc b/third_party/grpc/source/src/core/call/request_buffer.cc
index c53972d558fcc..37bbc3b30de7f 100644
--- a/third_party/grpc/source/src/core/call/request_buffer.cc
+++ b/third_party/grpc/source/src/core/call/request_buffer.cc
@@ -31,7 +31,7 @@ ValueOrFailure<size_t> RequestBuffer::PushClientInitialMetadata(
   MutexLock lock(&mu_);
   if (std::get_if<Cancelled>(&state_)) return Failure{};
   auto& buffering = std::get<Buffering>(state_);
-  CHECK_EQ(buffering.initial_metadata.get(), nullptr);
+  ABSL_CHECK_EQ(buffering.initial_metadata.get(), nullptr);
   buffering.initial_metadata = std::move(md);
   buffering.buffered += buffering.initial_metadata->TransportSize();
   WakeupAsyncAllPullers();
@@ -50,7 +50,7 @@ Poll<ValueOrFailure<size_t>> RequestBuffer::PollPushMessage(
     buffering->messages.push_back(std::move(message));
   } else {
     auto& streaming = std::get<Streaming>(state_);
-    CHECK_EQ(streaming.end_of_stream, false);
+    ABSL_CHECK_EQ(streaming.end_of_stream, false);
     if (streaming.message != nullptr) {
       return PendingPush();
     }
@@ -69,7 +69,7 @@ StatusFlag RequestBuffer::FinishSends() {
     state_.emplace<Buffered>(std::move(buffered));
   } else {
     auto& streaming = std::get<Streaming>(state_);
-    CHECK_EQ(streaming.end_of_stream, false);
+    ABSL_CHECK_EQ(streaming.end_of_stream, false);
     streaming.end_of_stream = true;
   }
   WakeupAsyncAllPullers();
@@ -85,7 +85,7 @@ void RequestBuffer::Cancel(absl::Status error) {

 void RequestBuffer::Commit(Reader* winner) {
   MutexLock lock(&mu_);
-  CHECK_EQ(winner_, nullptr);
+  ABSL_CHECK_EQ(winner_, nullptr);
   winner_ = winner;
   if (auto* buffering = std::get_if<Buffering>(&state_)) {
     if (buffering->initial_metadata != nullptr &&
@@ -94,7 +94,7 @@ void RequestBuffer::Commit(Reader* winner) {
       state_.emplace<Streaming>();
     }
   } else if (auto* buffered = std::get_if<Buffered>(&state_)) {
-    CHECK_NE(buffered->initial_metadata.get(), nullptr);
+    ABSL_CHECK_NE(buffered->initial_metadata.get(), nullptr);
     if (winner->message_index_ == buffered->messages.size()) {
       state_.emplace<Streaming>().end_of_stream = true;
     }
diff --git a/third_party/grpc/source/src/core/channelz/channelz.cc b/third_party/grpc/source/src/core/channelz/channelz.cc
index 1a8aa222a7292..1b5ddb619a1b4 100644
--- a/third_party/grpc/source/src/core/channelz/channelz.cc
+++ b/third_party/grpc/source/src/core/channelz/channelz.cc
@@ -26,7 +26,7 @@
 #include <atomic>
 #include <cstdint>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/escaping.h"
 #include "absl/strings/str_cat.h"
@@ -354,8 +354,8 @@ void ServerNode::RemoveChildListenSocket(intptr_t child_uuid) {

 std::string ServerNode::RenderServerSockets(intptr_t start_socket_id,
                                             intptr_t max_results) {
-  CHECK_GE(start_socket_id, 0);
-  CHECK_GE(max_results, 0);
+  ABSL_CHECK_GE(start_socket_id, 0);
+  ABSL_CHECK_GE(max_results, 0);
   // If user does not set max_results, we choose 500.
   size_t pagination_limit = max_results == 0 ? 500 : max_results;
   Json::Object object;
diff --git a/third_party/grpc/source/src/core/channelz/channelz_registry.cc b/third_party/grpc/source/src/core/channelz/channelz_registry.cc
index 6db28fa7514c6..339d16f0bda2c 100644
--- a/third_party/grpc/source/src/core/channelz/channelz_registry.cc
+++ b/third_party/grpc/source/src/core/channelz/channelz_registry.cc
@@ -29,8 +29,8 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/channelz/channelz.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
 #include "src/core/util/json/json.h"
@@ -57,9 +57,9 @@ void ChannelzRegistry::InternalRegister(BaseNode* node) {
 }

 void ChannelzRegistry::InternalUnregister(intptr_t uuid) {
-  CHECK_GE(uuid, 1);
+  ABSL_CHECK_GE(uuid, 1);
   MutexLock lock(&mu_);
-  CHECK(uuid <= uuid_generator_);
+  ABSL_CHECK(uuid <= uuid_generator_);
   node_map_.erase(uuid);
 }

@@ -170,7 +170,7 @@ void ChannelzRegistry::InternalLogAllEntities() {
   }
   for (size_t i = 0; i < nodes.size(); ++i) {
     std::string json = nodes[i]->RenderJsonString();
-    LOG(INFO) << json;
+    ABSL_LOG(INFO) << json;
   }
 }

diff --git a/third_party/grpc/source/src/core/client_channel/backup_poller.cc b/third_party/grpc/source/src/core/client_channel/backup_poller.cc
index ef13d2285e30c..5e85fa72ae7d2 100644
--- a/third_party/grpc/source/src/core/client_channel/backup_poller.cc
+++ b/third_party/grpc/source/src/core/client_channel/backup_poller.cc
@@ -23,7 +23,7 @@
 #include <grpc/support/sync.h>
 #include <inttypes.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "src/core/config/config_vars.h"
 #include "src/core/lib/iomgr/closure.h"
@@ -74,7 +74,7 @@ void grpc_client_channel_global_init_backup_polling() {
   int32_t poll_interval_ms =
       grpc_core::ConfigVars::Get().ClientChannelBackupPollIntervalMs();
   if (poll_interval_ms < 0) {
-    LOG(ERROR) << "Invalid GRPC_CLIENT_CHANNEL_BACKUP_POLL_INTERVAL_MS: "
+    ABSL_LOG(ERROR) << "Invalid GRPC_CLIENT_CHANNEL_BACKUP_POLL_INTERVAL_MS: "
                << poll_interval_ms << ", default value "
                << g_poll_interval.millis() << " will be used.";
   } else {
diff --git a/third_party/grpc/source/src/core/client_channel/client_channel.cc b/third_party/grpc/source/src/core/client_channel/client_channel.cc
index fad45a360849a..a7d729d9a4c58 100644
--- a/third_party/grpc/source/src/core/client_channel/client_channel.cc
+++ b/third_party/grpc/source/src/core/client_channel/client_channel.cc
@@ -37,7 +37,7 @@
 #include <vector>

 #include "absl/cleanup/cleanup.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/cord.h"
@@ -283,7 +283,7 @@ class ClientChannel::SubchannelWrapper::WatcherWrapper
           }
         }
       } else {
-        LOG(ERROR) << "client_channel="
+        ABSL_LOG(ERROR) << "client_channel="
                    << subchannel_wrapper_->client_channel_.get()
                    << ": Illegal keepalive throttling value "
                    << std::string(keepalive_throttling.value());
@@ -316,7 +316,7 @@ ClientChannel::SubchannelWrapper::SubchannelWrapper(
       << ": creating subchannel wrapper " << this << " for subchannel "
       << subchannel_.get();
 #ifndef NDEBUG
-  DCHECK(client_channel_->work_serializer_->RunningInWorkSerializer());
+  ABSL_DCHECK(client_channel_->work_serializer_->RunningInWorkSerializer());
 #endif
   if (client_channel_->channelz_node_ != nullptr) {
     auto* subchannel_node = subchannel_->channelz_node();
@@ -357,7 +357,7 @@ void ClientChannel::SubchannelWrapper::Orphaned() {
           if (subchannel_node != nullptr) {
             auto it = self->client_channel_->subchannel_refcount_map_.find(
                 self->subchannel_.get());
-            CHECK(it != self->client_channel_->subchannel_refcount_map_.end());
+            ABSL_CHECK(it != self->client_channel_->subchannel_refcount_map_.end());
             --it->second;
             if (it->second == 0) {
               self->client_channel_->channelz_node_->RemoveChildSubchannel(
@@ -372,7 +372,7 @@ void ClientChannel::SubchannelWrapper::Orphaned() {
 void ClientChannel::SubchannelWrapper::WatchConnectivityState(
     std::unique_ptr<ConnectivityStateWatcherInterface> watcher) {
   auto& watcher_wrapper = watcher_map_[watcher.get()];
-  CHECK(watcher_wrapper == nullptr);
+  ABSL_CHECK(watcher_wrapper == nullptr);
   watcher_wrapper = new WatcherWrapper(
       std::move(watcher),
       RefAsSubclass<SubchannelWrapper>(DEBUG_LOCATION, "WatcherWrapper"));
@@ -384,7 +384,7 @@ void ClientChannel::SubchannelWrapper::WatchConnectivityState(
 void ClientChannel::SubchannelWrapper::CancelConnectivityStateWatch(
     ConnectivityStateWatcherInterface* watcher) {
   auto it = watcher_map_.find(watcher);
-  CHECK(it != watcher_map_.end());
+  ABSL_CHECK(it != watcher_map_.end());
   subchannel_->CancelConnectivityStateWatch(it->second);
   watcher_map_.erase(it);
 }
@@ -393,7 +393,7 @@ void ClientChannel::SubchannelWrapper::AddDataWatcher(
     std::unique_ptr<DataWatcherInterface> watcher) {
   static_cast<InternalSubchannelDataWatcherInterface*>(watcher.get())
       ->SetSubchannel(subchannel_.get());
-  CHECK(data_watchers_.insert(std::move(watcher)).second);
+  ABSL_CHECK(data_watchers_.insert(std::move(watcher)).second);
 }

 void ClientChannel::SubchannelWrapper::CancelDataWatcher(
@@ -452,7 +452,7 @@ class ClientChannel::ClientChannelControlHelper
       const char* extra = client_channel_->disconnect_error_.ok()
                               ? ""
                               : " (ignoring -- channel shutting down)";
-      LOG(INFO) << "client_channel=" << client_channel_.get()
+      ABSL_LOG(INFO) << "client_channel=" << client_channel_.get()
                 << ": update: state=" << ConnectivityStateName(state)
                 << " status=(" << status << ") picker=" << picker.get()
                 << extra;
@@ -624,7 +624,7 @@ ClientChannel::ClientChannel(
       work_serializer_(std::make_shared<WorkSerializer>(event_engine_)),
       state_tracker_("client_channel", GRPC_CHANNEL_IDLE),
       subchannel_pool_(GetSubchannelPool(channel_args_)) {
-  CHECK(event_engine_.get() != nullptr);
+  ABSL_CHECK(event_engine_.get() != nullptr);
   GRPC_TRACE_LOG(client_channel, INFO)
       << "client_channel=" << this << ": creating client_channel";
   // Set initial keepalive time.
@@ -927,7 +927,7 @@ void ClientChannel::CreateResolverLocked() {
           WeakRefAsSubclass<ClientChannel>()));
   // Since the validity of the args was checked when the channel was created,
   // CreateResolver() must return a non-null result.
-  CHECK(resolver_ != nullptr);
+  ABSL_CHECK(resolver_ != nullptr);
   UpdateStateLocked(GRPC_CHANNEL_CONNECTING, absl::Status(),
                     "started resolving");
   resolver_->StartLocked();
@@ -989,11 +989,11 @@ RefCountedPtr<LoadBalancingPolicy::Config> ChooseLbPolicy(
               .LoadBalancingPolicyExists(*policy_name, &requires_config) ||
          requires_config)) {
       if (requires_config) {
-        LOG(ERROR) << "LB policy: " << *policy_name
+        ABSL_LOG(ERROR) << "LB policy: " << *policy_name
                    << " passed through channel_args must not "
                       "require a config. Using pick_first instead.";
       } else {
-        LOG(ERROR) << "LB policy: " << *policy_name
+        ABSL_LOG(ERROR) << "LB policy: " << *policy_name
                    << " passed through channel_args does not exist. "
                       "Using pick_first instead.";
       }
@@ -1019,7 +1019,7 @@ RefCountedPtr<LoadBalancingPolicy::Config> ChooseLbPolicy(
   // - A channel arg, in which case we check that the specified policy exists
   //   and accepts an empty config. If not, we revert to using pick_first
   //   lb_policy
-  CHECK_OK(lb_policy_config);
+  ABSL_CHECK_OK(lb_policy_config);
   return std::move(*lb_policy_config);
 }

diff --git a/third_party/grpc/source/src/core/client_channel/client_channel_filter.cc b/third_party/grpc/source/src/core/client_channel/client_channel_filter.cc
index 3182f1dcfdb88..567e3d6c8bec1 100644
--- a/third_party/grpc/source/src/core/client_channel/client_channel_filter.cc
+++ b/third_party/grpc/source/src/core/client_channel/client_channel_filter.cc
@@ -38,8 +38,8 @@
 #include <vector>

 #include "absl/cleanup/cleanup.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/cord.h"
@@ -337,8 +337,8 @@ class DynamicTerminationFilter final {

   static grpc_error_handle Init(grpc_channel_element* elem,
                                 grpc_channel_element_args* args) {
-    CHECK(args->is_last);
-    CHECK(elem->filter == &kFilterVtable);
+    ABSL_CHECK(args->is_last);
+    ABSL_CHECK(elem->filter == &kFilterVtable);
     new (elem->channel_data) DynamicTerminationFilter(args->channel_args);
     return absl::OkStatus();
   }
@@ -500,7 +500,7 @@ class ClientChannelFilter::SubchannelWrapper final
         << " for subchannel " << subchannel_.get();
     GRPC_CHANNEL_STACK_REF(chand_->owning_stack_, "SubchannelWrapper");
 #ifndef NDEBUG
-    DCHECK(chand_->work_serializer_->RunningInWorkSerializer());
+    ABSL_DCHECK(chand_->work_serializer_->RunningInWorkSerializer());
 #endif
     if (chand_->channelz_node_ != nullptr) {
       auto* subchannel_node = subchannel_->channelz_node();
@@ -536,7 +536,7 @@ class ClientChannelFilter::SubchannelWrapper final
         auto* subchannel_node = subchannel_->channelz_node();
         if (subchannel_node != nullptr) {
           auto it = chand_->subchannel_refcount_map_.find(subchannel_.get());
-          CHECK(it != chand_->subchannel_refcount_map_.end());
+          ABSL_CHECK(it != chand_->subchannel_refcount_map_.end());
           --it->second;
           if (it->second == 0) {
             chand_->channelz_node_->RemoveChildSubchannel(
@@ -553,7 +553,7 @@ class ClientChannelFilter::SubchannelWrapper final
       std::unique_ptr<ConnectivityStateWatcherInterface> watcher) override
       ABSL_EXCLUSIVE_LOCKS_REQUIRED(*chand_->work_serializer_) {
     auto& watcher_wrapper = watcher_map_[watcher.get()];
-    CHECK_EQ(watcher_wrapper, nullptr);
+    ABSL_CHECK_EQ(watcher_wrapper, nullptr);
     watcher_wrapper = new WatcherWrapper(
         std::move(watcher),
         RefAsSubclass<SubchannelWrapper>(DEBUG_LOCATION, "WatcherWrapper"));
@@ -565,7 +565,7 @@ class ClientChannelFilter::SubchannelWrapper final
   void CancelConnectivityStateWatch(ConnectivityStateWatcherInterface* watcher)
       override ABSL_EXCLUSIVE_LOCKS_REQUIRED(*chand_->work_serializer_) {
     auto it = watcher_map_.find(watcher);
-    CHECK(it != watcher_map_.end());
+    ABSL_CHECK(it != watcher_map_.end());
     subchannel_->CancelConnectivityStateWatch(it->second);
     watcher_map_.erase(it);
   }
@@ -582,7 +582,7 @@ class ClientChannelFilter::SubchannelWrapper final
       ABSL_EXCLUSIVE_LOCKS_REQUIRED(*chand_->work_serializer_) {
     static_cast<InternalSubchannelDataWatcherInterface*>(watcher.get())
         ->SetSubchannel(subchannel_.get());
-    CHECK(data_watchers_.insert(std::move(watcher)).second);
+    ABSL_CHECK(data_watchers_.insert(std::move(watcher)).second);
   }

   void CancelDataWatcher(DataWatcherInterface* watcher) override
@@ -675,7 +675,7 @@ class ClientChannelFilter::SubchannelWrapper final
             }
           }
         } else {
-          LOG(ERROR) << "chand=" << parent_->chand_
+          ABSL_LOG(ERROR) << "chand=" << parent_->chand_
                      << ": Illegal keepalive throttling value "
                      << std::string(keepalive_throttling.value());
         }
@@ -745,7 +745,7 @@ ClientChannelFilter::ExternalConnectivityWatcher::ExternalConnectivityWatcher(
   {
     MutexLock lock(&chand_->external_watchers_mu_);
     // Will be deleted when the watch is complete.
-    CHECK(chand->external_watchers_[on_complete] == nullptr);
+    ABSL_CHECK(chand->external_watchers_[on_complete] == nullptr);
     // Store a ref to the watcher in the external_watchers_ map.
     chand->external_watchers_[on_complete] =
         RefAsSubclass<ExternalConnectivityWatcher>(
@@ -1016,8 +1016,8 @@ class ClientChannelFilter::ClientChannelControlHelper final

 grpc_error_handle ClientChannelFilter::Init(grpc_channel_element* elem,
                                             grpc_channel_element_args* args) {
-  CHECK(args->is_last);
-  CHECK(elem->filter == &kFilter);
+  ABSL_CHECK(args->is_last);
+  ABSL_CHECK(elem->filter == &kFilter);
   grpc_error_handle error;
   new (elem->channel_data) ClientChannelFilter(args, &error);
   return error;
@@ -1175,11 +1175,11 @@ RefCountedPtr<LoadBalancingPolicy::Config> ChooseLbPolicy(
               .LoadBalancingPolicyExists(*policy_name, &requires_config) ||
          requires_config)) {
       if (requires_config) {
-        LOG(ERROR) << "LB policy: " << *policy_name
+        ABSL_LOG(ERROR) << "LB policy: " << *policy_name
                    << " passed through channel_args must not "
                       "require a config. Using pick_first instead.";
       } else {
-        LOG(ERROR) << "LB policy: " << *policy_name
+        ABSL_LOG(ERROR) << "LB policy: " << *policy_name
                    << " passed through channel_args does not exist. "
                       "Using pick_first instead.";
       }
@@ -1205,7 +1205,7 @@ RefCountedPtr<LoadBalancingPolicy::Config> ChooseLbPolicy(
   // - A channel arg, in which case we check that the specified policy exists
   //   and accepts an empty config. If not, we revert to using pick_first
   //   lb_policy
-  CHECK(lb_policy_config.ok());
+  ABSL_CHECK(lb_policy_config.ok());
   return std::move(*lb_policy_config);
 }

@@ -1475,7 +1475,7 @@ void ClientChannelFilter::UpdateServiceConfigInDataPlaneLocked(
   auto new_blackboard = MakeRefCounted<Blackboard>();
   RefCountedPtr<DynamicFilters> dynamic_filters = DynamicFilters::Create(
       new_args, std::move(filters), blackboard_.get(), new_blackboard.get());
-  CHECK(dynamic_filters != nullptr);
+  ABSL_CHECK(dynamic_filters != nullptr);
   blackboard_ = std::move(new_blackboard);
   // Grab data plane lock to update service config.
   //
@@ -1506,7 +1506,7 @@ void ClientChannelFilter::CreateResolverLocked() {
       std::make_unique<ResolverResultHandler>(this));
   // Since the validity of the args was checked when the channel was created,
   // CreateResolver() must return a non-null result.
-  CHECK(resolver_ != nullptr);
+  ABSL_CHECK(resolver_ != nullptr);
   UpdateStateLocked(GRPC_CHANNEL_CONNECTING, absl::Status(),
                     "started resolving");
   resolver_->StartLocked();
@@ -1611,7 +1611,7 @@ T HandlePickResult(
   }
   auto* drop_pick =
       std::get_if<LoadBalancingPolicy::PickResult::Drop>(&result->result);
-  CHECK_NE(drop_pick, nullptr);
+  ABSL_CHECK_NE(drop_pick, nullptr);
   return drop_func(drop_pick);
 }

@@ -1704,7 +1704,7 @@ void ClientChannelFilter::StartTransportOpLocked(grpc_transport_op* op) {
       }
     } else {
       // Disconnect.
-      CHECK(disconnect_error_.ok());
+      ABSL_CHECK(disconnect_error_.ok());
       disconnect_error_ = op->disconnect_with_error;
       UpdateStateAndPickerLocked(
           GRPC_CHANNEL_SHUTDOWN, absl::Status(), "shutdown from API",
@@ -1722,7 +1722,7 @@ void ClientChannelFilter::StartTransportOpLocked(grpc_transport_op* op) {
 void ClientChannelFilter::StartTransportOp(grpc_channel_element* elem,
                                            grpc_transport_op* op) {
   auto* chand = static_cast<ClientChannelFilter*>(elem->channel_data);
-  CHECK(op->set_accept_stream == false);
+  ABSL_CHECK(op->set_accept_stream == false);
   // Handle bind_pollset.
   if (op->bind_pollset != nullptr) {
     grpc_pollset_set_add_pollset(chand->interested_parties_, op->bind_pollset);
@@ -1943,7 +1943,7 @@ ClientChannelFilter::FilterBasedCallData::~FilterBasedCallData() {
   CSliceUnref(path_);
   // Make sure there are no remaining pending batches.
   for (size_t i = 0; i < GPR_ARRAY_SIZE(pending_batches_); ++i) {
-    CHECK_EQ(pending_batches_[i], nullptr);
+    ABSL_CHECK_EQ(pending_batches_[i], nullptr);
   }
 }

@@ -1974,7 +1974,7 @@ void ClientChannelFilter::FilterBasedCallData::StartTransportStreamOpBatch(
   auto* chand = static_cast<ClientChannelFilter*>(elem->channel_data);
   if (GRPC_TRACE_FLAG_ENABLED(client_channel_call) &&
       !GRPC_TRACE_FLAG_ENABLED(channel)) {
-    LOG(INFO) << "chand=" << chand << " calld=" << calld
+    ABSL_LOG(INFO) << "chand=" << chand << " calld=" << calld
               << ": batch started from above: "
               << grpc_transport_stream_op_batch_string(batch, false);
   }
@@ -2091,7 +2091,7 @@ void ClientChannelFilter::FilterBasedCallData::PendingBatchesAdd(
       << "chand=" << chand() << " calld=" << this
       << ": adding pending batch at index " << idx;
   grpc_transport_stream_op_batch*& pending = pending_batches_[idx];
-  CHECK_EQ(pending, nullptr);
+  ABSL_CHECK_EQ(pending, nullptr);
   pending = batch;
 }

@@ -2111,13 +2111,13 @@ void ClientChannelFilter::FilterBasedCallData::FailPendingBatchInCallCombiner(
 void ClientChannelFilter::FilterBasedCallData::PendingBatchesFail(
     grpc_error_handle error,
     YieldCallCombinerPredicate yield_call_combiner_predicate) {
-  CHECK(!error.ok());
+  ABSL_CHECK(!error.ok());
   if (GRPC_TRACE_FLAG_ENABLED(client_channel_call)) {
     size_t num_batches = 0;
     for (size_t i = 0; i < GPR_ARRAY_SIZE(pending_batches_); ++i) {
       if (pending_batches_[i] != nullptr) ++num_batches;
     }
-    LOG(INFO) << "chand=" << chand() << " calld=" << this << ": failing "
+    ABSL_LOG(INFO) << "chand=" << chand() << " calld=" << this << ": failing "
               << num_batches << " pending batches: " << StatusToString(error);
   }
   CallCombinerClosureList closures;
@@ -2159,7 +2159,7 @@ void ClientChannelFilter::FilterBasedCallData::PendingBatchesResume() {
     for (size_t i = 0; i < GPR_ARRAY_SIZE(pending_batches_); ++i) {
       if (pending_batches_[i] != nullptr) ++num_batches;
     }
-    LOG(INFO) << "chand=" << chand() << " calld=" << this << ": starting "
+    ABSL_LOG(INFO) << "chand=" << chand() << " calld=" << this << ": starting "
               << num_batches
               << " pending batches on dynamic_call=" << dynamic_call_.get();
   }
@@ -2530,11 +2530,11 @@ ClientChannelFilter::LoadBalancedCall::PickSubchannel(bool was_queued) {

 bool ClientChannelFilter::LoadBalancedCall::PickSubchannelImpl(
     LoadBalancingPolicy::SubchannelPicker* picker, grpc_error_handle* error) {
-  CHECK(connected_subchannel_ == nullptr);
+  ABSL_CHECK(connected_subchannel_ == nullptr);
   // Perform LB pick.
   LoadBalancingPolicy::PickArgs pick_args;
   Slice* path = send_initial_metadata()->get_pointer(HttpPathMetadata());
-  CHECK_NE(path, nullptr);
+  ABSL_CHECK_NE(path, nullptr);
   pick_args.path = path->as_string_view();
   LbCallState lb_call_state(this);
   pick_args.call_state = &lb_call_state;
@@ -2549,7 +2549,7 @@ bool ClientChannelFilter::LoadBalancedCall::PickSubchannelImpl(
             << "chand=" << chand_ << " lb_call=" << this
             << ": LB pick succeeded: subchannel="
             << complete_pick->subchannel.get();
-        CHECK(complete_pick->subchannel != nullptr);
+        ABSL_CHECK(complete_pick->subchannel != nullptr);
         // Grab a ref to the connected subchannel while we're still
         // holding the data plane mutex.
         SubchannelWrapper* subchannel =
@@ -2634,7 +2634,7 @@ ClientChannelFilter::FilterBasedLoadBalancedCall::
     ~FilterBasedLoadBalancedCall() {
   // Make sure there are no remaining pending batches.
   for (size_t i = 0; i < GPR_ARRAY_SIZE(pending_batches_); ++i) {
-    CHECK_EQ(pending_batches_[i], nullptr);
+    ABSL_CHECK_EQ(pending_batches_[i], nullptr);
   }
   if (on_call_destruction_complete_ != nullptr) {
     ExecCtx::Run(DEBUG_LOCATION, on_call_destruction_complete_,
@@ -2675,7 +2675,7 @@ void ClientChannelFilter::FilterBasedLoadBalancedCall::PendingBatchesAdd(
   GRPC_TRACE_LOG(client_channel_lb_call, INFO)
       << "chand=" << chand() << " lb_call=" << this
       << ": adding pending batch at index " << idx;
-  CHECK_EQ(pending_batches_[idx], nullptr);
+  ABSL_CHECK_EQ(pending_batches_[idx], nullptr);
   pending_batches_[idx] = batch;
 }

@@ -2695,14 +2695,14 @@ void ClientChannelFilter::FilterBasedLoadBalancedCall::
 void ClientChannelFilter::FilterBasedLoadBalancedCall::PendingBatchesFail(
     grpc_error_handle error,
     YieldCallCombinerPredicate yield_call_combiner_predicate) {
-  CHECK(!error.ok());
+  ABSL_CHECK(!error.ok());
   failure_error_ = error;
   if (GRPC_TRACE_FLAG_ENABLED(client_channel_lb_call)) {
     size_t num_batches = 0;
     for (size_t i = 0; i < GPR_ARRAY_SIZE(pending_batches_); ++i) {
       if (pending_batches_[i] != nullptr) ++num_batches;
     }
-    LOG(INFO) << "chand=" << chand() << " lb_call=" << this << ": failing "
+    ABSL_LOG(INFO) << "chand=" << chand() << " lb_call=" << this << ": failing "
               << num_batches << " pending batches: " << StatusToString(error);
   }
   CallCombinerClosureList closures;
@@ -2743,7 +2743,7 @@ void ClientChannelFilter::FilterBasedLoadBalancedCall::PendingBatchesResume() {
     for (size_t i = 0; i < GPR_ARRAY_SIZE(pending_batches_); ++i) {
       if (pending_batches_[i] != nullptr) ++num_batches;
     }
-    LOG(INFO) << "chand=" << chand() << " lb_call=" << this << ": starting "
+    ABSL_LOG(INFO) << "chand=" << chand() << " lb_call=" << this << ": starting "
               << num_batches << " pending batches on subchannel_call="
               << subchannel_call_.get();
   }
@@ -2768,7 +2768,7 @@ void ClientChannelFilter::FilterBasedLoadBalancedCall::
     StartTransportStreamOpBatch(grpc_transport_stream_op_batch* batch) {
   if (GRPC_TRACE_FLAG_ENABLED(client_channel_lb_call) ||
       GRPC_TRACE_FLAG_ENABLED(channel)) {
-    LOG(INFO) << "chand=" << chand() << " lb_call=" << this
+    ABSL_LOG(INFO) << "chand=" << chand() << " lb_call=" << this
               << ": batch started from above: "
               << grpc_transport_stream_op_batch_string(batch, false)
               << ", call_attempt_tracer()=" << call_attempt_tracer();
@@ -3041,7 +3041,7 @@ void ClientChannelFilter::FilterBasedLoadBalancedCall::RetryPickLocked() {

 void ClientChannelFilter::FilterBasedLoadBalancedCall::CreateSubchannelCall() {
   Slice* path = send_initial_metadata()->get_pointer(HttpPathMetadata());
-  CHECK_NE(path, nullptr);
+  ABSL_CHECK_NE(path, nullptr);
   SubchannelCall::Args call_args = {
       connected_subchannel()->Ref(), pollent_, path->Ref(), /*start_time=*/0,
       arena()->GetContext<Call>()->deadline(),
diff --git a/third_party/grpc/source/src/core/client_channel/client_channel_internal.h b/third_party/grpc/source/src/core/client_channel/client_channel_internal.h
index 99e045c00476c..383f0456c4542 100644
--- a/third_party/grpc/source/src/core/client_channel/client_channel_internal.h
+++ b/third_party/grpc/source/src/core/client_channel/client_channel_internal.h
@@ -22,7 +22,7 @@
 #include <utility>

 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/resource_quota/arena.h"
 #include "src/core/lib/transport/call_destination.h"
 #include "src/core/load_balancing/lb_policy.h"
@@ -64,7 +64,7 @@ class ClientChannelServiceConfigCallData final : public ServiceConfigCallData {
       : ServiceConfigCallData(arena) {}

   void SetOnCommit(absl::AnyInvocable<void()> on_commit) {
-    CHECK(on_commit_ == nullptr);
+    ABSL_CHECK(on_commit_ == nullptr);
     on_commit_ = std::move(on_commit);
   }

diff --git a/third_party/grpc/source/src/core/client_channel/config_selector.h b/third_party/grpc/source/src/core/client_channel/config_selector.h
index 2901ee471bd98..1f9b59c4a30af 100644
--- a/third_party/grpc/source/src/core/client_channel/config_selector.h
+++ b/third_party/grpc/source/src/core/client_channel/config_selector.h
@@ -24,7 +24,7 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/strings/string_view.h"
 #include "src/core/client_channel/client_channel_internal.h"
@@ -94,7 +94,7 @@ class DefaultConfigSelector final : public ConfigSelector {
     // The client channel code ensures that this will never be null.
     // If neither the resolver nor the client application provide a
     // config, a default empty config will be used.
-    DCHECK(service_config_ != nullptr);
+    ABSL_DCHECK(service_config_ != nullptr);
   }

   UniqueTypeName name() const override {
@@ -104,7 +104,7 @@ class DefaultConfigSelector final : public ConfigSelector {

   absl::Status GetCallConfig(GetCallConfigArgs args) override {
     Slice* path = args.initial_metadata->get_pointer(HttpPathMetadata());
-    CHECK_NE(path, nullptr);
+    ABSL_CHECK_NE(path, nullptr);
     auto* parsed_method_configs =
         service_config_->GetMethodParsedConfigVector(path->c_slice());
     args.service_config_call_data->SetServiceConfig(service_config_,
diff --git a/third_party/grpc/source/src/core/client_channel/dynamic_filters.cc b/third_party/grpc/source/src/core/client_channel/dynamic_filters.cc
index 93a3c49d9572e..10535421d6a52 100644
--- a/third_party/grpc/source/src/core/client_channel/dynamic_filters.cc
+++ b/third_party/grpc/source/src/core/client_channel/dynamic_filters.cc
@@ -22,8 +22,8 @@
 #include <new>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/statusor.h"
 #include "src/core/lib/channel/channel_args.h"
 #include "src/core/lib/channel/channel_stack.h"
@@ -64,7 +64,7 @@ DynamicFilters::Call::Call(Args args, grpc_error_handle* error)
   *error = grpc_call_stack_init(channel_stack_->channel_stack_.get(), 1,
                                 Destroy, this, &call_args);
   if (GPR_UNLIKELY(!error->ok())) {
-    LOG(ERROR) << "error: " << StatusToString(*error);
+    ABSL_LOG(ERROR) << "error: " << StatusToString(*error);
     return;
   }
   grpc_call_stack_set_pollset_or_pollset_set(call_stack, args.pollent);
@@ -81,8 +81,8 @@ void DynamicFilters::Call::StartTransportStreamOpBatch(
 }

 void DynamicFilters::Call::SetAfterCallStackDestroy(grpc_closure* closure) {
-  CHECK_EQ(after_call_stack_destroy_, nullptr);
-  CHECK_NE(closure, nullptr);
+  ABSL_CHECK_EQ(after_call_stack_destroy_, nullptr);
+  ABSL_CHECK_NE(closure, nullptr);
   after_call_stack_destroy_ = closure;
 }

diff --git a/third_party/grpc/source/src/core/client_channel/lb_metadata.cc b/third_party/grpc/source/src/core/client_channel/lb_metadata.cc
index 59f19f5951731..ca59728985cb0 100644
--- a/third_party/grpc/source/src/core/client_channel/lb_metadata.cc
+++ b/third_party/grpc/source/src/core/client_channel/lb_metadata.cc
@@ -14,7 +14,7 @@

 #include "src/core/client_channel/lb_metadata.h"

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"

 namespace grpc_core {

@@ -92,7 +92,7 @@ void MetadataMutationHandler::Apply(
     }
     metadata->Append(key, std::move(value),
                      [key = key](absl::string_view error, const Slice& value) {
-                       LOG(ERROR) << error << " key:" << key
+                       ABSL_LOG(ERROR) << error << " key:" << key
                                   << " value:" << value.as_string_view();
                      });
   }
diff --git a/third_party/grpc/source/src/core/client_channel/load_balanced_call_destination.cc b/third_party/grpc/source/src/core/client_channel/load_balanced_call_destination.cc
index fd2d4ba010c0d..1d0929fef72cf 100644
--- a/third_party/grpc/source/src/core/client_channel/load_balanced_call_destination.cc
+++ b/third_party/grpc/source/src/core/client_channel/load_balanced_call_destination.cc
@@ -14,7 +14,7 @@

 #include "src/core/client_channel/load_balanced_call_destination.h"

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/client_channel/client_channel.h"
 #include "src/core/client_channel/client_channel_internal.h"
 #include "src/core/client_channel/lb_metadata.h"
@@ -78,7 +78,7 @@ T HandlePickResult(
   }
   auto* drop_pick =
       std::get_if<LoadBalancingPolicy::PickResult::Drop>(&result->result);
-  CHECK(drop_pick != nullptr);
+  ABSL_CHECK(drop_pick != nullptr);
   return drop_func(drop_pick);
 }

@@ -97,7 +97,7 @@ LoopCtl<absl::StatusOr<RefCountedPtr<UnstartedCallDestination>>> PickSubchannel(
       unstarted_handler.UnprocessedClientInitialMetadata();
   LoadBalancingPolicy::PickArgs pick_args;
   Slice* path = client_initial_metadata.get_pointer(HttpPathMetadata());
-  CHECK(path != nullptr);
+  ABSL_CHECK(path != nullptr);
   pick_args.path = path->as_string_view();
   LbCallState lb_call_state;
   pick_args.call_state = &lb_call_state;
@@ -115,7 +115,7 @@ LoopCtl<absl::StatusOr<RefCountedPtr<UnstartedCallDestination>>> PickSubchannel(
             << "client_channel: " << GetContext<Activity>()->DebugTag()
             << " pick succeeded: subchannel="
             << complete_pick->subchannel.get();
-        CHECK(complete_pick->subchannel != nullptr);
+        ABSL_CHECK(complete_pick->subchannel != nullptr);
         // Grab a ref to the call destination while we're still
         // holding the data plane mutex.
         auto call_destination =
@@ -212,7 +212,7 @@ void LoadBalancedCallDestination::StartCall(
                       [unstarted_handler, &last_picker](
                           RefCountedPtr<LoadBalancingPolicy::SubchannelPicker>
                               picker) mutable {
-                        CHECK_NE(picker.get(), nullptr);
+                        ABSL_CHECK_NE(picker.get(), nullptr);
                         last_picker = std::move(picker);
                         // Returns 3 possible things:
                         // - Continue to queue the pick
diff --git a/third_party/grpc/source/src/core/client_channel/local_subchannel_pool.cc b/third_party/grpc/source/src/core/client_channel/local_subchannel_pool.cc
index 428db14bdf9c4..6cb91b2dc7f5a 100644
--- a/third_party/grpc/source/src/core/client_channel/local_subchannel_pool.cc
+++ b/third_party/grpc/source/src/core/client_channel/local_subchannel_pool.cc
@@ -22,7 +22,7 @@

 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/client_channel/subchannel.h"

 namespace grpc_core {
@@ -33,7 +33,7 @@ RefCountedPtr<Subchannel> LocalSubchannelPool::RegisterSubchannel(
   // Because this pool is only accessed under the client channel's work
   // serializer, and because FindSubchannel is checked before invoking
   // RegisterSubchannel, no such subchannel should exist in the map.
-  CHECK(it == subchannel_map_.end());
+  ABSL_CHECK(it == subchannel_map_.end());
   subchannel_map_[key] = constructed.get();
   return constructed;
 }
@@ -44,8 +44,8 @@ void LocalSubchannelPool::UnregisterSubchannel(const SubchannelKey& key,
   // Because this subchannel pool is accessed only under the client
   // channel's work serializer, any subchannel created by RegisterSubchannel
   // will be deleted from the map in UnregisterSubchannel.
-  CHECK(it != subchannel_map_.end());
-  CHECK(it->second == subchannel);
+  ABSL_CHECK(it != subchannel_map_.end());
+  ABSL_CHECK(it->second == subchannel);
   subchannel_map_.erase(it);
 }

diff --git a/third_party/grpc/source/src/core/client_channel/retry_filter.h b/third_party/grpc/source/src/core/client_channel/retry_filter.h
index f7bc5d33a9841..dfd8d195e1c04 100644
--- a/third_party/grpc/source/src/core/client_channel/retry_filter.h
+++ b/third_party/grpc/source/src/core/client_channel/retry_filter.h
@@ -27,7 +27,7 @@
 #include <new>
 #include <optional>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/client_channel/client_channel_filter.h"
 #include "src/core/client_channel/retry_service_config.h"
 #include "src/core/client_channel/retry_throttle.h"
@@ -84,8 +84,8 @@ class RetryFilter final {

   static grpc_error_handle Init(grpc_channel_element* elem,
                                 grpc_channel_element_args* args) {
-    CHECK(args->is_last);
-    CHECK(elem->filter == &kVtable);
+    ABSL_CHECK(args->is_last);
+    ABSL_CHECK(elem->filter == &kVtable);
     grpc_error_handle error;
     new (elem->channel_data) RetryFilter(args->channel_args, &error);
     return error;
diff --git a/third_party/grpc/source/src/core/client_channel/retry_filter_legacy_call_data.cc b/third_party/grpc/source/src/core/client_channel/retry_filter_legacy_call_data.cc
index f65de3b808da3..b604ba625187d 100644
--- a/third_party/grpc/source/src/core/client_channel/retry_filter_legacy_call_data.cc
+++ b/third_party/grpc/source/src/core/client_channel/retry_filter_legacy_call_data.cc
@@ -20,8 +20,8 @@
 #include <memory>
 #include <new>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/client_channel/client_channel_internal.h"
@@ -1501,14 +1501,14 @@ RetryFilter::LegacyCallData::~LegacyCallData() {
   CSliceUnref(path_);
   // Make sure there are no remaining pending batches.
   for (size_t i = 0; i < GPR_ARRAY_SIZE(pending_batches_); ++i) {
-    CHECK_EQ(pending_batches_[i].batch, nullptr);
+    ABSL_CHECK_EQ(pending_batches_[i].batch, nullptr);
   }
 }

 void RetryFilter::LegacyCallData::StartTransportStreamOpBatch(
     grpc_transport_stream_op_batch* batch) {
   if (GRPC_TRACE_FLAG_ENABLED(retry) && !GRPC_TRACE_FLAG_ENABLED(channel)) {
-    LOG(INFO) << "chand=" << chand_ << " calld=" << this
+    ABSL_LOG(INFO) << "chand=" << chand_ << " calld=" << this
               << ": batch started from surface: "
               << grpc_transport_stream_op_batch_string(batch, false);
   }
@@ -1730,7 +1730,7 @@ RetryFilter::LegacyCallData::PendingBatchesAdd(
   GRPC_TRACE_LOG(retry, INFO) << "chand=" << chand_ << " calld=" << this
                               << ": adding pending batch at index " << idx;
   PendingBatch* pending = &pending_batches_[idx];
-  CHECK_EQ(pending->batch, nullptr);
+  ABSL_CHECK_EQ(pending->batch, nullptr);
   pending->batch = batch;
   pending->send_ops_cached = false;
   // Update state in calld about pending batches.
@@ -1809,13 +1809,13 @@ void RetryFilter::LegacyCallData::FailPendingBatchInCallCombiner(

 // This is called via the call combiner, so access to calld is synchronized.
 void RetryFilter::LegacyCallData::PendingBatchesFail(grpc_error_handle error) {
-  CHECK(!error.ok());
+  ABSL_CHECK(!error.ok());
   if (GRPC_TRACE_FLAG_ENABLED(retry)) {
     size_t num_batches = 0;
     for (size_t i = 0; i < GPR_ARRAY_SIZE(pending_batches_); ++i) {
       if (pending_batches_[i].batch != nullptr) ++num_batches;
     }
-    LOG(INFO) << "chand=" << chand_ << " calld=" << this << ": failing "
+    ABSL_LOG(INFO) << "chand=" << chand_ << " calld=" << this << ": failing "
               << num_batches << " pending batches: " << StatusToString(error);
   }
   CallCombinerClosureList closures;
@@ -1886,7 +1886,7 @@ void RetryFilter::LegacyCallData::StartRetryTimer(
   // Compute backoff delay.
   Duration next_attempt_timeout;
   if (server_pushback.has_value()) {
-    CHECK(*server_pushback >= Duration::Zero());
+    ABSL_CHECK(*server_pushback >= Duration::Zero());
     next_attempt_timeout = *server_pushback;
     retry_backoff_.Reset();
   } else {
diff --git a/third_party/grpc/source/src/core/client_channel/retry_interceptor.cc b/third_party/grpc/source/src/core/client_channel/retry_interceptor.cc
index 11f42b5de5c4c..a497d26e73087 100644
--- a/third_party/grpc/source/src/core/client_channel/retry_interceptor.cc
+++ b/third_party/grpc/source/src/core/client_channel/retry_interceptor.cc
@@ -119,7 +119,7 @@ std::optional<Duration> RetryState::ShouldRetry(
   // We should retry.
   Duration next_attempt_timeout;
   if (server_pushback.has_value()) {
-    CHECK_GE(*server_pushback, Duration::Zero());
+    ABSL_CHECK_GE(*server_pushback, Duration::Zero());
     next_attempt_timeout = *server_pushback;
     retry_backoff_.Reset();
   } else {
diff --git a/third_party/grpc/source/src/core/client_channel/retry_interceptor.h b/third_party/grpc/source/src/core/client_channel/retry_interceptor.h
index 5c8c0bf75dbbb..09a6c7c4070f8 100644
--- a/third_party/grpc/source/src/core/client_channel/retry_interceptor.h
+++ b/third_party/grpc/source/src/core/client_channel/retry_interceptor.h
@@ -103,7 +103,7 @@ class RetryInterceptor : public Interceptor {
       if (current_attempt_ == attempt) current_attempt_ = nullptr;
     }
     bool IsCurrentAttempt(Attempt* attempt) {
-      CHECK(attempt != nullptr);
+      ABSL_CHECK(attempt != nullptr);
       return current_attempt_ == attempt;
     }

diff --git a/third_party/grpc/source/src/core/client_channel/retry_service_config.cc b/third_party/grpc/source/src/core/client_channel/retry_service_config.cc
index daa62363b349f..ce5d7fc542d51 100644
--- a/third_party/grpc/source/src/core/client_channel/retry_service_config.cc
+++ b/third_party/grpc/source/src/core/client_channel/retry_service_config.cc
@@ -27,7 +27,7 @@
 #include <utility>
 #include <vector>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/numbers.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/config/core_configuration.h"
@@ -140,7 +140,7 @@ void RetryMethodConfig::JsonPostLoad(const Json& json, const JsonArgs& args,
       if (max_attempts_ <= 1) {
         errors->AddError("must be at least 2");
       } else if (max_attempts_ > MAX_MAX_RETRY_ATTEMPTS) {
-        LOG(ERROR) << "service config: clamped retryPolicy.maxAttempts at "
+        ABSL_LOG(ERROR) << "service config: clamped retryPolicy.maxAttempts at "
                    << MAX_MAX_RETRY_ATTEMPTS;
         max_attempts_ = MAX_MAX_RETRY_ATTEMPTS;
       }
diff --git a/third_party/grpc/source/src/core/client_channel/subchannel.cc b/third_party/grpc/source/src/core/client_channel/subchannel.cc
index 9d07abf7b54ce..62025ab80a075 100644
--- a/third_party/grpc/source/src/core/client_channel/subchannel.cc
+++ b/third_party/grpc/source/src/core/client_channel/subchannel.cc
@@ -29,8 +29,8 @@
 #include <optional>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/cord.h"
 #include "absl/strings/str_cat.h"
@@ -255,7 +255,7 @@ SubchannelCall::SubchannelCall(Args args, grpc_error_handle* error)
   *error = grpc_call_stack_init(connected_subchannel_->channel_stack(), 1,
                                 SubchannelCall::Destroy, this, &call_args);
   if (GPR_UNLIKELY(!error->ok())) {
-    LOG(ERROR) << "error: " << StatusToString(*error);
+    ABSL_LOG(ERROR) << "error: " << StatusToString(*error);
     return;
   }
   grpc_call_stack_set_pollset_or_pollset_set(callstk, args.pollent);
@@ -281,8 +281,8 @@ grpc_call_stack* SubchannelCall::GetCallStack() {
 }

 void SubchannelCall::SetAfterCallStackDestroy(grpc_closure* closure) {
-  CHECK_EQ(after_call_stack_destroy_, nullptr);
-  CHECK_NE(closure, nullptr);
+  ABSL_CHECK_EQ(after_call_stack_destroy_, nullptr);
+  ABSL_CHECK_NE(closure, nullptr);
   after_call_stack_destroy_ = closure;
 }

@@ -333,7 +333,7 @@ void SubchannelCall::MaybeInterceptRecvTrailingMetadata(
   GRPC_CLOSURE_INIT(&recv_trailing_metadata_ready_, RecvTrailingMetadataReady,
                     this, grpc_schedule_on_exec_ctx);
   // save some state needed for the interception callback.
-  CHECK_EQ(recv_trailing_metadata_, nullptr);
+  ABSL_CHECK_EQ(recv_trailing_metadata_, nullptr);
   recv_trailing_metadata_ =
       batch->payload->recv_trailing_metadata.recv_trailing_metadata;
   original_recv_trailing_metadata_ =
@@ -359,12 +359,12 @@ void GetCallStatus(grpc_status_code* status, Timestamp deadline,
 void SubchannelCall::RecvTrailingMetadataReady(void* arg,
                                                grpc_error_handle error) {
   SubchannelCall* call = static_cast<SubchannelCall*>(arg);
-  CHECK_NE(call->recv_trailing_metadata_, nullptr);
+  ABSL_CHECK_NE(call->recv_trailing_metadata_, nullptr);
   grpc_status_code status = GRPC_STATUS_OK;
   GetCallStatus(&status, call->deadline_, call->recv_trailing_metadata_, error);
   channelz::SubchannelNode* channelz_node =
       call->connected_subchannel_->channelz_node();
-  CHECK_NE(channelz_node, nullptr);
+  ABSL_CHECK_NE(channelz_node, nullptr);
   if (status == GRPC_STATUS_OK) {
     channelz_node->RecordCallSucceeded();
   } else {
@@ -573,7 +573,7 @@ RefCountedPtr<Subchannel> Subchannel::Create(
     const grpc_resolved_address& address, const ChannelArgs& args) {
   SubchannelKey key(address, args);
   auto* subchannel_pool = args.GetObject<SubchannelPoolInterface>();
-  CHECK_NE(subchannel_pool, nullptr);
+  ABSL_CHECK_NE(subchannel_pool, nullptr);
   RefCountedPtr<Subchannel> c = subchannel_pool->FindSubchannel(key);
   if (c != nullptr) {
     return c;
@@ -662,7 +662,7 @@ void Subchannel::Orphaned() {
     subchannel_pool_.reset();
   }
   MutexLock lock(&mu_);
-  CHECK(!shutdown_);
+  ABSL_CHECK(!shutdown_);
   shutdown_ = true;
   connector_.reset();
   connected_subchannel_.reset();
@@ -808,7 +808,7 @@ bool Subchannel::PublishTransportLocked() {
     absl::StatusOr<RefCountedPtr<grpc_channel_stack>> stack = builder.Build();
     if (!stack.ok()) {
       connecting_result_.Reset();
-      LOG(ERROR) << "subchannel " << this << " " << key_.ToString()
+      ABSL_LOG(ERROR) << "subchannel " << this << " " << key_.ToString()
                  << ": error initializing subchannel stack: " << stack.status();
       return false;
     }
@@ -846,7 +846,7 @@ bool Subchannel::PublishTransportLocked() {
     auto call_destination = builder.Build(transport_destination);
     if (!call_destination.ok()) {
       connecting_result_.Reset();
-      LOG(ERROR) << "subchannel " << this << " " << key_.ToString()
+      ABSL_LOG(ERROR) << "subchannel " << this << " " << key_.ToString()
                  << ": error initializing subchannel stack: "
                  << call_destination.status();
       return false;
diff --git a/third_party/grpc/source/src/core/client_channel/subchannel_stream_client.cc b/third_party/grpc/source/src/core/client_channel/subchannel_stream_client.cc
index 205daac3d96ad..0e8cfa3054c4f 100644
--- a/third_party/grpc/source/src/core/client_channel/subchannel_stream_client.cc
+++ b/third_party/grpc/source/src/core/client_channel/subchannel_stream_client.cc
@@ -23,8 +23,8 @@

 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/channel/channel_args.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
 #include "src/core/lib/resource_quota/resource_quota.h"
@@ -74,21 +74,21 @@ SubchannelStreamClient::SubchannelStreamClient(
                   SUBCHANNEL_STREAM_RECONNECT_MAX_BACKOFF_SECONDS))),
       event_engine_(connected_subchannel_->args().GetObject<EventEngine>()) {
   if (GPR_UNLIKELY(tracer_ != nullptr)) {
-    LOG(INFO) << tracer_ << " " << this << ": created SubchannelStreamClient";
+    ABSL_LOG(INFO) << tracer_ << " " << this << ": created SubchannelStreamClient";
   }
   StartCall();
 }

 SubchannelStreamClient::~SubchannelStreamClient() {
   if (GPR_UNLIKELY(tracer_ != nullptr)) {
-    LOG(INFO) << tracer_ << " " << this
+    ABSL_LOG(INFO) << tracer_ << " " << this
               << ": destroying SubchannelStreamClient";
   }
 }

 void SubchannelStreamClient::Orphan() {
   if (GPR_UNLIKELY(tracer_ != nullptr)) {
-    LOG(INFO) << tracer_ << " " << this
+    ABSL_LOG(INFO) << tracer_ << " " << this
               << ": SubchannelStreamClient shutting down";
   }
   {
@@ -110,13 +110,13 @@ void SubchannelStreamClient::StartCall() {

 void SubchannelStreamClient::StartCallLocked() {
   if (event_handler_ == nullptr) return;
-  CHECK(call_state_ == nullptr);
+  ABSL_CHECK(call_state_ == nullptr);
   if (event_handler_ != nullptr) {
     event_handler_->OnCallStartLocked(this);
   }
   call_state_ = MakeOrphanable<CallState>(Ref(), interested_parties_);
   if (GPR_UNLIKELY(tracer_ != nullptr)) {
-    LOG(INFO) << tracer_ << " " << this
+    ABSL_LOG(INFO) << tracer_ << " " << this
               << ": SubchannelStreamClient created CallState "
               << call_state_.get();
   }
@@ -129,13 +129,13 @@ void SubchannelStreamClient::StartRetryTimerLocked() {
   }
   const Duration timeout = retry_backoff_.NextAttemptDelay();
   if (GPR_UNLIKELY(tracer_ != nullptr)) {
-    LOG(INFO) << tracer_ << " " << this
+    ABSL_LOG(INFO) << tracer_ << " " << this
               << ": SubchannelStreamClient health check call lost...";
     if (timeout > Duration::Zero()) {
-      LOG(INFO) << tracer_ << " " << this << ": ... will retry in "
+      ABSL_LOG(INFO) << tracer_ << " " << this << ": ... will retry in "
                 << timeout.millis() << "ms.";
     } else {
-      LOG(INFO) << tracer_ << " " << this << ": ... retrying immediately.";
+      ABSL_LOG(INFO) << tracer_ << " " << this << ": ... retrying immediately.";
     }
   }
   retry_timer_handle_ = event_engine_->RunAfter(
@@ -152,7 +152,7 @@ void SubchannelStreamClient::OnRetryTimer() {
   if (event_handler_ != nullptr && retry_timer_handle_.has_value() &&
       call_state_ == nullptr) {
     if (GPR_UNLIKELY(tracer_ != nullptr)) {
-      LOG(INFO) << tracer_ << " " << this
+      ABSL_LOG(INFO) << tracer_ << " " << this
                 << ": SubchannelStreamClient restarting health check call";
     }
     StartCallLocked();
@@ -173,7 +173,7 @@ SubchannelStreamClient::CallState::CallState(

 SubchannelStreamClient::CallState::~CallState() {
   if (GPR_UNLIKELY(subchannel_stream_client_->tracer_ != nullptr)) {
-    LOG(INFO) << subchannel_stream_client_->tracer_ << " "
+    ABSL_LOG(INFO) << subchannel_stream_client_->tracer_ << " "
               << subchannel_stream_client_.get()
               << ": SubchannelStreamClient destroying CallState " << this;
   }
@@ -207,7 +207,7 @@ void SubchannelStreamClient::CallState::StartCallLocked() {
   call_->SetAfterCallStackDestroy(&after_call_stack_destruction_);
   // Check if creation failed.
   if (!error.ok() || subchannel_stream_client_->event_handler_ == nullptr) {
-    LOG(ERROR) << "SubchannelStreamClient " << subchannel_stream_client_.get()
+    ABSL_LOG(ERROR) << "SubchannelStreamClient " << subchannel_stream_client_.get()
                << " CallState " << this << ": error creating "
                << "stream on subchannel (" << StatusToString(error)
                << "); will retry";
@@ -224,7 +224,7 @@ void SubchannelStreamClient::CallState::StartCallLocked() {
   send_initial_metadata_.Set(
       HttpPathMetadata(),
       subchannel_stream_client_->event_handler_->GetPathLocked());
-  CHECK(error.ok());
+  ABSL_CHECK(error.ok());
   payload_.send_initial_metadata.send_initial_metadata =
       &send_initial_metadata_;
   batch_.send_initial_metadata = true;
@@ -358,7 +358,7 @@ void SubchannelStreamClient::CallState::RecvMessageReady() {
               subchannel_stream_client_.get(), recv_message_->JoinIntoString());
       if (!status.ok()) {
         if (GPR_UNLIKELY(subchannel_stream_client_->tracer_ != nullptr)) {
-          LOG(INFO) << subchannel_stream_client_->tracer_ << " "
+          ABSL_LOG(INFO) << subchannel_stream_client_->tracer_ << " "
                     << subchannel_stream_client_.get()
                     << ": SubchannelStreamClient CallState " << this
                     << ": failed to parse response message: " << status;
@@ -404,7 +404,7 @@ void SubchannelStreamClient::CallState::RecvTrailingMetadataReady(
                           nullptr /* error_string */);
   }
   if (GPR_UNLIKELY(self->subchannel_stream_client_->tracer_ != nullptr)) {
-    LOG(INFO) << self->subchannel_stream_client_->tracer_ << " "
+    ABSL_LOG(INFO) << self->subchannel_stream_client_->tracer_ << " "
               << self->subchannel_stream_client_.get()
               << ": SubchannelStreamClient CallState " << self
               << ": health watch failed with status " << status;
@@ -430,7 +430,7 @@ void SubchannelStreamClient::CallState::CallEndedLocked(bool retry) {
   if (this == subchannel_stream_client_->call_state_.get()) {
     subchannel_stream_client_->call_state_.reset();
     if (retry) {
-      CHECK(subchannel_stream_client_->event_handler_ != nullptr);
+      ABSL_CHECK(subchannel_stream_client_->event_handler_ != nullptr);
       if (seen_response_.load(std::memory_order_acquire)) {
         // If the call fails after we've gotten a successful response, reset
         // the backoff and restart the call immediately.
diff --git a/third_party/grpc/source/src/core/config/core_configuration.cc b/third_party/grpc/source/src/core/config/core_configuration.cc
index 5c5dc46944610..dd44573fbf337 100644
--- a/third_party/grpc/source/src/core/config/core_configuration.cc
+++ b/third_party/grpc/source/src/core/config/core_configuration.cc
@@ -20,7 +20,7 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 namespace grpc_core {

@@ -50,7 +50,7 @@ CoreConfiguration::CoreConfiguration(Builder* builder)

 void CoreConfiguration::RegisterBuilder(
     absl::AnyInvocable<void(Builder*)> builder) {
-  CHECK(config_.load(std::memory_order_relaxed) == nullptr)
+  ABSL_CHECK(config_.load(std::memory_order_relaxed) == nullptr)
       << "CoreConfiguration was already instantiated before builder "
          "registration was completed";
   RegisteredBuilder* n = new RegisteredBuilder();
@@ -59,7 +59,7 @@ void CoreConfiguration::RegisterBuilder(
   while (!builders_.compare_exchange_weak(n->next, n, std::memory_order_acq_rel,
                                           std::memory_order_relaxed)) {
   }
-  CHECK(config_.load(std::memory_order_relaxed) == nullptr)
+  ABSL_CHECK(config_.load(std::memory_order_relaxed) == nullptr)
       << "CoreConfiguration was already instantiated before builder "
          "registration was completed";
 }
diff --git a/third_party/grpc/source/src/core/config/core_configuration.h b/third_party/grpc/source/src/core/config/core_configuration.h
index 29bacf96d5dde..119aaf0461fee 100644
--- a/third_party/grpc/source/src/core/config/core_configuration.h
+++ b/third_party/grpc/source/src/core/config/core_configuration.h
@@ -20,7 +20,7 @@
 #include <atomic>

 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/handshaker/handshaker_registry.h"
 #include "src/core/handshaker/proxy_mapper_registry.h"
 #include "src/core/lib/channel/channel_args_preconditioning.h"
@@ -128,9 +128,9 @@ class GRPC_DLL CoreConfiguration {
     ~WithSubstituteBuilder() {
       // Reset and restore.
       Reset();
-      CHECK(CoreConfiguration::config_.exchange(
+      ABSL_CHECK(CoreConfiguration::config_.exchange(
                 config_restore_, std::memory_order_acquire) == nullptr);
-      CHECK(CoreConfiguration::builders_.exchange(
+      ABSL_CHECK(CoreConfiguration::builders_.exchange(
                 builders_restore_, std::memory_order_acquire) == nullptr);
     }

diff --git a/third_party/grpc/source/src/core/config/load_config.cc b/third_party/grpc/source/src/core/config/load_config.cc
index e1ddf301d8f76..e03c1ecf55860 100644
--- a/third_party/grpc/source/src/core/config/load_config.cc
+++ b/third_party/grpc/source/src/core/config/load_config.cc
@@ -19,7 +19,7 @@

 #include <optional>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/numbers.h"
 #include "absl/strings/str_join.h"
 #include "src/core/util/env.h"
@@ -34,7 +34,7 @@ std::optional<std::string> LoadEnv(absl::string_view environment_variable) {

 std::string LoadConfigFromEnv(absl::string_view environment_variable,
                               const char* default_value) {
-  CHECK(!environment_variable.empty());
+  ABSL_CHECK(!environment_variable.empty());
   return LoadEnv(environment_variable).value_or(default_value);
 }

diff --git a/third_party/grpc/source/src/core/ext/filters/backend_metrics/backend_metric_filter.cc b/third_party/grpc/source/src/core/ext/filters/backend_metrics/backend_metric_filter.cc
index 5930beb4bf69e..f3b5d2b9e7145 100644
--- a/third_party/grpc/source/src/core/ext/filters/backend_metrics/backend_metric_filter.cc
+++ b/third_party/grpc/source/src/core/ext/filters/backend_metrics/backend_metric_filter.cc
@@ -24,7 +24,7 @@
 #include <memory>
 #include <utility>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/string_view.h"
 #include "src/core/config/core_configuration.h"
 #include "src/core/lib/channel/channel_stack.h"
diff --git a/third_party/grpc/source/src/core/ext/filters/fault_injection/fault_injection_filter.cc b/third_party/grpc/source/src/core/ext/filters/fault_injection/fault_injection_filter.cc
index 6c057937e39d4..186f491f49ef3 100644
--- a/third_party/grpc/source/src/core/ext/filters/fault_injection/fault_injection_filter.cc
+++ b/third_party/grpc/source/src/core/ext/filters/fault_injection/fault_injection_filter.cc
@@ -28,7 +28,7 @@
 #include <type_traits>
 #include <utility>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/meta/type_traits.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
diff --git a/third_party/grpc/source/src/core/ext/filters/gcp_authentication/gcp_authentication_filter.cc b/third_party/grpc/source/src/core/ext/filters/gcp_authentication/gcp_authentication_filter.cc
index af17f3a025dd2..a09f8a0e24b04 100644
--- a/third_party/grpc/source/src/core/ext/filters/gcp_authentication/gcp_authentication_filter.cc
+++ b/third_party/grpc/source/src/core/ext/filters/gcp_authentication/gcp_authentication_filter.cc
@@ -20,7 +20,7 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/config/core_configuration.h"
 #include "src/core/ext/filters/gcp_authentication/gcp_authentication_service_config_parser.h"
diff --git a/third_party/grpc/source/src/core/ext/filters/http/message_compress/compression_filter.cc b/third_party/grpc/source/src/core/ext/filters/http/message_compress/compression_filter.cc
index a752ea76b3fa4..5c8dd7e9cf084 100644
--- a/third_party/grpc/source/src/core/ext/filters/http/message_compress/compression_filter.cc
+++ b/third_party/grpc/source/src/core/ext/filters/http/message_compress/compression_filter.cc
@@ -26,7 +26,7 @@
 #include <optional>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
@@ -94,7 +94,7 @@ ChannelCompression::ChannelCompression(const ChannelArgs& args)
                                          &name)) {
       name = "<unknown>";
     }
-    LOG(ERROR) << "default compression algorithm " << name
+    ABSL_LOG(ERROR) << "default compression algorithm " << name
                << " not enabled: switching to none";
     default_compression_algorithm_ = GRPC_COMPRESS_NONE;
   }
@@ -131,8 +131,8 @@ MessageHandle ChannelCompression::CompressMessage(
       const size_t after_size = tmp.Length();
       const float savings_ratio = 1.0f - (static_cast<float>(after_size) /
                                           static_cast<float>(before_size));
-      CHECK(grpc_compression_algorithm_name(algorithm, &algo_name));
-      LOG(INFO) << absl::StrFormat(
+      ABSL_CHECK(grpc_compression_algorithm_name(algorithm, &algo_name));
+      ABSL_LOG(INFO) << absl::StrFormat(
           "Compressed[%s] %" PRIuPTR " bytes vs. %" PRIuPTR
           " bytes (%.2f%% savings)",
           algo_name, before_size, after_size, 100 * savings_ratio);
@@ -145,8 +145,8 @@ MessageHandle ChannelCompression::CompressMessage(
   } else {
     if (GRPC_TRACE_FLAG_ENABLED(compression)) {
       const char* algo_name;
-      CHECK(grpc_compression_algorithm_name(algorithm, &algo_name));
-      LOG(INFO) << "Algorithm '" << algo_name
+      ABSL_CHECK(grpc_compression_algorithm_name(algorithm, &algo_name));
+      ABSL_LOG(INFO) << "Algorithm '" << algo_name
                 << "' enabled but decided not to compress. Input size: "
                 << payload->Length();
     }
diff --git a/third_party/grpc/source/src/core/ext/filters/http/server/http_server_filter.cc b/third_party/grpc/source/src/core/ext/filters/http/server/http_server_filter.cc
index fdaa56677637f..fa0a0ef9e0835 100644
--- a/third_party/grpc/source/src/core/ext/filters/http/server/http_server_filter.cc
+++ b/third_party/grpc/source/src/core/ext/filters/http/server/http_server_filter.cc
@@ -28,7 +28,7 @@
 #include <utility>

 #include "absl/base/attributes.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/string_view.h"
 #include "src/core/lib/channel/channel_args.h"
 #include "src/core/lib/channel/channel_stack.h"
diff --git a/third_party/grpc/source/src/core/ext/filters/load_reporting/server_load_reporting_filter.cc b/third_party/grpc/source/src/core/ext/filters/load_reporting/server_load_reporting_filter.cc
index 1861f41512ee2..342044d041f43 100644
--- a/third_party/grpc/source/src/core/ext/filters/load_reporting/server_load_reporting_filter.cc
+++ b/third_party/grpc/source/src/core/ext/filters/load_reporting/server_load_reporting_filter.cc
@@ -33,7 +33,7 @@
 #include <utility>

 #include "absl/container/inlined_vector.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/ascii.h"
 #include "absl/strings/str_cat.h"
@@ -96,14 +96,14 @@ std::string GetCensusSafeClientIpString(
   // Find the client URI string.
   const Slice* client_uri_slice = initial_metadata.get_pointer(PeerString());
   if (client_uri_slice == nullptr) {
-    LOG(ERROR) << "Unable to extract client URI string (peer string) from gRPC "
+    ABSL_LOG(ERROR) << "Unable to extract client URI string (peer string) from gRPC "
                   "metadata.";
     return "";
   }
   absl::StatusOr<URI> client_uri =
       URI::Parse(client_uri_slice->as_string_view());
   if (!client_uri.ok()) {
-    LOG(ERROR) << "Unable to parse the client URI string (peer string) to a "
+    ABSL_LOG(ERROR) << "Unable to parse the client URI string (peer string) to a "
                   "client URI. Error: "
                << client_uri.status();
     return "";
@@ -112,7 +112,7 @@ std::string GetCensusSafeClientIpString(
   grpc_resolved_address resolved_address;
   bool success = grpc_parse_uri(*client_uri, &resolved_address);
   if (!success) {
-    LOG(ERROR) << "Unable to parse client URI into a grpc_resolved_address.";
+    ABSL_LOG(ERROR) << "Unable to parse client URI into a grpc_resolved_address.";
     return "";
   }
   // Convert the socket address in the grpc_resolved_address into a hex string
diff --git a/third_party/grpc/source/src/core/ext/filters/logging/logging_filter.cc b/third_party/grpc/source/src/core/ext/filters/logging/logging_filter.cc
index ad5e73c5225df..3f0c3de1376da 100644
--- a/third_party/grpc/source/src/core/ext/filters/logging/logging_filter.cc
+++ b/third_party/grpc/source/src/core/ext/filters/logging/logging_filter.cc
@@ -34,7 +34,7 @@
 #include <utility>
 #include <vector>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/numeric/int128.h"
 #include "absl/random/random.h"
 #include "absl/random/uniform_int_distribution.h"
@@ -100,7 +100,7 @@ class MetadataEncoder {
     }
     uint64_t mdentry_len = key.length() + value.length();
     if (mdentry_len > log_len_) {
-      VLOG(2) << "Skipped metadata key because of max metadata logging bytes "
+      ABSL_VLOG(2) << "Skipped metadata key because of max metadata logging bytes "
               << mdentry_len << " (current) vs " << log_len_
               << " (max less already accounted metadata)";
       truncated_ = true;
@@ -152,7 +152,7 @@ LoggingSink::Entry::Address PeerStringToAddress(const Slice& peer_string) {
   LoggingSink::Entry::Address address;
   absl::StatusOr<URI> uri = URI::Parse(peer_string.as_string_view());
   if (!uri.ok()) {
-    VLOG(2) << "peer_string is in invalid format and cannot be logged";
+    ABSL_VLOG(2) << "peer_string is in invalid format and cannot be logged";
     return address;
   }

diff --git a/third_party/grpc/source/src/core/ext/filters/message_size/message_size_filter.cc b/third_party/grpc/source/src/core/ext/filters/message_size/message_size_filter.cc
index a487ec2246719..c91825827590f 100644
--- a/third_party/grpc/source/src/core/ext/filters/message_size/message_size_filter.cc
+++ b/third_party/grpc/source/src/core/ext/filters/message_size/message_size_filter.cc
@@ -24,7 +24,7 @@
 #include <functional>
 #include <utility>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_format.h"
 #include "src/core/config/core_configuration.h"
 #include "src/core/lib/channel/channel_args.h"
diff --git a/third_party/grpc/source/src/core/ext/filters/stateful_session/stateful_session_filter.cc b/third_party/grpc/source/src/core/ext/filters/stateful_session/stateful_session_filter.cc
index 91ef18c2d5212..44e25703469a1 100644
--- a/third_party/grpc/source/src/core/ext/filters/stateful_session/stateful_session_filter.cc
+++ b/third_party/grpc/source/src/core/ext/filters/stateful_session/stateful_session_filter.cc
@@ -27,7 +27,7 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/escaping.h"
 #include "absl/strings/match.h"
 #include "absl/strings/str_cat.h"
@@ -134,7 +134,7 @@ absl::string_view GetClusterToUse(
   // Get cluster assigned by the XdsConfigSelector.
   auto cluster_attribute =
       service_config_call_data->GetCallAttribute<XdsClusterAttribute>();
-  CHECK_NE(cluster_attribute, nullptr);
+  ABSL_CHECK_NE(cluster_attribute, nullptr);
   auto current_cluster = cluster_attribute->cluster();
   static constexpr absl::string_view kClusterPrefix = "cluster:";
   // If prefix is not "cluster:", then we can't use cluster override.
@@ -148,7 +148,7 @@ absl::string_view GetClusterToUse(
   // Use cluster from the cookie if it is configured for the route.
   auto route_data =
       service_config_call_data->GetCallAttribute<XdsRouteStateAttribute>();
-  CHECK_NE(route_data, nullptr);
+  ABSL_CHECK_NE(route_data, nullptr);
   // Cookie cluster was not configured for route - use the one from the
   // attribute
   if (!route_data->HasClusterForRoute(cluster_from_cookie)) {
@@ -193,7 +193,7 @@ bool IsConfiguredPath(absl::string_view configured_path,
   // Check to see if the configured path matches the request path.
   const Slice* path_slice =
       client_initial_metadata.get_pointer(HttpPathMetadata());
-  CHECK_NE(path_slice, nullptr);
+  ABSL_CHECK_NE(path_slice, nullptr);
   absl::string_view path = path_slice->as_string_view();
   // Matching criteria from
   // https://www.rfc-editor.org/rfc/rfc6265#section-5.1.4.
@@ -217,13 +217,13 @@ void StatefulSessionFilter::Call::OnClientInitialMetadata(
       "StatefulSessionFilter::Call::OnClientInitialMetadata");
   // Get config.
   auto* service_config_call_data = GetContext<ServiceConfigCallData>();
-  CHECK_NE(service_config_call_data, nullptr);
+  ABSL_CHECK_NE(service_config_call_data, nullptr);
   auto* method_params = static_cast<StatefulSessionMethodParsedConfig*>(
       service_config_call_data->GetMethodParsedConfig(
           filter->service_config_parser_index_));
-  CHECK_NE(method_params, nullptr);
+  ABSL_CHECK_NE(method_params, nullptr);
   cookie_config_ = method_params->GetConfig(filter->index_);
-  CHECK_NE(cookie_config_, nullptr);
+  ABSL_CHECK_NE(cookie_config_, nullptr);
   if (!cookie_config_->name.has_value() ||
       !IsConfiguredPath(cookie_config_->path, md)) {
     return;
diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/chaotic_good_transport.h b/third_party/grpc/source/src/core/ext/transport/chaotic_good/chaotic_good_transport.h
index b7075b310d43b..bf9fe18df4bd5 100644
--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/chaotic_good_transport.h
+++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/chaotic_good_transport.h
@@ -230,7 +230,7 @@ class ChaoticGoodTransport : public RefCounted<ChaoticGoodTransport> {
     GRPC_TRACE_LOG(chaotic_good, INFO)
         << "CHAOTIC_GOOD: Deserialize " << header << " with payload "
         << absl::CEscape(payload.JoinIntoString());
-    CHECK_EQ(header.payload_length, payload.Length());
+    ABSL_CHECK_EQ(header.payload_length, payload.Length());
     auto s = frame.Deserialize(header, std::move(payload));
     GRPC_TRACE_LOG(chaotic_good, INFO)
         << "CHAOTIC_GOOD: DeserializeFrame "
diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/client/chaotic_good_connector.cc b/third_party/grpc/source/src/core/ext/transport/chaotic_good/client/chaotic_good_connector.cc
index cb3faaae28068..f0e54939349b7 100644
--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/client/chaotic_good_connector.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/client/chaotic_good_connector.cc
@@ -21,8 +21,8 @@
 #include <memory>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/random/bit_gen_ref.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
@@ -221,7 +221,7 @@ void ChaoticGoodConnector::Connect(const Args& args, Result* result,
   arena->SetContext(event_engine.get());
   auto resolved_addr = EventEngine::ResolvedAddress(
       reinterpret_cast<const sockaddr*>(args.address->addr), args.address->len);
-  CHECK_NE(resolved_addr.address(), nullptr);
+  ABSL_CHECK_NE(resolved_addr.address(), nullptr);
   auto* result_notifier_ptr = result_notifier.get();
   auto activity = MakeActivity(
       [result_notifier_ptr, resolved_addr]() mutable {
@@ -318,7 +318,7 @@ grpc_channel* grpc_chaotic_good_channel_create(const char* target,
   if (r.ok()) {
     return r->release()->c_ptr();
   }
-  LOG(ERROR) << "Failed to create chaotic good client channel: " << r.status();
+  ABSL_LOG(ERROR) << "Failed to create chaotic good client channel: " << r.status();
   error = absl_status_to_grpc_error(r.status());
   intptr_t integer;
   grpc_status_code status = GRPC_STATUS_INTERNAL;
diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/client_transport.cc b/third_party/grpc/source/src/core/ext/transport/chaotic_good/client_transport.cc
index 9cefc35f4773b..58d368cd404a7 100644
--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/client_transport.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/client_transport.cc
@@ -26,8 +26,8 @@
 #include <tuple>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/random/bit_gen_ref.h"
 #include "absl/random/random.h"
 #include "absl/status/status.h"
@@ -74,10 +74,10 @@ ChaoticGoodClientTransport::LookupStream(uint32_t stream_id) {

 auto ChaoticGoodClientTransport::PushFrameIntoCall(
     ServerInitialMetadataFrame frame, RefCountedPtr<Stream> stream) {
-  DCHECK(stream->message_reassembly.in_message_boundary());
+  ABSL_DCHECK(stream->message_reassembly.in_message_boundary());
   auto headers = ServerMetadataGrpcFromProto(frame.body);
   if (!headers.ok()) {
-    LOG_EVERY_N_SEC(INFO, 10) << "Encode headers failed: " << headers.status();
+    ABSL_LOG_EVERY_N_SEC(INFO, 10) << "Encode headers failed: " << headers.status();
     return Immediate(StatusFlag(Failure{}));
   }
   return Immediate(stream->call.PushServerInitialMetadata(std::move(*headers)));
@@ -185,7 +185,7 @@ auto ChaoticGoodClientTransport::TransportReadLoop(
                               std::move(transport), std::move(incoming_frame));
                         }),
                         Default([&]() {
-                          LOG_EVERY_N_SEC(INFO, 10)
+                          ABSL_LOG_EVERY_N_SEC(INFO, 10)
                               << "Bad frame type: "
                               << incoming_frame.header().ToString();
                           return absl::OkStatus();
diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/config.h b/third_party/grpc/source/src/core/ext/transport/chaotic_good/config.h
index 497ea1a15b2d1..30f7cc1a5ac43 100644
--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/config.h
+++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/config.h
@@ -91,7 +91,7 @@ class Config {
   }

   void PrepareClientOutgoingSettings(chaotic_good_frame::Settings& settings) {
-    CHECK_EQ(pending_data_endpoints_.size(), 0u);
+    ABSL_CHECK_EQ(pending_data_endpoints_.size(), 0u);
     PrepareOutgoingSettings(settings);
   }

diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/control_endpoint.cc b/third_party/grpc/source/src/core/ext/transport/chaotic_good/control_endpoint.cc
index e2d4c1eecf422..117f64b300912 100644
--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/control_endpoint.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/control_endpoint.cc
@@ -43,7 +43,7 @@ ControlEndpoint::ControlEndpoint(
   auto arena = SimpleArenaAllocator(0)->MakeArena();
   arena->SetContext(event_engine);
   write_party_ = Party::Make(arena);
-  CHECK(event_engine != nullptr);
+  ABSL_CHECK(event_engine != nullptr);
   write_party_->arena()->SetContext(event_engine);
   write_party_->Spawn(
       "flush-control",
diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/data_endpoints.cc b/third_party/grpc/source/src/core/ext/transport/chaotic_good/data_endpoints.cc
index e5bc1b5d484d8..9031307d9d1c3 100644
--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/data_endpoints.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/data_endpoints.cc
@@ -75,7 +75,7 @@ Poll<SliceBuffer> OutputBuffers::PollNext(uint32_t connection_id) {
   auto cleanup = absl::MakeCleanup([&waker]() { waker.Wakeup(); });
   MutexLock lock(&mu_);
   auto& buffer = buffers_[connection_id];
-  CHECK(buffer.has_value());
+  ABSL_CHECK(buffer.has_value());
   if (buffer->HavePending()) {
     waker = std::move(write_waker_);
     return buffer->TakePending();
@@ -91,7 +91,7 @@ void OutputBuffers::AddEndpoint(uint32_t connection_id) {
   if (buffers_.size() < connection_id + 1) {
     buffers_.resize(connection_id + 1);
   }
-  CHECK(!buffers_[connection_id].has_value()) << GRPC_DUMP_ARGS(connection_id);
+  ABSL_CHECK(!buffers_[connection_id].has_value()) << GRPC_DUMP_ARGS(connection_id);
   buffers_[connection_id].emplace();
   waker = std::move(write_waker_);
   ready_endpoints_.fetch_add(1, std::memory_order_relaxed);
@@ -125,7 +125,7 @@ absl::StatusOr<uint64_t> InputQueues::CreateTicket(uint32_t connection_id,
 Poll<absl::StatusOr<SliceBuffer>> InputQueues::PollRead(uint64_t ticket) {
   MutexLock lock(&mu_);
   auto it = outstanding_reads_.find(ticket);
-  CHECK(it != outstanding_reads_.end()) << " ticket=" << ticket;
+  ABSL_CHECK(it != outstanding_reads_.end()) << " ticket=" << ticket;
   if (auto* waker = std::get_if<Waker>(&it->second)) {
     *waker = GetContext<Activity>()->MakeNonOwningWaker();
     return Pending{};
@@ -172,7 +172,7 @@ void InputQueues::CancelTicket(uint64_t ticket) {

 void InputQueues::AddEndpoint(uint32_t connection_id) {
   MutexLock lock(&mu_);
-  CHECK_EQ(read_requests_.size(), read_request_waker_.size());
+  ABSL_CHECK_EQ(read_requests_.size(), read_request_waker_.size());
   if (read_requests_.size() <= connection_id) {
     read_requests_.resize(connection_id + 1);
     read_request_waker_.resize(connection_id + 1);
@@ -289,7 +289,7 @@ DataEndpoints::DataEndpoints(
     bool enable_tracing)
     : output_buffers_(MakeRefCounted<data_endpoints_detail::OutputBuffers>()),
       input_queues_(MakeRefCounted<data_endpoints_detail::InputQueues>()) {
-  CHECK(event_engine != nullptr);
+  ABSL_CHECK(event_engine != nullptr);
   for (size_t i = 0; i < endpoints_vec.size(); ++i) {
     endpoints_.emplace_back(i, output_buffers_, input_queues_,
                             std::move(endpoints_vec[i]), enable_tracing,
diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/frame.cc b/third_party/grpc/source/src/core/ext/transport/chaotic_good/frame.cc
index 72ca1322e4c8e..c16e846ccdb00 100644
--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/frame.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/frame.cc
@@ -23,7 +23,7 @@
 #include <type_traits>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "src/core/ext/transport/chaotic_good/chaotic_good_frame.pb.h"
@@ -50,13 +50,13 @@ absl::Status ReadProto(SliceBuffer payload,
 void WriteProto(const google::protobuf::MessageLite& msg, SliceBuffer& output) {
   auto length = msg.ByteSizeLong();
   auto slice = MutableSlice::CreateUninitialized(length);
-  CHECK(msg.SerializeToArray(slice.data(), length));
+  ABSL_CHECK(msg.SerializeToArray(slice.data(), length));
   output.AppendIndexed(Slice(std::move(slice)));
 }

 uint32_t ProtoPayloadSize(const google::protobuf::MessageLite& msg) {
   auto length = msg.ByteSizeLong();
-  CHECK_LE(length, std::numeric_limits<uint32_t>::max());
+  ABSL_CHECK_LE(length, std::numeric_limits<uint32_t>::max());
   return static_cast<uint32_t>(length);
 }

@@ -151,7 +151,7 @@ struct ServerMetadataEncoder {
   }

   void EncodeWithWarning(const Slice& key, const Slice& value) {
-    LOG_EVERY_N_SEC(INFO, 10) << "encoding known key " << key.as_string_view()
+    ABSL_LOG_EVERY_N_SEC(INFO, 10) << "encoding known key " << key.as_string_view()
                               << " with unknown encoding";
     Encode(key, value);
   }
@@ -229,7 +229,7 @@ absl::StatusOr<ServerMetadataHandle> ServerMetadataGrpcFromProto(

 absl::Status MessageFrame::Deserialize(const FrameHeader& header,
                                        SliceBuffer payload) {
-  CHECK_EQ(header.type, FrameType::kMessage);
+  ABSL_CHECK_EQ(header.type, FrameType::kMessage);
   if (header.stream_id == 0) {
     return absl::InternalError("Expected non-zero stream id");
   }
@@ -240,13 +240,13 @@ absl::Status MessageFrame::Deserialize(const FrameHeader& header,

 FrameHeader MessageFrame::MakeHeader() const {
   auto length = message->payload()->Length();
-  CHECK_LE(length, std::numeric_limits<uint32_t>::max());
+  ABSL_CHECK_LE(length, std::numeric_limits<uint32_t>::max());
   return FrameHeader{FrameType::kMessage, 0, stream_id,
                      static_cast<uint32_t>(length)};
 }

 void MessageFrame::SerializePayload(SliceBuffer& payload) const {
-  CHECK_NE(stream_id, 0u);
+  ABSL_CHECK_NE(stream_id, 0u);
   payload.Append(*message->payload());
 }

@@ -261,7 +261,7 @@ std::string MessageFrame::ToString() const {

 absl::Status MessageChunkFrame::Deserialize(const FrameHeader& header,
                                             SliceBuffer payload) {
-  CHECK_EQ(header.type, FrameType::kMessageChunk);
+  ABSL_CHECK_EQ(header.type, FrameType::kMessageChunk);
   if (header.stream_id == 0) {
     return absl::InternalError("Expected non-zero stream id");
   }
@@ -272,13 +272,13 @@ absl::Status MessageChunkFrame::Deserialize(const FrameHeader& header,

 FrameHeader MessageChunkFrame::MakeHeader() const {
   auto length = payload.Length();
-  CHECK_LE(length, std::numeric_limits<uint32_t>::max());
+  ABSL_CHECK_LE(length, std::numeric_limits<uint32_t>::max());
   return FrameHeader{FrameType::kMessageChunk, 0, stream_id,
                      static_cast<uint32_t>(length)};
 }

 void MessageChunkFrame::SerializePayload(SliceBuffer& payload) const {
-  CHECK_NE(stream_id, 0u);
+  ABSL_CHECK_NE(stream_id, 0u);
   payload.Append(this->payload);
 }

diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/frame.h b/third_party/grpc/source/src/core/ext/transport/chaotic_good/frame.h
index 011db54dd6afa..1289b4e0af58b 100644
--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/frame.h
+++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/frame.h
@@ -81,7 +81,7 @@ template <FrameType frame_type, typename Body>
 struct ProtoTransportFrame final : public FrameInterface {
   absl::Status Deserialize(const FrameHeader& header,
                            SliceBuffer payload) override {
-    DCHECK_EQ(header.type, frame_type);
+    ABSL_DCHECK_EQ(header.type, frame_type);
     return ReadTransportProto(header, std::move(payload), body);
   }
   FrameHeader MakeHeader() const override {
@@ -104,14 +104,14 @@ template <FrameType frame_type, typename Body>
 struct ProtoStreamFrame final : public FrameInterface {
   absl::Status Deserialize(const FrameHeader& header,
                            SliceBuffer payload) override {
-    DCHECK_EQ(header.type, frame_type);
+    ABSL_DCHECK_EQ(header.type, frame_type);
     return ReadStreamProto(header, std::move(payload), body, stream_id);
   }
   FrameHeader MakeHeader() const override {
     return FrameHeader{frame_type, 0, stream_id, ProtoPayloadSize(body)};
   }
   void SerializePayload(SliceBuffer& payload) const override {
-    DCHECK_NE(stream_id, 0u);
+    ABSL_DCHECK_NE(stream_id, 0u);
     WriteProto(body, payload);
   }
   std::string ToString() const override {
@@ -129,7 +129,7 @@ struct EmptyStreamFrame final : public FrameInterface {
   EmptyStreamFrame() = default;
   explicit EmptyStreamFrame(uint32_t stream_id) : stream_id(stream_id) {}
   absl::Status Deserialize(const FrameHeader& header, SliceBuffer) override {
-    DCHECK_EQ(header.type, frame_type);
+    ABSL_DCHECK_EQ(header.type, frame_type);
     return ReadEmptyFrame(header, stream_id);
   }
   FrameHeader MakeHeader() const override {
diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/message_reassembly.h b/third_party/grpc/source/src/core/ext/transport/chaotic_good/message_reassembly.h
index 796c90ea116ee..1c6d4d1e7653b 100644
--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/message_reassembly.h
+++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/message_reassembly.h
@@ -15,7 +15,7 @@
 #ifndef GRPC_SRC_CORE_EXT_TRANSPORT_CHAOTIC_GOOD_MESSAGE_REASSEMBLY_H
 #define GRPC_SRC_CORE_EXT_TRANSPORT_CHAOTIC_GOOD_MESSAGE_REASSEMBLY_H

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/ext/transport/chaotic_good/frame.h"
 #include "src/core/lib/transport/call_spine.h"

@@ -27,11 +27,11 @@ namespace chaotic_good {
 class MessageReassembly {
  public:
   void FailCall(CallInitiator& call, absl::string_view msg) {
-    LOG_EVERY_N_SEC(INFO, 10) << "Call failed during reassembly: " << msg;
+    ABSL_LOG_EVERY_N_SEC(INFO, 10) << "Call failed during reassembly: " << msg;
     call.Cancel();
   }
   void FailCall(CallHandler& call, absl::string_view msg) {
-    LOG_EVERY_N_SEC(INFO, 10) << "Call failed during reassembly: " << msg;
+    ABSL_LOG_EVERY_N_SEC(INFO, 10) << "Call failed during reassembly: " << msg;
     call.PushServerTrailingMetadata(
         CancelledServerMetadataFromStatus(GRPC_STATUS_INTERNAL, msg));
   }
diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/server/chaotic_good_server.cc b/third_party/grpc/source/src/core/ext/transport/chaotic_good/server/chaotic_good_server.cc
index 9653016ac6589..23674f749fb66 100644
--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/server/chaotic_good_server.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/server/chaotic_good_server.cc
@@ -26,8 +26,8 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/random/bit_gen_ref.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
@@ -104,7 +104,7 @@ absl::StatusOr<int> ChaoticGoodServerListener::Bind(
     grpc_event_engine::experimental::EventEngine::ResolvedAddress addr) {
   if (GRPC_TRACE_FLAG_ENABLED(chaotic_good)) {
     auto str = grpc_event_engine::experimental::ResolvedAddressToString(addr);
-    LOG(INFO) << "CHAOTIC_GOOD: Listen on "
+    ABSL_LOG(INFO) << "CHAOTIC_GOOD: Listen on "
               << (str.ok() ? str->c_str() : str.status().ToString());
   }
   EventEngine::Listener::AcceptCallback accept_cb =
@@ -118,16 +118,16 @@ absl::StatusOr<int> ChaoticGoodServerListener::Bind(
       };
   auto shutdown_cb = [](absl::Status status) {
     if (!status.ok()) {
-      LOG(ERROR) << "Server accept connection failed: " << status;
+      ABSL_LOG(ERROR) << "Server accept connection failed: " << status;
     }
   };
-  CHECK_NE(event_engine_, nullptr);
+  ABSL_CHECK_NE(event_engine_, nullptr);
   auto ee_listener = event_engine_->CreateListener(
       std::move(accept_cb), std::move(shutdown_cb),
       grpc_event_engine::experimental::ChannelArgsEndpointConfig(args_),
       std::make_unique<MemoryQuota>("chaotic_good_server_listener"));
   if (!ee_listener.ok()) {
-    LOG(ERROR) << "Bind failed: " << ee_listener.status().ToString();
+    ABSL_LOG(ERROR) << "Bind failed: " << ee_listener.status().ToString();
     return ee_listener.status();
   }
   ee_listener_ = std::move(ee_listener.value());
@@ -139,10 +139,10 @@ absl::StatusOr<int> ChaoticGoodServerListener::Bind(
 }

 absl::Status ChaoticGoodServerListener::StartListening() {
-  CHECK(ee_listener_ != nullptr);
+  ABSL_CHECK(ee_listener_ != nullptr);
   auto status = ee_listener_->Start();
   if (!status.ok()) {
-    LOG(ERROR) << "Start listening failed: " << status;
+    ABSL_LOG(ERROR) << "Start listening failed: " << status;
   } else {
     GRPC_TRACE_LOG(chaotic_good, INFO) << "CHAOTIC_GOOD: Started listening";
   }
@@ -244,7 +244,7 @@ void ChaoticGoodServerListener::DataConnectionListener::Orphaned() {
   absl::flat_hash_map<std::string, PendingConnectionInfo> pending_connections;
   {
     MutexLock lock(&mu_);
-    CHECK(!shutdown_);
+    ABSL_CHECK(!shutdown_);
     pending_connections = std::move(pending_connections_);
     pending_connections_.clear();
     shutdown_ = true;
@@ -406,18 +406,18 @@ auto ChaoticGoodServerListener::ActiveConnection::HandshakingState::
 void ChaoticGoodServerListener::ActiveConnection::HandshakingState::
     OnHandshakeDone(absl::StatusOr<HandshakerArgs*> result) {
   if (!result.ok()) {
-    LOG_EVERY_N_SEC(ERROR, 5) << "Handshake failed: ", result.status();
+    ABSL_LOG_EVERY_N_SEC(ERROR, 5) << "Handshake failed: ", result.status();
     connection_->Done();
     return;
   }
-  CHECK_NE(*result, nullptr);
+  ABSL_CHECK_NE(*result, nullptr);
   if ((*result)->endpoint == nullptr) {
-    LOG_EVERY_N_SEC(ERROR, 5)
+    ABSL_LOG_EVERY_N_SEC(ERROR, 5)
         << "Server handshake done but has empty endpoint.";
     connection_->Done();
     return;
   }
-  CHECK(grpc_event_engine::experimental::grpc_is_event_engine_endpoint(
+  ABSL_CHECK(grpc_event_engine::experimental::grpc_is_event_engine_endpoint(
       (*result)->endpoint.get()));
   auto ee_endpoint =
       grpc_event_engine::experimental::grpc_take_wrapped_event_engine_endpoint(
@@ -489,14 +489,14 @@ int grpc_server_add_chaotic_good_port(grpc_server* server, const char* addr) {
         core_server->channel_args().GetObjectRef<EventEngine>()->GetDNSResolver(
             EventEngine::DNSResolver::ResolverOptions());
     if (!ee_resolver.ok()) {
-      LOG(ERROR) << "Failed to resolve " << addr << ": "
+      ABSL_LOG(ERROR) << "Failed to resolve " << addr << ": "
                  << ee_resolver.status().ToString();
       return 0;
     }
     results = grpc_event_engine::experimental::LookupHostnameBlocking(
         ee_resolver->get(), parsed_addr, absl::StrCat(0xd20));
     if (!results.ok()) {
-      LOG(ERROR) << "Failed to resolve " << addr << ": "
+      ABSL_LOG(ERROR) << "Failed to resolve " << addr << ": "
                  << results.status().ToString();
       return 0;
     }
@@ -507,7 +507,7 @@ int grpc_server_add_chaotic_good_port(grpc_server* server, const char* addr) {
         grpc_core::GetDNSResolver()->LookupHostnameBlocking(
             parsed_addr, absl::StrCat(0xd20));
     if (!resolved_or.ok()) {
-      LOG(ERROR) << "Failed to resolve " << addr << ": "
+      ABSL_LOG(ERROR) << "Failed to resolve " << addr << ": "
                  << resolved_or.status().ToString();
       return 0;
     }
@@ -534,17 +534,17 @@ int grpc_server_add_chaotic_good_port(grpc_server* server, const char* addr) {
     if (port_num == 0) {
       port_num = bind_result.value();
     } else {
-      CHECK(port_num == bind_result.value());
+      ABSL_CHECK(port_num == bind_result.value());
     }
     core_server->AddListener(std::move(listener));
   }
   if (error_list.size() == results->size()) {
-    LOG(ERROR) << "Failed to bind any address for " << addr;
+    ABSL_LOG(ERROR) << "Failed to bind any address for " << addr;
     for (const auto& error : error_list) {
-      LOG(ERROR) << "  " << error.first << ": " << error.second;
+      ABSL_LOG(ERROR) << "  " << error.first << ": " << error.second;
     }
   } else if (!error_list.empty()) {
-    LOG(INFO) << "Failed to bind some addresses for " << addr;
+    ABSL_LOG(INFO) << "Failed to bind some addresses for " << addr;
     for (const auto& error : error_list) {
       GRPC_TRACE_LOG(chaotic_good, INFO)
           << "Binding Failed: " << error.first << ": " << error.second;
diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/server/chaotic_good_server.h b/third_party/grpc/source/src/core/ext/transport/chaotic_good/server/chaotic_good_server.h
index bcabd259cb9e8..81b2af5a472cf 100644
--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/server/chaotic_good_server.h
+++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/server/chaotic_good_server.h
@@ -141,7 +141,7 @@ class ChaoticGoodServerListener final : public Server::ListenerInterface {
         Duration connect_timeout,
         std::shared_ptr<grpc_event_engine::experimental::EventEngine>
             event_engine);
-    ~DataConnectionListener() override { CHECK(shutdown_); }
+    ~DataConnectionListener() override { ABSL_CHECK(shutdown_); }

     void Orphaned() override;

diff --git a/third_party/grpc/source/src/core/ext/transport/chaotic_good/server_transport.cc b/third_party/grpc/source/src/core/ext/transport/chaotic_good/server_transport.cc
index 039d531093b9d..77e74cbd22042 100644
--- a/third_party/grpc/source/src/core/ext/transport/chaotic_good/server_transport.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chaotic_good/server_transport.cc
@@ -24,8 +24,8 @@
 #include <tuple>

 #include "absl/cleanup/cleanup.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/random/bit_gen_ref.h"
 #include "absl/random/random.h"
 #include "absl/status/status.h"
@@ -216,7 +216,7 @@ auto ChaoticGoodServerTransport::CallOutboundLoop(
 absl::Status ChaoticGoodServerTransport::NewStream(
     ChaoticGoodTransport& transport, const FrameHeader& header,
     SliceBuffer payload) {
-  CHECK_EQ(header.payload_length, payload.Length());
+  ABSL_CHECK_EQ(header.payload_length, payload.Length());
   auto client_initial_metadata_frame =
       transport.DeserializeFrame<ClientInitialMetadataFrame>(
           header, std::move(payload));
@@ -300,7 +300,7 @@ auto ChaoticGoodServerTransport::ReadOneFrame(
                       []() -> absl::Status { return absl::OkStatus(); });
                 }),
                 Default([&]() {
-                  LOG_EVERY_N_SEC(INFO, 10)
+                  ABSL_LOG_EVERY_N_SEC(INFO, 10)
                       << "Bad frame type: "
                       << incoming_frame.header().ToString();
                   return ImmediateOkStatus();
@@ -360,8 +360,8 @@ ChaoticGoodServerTransport::ChaoticGoodServerTransport(

 void ChaoticGoodServerTransport::SetCallDestination(
     RefCountedPtr<UnstartedCallDestination> call_destination) {
-  CHECK(call_destination_ == nullptr);
-  CHECK(call_destination != nullptr);
+  ABSL_CHECK(call_destination_ == nullptr);
+  ABSL_CHECK(call_destination != nullptr);
   call_destination_ = call_destination;
   got_acceptor_.Set();
 }
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/alpn/alpn.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/alpn/alpn.cc
index cd6119f4782a6..6bf0b208f05ed 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/alpn/alpn.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/alpn/alpn.cc
@@ -20,7 +20,7 @@

 #include <grpc/support/port_platform.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/util/useful.h"

 // in order of preference
@@ -42,6 +42,6 @@ size_t grpc_chttp2_num_alpn_versions(void) {
 }

 const char* grpc_chttp2_get_alpn_version_index(size_t i) {
-  CHECK_LT(i, GPR_ARRAY_SIZE(supported_versions));
+  ABSL_CHECK_LT(i, GPR_ARRAY_SIZE(supported_versions));
   return supported_versions[i];
 }
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/client/chttp2_connector.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/client/chttp2_connector.cc
index 985b0be82c148..34b09870bd2fb 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/client/chttp2_connector.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/client/chttp2_connector.cc
@@ -32,8 +32,8 @@
 #include <type_traits>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_format.h"
@@ -96,7 +96,7 @@ void Chttp2Connector::Connect(const Args& args, Result* result,
                               grpc_closure* notify) {
   {
     MutexLock lock(&mu_);
-    CHECK_EQ(notify_, nullptr);
+    ABSL_CHECK_EQ(notify_, nullptr);
     args_ = args;
     result_ = result;
     notify_ = notify;
@@ -144,7 +144,7 @@ void Chttp2Connector::OnHandshakeDone(absl::StatusOr<HandshakerArgs*> result) {
   } else if ((*result)->endpoint != nullptr) {
     result_->transport = grpc_create_chttp2_transport(
         (*result)->args, std::move((*result)->endpoint), true);
-    CHECK_NE(result_->transport, nullptr);
+    ABSL_CHECK_NE(result_->transport, nullptr);
     result_->socket_node =
         grpc_chttp2_transport_get_socket_node(result_->transport);
     result_->channel_args = std::move((*result)->args);
@@ -167,7 +167,7 @@ void Chttp2Connector::OnHandshakeDone(absl::StatusOr<HandshakerArgs*> result) {
     // If the handshaking succeeded but there is no endpoint, then the
     // handshaker may have handed off the connection to some external
     // code. Just verify that exit_early flag is set.
-    DCHECK((*result)->exit_early);
+    ABSL_DCHECK((*result)->exit_early);
     NullThenSchedClosure(DEBUG_LOCATION, &notify_, result.status());
   }
   handshake_mgr_.reset();
@@ -234,7 +234,7 @@ class Chttp2SecureClientChannelFactory : public ClientChannelFactory {
       const grpc_resolved_address& address, const ChannelArgs& args) override {
     absl::StatusOr<ChannelArgs> new_args = GetSecureNamingChannelArgs(args);
     if (!new_args.ok()) {
-      LOG(ERROR) << "Failed to create channel args during subchannel creation: "
+      ABSL_LOG(ERROR) << "Failed to create channel args during subchannel creation: "
                  << new_args.status() << "; Got args: " << args.ToString();
       return nullptr;
     }
@@ -277,7 +277,7 @@ class Chttp2SecureClientChannelFactory : public ClientChannelFactory {
 absl::StatusOr<RefCountedPtr<Channel>> CreateChannel(const char* target,
                                                      const ChannelArgs& args) {
   if (target == nullptr) {
-    LOG(ERROR) << "cannot create channel with NULL target name";
+    ABSL_LOG(ERROR) << "cannot create channel with NULL target name";
     return absl::InvalidArgumentError("channel target is NULL");
   }
   return ChannelCreate(target, args, GRPC_CLIENT_CHANNEL, nullptr);
@@ -364,14 +364,14 @@ grpc_channel* grpc_channel_create_from_fd(const char* target, int fd,
           .SetObject(creds->Ref());

   int flags = fcntl(fd, F_GETFL, 0);
-  CHECK_EQ(fcntl(fd, F_SETFL, flags | O_NONBLOCK), 0);
+  ABSL_CHECK_EQ(fcntl(fd, F_SETFL, flags | O_NONBLOCK), 0);
   grpc_core::OrphanablePtr<grpc_endpoint> client(grpc_tcp_create_from_fd(
       grpc_fd_create(fd, "client", true),
       grpc_event_engine::experimental::ChannelArgsEndpointConfig(final_args),
       "fd-client"));
   grpc_core::Transport* transport =
       grpc_create_chttp2_transport(final_args, std::move(client), true);
-  CHECK(transport);
+  ABSL_CHECK(transport);
   auto channel = grpc_core::ChannelCreate(
       target, final_args, GRPC_CLIENT_DIRECT_CHANNEL, transport);
   if (channel.ok()) {
@@ -393,7 +393,7 @@ grpc_channel* grpc_channel_create_from_fd(const char* /* target */,
                                           int /* fd */,
                                           grpc_channel_credentials* /* creds*/,
                                           const grpc_channel_args* /* args */) {
-  CHECK(0);
+  ABSL_CHECK(0);
   return nullptr;
 }

diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/server/chttp2_server.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/server/chttp2_server.cc
index 66ee7105b444b..b5bb15ef65ebd 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/server/chttp2_server.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/server/chttp2_server.cc
@@ -38,8 +38,8 @@
 #include <vector>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -323,7 +323,7 @@ void Chttp2ServerListener::ConfigFetcherWatcher::UpdateConnectionManager(
     void set_connections(
         std::map<ActiveConnection*, OrphanablePtr<ActiveConnection>>
             connections) {
-      CHECK(connections_.empty());
+      ABSL_CHECK(connections_.empty());
       connections_ = std::move(connections);
     }

@@ -345,10 +345,10 @@ void Chttp2ServerListener::ConfigFetcherWatcher::UpdateConnectionManager(
   grpc_error_handle error = grpc_tcp_server_add_port(
       listener_->tcp_server_, &listener_->resolved_address_, &port_temp);
   if (!error.ok()) {
-    LOG(ERROR) << "Error adding port to server: " << StatusToString(error);
+    ABSL_LOG(ERROR) << "Error adding port to server: " << StatusToString(error);
     // TODO(yashykt): We wouldn't need to assert here if we bound to the
     // port earlier during AddPort.
-    CHECK(0);
+    ABSL_CHECK(0);
   }
   listener_->StartListening();
   {
@@ -538,7 +538,7 @@ void Chttp2ServerListener::ActiveConnection::HandshakingState::OnHandshakeDone(
               });
         } else {
           // Failed to create channel from transport. Clean up.
-          LOG(ERROR) << "Failed to create channel: "
+          ABSL_LOG(ERROR) << "Failed to create channel: "
                      << StatusToString(channel_init_err);
           transport->Orphan();
           cleanup_connection = true;
@@ -937,7 +937,7 @@ void Chttp2ServerListener::Orphan() {
   // Cancel the watch before shutting down so as to avoid holding a ref to the
   // listener in the watcher.
   if (config_fetcher_watcher_ != nullptr) {
-    CHECK_NE(config_fetcher_, nullptr);
+    ABSL_CHECK_NE(config_fetcher_, nullptr);
     config_fetcher_->CancelWatch(config_fetcher_watcher_);
   }
   std::map<ActiveConnection*, OrphanablePtr<ActiveConnection>> connections;
@@ -1106,7 +1106,7 @@ void NewChttp2ServerListener::ActiveConnection::HandshakingState::
           });
     } else {
       // Failed to create channel from transport. Clean up.
-      LOG(ERROR) << "Failed to create channel: "
+      ABSL_LOG(ERROR) << "Failed to create channel: "
                  << StatusToString(channel_init_err);
       transport->Orphan();
     }
@@ -1363,10 +1363,10 @@ void NewChttp2ServerListener::Start() {
     grpc_error_handle error =
         grpc_tcp_server_add_port(tcp_server_, resolved_address(), &port_temp);
     if (!error.ok()) {
-      LOG(ERROR) << "Error adding port to server: " << StatusToString(error);
+      ABSL_LOG(ERROR) << "Error adding port to server: " << StatusToString(error);
       // TODO(yashykt): We wouldn't need to assert here if we bound to the
       // port earlier during AddPort.
-      CHECK(0);
+      ABSL_CHECK(0);
     }
   }
   if (tcp_server != nullptr) {
@@ -1544,7 +1544,7 @@ grpc_error_handle Chttp2ServerAddPort(Server* server, const char* addr,
         if (*port_num == -1) {
           *port_num = port_temp;
         } else {
-          CHECK(*port_num == port_temp);
+          ABSL_CHECK(*port_num == port_temp);
         }
       }
     }
@@ -1561,7 +1561,7 @@ grpc_error_handle Chttp2ServerAddPort(Server* server, const char* addr,
                           results->size() - error_list.size(), results->size());
       error = GRPC_ERROR_CREATE_REFERENCING(msg.c_str(), error_list.data(),
                                             error_list.size());
-      LOG(INFO) << "WARNING: " << StatusToString(error);
+      ABSL_LOG(INFO) << "WARNING: " << StatusToString(error);
       // we managed to bind some addresses: continue without error
     }
     return absl::OkStatus();
@@ -1576,7 +1576,7 @@ namespace experimental {

 absl::Status PassiveListenerImpl::AcceptConnectedEndpoint(
     std::unique_ptr<EventEngine::Endpoint> endpoint) {
-  CHECK_NE(server_.get(), nullptr);
+  ABSL_CHECK_NE(server_.get(), nullptr);
   if (IsServerListenerEnabled()) {
     RefCountedPtr<NewChttp2ServerListener> new_listener;
     {
@@ -1615,7 +1615,7 @@ absl::Status PassiveListenerImpl::AcceptConnectedEndpoint(
 }

 absl::Status PassiveListenerImpl::AcceptConnectedFd(int fd) {
-  CHECK_NE(server_.get(), nullptr);
+  ABSL_CHECK_NE(server_.get(), nullptr);
   ExecCtx exec_ctx;
   auto& args = server_->channel_args();
   auto* supports_fd = QueryExtension<EventEngineSupportsFdExtension>(
@@ -1682,7 +1682,7 @@ int grpc_server_add_http2_port(grpc_server* server, const char* addr,
 done:
   sc.reset(DEBUG_LOCATION, "server");
   if (!err.ok()) {
-    LOG(ERROR) << grpc_core::StatusToString(err);
+    ABSL_LOG(ERROR) << grpc_core::StatusToString(err);
   }
   return port_num;
 }
@@ -1693,7 +1693,7 @@ void grpc_server_add_channel_from_fd(grpc_server* server, int fd,
   // For now, we only support insecure server credentials
   if (creds == nullptr ||
       creds->type() != grpc_core::InsecureServerCredentials::Type()) {
-    LOG(ERROR) << "Failed to create channel due to invalid creds";
+    ABSL_LOG(ERROR) << "Failed to create channel due to invalid creds";
     return;
   }
   grpc_core::ExecCtx exec_ctx;
@@ -1721,7 +1721,7 @@ void grpc_server_add_channel_from_fd(grpc_server* server, int fd,
     grpc_chttp2_transport_start_reading(transport, nullptr, nullptr, nullptr,
                                         nullptr);
   } else {
-    LOG(ERROR) << "Failed to create channel: "
+    ABSL_LOG(ERROR) << "Failed to create channel: "
                << grpc_core::StatusToString(error);
     transport->Orphan();
   }
@@ -1731,7 +1731,7 @@ void grpc_server_add_channel_from_fd(grpc_server* server, int fd,

 void grpc_server_add_channel_from_fd(grpc_server* /* server */, int /* fd */,
                                      grpc_server_credentials* /* creds */) {
-  CHECK(0);
+  ABSL_CHECK(0);
 }

 #endif  // GPR_SUPPORT_CHANNELS_FROM_FD
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/bin_decoder.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/bin_decoder.cc
index 8ccfdc2f3cff8..50504bab974cc 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/bin_decoder.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/bin_decoder.cc
@@ -22,8 +22,8 @@
 #include <grpc/support/port_platform.h>

 #include "absl/base/attributes.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/slice/slice.h"

 static uint8_t decode_table[] = {
@@ -57,7 +57,7 @@ static bool input_is_valid(const uint8_t* input_ptr, size_t length) {

   for (i = 0; i < length; ++i) {
     if (GPR_UNLIKELY((decode_table[input_ptr[i]] & 0xC0) != 0)) {
-      LOG(ERROR) << "Base64 decoding failed, invalid character '"
+      ABSL_LOG(ERROR) << "Base64 decoding failed, invalid character '"
                  << static_cast<char>(*input_ptr) << "' in base64 input.\n";
       return false;
     }
@@ -86,13 +86,13 @@ size_t grpc_chttp2_base64_infer_length_after_decode(const grpc_slice& slice) {
     len--;
   }
   if (GPR_UNLIKELY(GRPC_SLICE_LENGTH(slice) - len > 2)) {
-    LOG(ERROR) << "Base64 decoding failed. Input has more than 2 paddings.";
+    ABSL_LOG(ERROR) << "Base64 decoding failed. Input has more than 2 paddings.";
     return 0;
   }
   size_t tuples = len / 4;
   size_t tail_case = len % 4;
   if (GPR_UNLIKELY(tail_case == 1)) {
-    LOG(ERROR) << "Base64 decoding failed. Input has a length of " << len
+    ABSL_LOG(ERROR) << "Base64 decoding failed. Input has a length of " << len
                << " (without padding), which is invalid.\n";
     return 0;
   }
@@ -161,7 +161,7 @@ grpc_slice grpc_chttp2_base64_decode(const grpc_slice& input) {
   grpc_slice output;

   if (GPR_UNLIKELY(input_length % 4 != 0)) {
-    LOG(ERROR) << "Base64 decoding failed, input of "
+    ABSL_LOG(ERROR) << "Base64 decoding failed, input of "
                   "grpc_chttp2_base64_decode has a length of "
                << input_length << ", which is not a multiple of 4.\n";
     return grpc_empty_slice();
@@ -186,13 +186,13 @@ grpc_slice grpc_chttp2_base64_decode(const grpc_slice& input) {

   if (GPR_UNLIKELY(!grpc_base64_decode_partial(&ctx))) {
     char* s = grpc_slice_to_c_string(input);
-    LOG(ERROR) << "Base64 decoding failed, input string:\n" << s << "\n";
+    ABSL_LOG(ERROR) << "Base64 decoding failed, input string:\n" << s << "\n";
     gpr_free(s);
     grpc_core::CSliceUnref(output);
     return grpc_empty_slice();
   }
-  CHECK(ctx.output_cur == GRPC_SLICE_END_PTR(output));
-  CHECK(ctx.input_cur == GRPC_SLICE_END_PTR(input));
+  ABSL_CHECK(ctx.output_cur == GRPC_SLICE_END_PTR(output));
+  ABSL_CHECK(ctx.input_cur == GRPC_SLICE_END_PTR(input));
   return output;
 }

@@ -204,7 +204,7 @@ grpc_slice grpc_chttp2_base64_decode_with_length(const grpc_slice& input,

   // The length of a base64 string cannot be 4 * n + 1
   if (GPR_UNLIKELY(input_length % 4 == 1)) {
-    LOG(ERROR) << "Base64 decoding failed, input of "
+    ABSL_LOG(ERROR) << "Base64 decoding failed, input of "
                   "grpc_chttp2_base64_decode_with_length has a length of "
                << input_length << ", which has a tail of 1 byte.\n";
     grpc_core::CSliceUnref(output);
@@ -213,7 +213,7 @@ grpc_slice grpc_chttp2_base64_decode_with_length(const grpc_slice& input,

   if (GPR_UNLIKELY(output_length >
                    input_length / 4 * 3 + tail_xtra[input_length % 4])) {
-    LOG(ERROR) << "Base64 decoding failed, output_length " << output_length
+    ABSL_LOG(ERROR) << "Base64 decoding failed, output_length " << output_length
                << " is longer than the max possible output length "
                << ((input_length / 4 * 3) + tail_xtra[input_length % 4])
                << ".\n";
@@ -229,12 +229,12 @@ grpc_slice grpc_chttp2_base64_decode_with_length(const grpc_slice& input,

   if (GPR_UNLIKELY(!grpc_base64_decode_partial(&ctx))) {
     char* s = grpc_slice_to_c_string(input);
-    LOG(ERROR) << "Base64 decoding failed, input string:\n" << s << "\n";
+    ABSL_LOG(ERROR) << "Base64 decoding failed, input string:\n" << s << "\n";
     gpr_free(s);
     grpc_core::CSliceUnref(output);
     return grpc_empty_slice();
   }
-  CHECK(ctx.output_cur == GRPC_SLICE_END_PTR(output));
-  CHECK(ctx.input_cur <= GRPC_SLICE_END_PTR(input));
+  ABSL_CHECK(ctx.output_cur == GRPC_SLICE_END_PTR(output));
+  ABSL_CHECK(ctx.input_cur <= GRPC_SLICE_END_PTR(input));
   return output;
 }
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/bin_encoder.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/bin_encoder.cc
index c9727428ebca3..6ae90c7e6bb9e 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/bin_encoder.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/bin_encoder.cc
@@ -22,7 +22,7 @@
 #include <stdint.h>
 #include <string.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/ext/transport/chttp2/transport/huffsyms.h"

 static const char alphabet[] =
@@ -86,8 +86,8 @@ grpc_slice grpc_chttp2_base64_encode(const grpc_slice& input) {
       break;
   }

-  CHECK(out == (char*)GRPC_SLICE_END_PTR(output));
-  CHECK(in == GRPC_SLICE_END_PTR(input));
+  ABSL_CHECK(out == (char*)GRPC_SLICE_END_PTR(output));
+  ABSL_CHECK(in == GRPC_SLICE_END_PTR(input));
   return output;
 }

@@ -130,7 +130,7 @@ grpc_slice grpc_chttp2_huffman_compress(const grpc_slice& input) {
                              static_cast<uint8_t>(0xffu >> temp_length));
   }

-  CHECK(out == GRPC_SLICE_END_PTR(output));
+  ABSL_CHECK(out == GRPC_SLICE_END_PTR(output));

   return output;
 }
@@ -226,9 +226,9 @@ grpc_slice grpc_chttp2_base64_encode_and_huffman_compress(
         static_cast<uint8_t>(0xffu >> out.temp_length));
   }

-  CHECK(out.out <= GRPC_SLICE_END_PTR(output));
+  ABSL_CHECK(out.out <= GRPC_SLICE_END_PTR(output));
   GRPC_SLICE_SET_LENGTH(output, out.out - start_out);

-  CHECK(in == GRPC_SLICE_END_PTR(input));
+  ABSL_CHECK(in == GRPC_SLICE_END_PTR(input));
   return output;
 }
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/chttp2_transport.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/chttp2_transport.cc
index e22db84bfb54f..d827f01bd1309 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/chttp2_transport.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/chttp2_transport.cc
@@ -46,8 +46,8 @@
 #include "absl/base/attributes.h"
 #include "absl/container/flat_hash_map.h"
 #include "absl/hash/hash.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/meta/type_traits.h"
 #include "absl/random/random.h"
 #include "absl/status/status.h"
@@ -395,11 +395,11 @@ grpc_chttp2_transport::~grpc_chttp2_transport() {
   grpc_chttp2_goaway_parser_destroy(&goaway_parser);

   for (i = 0; i < STREAM_LIST_COUNT; i++) {
-    CHECK_EQ(lists[i].head, nullptr);
-    CHECK_EQ(lists[i].tail, nullptr);
+    ABSL_CHECK_EQ(lists[i].head, nullptr);
+    ABSL_CHECK_EQ(lists[i].tail, nullptr);
   }

-  CHECK(stream_map.empty());
+  ABSL_CHECK(stream_map.empty());
   GRPC_COMBINER_UNREF(combiner, "chttp2_transport");

   while (write_cb_pool) {
@@ -421,7 +421,7 @@ static void read_channel_args(grpc_chttp2_transport* t,
       channel_args.GetInt(GRPC_ARG_HTTP2_INITIAL_SEQUENCE_NUMBER).value_or(-1);
   if (initial_sequence_number > 0) {
     if ((t->next_stream_id & 1) != (initial_sequence_number & 1)) {
-      LOG(ERROR) << GRPC_ARG_HTTP2_INITIAL_SEQUENCE_NUMBER
+      ABSL_LOG(ERROR) << GRPC_ARG_HTTP2_INITIAL_SEQUENCE_NUMBER
                  << ": low bit must be " << (t->next_stream_id & 1) << " on "
                  << (is_client ? "client" : "server");
     } else {
@@ -524,7 +524,7 @@ static void read_channel_args(grpc_chttp2_transport* t,
       t->settings.mutable_local().SetMaxConcurrentStreams(value);
     }
   } else if (channel_args.Contains(GRPC_ARG_MAX_CONCURRENT_STREAMS)) {
-    VLOG(2) << GRPC_ARG_MAX_CONCURRENT_STREAMS
+    ABSL_VLOG(2) << GRPC_ARG_MAX_CONCURRENT_STREAMS
             << " is not available on clients";
   }
   value =
@@ -572,7 +572,7 @@ static void read_channel_args(grpc_chttp2_transport* t,
 static void init_keepalive_pings_if_enabled_locked(
     grpc_core::RefCountedPtr<grpc_chttp2_transport> t,
     GRPC_UNUSED grpc_error_handle error) {
-  DCHECK(error.ok());
+  ABSL_DCHECK(error.ok());
   if (t->keepalive_time != grpc_core::Duration::Infinity()) {
     t->keepalive_state = GRPC_CHTTP2_KEEPALIVE_STATE_WAITING;
     t->keepalive_ping_timer_handle =
@@ -671,7 +671,7 @@ grpc_chttp2_transport::grpc_chttp2_transport(
     }
   }

-  CHECK(strlen(GRPC_CHTTP2_CLIENT_CONNECT_STRING) ==
+  ABSL_CHECK(strlen(GRPC_CHTTP2_CLIENT_CONNECT_STRING) ==
         GRPC_CHTTP2_CLIENT_CONNECT_STRLEN);

   grpc_slice_buffer_init(&read_buffer);
@@ -763,7 +763,7 @@ static void close_transport_locked(grpc_chttp2_transport* t,
           grpc_error_add_child(t->close_transport_on_writes_finished, error);
       return;
     }
-    CHECK(!error.ok());
+    ABSL_CHECK(!error.ok());
     t->closed_with_error = error;
     connectivity_state_set(t, GRPC_CHANNEL_SHUTDOWN, absl::Status(),
                            "close_transport");
@@ -807,7 +807,7 @@ static void close_transport_locked(grpc_chttp2_transport* t,
     while (grpc_chttp2_list_pop_writable_stream(t, &s)) {
       GRPC_CHTTP2_STREAM_UNREF(s, "chttp2_writing:close");
     }
-    CHECK(t->write_state == GRPC_CHTTP2_WRITE_STATE_IDLE);
+    ABSL_CHECK(t->write_state == GRPC_CHTTP2_WRITE_STATE_IDLE);
     if (t->interested_parties_until_recv_settings != nullptr) {
       grpc_endpoint_delete_from_pollset_set(
           t->ep.get(), t->interested_parties_until_recv_settings);
@@ -896,9 +896,9 @@ grpc_chttp2_stream::~grpc_chttp2_stream() {
     }
   }

-  CHECK((write_closed && read_closed) || id == 0);
+  ABSL_CHECK((write_closed && read_closed) || id == 0);
   if (id != 0) {
-    CHECK_EQ(t->stream_map.count(id), 0u);
+    ABSL_CHECK_EQ(t->stream_map.count(id), 0u);
   }

   grpc_slice_buffer_destroy(&frame_storage);
@@ -911,11 +911,11 @@ grpc_chttp2_stream::~grpc_chttp2_stream() {
     }
   }

-  CHECK_EQ(send_initial_metadata_finished, nullptr);
-  CHECK_EQ(send_trailing_metadata_finished, nullptr);
-  CHECK_EQ(recv_initial_metadata_ready, nullptr);
-  CHECK_EQ(recv_message_ready, nullptr);
-  CHECK_EQ(recv_trailing_metadata_finished, nullptr);
+  ABSL_CHECK_EQ(send_initial_metadata_finished, nullptr);
+  ABSL_CHECK_EQ(send_trailing_metadata_finished, nullptr);
+  ABSL_CHECK_EQ(recv_initial_metadata_ready, nullptr);
+  ABSL_CHECK_EQ(recv_message_ready, nullptr);
+  ABSL_CHECK_EQ(recv_trailing_metadata_finished, nullptr);
   grpc_slice_buffer_destroy(&flow_controlled_buffer);
   grpc_core::ExecCtx::Run(DEBUG_LOCATION, destroy_stream_arg, absl::OkStatus());
 }
@@ -948,7 +948,7 @@ grpc_chttp2_stream* grpc_chttp2_parsing_accept_stream(grpc_chttp2_transport* t,
     return nullptr;
   }
   grpc_chttp2_stream* accepting = nullptr;
-  CHECK_EQ(t->accepting_stream, nullptr);
+  ABSL_CHECK_EQ(t->accepting_stream, nullptr);
   t->accepting_stream = &accepting;
   t->accept_stream_cb(t->accept_stream_cb_user_data, t,
                       reinterpret_cast<void*>(id));
@@ -1051,7 +1051,7 @@ static void write_action_begin_locked(
     grpc_core::RefCountedPtr<grpc_chttp2_transport> t,
     grpc_error_handle /*error_ignored*/) {
   GRPC_LATENT_SEE_INNER_SCOPE("write_action_begin_locked");
-  CHECK(t->write_state != GRPC_CHTTP2_WRITE_STATE_IDLE);
+  ABSL_CHECK(t->write_state != GRPC_CHTTP2_WRITE_STATE_IDLE);
   grpc_chttp2_begin_write_result r;
   if (!t->closed_with_error.ok()) {
     r.writing = false;
@@ -1065,7 +1065,7 @@ static void write_action_begin_locked(
                     begin_writing_desc(r.partial));
     write_action(t.get());
     if (t->reading_paused_on_pending_induced_frames) {
-      CHECK_EQ(t->num_pending_induced_frames, 0u);
+      ABSL_CHECK_EQ(t->num_pending_induced_frames, 0u);
       // We had paused reading, because we had many induced frames (SETTINGS
       // ACK, PINGS ACK and RST_STREAMS) pending in t->qbuf. Now that we have
       // been able to flush qbuf, we can resume reading.
@@ -1205,7 +1205,7 @@ void grpc_chttp2_add_incoming_goaway(grpc_chttp2_transport* t,
   // We want to log this irrespective of whether http tracing is enabled if we
   // received a GOAWAY with a non NO_ERROR code.
   if (goaway_error != GRPC_HTTP2_NO_ERROR) {
-    LOG(INFO) << t->peer_string.as_string_view() << ": Got goaway ["
+    ABSL_LOG(INFO) << t->peer_string.as_string_view() << ": Got goaway ["
               << goaway_error
               << "] err=" << grpc_core::StatusToString(t->goaway_error);
   }
@@ -1233,7 +1233,7 @@ void grpc_chttp2_add_incoming_goaway(grpc_chttp2_transport* t,
   if (GPR_UNLIKELY(t->is_client &&
                    goaway_error == GRPC_HTTP2_ENHANCE_YOUR_CALM &&
                    goaway_text == "too_many_pings")) {
-    LOG(ERROR) << t->peer_string.as_string_view()
+    ABSL_LOG(ERROR) << t->peer_string.as_string_view()
                << ": Received a GOAWAY with error code ENHANCE_YOUR_CALM and "
                   "debug data equal to \"too_many_pings\". Current keepalive "
                   "time (before throttling): "
@@ -1274,7 +1274,7 @@ static void maybe_start_some_streams(grpc_chttp2_transport* t) {
         << " allocating new grpc_chttp2_stream " << s << " to id "
         << t->next_stream_id;

-    CHECK_EQ(s->id, 0u);
+    ABSL_CHECK_EQ(s->id, 0u);
     s->id = t->next_stream_id;
     t->next_stream_id += 2;

@@ -1379,11 +1379,11 @@ static bool contains_non_ok_status(grpc_metadata_batch* batch) {

 static void log_metadata(const grpc_metadata_batch* md_batch, uint32_t id,
                          const bool is_client, const bool is_initial) {
-  VLOG(2) << "--metadata--";
+  ABSL_VLOG(2) << "--metadata--";
   const std::string prefix = absl::StrCat(
       "HTTP:", id, is_initial ? ":HDR" : ":TRL", is_client ? ":CLI:" : ":SVR:");
   md_batch->Log([&prefix](absl::string_view key, absl::string_view value) {
-    VLOG(2) << prefix << key << ": " << value;
+    ABSL_VLOG(2) << prefix << key << ": " << value;
   });
 }

@@ -1416,7 +1416,7 @@ static void send_initial_metadata_locked(
   if (t->is_client && t->channelz_socket != nullptr) {
     t->channelz_socket->RecordStreamStartedFromLocal();
   }
-  CHECK_EQ(s->send_initial_metadata_finished, nullptr);
+  ABSL_CHECK_EQ(s->send_initial_metadata_finished, nullptr);
   on_complete->next_data.scratch |= t->closure_barrier_may_cover_write;

   s->send_initial_metadata_finished = add_closure_barrier(on_complete);
@@ -1434,7 +1434,7 @@ static void send_initial_metadata_locked(
   if (!s->write_closed) {
     if (t->is_client) {
       if (t->closed_with_error.ok()) {
-        CHECK_EQ(s->id, 0u);
+        ABSL_CHECK_EQ(s->id, 0u);
         if (t->max_concurrent_streams_reject_on_client &&
             t->stream_map.size() >=
                 t->settings.peer().max_concurrent_streams()) {
@@ -1467,7 +1467,7 @@ static void send_initial_metadata_locked(
             false);
       }
     } else {
-      CHECK_NE(s->id, 0u);
+      ABSL_CHECK_NE(s->id, 0u);
       grpc_chttp2_mark_stream_writable(t, s);
       if (!(op->send_message &&
             (op->payload->send_message.flags & GRPC_WRITE_BUFFER_HINT))) {
@@ -1583,7 +1583,7 @@ static void send_trailing_metadata_locked(
     grpc_transport_stream_op_batch* op, grpc_chttp2_stream* s,
     grpc_transport_stream_op_batch_payload* op_payload,
     grpc_chttp2_transport* t, grpc_closure* on_complete) {
-  CHECK_EQ(s->send_trailing_metadata_finished, nullptr);
+  ABSL_CHECK_EQ(s->send_trailing_metadata_finished, nullptr);
   on_complete->next_data.scratch |= t->closure_barrier_may_cover_write;
   s->send_trailing_metadata_finished = add_closure_barrier(on_complete);
   s->send_trailing_metadata =
@@ -1615,7 +1615,7 @@ static void send_trailing_metadata_locked(
 static void recv_initial_metadata_locked(
     grpc_chttp2_stream* s, grpc_transport_stream_op_batch_payload* op_payload,
     grpc_chttp2_transport* t) {
-  CHECK_EQ(s->recv_initial_metadata_ready, nullptr);
+  ABSL_CHECK_EQ(s->recv_initial_metadata_ready, nullptr);
   s->recv_initial_metadata_ready =
       op_payload->recv_initial_metadata.recv_initial_metadata_ready;
   s->recv_initial_metadata =
@@ -1631,7 +1631,7 @@ static void recv_initial_metadata_locked(
 static void recv_message_locked(
     grpc_chttp2_stream* s, grpc_transport_stream_op_batch_payload* op_payload,
     grpc_chttp2_transport* t) {
-  CHECK_EQ(s->recv_message_ready, nullptr);
+  ABSL_CHECK_EQ(s->recv_message_ready, nullptr);
   s->recv_message_ready = op_payload->recv_message.recv_message_ready;
   s->recv_message = op_payload->recv_message.recv_message;
   s->recv_message->emplace();
@@ -1644,9 +1644,9 @@ static void recv_message_locked(
 static void recv_trailing_metadata_locked(
     grpc_chttp2_stream* s, grpc_transport_stream_op_batch_payload* op_payload,
     grpc_chttp2_transport* t) {
-  CHECK_EQ(s->collecting_stats, nullptr);
+  ABSL_CHECK_EQ(s->collecting_stats, nullptr);
   s->collecting_stats = op_payload->recv_trailing_metadata.collect_stats;
-  CHECK_EQ(s->recv_trailing_metadata_finished, nullptr);
+  ABSL_CHECK_EQ(s->recv_trailing_metadata_finished, nullptr);
   s->recv_trailing_metadata_finished =
       op_payload->recv_trailing_metadata.recv_trailing_metadata_ready;
   s->recv_trailing_metadata =
@@ -1670,7 +1670,7 @@ static void perform_stream_op_locked(void* stream_op,
   }
   s->tcp_tracer = TcpTracerIfSampled(s);
   if (GRPC_TRACE_FLAG_ENABLED(http)) {
-    LOG(INFO) << "perform_stream_op_locked[s=" << s << "; op=" << op
+    ABSL_LOG(INFO) << "perform_stream_op_locked[s=" << s << "; op=" << op
               << "]: " << grpc_transport_stream_op_batch_string(op, false)
               << "; on_complete = " << op->on_complete;
     if (op->send_initial_metadata) {
@@ -1735,12 +1735,12 @@ void grpc_chttp2_transport::PerformStreamOp(

   if (!is_client) {
     if (op->send_initial_metadata) {
-      CHECK(!op->payload->send_initial_metadata.send_initial_metadata
+      ABSL_CHECK(!op->payload->send_initial_metadata.send_initial_metadata
                  ->get(grpc_core::GrpcTimeoutMetadata())
                  .has_value());
     }
     if (op->send_trailing_metadata) {
-      CHECK(!op->payload->send_trailing_metadata.send_trailing_metadata
+      ABSL_CHECK(!op->payload->send_trailing_metadata.send_trailing_metadata
                  ->get(grpc_core::GrpcTimeoutMetadata())
                  .has_value());
     }
@@ -1833,8 +1833,8 @@ void grpc_chttp2_retry_initiate_ping(
 static void retry_initiate_ping_locked(
     grpc_core::RefCountedPtr<grpc_chttp2_transport> t,
     GRPC_UNUSED grpc_error_handle error) {
-  DCHECK(error.ok());
-  CHECK(t->delayed_ping_timer_handle != TaskHandle::kInvalid);
+  ABSL_DCHECK(error.ok());
+  ABSL_CHECK(t->delayed_ping_timer_handle != TaskHandle::kInvalid);
   t->delayed_ping_timer_handle = TaskHandle::kInvalid;
   grpc_chttp2_initiate_write(t.get(),
                              GRPC_CHTTP2_INITIATE_WRITE_RETRY_SEND_PING);
@@ -1842,7 +1842,7 @@ static void retry_initiate_ping_locked(

 void grpc_chttp2_ack_ping(grpc_chttp2_transport* t, uint64_t id) {
   if (!t->ping_callbacks.AckPing(id, t->event_engine.get())) {
-    VLOG(2) << "Unknown ping response from " << t->peer_string.as_string_view()
+    ABSL_VLOG(2) << "Unknown ping response from " << t->peer_string.as_string_view()
             << ": " << id;
     return;
   }
@@ -2017,7 +2017,7 @@ static void send_goaway(grpc_chttp2_transport* t, grpc_error_handle error,
   } else if (t->sent_goaway_state == GRPC_CHTTP2_NO_GOAWAY_SEND ||
              t->sent_goaway_state == GRPC_CHTTP2_GRACEFUL_GOAWAY) {
     // We want to log this irrespective of whether http tracing is enabled
-    VLOG(2) << t->peer_string.as_string_view() << " "
+    ABSL_VLOG(2) << t->peer_string.as_string_view() << " "
             << (t->is_client ? "CLIENT" : "SERVER")
             << ": Sending goaway last_new_stream_id=" << t->last_new_stream_id
             << " err=" << grpc_core::StatusToString(error);
@@ -2164,7 +2164,7 @@ void grpc_chttp2_maybe_complete_recv_message(grpc_chttp2_transport* t,
     } else {
       if (s->frame_storage.length != 0) {
         while (true) {
-          CHECK_GT(s->frame_storage.length, 0u);
+          ABSL_CHECK_GT(s->frame_storage.length, 0u);
           int64_t min_progress_size;
           auto r = grpc_deframe_unprocessed_incoming_frames(
               s, &min_progress_size, &**s->recv_message, s->recv_message_flags);
@@ -2246,7 +2246,7 @@ void grpc_chttp2_maybe_complete_recv_trailing_metadata(grpc_chttp2_transport* t,
 static grpc_chttp2_transport::RemovedStreamHandle remove_stream(
     grpc_chttp2_transport* t, uint32_t id, grpc_error_handle error) {
   grpc_chttp2_stream* s = t->stream_map.extract(id).mapped();
-  DCHECK(s);
+  ABSL_DCHECK(s);
   if (t->incoming_stream == s) {
     t->incoming_stream = nullptr;
     grpc_chttp2_parsing_become_skip_parser(t);
@@ -2496,8 +2496,8 @@ static void close_from_api(grpc_chttp2_transport* t, grpc_chttp2_stream* s,
   grpc_error_get_status(error, s->deadline, &grpc_status, &message, nullptr,
                         nullptr);

-  CHECK_GE(grpc_status, 0);
-  CHECK_LT((int)grpc_status, 100);
+  ABSL_CHECK_GE(grpc_status, 0);
+  ABSL_CHECK_LT((int)grpc_status, 100);

   auto remove_stream_handle = grpc_chttp2_mark_stream_closed(t, s, 1, 1, error);
   grpc_core::MaybeTarpit(
@@ -2538,7 +2538,7 @@ static void close_from_api(grpc_chttp2_transport* t, grpc_chttp2_stream* s,
           *p++ = '2';
           *p++ = '0';
           *p++ = '0';
-          CHECK(p == GRPC_SLICE_END_PTR(http_status_hdr));
+          ABSL_CHECK(p == GRPC_SLICE_END_PTR(http_status_hdr));
           len += static_cast<uint32_t> GRPC_SLICE_LENGTH(http_status_hdr);

           content_type_hdr = GRPC_SLICE_MALLOC(31);
@@ -2574,7 +2574,7 @@ static void close_from_api(grpc_chttp2_transport* t, grpc_chttp2_stream* s,
           *p++ = 'r';
           *p++ = 'p';
           *p++ = 'c';
-          CHECK(p == GRPC_SLICE_END_PTR(content_type_hdr));
+          ABSL_CHECK(p == GRPC_SLICE_END_PTR(content_type_hdr));
           len += static_cast<uint32_t> GRPC_SLICE_LENGTH(content_type_hdr);
         }

@@ -2601,11 +2601,11 @@ static void close_from_api(grpc_chttp2_transport* t, grpc_chttp2_stream* s,
           *p++ = static_cast<uint8_t>('0' + (grpc_status / 10));
           *p++ = static_cast<uint8_t>('0' + (grpc_status % 10));
         }
-        CHECK(p == GRPC_SLICE_END_PTR(status_hdr));
+        ABSL_CHECK(p == GRPC_SLICE_END_PTR(status_hdr));
         len += static_cast<uint32_t> GRPC_SLICE_LENGTH(status_hdr);

         size_t msg_len = message.length();
-        CHECK(msg_len <= UINT32_MAX);
+        ABSL_CHECK(msg_len <= UINT32_MAX);
         grpc_core::VarintWriter<1> msg_len_writer(
             static_cast<uint32_t>(msg_len));
         message_pfx = GRPC_SLICE_MALLOC(14 + msg_len_writer.length());
@@ -2626,7 +2626,7 @@ static void close_from_api(grpc_chttp2_transport* t, grpc_chttp2_stream* s,
         *p++ = 'e';
         msg_len_writer.Write(0, p);
         p += msg_len_writer.length();
-        CHECK(p == GRPC_SLICE_END_PTR(message_pfx));
+        ABSL_CHECK(p == GRPC_SLICE_END_PTR(message_pfx));
         len += static_cast<uint32_t> GRPC_SLICE_LENGTH(message_pfx);
         len += static_cast<uint32_t>(msg_len);

@@ -2642,7 +2642,7 @@ static void close_from_api(grpc_chttp2_transport* t, grpc_chttp2_stream* s,
         *p++ = static_cast<uint8_t>(id >> 16);
         *p++ = static_cast<uint8_t>(id >> 8);
         *p++ = static_cast<uint8_t>(id);
-        CHECK(p == GRPC_SLICE_END_PTR(hdr));
+        ABSL_CHECK(p == GRPC_SLICE_END_PTR(hdr));

         grpc_slice_buffer_add(&t->qbuf, hdr);
         if (!sent_initial_metadata) {
@@ -2862,7 +2862,7 @@ static void read_action_locked(
   if (t->keepalive_ping_timeout_handle != TaskHandle::kInvalid) {
     if (GRPC_TRACE_FLAG_ENABLED(http2_ping) ||
         GRPC_TRACE_FLAG_ENABLED(http_keepalive)) {
-      LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t.get()
+      ABSL_LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t.get()
                 << "]: Clear keepalive timer because data was received";
     }
     t->event_engine->Cancel(
@@ -2955,7 +2955,7 @@ static void finish_bdp_ping_locked(
       t->flow_control.bdp_estimator()->CompletePing();
   grpc_chttp2_act_on_flowctl_action(t->flow_control.PeriodicUpdate(), t.get(),
                                     nullptr);
-  CHECK(t->next_bdp_ping_timer_handle == TaskHandle::kInvalid);
+  ABSL_CHECK(t->next_bdp_ping_timer_handle == TaskHandle::kInvalid);
   t->next_bdp_ping_timer_handle =
       t->event_engine->RunAfter(next_ping - grpc_core::Timestamp::Now(), [t] {
         grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;
@@ -2974,7 +2974,7 @@ static void next_bdp_ping_timer_expired(grpc_chttp2_transport* t) {
 static void next_bdp_ping_timer_expired_locked(
     grpc_core::RefCountedPtr<grpc_chttp2_transport> t,
     GRPC_UNUSED grpc_error_handle error) {
-  DCHECK(error.ok());
+  ABSL_DCHECK(error.ok());
   t->next_bdp_ping_timer_handle = TaskHandle::kInvalid;
   if (t->flow_control.bdp_estimator()->accumulator() == 0) {
     // Block the bdp ping till we receive more data.
@@ -3042,9 +3042,9 @@ static void init_keepalive_ping(
 static void init_keepalive_ping_locked(
     grpc_core::RefCountedPtr<grpc_chttp2_transport> t,
     GRPC_UNUSED grpc_error_handle error) {
-  DCHECK(error.ok());
-  CHECK(t->keepalive_state == GRPC_CHTTP2_KEEPALIVE_STATE_WAITING);
-  CHECK(t->keepalive_ping_timer_handle != TaskHandle::kInvalid);
+  ABSL_DCHECK(error.ok());
+  ABSL_CHECK(t->keepalive_state == GRPC_CHTTP2_KEEPALIVE_STATE_WAITING);
+  ABSL_CHECK(t->keepalive_ping_timer_handle != TaskHandle::kInvalid);
   t->keepalive_ping_timer_handle = TaskHandle::kInvalid;
   grpc_core::Timestamp now = grpc_core::Timestamp::Now();
   grpc_core::Timestamp adjusted_keepalive_timestamp = std::exchange(
@@ -3092,11 +3092,11 @@ static void finish_keepalive_ping_locked(
     if (error.ok()) {
       if (GRPC_TRACE_FLAG_ENABLED(http) ||
           GRPC_TRACE_FLAG_ENABLED(http_keepalive)) {
-        LOG(INFO) << t->peer_string.as_string_view()
+        ABSL_LOG(INFO) << t->peer_string.as_string_view()
                   << ": Finish keepalive ping";
       }
       t->keepalive_state = GRPC_CHTTP2_KEEPALIVE_STATE_WAITING;
-      CHECK(t->keepalive_ping_timer_handle == TaskHandle::kInvalid);
+      ABSL_CHECK(t->keepalive_ping_timer_handle == TaskHandle::kInvalid);
       t->keepalive_ping_timer_handle =
           t->event_engine->RunAfter(t->keepalive_time, [t] {
             grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;
@@ -3139,7 +3139,7 @@ static void maybe_reset_keepalive_ping_timer_locked(grpc_chttp2_transport* t) {
     // need to Ref or Unref here since we still hold the Ref.
     if (GRPC_TRACE_FLAG_ENABLED(http) ||
         GRPC_TRACE_FLAG_ENABLED(http_keepalive)) {
-      LOG(INFO) << t->peer_string.as_string_view()
+      ABSL_LOG(INFO) << t->peer_string.as_string_view()
                 << ": Keepalive ping cancelled. Resetting timer.";
     }
   }
@@ -3241,7 +3241,7 @@ static void benign_reclaimer_locked(
                                    GRPC_HTTP2_ENHANCE_YOUR_CALM),
                 /*immediate_disconnect_hint=*/true);
   } else if (error.ok() && GRPC_TRACE_FLAG_ENABLED(resource_quota)) {
-    LOG(INFO) << "HTTP2: " << t->peer_string.as_string_view()
+    ABSL_LOG(INFO) << "HTTP2: " << t->peer_string.as_string_view()
               << " - skip benign reclamation, there are still "
               << t->stream_map.size() << " streams";
   }
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/flow_control.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/flow_control.cc
index 91f611959d0af..478fefaed5e8b 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/flow_control.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/flow_control.cc
@@ -28,8 +28,8 @@
 #include <tuple>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
 #include "absl/strings/str_join.h"
@@ -332,7 +332,7 @@ void StreamFlowControl::SentUpdate(uint32_t announce) {
   TransportFlowControl::IncomingUpdateContext tfc_upd(tfc_);
   pending_size_ = std::nullopt;
   tfc_upd.UpdateAnnouncedWindowDelta(&announced_window_delta_, announce);
-  CHECK_EQ(DesiredAnnounceSize(), 0u);
+  ABSL_CHECK_EQ(DesiredAnnounceSize(), 0u);
   std::ignore = tfc_upd.MakeAction();
 }

@@ -382,7 +382,7 @@ FlowControlAction StreamFlowControl::UpdateAction(FlowControlAction action) {

 void StreamFlowControl::IncomingUpdateContext::SetPendingSize(
     int64_t pending_size) {
-  CHECK_GE(pending_size, 0);
+  ABSL_CHECK_GE(pending_size, 0);
   sfc_->pending_size_ = pending_size;
 }

diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/flow_control.h b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/flow_control.h
index 769fce6ec5e42..382c9f45c06f3 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/flow_control.h
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/flow_control.h
@@ -29,7 +29,7 @@
 #include <utility>

 #include "absl/functional/function_ref.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/strings/string_view.h"
 #include "src/core/ext/transport/chttp2/transport/http2_settings.h"
@@ -128,7 +128,7 @@ class GRPC_MUST_USE_RESULT FlowControlAction {
   static const char* UrgencyString(Urgency u);
   std::string DebugString() const;

-  void AssertEmpty() { CHECK(*this == FlowControlAction()); }
+  void AssertEmpty() { ABSL_CHECK(*this == FlowControlAction()); }

   bool operator==(const FlowControlAction& other) const {
     return send_stream_update_ == other.send_stream_update_ &&
@@ -191,7 +191,7 @@ class TransportFlowControl final {
   class IncomingUpdateContext {
    public:
     explicit IncomingUpdateContext(TransportFlowControl* tfc) : tfc_(tfc) {}
-    ~IncomingUpdateContext() { CHECK_EQ(tfc_, nullptr); }
+    ~IncomingUpdateContext() { ABSL_CHECK_EQ(tfc_, nullptr); }

     IncomingUpdateContext(const IncomingUpdateContext&) = delete;
     IncomingUpdateContext& operator=(const IncomingUpdateContext&) = delete;
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame.cc
index e12cc5afba84e..a4338068a13a7 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame.cc
@@ -20,7 +20,7 @@
 #include <cstdint>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/util/crash.h"
@@ -58,7 +58,7 @@ uint16_t Read2b(const uint8_t* input) {
 }

 void Write3b(uint32_t x, uint8_t* output) {
-  CHECK_LT(x, 16777216u);
+  ABSL_CHECK_LT(x, 16777216u);
   output[0] = static_cast<uint8_t>(x >> 16);
   output[1] = static_cast<uint8_t>(x >> 8);
   output[2] = static_cast<uint8_t>(x);
@@ -491,7 +491,7 @@ void Serialize(absl::Span<Http2Frame> frames, SliceBuffer& out) {

 absl::StatusOr<Http2Frame> ParseFramePayload(const Http2FrameHeader& hdr,
                                              SliceBuffer payload) {
-  CHECK(payload.Length() == hdr.length);
+  ABSL_CHECK(payload.Length() == hdr.length);
   switch (hdr.type) {
     case kFrameTypeData:
       return ParseDataFrame(hdr, payload);
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_data.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_data.cc
index 1ec015abecaa0..cc2f0c4b8a1f8 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_data.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_data.cc
@@ -22,7 +22,7 @@
 #include <grpc/support/port_platform.h>
 #include <stdlib.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_format.h"
 #include "src/core/ext/transport/chttp2/transport/call_tracer_wrapper.h"
@@ -61,7 +61,7 @@ void grpc_chttp2_encode_data(uint32_t id, grpc_slice_buffer* inbuf,

   hdr = GRPC_SLICE_MALLOC(header_size);
   p = GRPC_SLICE_START_PTR(hdr);
-  CHECK(write_bytes < (1 << 24));
+  ABSL_CHECK(write_bytes < (1 << 24));
   *p++ = static_cast<uint8_t>(write_bytes >> 16);
   *p++ = static_cast<uint8_t>(write_bytes >> 8);
   *p++ = static_cast<uint8_t>(write_bytes);
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_goaway.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_goaway.cc
index a108986a24d33..3d9e2ef2a8b94 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_goaway.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_goaway.cc
@@ -24,7 +24,7 @@
 #include <string.h>

 #include "absl/base/attributes.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_format.h"
 #include "absl/strings/string_view.h"
@@ -134,7 +134,7 @@ grpc_error_handle grpc_chttp2_goaway_parser_parse(void* parser,
         memcpy(p->debug_data + p->debug_pos, cur,
                static_cast<size_t>(end - cur));
       }
-      CHECK((size_t)(end - cur) < UINT32_MAX - p->debug_pos);
+      ABSL_CHECK((size_t)(end - cur) < UINT32_MAX - p->debug_pos);
       p->debug_pos += static_cast<uint32_t>(end - cur);
       p->state = GRPC_CHTTP2_GOAWAY_DEBUG;
       if (is_last) {
@@ -155,7 +155,7 @@ void grpc_chttp2_goaway_append(uint32_t last_stream_id, uint32_t error_code,
   grpc_slice header = GRPC_SLICE_MALLOC(9 + 4 + 4);
   uint8_t* p = GRPC_SLICE_START_PTR(header);
   uint32_t frame_length;
-  CHECK(GRPC_SLICE_LENGTH(debug_data) < UINT32_MAX - 4 - 4);
+  ABSL_CHECK(GRPC_SLICE_LENGTH(debug_data) < UINT32_MAX - 4 - 4);
   frame_length = 4 + 4 + static_cast<uint32_t> GRPC_SLICE_LENGTH(debug_data);

   // frame header: length
@@ -181,7 +181,7 @@ void grpc_chttp2_goaway_append(uint32_t last_stream_id, uint32_t error_code,
   *p++ = static_cast<uint8_t>(error_code >> 16);
   *p++ = static_cast<uint8_t>(error_code >> 8);
   *p++ = static_cast<uint8_t>(error_code);
-  CHECK(p == GRPC_SLICE_END_PTR(header));
+  ABSL_CHECK(p == GRPC_SLICE_END_PTR(header));
   grpc_slice_buffer_add(slice_buffer, header);
   grpc_slice_buffer_add(slice_buffer, debug_data);
 }
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_ping.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_ping.cc
index 2db29ee7ef617..9f0514502f79d 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_ping.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_ping.cc
@@ -26,8 +26,8 @@
 #include <algorithm>

 #include "absl/container/flat_hash_map.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_format.h"
 #include "src/core/ext/transport/chttp2/transport/internal.h"
@@ -89,7 +89,7 @@ grpc_error_handle grpc_chttp2_ping_parser_parse(void* parser,
   }

   if (p->byte == 8) {
-    CHECK(is_last);
+    ABSL_CHECK(is_last);
     if (p->is_ack) {
       GRPC_TRACE_LOG(http2_ping, INFO)
           << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
@@ -101,7 +101,7 @@ grpc_error_handle grpc_chttp2_ping_parser_parse(void* parser,
             t->keepalive_permit_without_calls == 0 && t->stream_map.empty();
         if (GRPC_TRACE_FLAG_ENABLED(http_keepalive) ||
             GRPC_TRACE_FLAG_ENABLED(http)) {
-          LOG(INFO) << "SERVER[" << t << "]: received ping " << p->opaque_8bytes
+          ABSL_LOG(INFO) << "SERVER[" << t << "]: received ping " << p->opaque_8bytes
                     << ": "
                     << t->ping_abuse_policy.GetDebugString(transport_idle);
         }
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_rst_stream.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_rst_stream.cc
index 0378d6773c083..f5328b2d172c2 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_rst_stream.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_rst_stream.cc
@@ -22,8 +22,8 @@
 #include <grpc/support/port_platform.h>
 #include <stddef.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/random/distributions.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
@@ -107,7 +107,7 @@ grpc_error_handle grpc_chttp2_rst_stream_parser_parse(void* parser,
   s->call_tracer_wrapper.RecordIncomingBytes({framing_bytes, 0, 0});

   if (p->byte == 4) {
-    CHECK(is_last);
+    ABSL_CHECK(is_last);
     uint32_t reason = ((static_cast<uint32_t>(p->reason_bytes[0])) << 24) |
                       ((static_cast<uint32_t>(p->reason_bytes[1])) << 16) |
                       ((static_cast<uint32_t>(p->reason_bytes[2])) << 8) |
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_settings.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_settings.cc
index c8a7df69549f5..41888a7b66613 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_settings.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_settings.cc
@@ -25,7 +25,7 @@
 #include <string>

 #include "absl/base/attributes.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_format.h"
 #include "src/core/ext/transport/chttp2/transport/flow_control.h"
@@ -186,7 +186,7 @@ grpc_error_handle grpc_chttp2_settings_parser_parse(void* p,
               parser->incoming_settings->initial_window_size();
           if (GRPC_TRACE_FLAG_ENABLED(http) ||
               GRPC_TRACE_FLAG_ENABLED(flowctl)) {
-            LOG(INFO) << t << "[" << (t->is_client ? "cli" : "svr")
+            ABSL_LOG(INFO) << t << "[" << (t->is_client ? "cli" : "svr")
                       << "] adding " << t->initial_window_update
                       << " for initial_window change";
           }
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_window_update.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_window_update.cc
index 92ad73d90126c..d073d6a7ce09d 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_window_update.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/frame_window_update.cc
@@ -21,7 +21,7 @@
 #include <grpc/support/port_platform.h>
 #include <stddef.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
@@ -42,7 +42,7 @@ grpc_slice grpc_chttp2_window_update_create(
   }
   uint8_t* p = GRPC_SLICE_START_PTR(slice);

-  CHECK(window_delta);
+  ABSL_CHECK(window_delta);

   *p++ = 0;
   *p++ = 0;
@@ -99,7 +99,7 @@ grpc_error_handle grpc_chttp2_window_update_parser_parse(
       return GRPC_ERROR_CREATE(
           absl::StrCat("invalid window update bytes: ", p->amount));
     }
-    CHECK(is_last);
+    ABSL_CHECK(is_last);

     if (t->incoming_stream_id != 0) {
       if (s != nullptr) {
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder.cc
index cc17bba7597d9..0f086e78c8230 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder.cc
@@ -25,8 +25,8 @@
 #include <algorithm>
 #include <cstdint>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/ext/transport/chttp2/transport/bin_encoder.h"
 #include "src/core/ext/transport/chttp2/transport/hpack_constants.h"
 #include "src/core/ext/transport/chttp2/transport/hpack_encoder_table.h"
@@ -61,7 +61,7 @@ static void FillHeader(uint8_t* p, uint8_t type, uint32_t id, size_t len,
   // max_frame_size is derived from GRPC_CHTTP2_SETTINGS_MAX_FRAME_SIZE,
   // which has a max allowable value of 16777215 (see chttp_transport.cc).
   // Thus, the following assert can be a debug assert.
-  DCHECK_LE(len, 16777216u);
+  ABSL_DCHECK_LE(len, 16777216u);
   *p++ = static_cast<uint8_t>(len >> 16);
   *p++ = static_cast<uint8_t>(len >> 8);
   *p++ = static_cast<uint8_t>(len);
@@ -374,7 +374,7 @@ void Compressor<HttpSchemeMetadata, HttpSchemeCompressor>::EncodeWith(
       encoder->EmitIndexed(7);  // :scheme: https
       break;
     case HttpSchemeMetadata::ValueType::kInvalid:
-      LOG(ERROR) << "Not encoding bad http scheme";
+      ABSL_LOG(ERROR) << "Not encoding bad http scheme";
       encoder->NoteEncodingError();
       break;
   }
@@ -432,7 +432,7 @@ void Compressor<HttpMethodMetadata, HttpMethodCompressor>::EncodeWith(
           Slice::FromStaticString(":method"), Slice::FromStaticString("PUT"));
       break;
     case HttpMethodMetadata::ValueType::kInvalid:
-      LOG(ERROR) << "Not encoding bad http method";
+      ABSL_LOG(ERROR) << "Not encoding bad http method";
       encoder->NoteEncodingError();
       break;
   }
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder.h b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder.h
index 4fd5b1c08f409..133c4527624b0 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder.h
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder.h
@@ -27,7 +27,7 @@
 #include <utility>
 #include <vector>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/match.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
@@ -207,7 +207,7 @@ class Compressor<
   void EncodeWith(MetadataTrait, const typename MetadataTrait::ValueType& value,
                   Encoder* encoder) {
     if (value != known_value) {
-      LOG(ERROR) << "Not encoding bad " << MetadataTrait::key() << " header";
+      ABSL_LOG(ERROR) << "Not encoding bad " << MetadataTrait::key() << " header";
       encoder->NoteEncodingError();
       return;
     }
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder_table.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder_table.cc
index 2947587c7a641..98e44b1c2169c 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder_table.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_encoder_table.cc
@@ -18,15 +18,15 @@

 #include <algorithm>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 namespace grpc_core {

 uint32_t HPackEncoderTable::AllocateIndex(size_t element_size) {
-  DCHECK_GE(element_size, 32u);
+  ABSL_DCHECK_GE(element_size, 32u);

   uint32_t new_index = tail_remote_index_ + table_elems_ + 1;
-  DCHECK(element_size <= MaxEntrySize());
+  ABSL_DCHECK(element_size <= MaxEntrySize());

   if (element_size > max_table_size_) {
     while (table_size_ > 0) {
@@ -41,7 +41,7 @@ uint32_t HPackEncoderTable::AllocateIndex(size_t element_size) {
   while (table_size_ + element_size > max_table_size_) {
     EvictOne();
   }
-  CHECK(table_elems_ < elem_size_.size());
+  ABSL_CHECK(table_elems_ < elem_size_.size());
   elem_size_[new_index % elem_size_.size()] =
       static_cast<uint16_t>(element_size);
   table_size_ += element_size;
@@ -70,17 +70,17 @@ bool HPackEncoderTable::SetMaxSize(uint32_t max_table_size) {

 void HPackEncoderTable::EvictOne() {
   tail_remote_index_++;
-  CHECK_GT(tail_remote_index_, 0u);
-  CHECK_GT(table_elems_, 0u);
+  ABSL_CHECK_GT(tail_remote_index_, 0u);
+  ABSL_CHECK_GT(table_elems_, 0u);
   auto removing_size = elem_size_[tail_remote_index_ % elem_size_.size()];
-  CHECK(table_size_ >= removing_size);
+  ABSL_CHECK(table_size_ >= removing_size);
   table_size_ -= removing_size;
   table_elems_--;
 }

 void HPackEncoderTable::Rebuild(uint32_t capacity) {
   decltype(elem_size_) new_elem_size(capacity);
-  CHECK_LE(table_elems_, capacity);
+  ABSL_CHECK_LE(table_elems_, capacity);
   for (uint32_t i = 0; i < table_elems_; i++) {
     uint32_t ofs = tail_remote_index_ + i + 1;
     new_elem_size[ofs % capacity] = elem_size_[ofs % elem_size_.size()];
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parse_result.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parse_result.cc
index ffead9117a94f..4ad438a7da65e 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parse_result.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parse_result.cc
@@ -17,7 +17,7 @@
 #include <grpc/support/port_platform.h>
 #include <stddef.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_format.h"
 #include "src/core/ext/transport/chttp2/transport/hpack_constants.h"
 #include "src/core/lib/iomgr/error.h"
@@ -52,7 +52,7 @@ class MetadataSizeLimitExceededEncoder {
 };

 absl::Status MakeStreamError(absl::Status error) {
-  DCHECK(!error.ok());
+  ABSL_DCHECK(!error.ok());
   return grpc_error_set_int(std::move(error), StatusIntProperty::kStreamId, 0);
 }
 }  // namespace
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parse_result.h b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parse_result.h
index 583edbd85ce12..2c9bbf0e2b306 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parse_result.h
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parse_result.h
@@ -23,7 +23,7 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
@@ -191,7 +191,7 @@ class HpackParseResult {

   static HpackParseResult InvalidMetadataError(ValidateMetadataResult result,
                                                absl::string_view key) {
-    DCHECK(result != ValidateMetadataResult::kOk);
+    ABSL_DCHECK(result != ValidateMetadataResult::kOk);
     HpackParseResult p{HpackParseStatus::kInvalidMetadata};
     p.state_->key = std::string(key);
     p.state_->validate_metadata_result = result;
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parser.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parser.cc
index c6ae51074f6c8..f793e2119debf 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parser.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parser.cc
@@ -31,8 +31,8 @@
 #include <variant>

 #include "absl/base/attributes.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/match.h"
 #include "absl/strings/str_cat.h"
@@ -193,7 +193,7 @@ class HPackParser::Input {
   std::optional<StringPrefix> ParseStringPrefix() {
     auto cur = Next();
     if (!cur.has_value()) {
-      DCHECK(eof_error());
+      ABSL_DCHECK(eof_error());
       return {};
     }
     // Huffman if the top bit is 1
@@ -204,7 +204,7 @@ class HPackParser::Input {
       // all ones ==> varint string length
       auto v = ParseVarint(0x7f);
       if (!v.has_value()) {
-        DCHECK(eof_error());
+        ABSL_DCHECK(eof_error());
         return {};
       }
       strlen = *v;
@@ -231,7 +231,7 @@ class HPackParser::Input {
   // Intended for errors that are specific to a stream and recoverable.
   // Callers should ensure that any hpack table updates happen.
   void SetErrorAndContinueParsing(HpackParseResult error) {
-    DCHECK(error.stream_error());
+    ABSL_DCHECK(error.stream_error());
     SetError(std::move(error));
   }

@@ -239,7 +239,7 @@ class HPackParser::Input {
   // Intended for unrecoverable errors, with the expectation that they will
   // close the connection on return to chttp2.
   void SetErrorAndStopParsing(HpackParseResult error) {
-    DCHECK(error.connection_error());
+    ABSL_DCHECK(error.connection_error());
     SetError(std::move(error));
     begin_ = end_;
   }
@@ -248,17 +248,17 @@ class HPackParser::Input {
   // min_progress_size: how many bytes beyond the current frontier do we need to
   // read prior to being able to get further in this parse.
   void UnexpectedEOF(size_t min_progress_size) {
-    CHECK_GT(min_progress_size, 0u);
+    ABSL_CHECK_GT(min_progress_size, 0u);
     if (eof_error()) return;
     // Set min progress size, taking into account bytes parsed already but not
     // consumed.
     min_progress_size_ = min_progress_size + (begin_ - frontier_);
-    DCHECK(eof_error());
+    ABSL_DCHECK(eof_error());
   }

   // Update the frontier - signifies we've successfully parsed another element
   void UpdateFrontier() {
-    DCHECK_EQ(skip_bytes_, 0u);
+    ABSL_DCHECK_EQ(skip_bytes_, 0u);
     frontier_ = begin_;
   }

@@ -381,7 +381,7 @@ HPackParser::String::StringResult HPackParser::String::ParseUncompressed(
   // Check there's enough bytes
   if (input->remaining() < length) {
     input->UnexpectedEOF(/*min_progress_size=*/length);
-    DCHECK(input->eof_error());
+    ABSL_DCHECK(input->eof_error());
     return StringResult{HpackParseStatus::kEof, wire_size, String{}};
   }
   auto* refcount = input->slice_refcount();
@@ -601,7 +601,7 @@ class HPackParser::Parser {

  private:
   bool ParseTop() {
-    DCHECK(state_.parse_state == ParseState::kTop);
+    ABSL_DCHECK(state_.parse_state == ParseState::kTop);
     auto cur = *input_->Next();
     input_->ClearFieldError();
     switch (cur >> 4) {
@@ -708,7 +708,7 @@ class HPackParser::Parser {
         type = "???";
         break;
     }
-    LOG(INFO) << "HTTP:" << log_info_.stream_id << ":" << type << ":"
+    ABSL_LOG(INFO) << "HTTP:" << log_info_.stream_id << ":" << type << ":"
               << (log_info_.is_client ? "CLI" : "SVR") << ": "
               << memento.md.DebugString()
               << (memento.parse_status.get() == nullptr
@@ -773,7 +773,7 @@ class HPackParser::Parser {

   // Parse an index encoded key and a string encoded value
   bool StartIdxKey(uint32_t index, bool add_to_table) {
-    DCHECK(state_.parse_state == ParseState::kTop);
+    ABSL_DCHECK(state_.parse_state == ParseState::kTop);
     input_->UpdateFrontier();
     const auto* elem = state_.hpack_table.Lookup(index);
     if (GPR_UNLIKELY(elem == nullptr)) {
@@ -789,14 +789,14 @@ class HPackParser::Parser {

   // Parse a varint index encoded key and a string encoded value
   bool StartVarIdxKey(uint32_t offset, bool add_to_table) {
-    DCHECK(state_.parse_state == ParseState::kTop);
+    ABSL_DCHECK(state_.parse_state == ParseState::kTop);
     auto index = input_->ParseVarint(offset);
     if (GPR_UNLIKELY(!index.has_value())) return false;
     return StartIdxKey(*index, add_to_table);
   }

   bool StartParseLiteralKey(bool add_to_table) {
-    DCHECK(state_.parse_state == ParseState::kTop);
+    ABSL_DCHECK(state_.parse_state == ParseState::kTop);
     state_.add_to_table = add_to_table;
     state_.parse_state = ParseState::kParsingKeyLength;
     input_->UpdateFrontier();
@@ -831,7 +831,7 @@ class HPackParser::Parser {
   }

   bool ParseKeyLength() {
-    DCHECK(state_.parse_state == ParseState::kParsingKeyLength);
+    ABSL_DCHECK(state_.parse_state == ParseState::kParsingKeyLength);
     auto pfx = input_->ParseStringPrefix();
     if (!pfx.has_value()) return false;
     state_.is_string_huff_compressed = pfx->huff;
@@ -852,14 +852,14 @@ class HPackParser::Parser {
   }

   bool ParseKeyBody() {
-    DCHECK(state_.parse_state == ParseState::kParsingKeyBody);
+    ABSL_DCHECK(state_.parse_state == ParseState::kParsingKeyBody);
     auto key = String::Parse(input_, state_.is_string_huff_compressed,
                              state_.string_length);
     switch (key.status) {
       case HpackParseStatus::kOk:
         break;
       case HpackParseStatus::kEof:
-        DCHECK(input_->eof_error());
+        ABSL_DCHECK(input_->eof_error());
         return false;
       default:
         input_->SetErrorAndStopParsing(
@@ -899,7 +899,7 @@ class HPackParser::Parser {
   }

   bool SkipKeyBody() {
-    DCHECK(state_.parse_state == ParseState::kSkippingKeyBody);
+    ABSL_DCHECK(state_.parse_state == ParseState::kSkippingKeyBody);
     if (!SkipStringBody()) return false;
     input_->UpdateFrontier();
     state_.parse_state = ParseState::kSkippingValueLength;
@@ -907,7 +907,7 @@ class HPackParser::Parser {
   }

   bool SkipValueLength() {
-    DCHECK(state_.parse_state == ParseState::kSkippingValueLength);
+    ABSL_DCHECK(state_.parse_state == ParseState::kSkippingValueLength);
     auto pfx = input_->ParseStringPrefix();
     if (!pfx.has_value()) return false;
     state_.string_length = pfx->length;
@@ -917,7 +917,7 @@ class HPackParser::Parser {
   }

   bool SkipValueBody() {
-    DCHECK(state_.parse_state == ParseState::kSkippingValueBody);
+    ABSL_DCHECK(state_.parse_state == ParseState::kSkippingValueBody);
     if (!SkipStringBody()) return false;
     input_->UpdateFrontier();
     state_.parse_state = ParseState::kTop;
@@ -928,7 +928,7 @@ class HPackParser::Parser {
   }

   bool ParseValueLength() {
-    DCHECK(state_.parse_state == ParseState::kParsingValueLength);
+    ABSL_DCHECK(state_.parse_state == ParseState::kParsingValueLength);
     auto pfx = input_->ParseStringPrefix();
     if (!pfx.has_value()) return false;
     state_.is_string_huff_compressed = pfx->huff;
@@ -952,7 +952,7 @@ class HPackParser::Parser {
   }

   bool ParseValueBody() {
-    DCHECK(state_.parse_state == ParseState::kParsingValueBody);
+    ABSL_DCHECK(state_.parse_state == ParseState::kParsingValueBody);
     auto value =
         state_.is_binary_header
             ? String::ParseBinary(input_, state_.is_string_huff_compressed,
@@ -980,7 +980,7 @@ class HPackParser::Parser {
       case HpackParseStatus::kOk:
         break;
       case HpackParseStatus::kEof:
-        DCHECK(input_->eof_error());
+        ABSL_DCHECK(input_->eof_error());
         return false;
       default: {
         auto result =
@@ -1003,7 +1003,7 @@ class HPackParser::Parser {
           if (!state_.field_error.ok()) return;
           input_->SetErrorAndContinueParsing(
               HpackParseResult::MetadataParseError(key_string));
-          LOG(ERROR) << "Error parsing '" << key_string
+          ABSL_LOG(ERROR) << "Error parsing '" << key_string
                      << "' metadata: " << message;
         });
     HPackTable::Memento memento{
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parser_table.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parser_table.cc
index b258e6ead0975..a61ad9d03b071 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parser_table.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/hpack_parser_table.cc
@@ -26,8 +26,8 @@
 #include <cstring>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
@@ -40,7 +40,7 @@
 namespace grpc_core {

 void HPackTable::MementoRingBuffer::Put(Memento m) {
-  CHECK_LT(num_entries_, max_entries_);
+  ABSL_CHECK_LT(num_entries_, max_entries_);
   if (entries_.size() < max_entries_) {
     ++num_entries_;
     return entries_.push_back(std::move(m));
@@ -55,7 +55,7 @@ void HPackTable::MementoRingBuffer::Put(Memento m) {
 }

 auto HPackTable::MementoRingBuffer::PopOne() -> Memento {
-  CHECK_GT(num_entries_, 0u);
+  ABSL_CHECK_GT(num_entries_, 0u);
   size_t index = first_entry_ % max_entries_;
   if (index == timestamp_index_) {
     global_stats().IncrementHttp2HpackEntryLifetime(
@@ -120,7 +120,7 @@ HPackTable::MementoRingBuffer::~MementoRingBuffer() {
 // Evict one element from the table
 void HPackTable::EvictOne() {
   auto first_entry = entries_.PopOne();
-  CHECK(first_entry.md.transport_size() <= mem_used_);
+  ABSL_CHECK(first_entry.md.transport_size() <= mem_used_);
   mem_used_ -= first_entry.md.transport_size();
 }

diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/internal.h b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/internal.h
index fd1cf9ca1cd04..cdb7dd7082519 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/internal.h
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/internal.h
@@ -798,7 +798,7 @@ void grpc_chttp2_settings_timeout(
   (sizeof(GRPC_CHTTP2_CLIENT_CONNECT_STRING) - 1)

 #define GRPC_CHTTP2_IF_TRACING(severity) \
-  LOG_IF(severity, GRPC_TRACE_FLAG_ENABLED(http))
+  ABSL_LOG_IF(severity, GRPC_TRACE_FLAG_ENABLED(http))

 void grpc_chttp2_fake_status(grpc_chttp2_transport* t,
                              grpc_chttp2_stream* stream,
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/parsing.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/parsing.cc
index ccb9642e111d9..36295dd1bd3a4 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/parsing.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/parsing.cc
@@ -33,8 +33,8 @@

 #include "absl/base/attributes.h"
 #include "absl/container/flat_hash_map.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/random/bit_gen_ref.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
@@ -270,7 +270,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
       }
       [[fallthrough]];
     case GRPC_DTS_FH_0:
-      DCHECK_LT(cur, end);
+      ABSL_DCHECK_LT(cur, end);
       t->incoming_frame_size = (static_cast<uint32_t>(*cur)) << 16;
       if (++cur == end) {
         t->deframe_state = GRPC_DTS_FH_1;
@@ -278,7 +278,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
       }
       [[fallthrough]];
     case GRPC_DTS_FH_1:
-      DCHECK_LT(cur, end);
+      ABSL_DCHECK_LT(cur, end);
       t->incoming_frame_size |= (static_cast<uint32_t>(*cur)) << 8;
       if (++cur == end) {
         t->deframe_state = GRPC_DTS_FH_2;
@@ -286,7 +286,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
       }
       [[fallthrough]];
     case GRPC_DTS_FH_2:
-      DCHECK_LT(cur, end);
+      ABSL_DCHECK_LT(cur, end);
       t->incoming_frame_size |= *cur;
       if (++cur == end) {
         t->deframe_state = GRPC_DTS_FH_3;
@@ -294,7 +294,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
       }
       [[fallthrough]];
     case GRPC_DTS_FH_3:
-      DCHECK_LT(cur, end);
+      ABSL_DCHECK_LT(cur, end);
       t->incoming_frame_type = *cur;
       if (++cur == end) {
         t->deframe_state = GRPC_DTS_FH_4;
@@ -302,7 +302,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
       }
       [[fallthrough]];
     case GRPC_DTS_FH_4:
-      DCHECK_LT(cur, end);
+      ABSL_DCHECK_LT(cur, end);
       t->incoming_frame_flags = *cur;
       if (++cur == end) {
         t->deframe_state = GRPC_DTS_FH_5;
@@ -310,7 +310,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
       }
       [[fallthrough]];
     case GRPC_DTS_FH_5:
-      DCHECK_LT(cur, end);
+      ABSL_DCHECK_LT(cur, end);
       t->incoming_stream_id = ((static_cast<uint32_t>(*cur)) & 0x7f) << 24;
       if (++cur == end) {
         t->deframe_state = GRPC_DTS_FH_6;
@@ -318,7 +318,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
       }
       [[fallthrough]];
     case GRPC_DTS_FH_6:
-      DCHECK_LT(cur, end);
+      ABSL_DCHECK_LT(cur, end);
       t->incoming_stream_id |= (static_cast<uint32_t>(*cur)) << 16;
       if (++cur == end) {
         t->deframe_state = GRPC_DTS_FH_7;
@@ -326,7 +326,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
       }
       [[fallthrough]];
     case GRPC_DTS_FH_7:
-      DCHECK_LT(cur, end);
+      ABSL_DCHECK_LT(cur, end);
       t->incoming_stream_id |= (static_cast<uint32_t>(*cur)) << 8;
       if (++cur == end) {
         t->deframe_state = GRPC_DTS_FH_8;
@@ -334,7 +334,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
       }
       [[fallthrough]];
     case GRPC_DTS_FH_8:
-      DCHECK_LT(cur, end);
+      ABSL_DCHECK_LT(cur, end);
       t->incoming_stream_id |= (static_cast<uint32_t>(*cur));
       GRPC_TRACE_LOG(http, INFO)
           << "INCOMING[" << t << "]: "
@@ -368,7 +368,7 @@ std::variant<size_t, absl::Status> grpc_chttp2_perform_read(
       }
       [[fallthrough]];
     case GRPC_DTS_FRAME:
-      DCHECK_LT(cur, end);
+      ABSL_DCHECK_LT(cur, end);
       if (static_cast<uint32_t>(end - cur) == t->incoming_frame_size) {
         err = parse_frame_slice(
             t,
@@ -458,7 +458,7 @@ static grpc_error_handle init_frame_parser(grpc_chttp2_transport* t,
     case GRPC_CHTTP2_FRAME_SECURITY:
       if (!t->settings.peer().allow_security_frame()) {
         if (GRPC_TRACE_FLAG_ENABLED(http)) {
-          LOG(ERROR) << "Security frame received but not allowed, ignoring";
+          ABSL_LOG(ERROR) << "Security frame received but not allowed, ignoring";
         }
         return init_non_header_skip_frame_parser(t);
       }
@@ -734,7 +734,7 @@ static grpc_error_handle init_header_frame_parser(grpc_chttp2_transport* t,
     }
     if (GRPC_TRACE_FLAG_ENABLED(http) ||
         GRPC_TRACE_FLAG_ENABLED(chttp2_new_stream)) {
-      LOG(INFO) << "[t:" << t << " fd:" << grpc_endpoint_get_fd(t->ep.get())
+      ABSL_LOG(INFO) << "[t:" << t << " fd:" << grpc_endpoint_get_fd(t->ep.get())
                 << " peer:" << t->peer_string.as_string_view()
                 << "] Accepting new stream; "
                    "num_incoming_streams_before_settings_ack="
@@ -746,7 +746,7 @@ static grpc_error_handle init_header_frame_parser(grpc_chttp2_transport* t,
   } else {
     t->incoming_stream = s;
   }
-  DCHECK_NE(s, nullptr);
+  ABSL_DCHECK_NE(s, nullptr);
   s->call_tracer_wrapper.RecordIncomingBytes({9, 0, 0});
   if (GPR_UNLIKELY(s->read_closed)) {
     GRPC_CHTTP2_IF_TRACING(ERROR)
@@ -785,7 +785,7 @@ static grpc_error_handle init_header_frame_parser(grpc_chttp2_transport* t,
       frame_type = HPackParser::LogInfo::kTrailers;
       break;
     case 2:
-      LOG(ERROR) << "too many header frames received";
+      ABSL_LOG(ERROR) << "too many header frames received";
       return init_header_skip_frame_parser(t, priority_type, is_eoh);
   }
   if (frame_type == HPackParser::LogInfo::kTrailers && !t->header_eof) {
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/ping_callbacks.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/ping_callbacks.cc
index 90d78a11e4a4f..b2f3e7027c2c8 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/ping_callbacks.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/ping_callbacks.cc
@@ -18,7 +18,7 @@

 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/meta/type_traits.h"
 #include "absl/random/distributions.h"

@@ -93,7 +93,7 @@ std::optional<uint64_t> Chttp2PingCallbacks::OnPingTimeout(
     Duration ping_timeout,
     grpc_event_engine::experimental::EventEngine* event_engine,
     Callback callback) {
-  CHECK(started_new_ping_without_setting_timeout_);
+  ABSL_CHECK(started_new_ping_without_setting_timeout_);
   started_new_ping_without_setting_timeout_ = false;
   auto it = inflight_.find(most_recent_inflight_);
   if (it == inflight_.end()) return std::nullopt;
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/stream_lists.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/stream_lists.cc
index 4ff249fa870bf..72c13d476208c 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/stream_lists.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/stream_lists.cc
@@ -20,8 +20,8 @@

 #include <grpc/support/port_platform.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/ext/transport/chttp2/transport/internal.h"
 #include "src/core/ext/transport/chttp2/transport/legacy_frame.h"
 #include "src/core/lib/debug/trace.h"
@@ -59,7 +59,7 @@ static bool stream_list_pop(grpc_chttp2_transport* t,
   grpc_chttp2_stream* s = t->lists[id].head;
   if (s) {
     grpc_chttp2_stream* new_head = s->links[id].next;
-    CHECK(s->included.is_set(id));
+    ABSL_CHECK(s->included.is_set(id));
     if (new_head) {
       t->lists[id].head = new_head;
       new_head->links[id].prev = nullptr;
@@ -71,7 +71,7 @@ static bool stream_list_pop(grpc_chttp2_transport* t,
   }
   *stream = s;
   if (s && GRPC_TRACE_FLAG_ENABLED(http2_stream_state)) {
-    LOG(INFO) << t << "[" << s->id << "][" << (t->is_client ? "cli" : "svr")
+    ABSL_LOG(INFO) << t << "[" << s->id << "][" << (t->is_client ? "cli" : "svr")
               << "]: pop from " << stream_list_id_string(id);
   }
   return s != nullptr;
@@ -79,12 +79,12 @@ static bool stream_list_pop(grpc_chttp2_transport* t,

 static void stream_list_remove(grpc_chttp2_transport* t, grpc_chttp2_stream* s,
                                grpc_chttp2_stream_list_id id) {
-  CHECK(s->included.is_set(id));
+  ABSL_CHECK(s->included.is_set(id));
   s->included.clear(id);
   if (s->links[id].prev) {
     s->links[id].prev->links[id].next = s->links[id].next;
   } else {
-    CHECK(t->lists[id].head == s);
+    ABSL_CHECK(t->lists[id].head == s);
     t->lists[id].head = s->links[id].next;
   }
   if (s->links[id].next) {
@@ -112,7 +112,7 @@ static void stream_list_add_tail(grpc_chttp2_transport* t,
                                  grpc_chttp2_stream* s,
                                  grpc_chttp2_stream_list_id id) {
   grpc_chttp2_stream* old_tail;
-  CHECK(!s->included.is_set(id));
+  ABSL_CHECK(!s->included.is_set(id));
   old_tail = t->lists[id].tail;
   s->links[id].next = nullptr;
   s->links[id].prev = old_tail;
@@ -132,7 +132,7 @@ static void stream_list_add_head(grpc_chttp2_transport* t,
                                  grpc_chttp2_stream* s,
                                  grpc_chttp2_stream_list_id id) {
   grpc_chttp2_stream* old_head;
-  CHECK(!s->included.is_set(id));
+  ABSL_CHECK(!s->included.is_set(id));
   old_head = t->lists[id].head;
   s->links[id].next = old_head;
   s->links[id].prev = nullptr;
@@ -170,7 +170,7 @@ static bool stream_list_prepend(grpc_chttp2_transport* t, grpc_chttp2_stream* s,

 bool grpc_chttp2_list_add_writable_stream(grpc_chttp2_transport* t,
                                           grpc_chttp2_stream* s) {
-  CHECK_NE(s->id, 0u);
+  ABSL_CHECK_NE(s->id, 0u);
   if (grpc_core::IsPrioritizeFinishedRequestsEnabled() &&
       s->send_trailing_metadata != nullptr) {
     return stream_list_prepend(t, s, GRPC_CHTTP2_LIST_WRITABLE);
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/varint.h b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/varint.h
index e84f1b6ee2105..02c8a85d14ea8 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/varint.h
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/varint.h
@@ -23,7 +23,7 @@
 #include <stdint.h>
 #include <stdlib.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 // Helpers for hpack varint encoding

@@ -49,7 +49,7 @@ class VarintWriter {
   explicit VarintWriter(size_t value)
       : value_(value),
         length_(value < kMaxInPrefix ? 1 : VarintLength(value - kMaxInPrefix)) {
-    CHECK(value <= UINT32_MAX);
+    ABSL_CHECK(value <= UINT32_MAX);
   }

   size_t value() const { return value_; }
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/write_size_policy.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/write_size_policy.cc
index b843205de7017..85049a0385a6a 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/write_size_policy.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/write_size_policy.cc
@@ -18,14 +18,14 @@

 #include <algorithm>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 namespace grpc_core {

 size_t Chttp2WriteSizePolicy::WriteTargetSize() { return current_target_; }

 void Chttp2WriteSizePolicy::BeginWrite(size_t size) {
-  CHECK(experiment_start_time_ == Timestamp::InfFuture());
+  ABSL_CHECK(experiment_start_time_ == Timestamp::InfFuture());
   if (size < current_target_ * 7 / 10) {
     // If we were trending fast but stopped getting enough data to verify, then
     // reset back to the default state.
diff --git a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/writing.cc b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/writing.cc
index f4b551d7b00fb..a7cf58f9c3d44 100644
--- a/third_party/grpc/source/src/core/ext/transport/chttp2/transport/writing.cc
+++ b/third_party/grpc/source/src/core/ext/transport/chttp2/transport/writing.cc
@@ -31,8 +31,8 @@
 #include <utility>

 #include "absl/container/flat_hash_map.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "src/core/channelz/channelz.h"
 #include "src/core/ext/transport/chttp2/transport/call_tracer_wrapper.h"
@@ -135,7 +135,7 @@ static void maybe_initiate_ping(grpc_chttp2_transport* t) {
             GRPC_TRACE_FLAG_ENABLED(bdp_estimator) ||
             GRPC_TRACE_FLAG_ENABLED(http_keepalive) ||
             GRPC_TRACE_FLAG_ENABLED(http2_ping)) {
-          LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
+          ABSL_LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
                     << "]: Ping " << id << " sent ["
                     << std::string(t->peer_string.as_string_view())
                     << "]: " << t->ping_rate_policy.GetDebugString();
@@ -147,7 +147,7 @@ static void maybe_initiate_ping(grpc_chttp2_transport* t) {
             GRPC_TRACE_FLAG_ENABLED(bdp_estimator) ||
             GRPC_TRACE_FLAG_ENABLED(http_keepalive) ||
             GRPC_TRACE_FLAG_ENABLED(http2_ping)) {
-          LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
+          ABSL_LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
                     << "]: Ping delayed ["
                     << std::string(t->peer_string.as_string_view())
                     << "]: too many recent pings: "
@@ -160,7 +160,7 @@ static void maybe_initiate_ping(grpc_chttp2_transport* t) {
             GRPC_TRACE_FLAG_ENABLED(bdp_estimator) ||
             GRPC_TRACE_FLAG_ENABLED(http_keepalive) ||
             GRPC_TRACE_FLAG_ENABLED(http2_ping)) {
-          LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
+          ABSL_LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
                     << "]: Ping delayed ["
                     << std::string(t->peer_string.as_string_view())
                     << "]: not enough time elapsed since last "
@@ -261,7 +261,7 @@ class WriteContext {
       grpc_core::Http2Frame frame(std::move(*update));
       Serialize(absl::Span<grpc_core::Http2Frame>(&frame, 1), t_->outbuf);
       if (t_->keepalive_timeout != grpc_core::Duration::Infinity()) {
-        CHECK(
+        ABSL_CHECK(
             t_->settings_ack_watchdog ==
             grpc_event_engine::experimental::EventEngine::TaskHandle::kInvalid);
         // We base settings timeout on keepalive timeout, but double it to allow
@@ -282,7 +282,7 @@ class WriteContext {
     // simple writes are queued to qbuf, and flushed here
     grpc_slice_buffer_move_into(&t_->qbuf, t_->outbuf.c_slice_buffer());
     t_->num_pending_induced_frames = 0;
-    CHECK_EQ(t_->qbuf.count, 0u);
+    ABSL_CHECK_EQ(t_->qbuf.count, 0u);
   }

   void FlushWindowUpdates() {
@@ -755,7 +755,7 @@ void grpc_chttp2_end_write(grpc_chttp2_transport* t, grpc_error_handle error) {
           grpc_chttp2_ping_timeout(t);
         });
     if (GRPC_TRACE_FLAG_ENABLED(http2_ping) && id.has_value()) {
-      LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
+      ABSL_LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
                 << "]: Set ping timeout timer of " << timeout.ToString()
                 << " for ping id " << id.value();
     }
@@ -767,7 +767,7 @@ void grpc_chttp2_end_write(grpc_chttp2_transport* t, grpc_error_handle error) {
                 kInvalid) {
       if (GRPC_TRACE_FLAG_ENABLED(http2_ping) ||
           GRPC_TRACE_FLAG_ENABLED(http_keepalive)) {
-        LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
+        ABSL_LOG(INFO) << (t->is_client ? "CLIENT" : "SERVER") << "[" << t
                   << "]: Set keepalive ping timeout timer of "
                   << t->keepalive_timeout.ToString();
       }
diff --git a/third_party/grpc/source/src/core/ext/transport/cronet/client/secure/cronet_channel_create.cc b/third_party/grpc/source/src/core/ext/transport/cronet/client/secure/cronet_channel_create.cc
index ff036c2795527..9ec3d7be5c411 100644
--- a/third_party/grpc/source/src/core/ext/transport/cronet/client/secure/cronet_channel_create.cc
+++ b/third_party/grpc/source/src/core/ext/transport/cronet/client/secure/cronet_channel_create.cc
@@ -21,7 +21,7 @@
 #include <grpc/impl/channel_arg_names.h>
 #include <grpc/support/port_platform.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/statusor.h"
 #include "src/core/config/core_configuration.h"
 #include "src/core/ext/transport/cronet/transport/cronet_transport.h"
@@ -37,7 +37,7 @@
 GRPCAPI grpc_channel* grpc_cronet_secure_channel_create(
     void* engine, const char* target, const grpc_channel_args* args,
     void* reserved) {
-  VLOG(2) << "grpc_create_cronet_transport: stream_engine = " << engine
+  ABSL_VLOG(2) << "grpc_create_cronet_transport: stream_engine = " << engine
           << ", target=" << target;

   // Disable client authority filter when using Cronet
diff --git a/third_party/grpc/source/src/core/ext/transport/cronet/transport/cronet_api_phony.cc b/third_party/grpc/source/src/core/ext/transport/cronet/transport/cronet_api_phony.cc
index 25b80945e5b17..d921f92d504d8 100644
--- a/third_party/grpc/source/src/core/ext/transport/cronet/transport/cronet_api_phony.cc
+++ b/third_party/grpc/source/src/core/ext/transport/cronet/transport/cronet_api_phony.cc
@@ -21,7 +21,7 @@

 #include <grpc/support/port_platform.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "third_party/objective_c/Cronet/bidirectional_stream_c.h"

 #ifdef GRPC_COMPILE_WITH_CRONET
@@ -31,12 +31,12 @@
 bidirectional_stream* bidirectional_stream_create(
     stream_engine* /*engine*/, void* /*annotation*/,
     bidirectional_stream_callback* /*callback*/) {
-  CHECK(0);
+  ABSL_CHECK(0);
   return nullptr;
 }

 int bidirectional_stream_destroy(bidirectional_stream* /*stream*/) {
-  CHECK(0);
+  ABSL_CHECK(0);
   return 0;
 }

@@ -45,35 +45,35 @@ int bidirectional_stream_start(
     const char* /*method*/,
     const bidirectional_stream_header_array* /*headers*/,
     bool /*end_of_stream*/) {
-  CHECK(0);
+  ABSL_CHECK(0);
   return 0;
 }

 int bidirectional_stream_read(bidirectional_stream* /*stream*/,
                               char* /*buffer*/, int /*capacity*/) {
-  CHECK(0);
+  ABSL_CHECK(0);
   return 0;
 }

 int bidirectional_stream_write(bidirectional_stream* /*stream*/,
                                const char* /*buffer*/, int /*count*/,
                                bool /*end_of_stream*/) {
-  CHECK(0);
+  ABSL_CHECK(0);
   return 0;
 }

-void bidirectional_stream_cancel(bidirectional_stream* /*stream*/) { CHECK(0); }
+void bidirectional_stream_cancel(bidirectional_stream* /*stream*/) { ABSL_CHECK(0); }

 void bidirectional_stream_disable_auto_flush(bidirectional_stream* /*stream*/,
                                              bool /*disable_auto_flush*/) {
-  CHECK(0);
+  ABSL_CHECK(0);
 }

 void bidirectional_stream_delay_request_headers_until_flush(
     bidirectional_stream* /*stream*/, bool /*delay_headers_until_flush*/) {
-  CHECK(0);
+  ABSL_CHECK(0);
 }

-void bidirectional_stream_flush(bidirectional_stream* /*stream*/) { CHECK(0); }
+void bidirectional_stream_flush(bidirectional_stream* /*stream*/) { ABSL_CHECK(0); }

 #endif  // GRPC_COMPILE_WITH_CRONET
diff --git a/third_party/grpc/source/src/core/ext/transport/cronet/transport/cronet_transport.cc b/third_party/grpc/source/src/core/ext/transport/cronet/transport/cronet_transport.cc
index cf4d67e3cea14..12cc5fd05f9e1 100644
--- a/third_party/grpc/source/src/core/ext/transport/cronet/transport/cronet_transport.cc
+++ b/third_party/grpc/source/src/core/ext/transport/cronet/transport/cronet_transport.cc
@@ -33,8 +33,8 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/match.h"
 #include "absl/strings/str_cat.h"
@@ -407,7 +407,7 @@ static void execute_from_storage(stream_obj* s) {
   for (struct op_and_state* curr = s->storage.head; curr != nullptr;) {
     GRPC_TRACE_VLOG(cronet, 2)
         << "calling op at " << curr << ". done = " << curr->done;
-    CHECK(!curr->done);
+    ABSL_CHECK(!curr->done);
     enum e_op_result result = execute_stream_op(curr);
     GRPC_TRACE_VLOG(cronet, 2) << "execute_stream_op[" << curr << "] returns "
                                << op_result_string(result);
@@ -442,7 +442,7 @@ static void convert_cronet_array_to_metadata(
     }
     mds->Append(header_array->headers[i].key, grpc_core::Slice(value),
                 [&](absl::string_view error, const grpc_core::Slice& value) {
-                  VLOG(2) << "Failed to parse metadata: key="
+                  ABSL_VLOG(2) << "Failed to parse metadata: key="
                           << header_array->headers[i].key << " error=" << error
                           << " value=" << value.as_string_view();
                 });
@@ -453,7 +453,7 @@ static void convert_cronet_array_to_metadata(
 // Cronet callback
 //
 static void on_failed(bidirectional_stream* stream, int net_error) {
-  LOG(ERROR) << "on_failed(" << stream << ", " << net_error << ")";
+  ABSL_LOG(ERROR) << "on_failed(" << stream << ", " << net_error << ")";
   grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;
   grpc_core::ExecCtx exec_ctx;

@@ -587,7 +587,7 @@ static void on_response_headers_received(
         s->state.state_callback_received[OP_FAILED])) {
     // Do an extra read to trigger on_succeeded() callback in case connection
     // is closed
-    CHECK(s->state.rs.length_field_received == false);
+    ABSL_CHECK(s->state.rs.length_field_received == false);
     read_grpc_header(s);
   }
   gpr_mu_unlock(&s->mu);
@@ -793,7 +793,7 @@ class CronetMetadataEncoder {
       value = grpc_slice_to_c_string(value_slice.c_slice());
     }
     GRPC_TRACE_VLOG(cronet, 2) << "header " << key << " = " << value;
-    CHECK_LT(count_, capacity_);
+    ABSL_CHECK_LT(count_, capacity_);
     headers_[count_].key = key;
     headers_[count_].value = value;
     ++count_;
@@ -1052,8 +1052,8 @@ static enum e_op_result execute_stream_op_send_initial_metadata(
       << "running: " << oas << " OP_SEND_INITIAL_METADATA";
   // Start new cronet stream. It is destroyed in on_succeeded, on_canceled,
   // on_failed
-  CHECK_EQ(s->cbs, nullptr);
-  CHECK(!stream_state->state_op_done[OP_SEND_INITIAL_METADATA]);
+  ABSL_CHECK_EQ(s->cbs, nullptr);
+  ABSL_CHECK(!stream_state->state_op_done[OP_SEND_INITIAL_METADATA]);
   s->cbs =
       bidirectional_stream_create(t->engine, s->curr_gs, &cronet_callbacks);
   GRPC_TRACE_VLOG(cronet, 2) << s->cbs << " = bidirectional_stream_create()";
@@ -1257,7 +1257,7 @@ static enum e_op_result execute_stream_op_recv_message(
       if (stream_state->rs.length_field > 0) {
         stream_state->rs.read_buffer = static_cast<char*>(
             gpr_malloc(static_cast<size_t>(stream_state->rs.length_field)));
-        CHECK(stream_state->rs.read_buffer);
+        ABSL_CHECK(stream_state->rs.read_buffer);
         stream_state->rs.remaining_bytes = stream_state->rs.length_field;
         stream_state->rs.received_bytes = 0;
         GRPC_TRACE_VLOG(cronet, 2)
@@ -1574,7 +1574,7 @@ grpc_core::Transport* grpc_create_cronet_transport(
       if (0 ==
           strcmp(args->args[i].key, GRPC_ARG_USE_CRONET_PACKET_COALESCING)) {
         if (GPR_UNLIKELY(args->args[i].type != GRPC_ARG_INTEGER)) {
-          LOG(ERROR) << GRPC_ARG_USE_CRONET_PACKET_COALESCING
+          ABSL_LOG(ERROR) << GRPC_ARG_USE_CRONET_PACKET_COALESCING
                      << " ignored: it must be an integer";
         } else {
           ct->use_packet_coalescing = (args->args[i].value.integer != 0);
diff --git a/third_party/grpc/source/src/core/ext/transport/inproc/inproc_transport.cc b/third_party/grpc/source/src/core/ext/transport/inproc/inproc_transport.cc
index ef0cd9bc1a8eb..9d5494d8f905e 100644
--- a/third_party/grpc/source/src/core/ext/transport/inproc/inproc_transport.cc
+++ b/third_party/grpc/source/src/core/ext/transport/inproc/inproc_transport.cc
@@ -20,8 +20,8 @@
 #include <atomic>
 #include <memory>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "src/core/config/core_configuration.h"
 #include "src/core/ext/transport/inproc/legacy_inproc_transport.h"
@@ -239,7 +239,7 @@ InprocServerTransport::MakeClientTransport() {

 RefCountedPtr<Channel> MakeLameChannel(absl::string_view why,
                                        absl::Status error) {
-  LOG(ERROR) << why << ": " << error.message();
+  ABSL_LOG(ERROR) << why << ": " << error.message();
   intptr_t integer;
   grpc_status_code status = GRPC_STATUS_INTERNAL;
   if (grpc_error_get_int(error, StatusIntProperty::kRpcStatus, &integer)) {
diff --git a/third_party/grpc/source/src/core/ext/transport/inproc/legacy_inproc_transport.cc b/third_party/grpc/source/src/core/ext/transport/inproc/legacy_inproc_transport.cc
index 9abf6b75a082d..7ede595c46304 100644
--- a/third_party/grpc/source/src/core/ext/transport/inproc/legacy_inproc_transport.cc
+++ b/third_party/grpc/source/src/core/ext/transport/inproc/legacy_inproc_transport.cc
@@ -35,8 +35,8 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -314,7 +314,7 @@ void log_metadata(const grpc_metadata_batch* md_batch, bool is_client,
   std::string prefix = absl::StrCat(
       "INPROC:", is_initial ? "HDR:" : "TRL:", is_client ? "CLI:" : "SVR:");
   md_batch->Log([&prefix](absl::string_view key, absl::string_view value) {
-    LOG(INFO) << absl::StrCat(prefix, key, ": ", value);
+    ABSL_LOG(INFO) << absl::StrCat(prefix, key, ": ", value);
   });
 }

@@ -1271,8 +1271,8 @@ grpc_channel* grpc_legacy_inproc_channel_create(grpc_server* server,
     auto new_channel = grpc_core::ChannelCreate(
         "inproc", client_args, GRPC_CLIENT_DIRECT_CHANNEL, client_transport);
     if (!new_channel.ok()) {
-      CHECK(!channel);
-      LOG(ERROR) << "Failed to create client channel: "
+      ABSL_CHECK(!channel);
+      ABSL_LOG(ERROR) << "Failed to create client channel: "
                  << grpc_core::StatusToString(error);
       intptr_t integer;
       grpc_status_code status = GRPC_STATUS_INTERNAL;
@@ -1289,8 +1289,8 @@ grpc_channel* grpc_legacy_inproc_channel_create(grpc_server* server,
       channel = new_channel->release()->c_ptr();
     }
   } else {
-    CHECK(!channel);
-    LOG(ERROR) << "Failed to create server channel: "
+    ABSL_CHECK(!channel);
+    ABSL_LOG(ERROR) << "Failed to create server channel: "
                << grpc_core::StatusToString(error);
     intptr_t integer;
     grpc_status_code status = GRPC_STATUS_INTERNAL;
diff --git a/third_party/grpc/source/src/core/handshaker/handshaker.cc b/third_party/grpc/source/src/core/handshaker/handshaker.cc
index 241d656da802e..6cc90d1dc1e33 100644
--- a/third_party/grpc/source/src/core/handshaker/handshaker.cc
+++ b/third_party/grpc/source/src/core/handshaker/handshaker.cc
@@ -29,8 +29,8 @@
 #include <utility>

 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_format.h"
@@ -96,7 +96,7 @@ void HandshakeManager::DoHandshake(
   // last ref to this object.
   auto self = Ref();
   MutexLock lock(&mu_);
-  CHECK_EQ(index_, 0u);
+  ABSL_CHECK_EQ(index_, 0u);
   on_handshake_done_ = std::move(on_handshake_done);
   // Construct handshaker args.  These will be passed through all
   // handshakers and eventually be freed by the on_handshake_done callback.
@@ -153,7 +153,7 @@ void HandshakeManager::CallNextHandshakerLocked(absl::Status error) {
       << "handshake_manager " << this << ": error=" << error
       << " shutdown=" << is_shutdown_ << " index=" << index_
       << ", args=" << HandshakerArgsString(&args_);
-  CHECK(index_ <= handshakers_.size());
+  ABSL_CHECK(index_ <= handshakers_.size());
   // If we got an error or we've been shut down or we're exiting early or
   // we've finished the last handshaker, invoke the on_handshake_done
   // callback.
diff --git a/third_party/grpc/source/src/core/handshaker/http_connect/http_connect_handshaker.cc b/third_party/grpc/source/src/core/handshaker/http_connect/http_connect_handshaker.cc
index 1490215b79fd4..b8b419a0d3719 100644
--- a/third_party/grpc/source/src/core/handshaker/http_connect/http_connect_handshaker.cc
+++ b/third_party/grpc/source/src/core/handshaker/http_connect/http_connect_handshaker.cc
@@ -31,7 +31,7 @@
 #include <utility>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
@@ -111,7 +111,7 @@ void HttpConnectHandshaker::HandshakeFailedLocked(absl::Status error) {
   if (args_ != nullptr && args_->endpoint != nullptr) {
     peer_string = grpc_endpoint_get_peer(args_->endpoint.get());
   }
-  LOG_EVERY_N_SEC(ERROR, 60)
+  ABSL_LOG_EVERY_N_SEC(ERROR, 60)
       << "HTTP proxy handshake with " << peer_string << " failed: " << error;
   // Invoke callback.
   FinishLocked(std::move(error));
@@ -282,7 +282,7 @@ void HttpConnectHandshaker::DoHandshake(
     for (size_t i = 0; i < num_header_strings; ++i) {
       char* sep = strchr(header_strings[i], ':');
       if (sep == nullptr) {
-        LOG(ERROR) << "skipping unparsable HTTP CONNECT header: "
+        ABSL_LOG(ERROR) << "skipping unparsable HTTP CONNECT header: "
                    << header_strings[i];
         continue;
       }
@@ -299,7 +299,7 @@ void HttpConnectHandshaker::DoHandshake(
   // Log connection via proxy.
   std::string proxy_name(grpc_endpoint_get_peer(args->endpoint.get()));
   std::string server_name_string(*server_name);
-  VLOG(2) << "Connecting to server " << server_name_string << " via HTTP proxy "
+  ABSL_VLOG(2) << "Connecting to server " << server_name_string << " via HTTP proxy "
           << proxy_name;
   // Construct HTTP CONNECT request.
   grpc_http_request request;
diff --git a/third_party/grpc/source/src/core/handshaker/http_connect/http_proxy_mapper.cc b/third_party/grpc/source/src/core/handshaker/http_connect/http_proxy_mapper.cc
index 52d9445513a39..d9160976062c5 100644
--- a/third_party/grpc/source/src/core/handshaker/http_connect/http_proxy_mapper.cc
+++ b/third_party/grpc/source/src/core/handshaker/http_connect/http_proxy_mapper.cc
@@ -29,8 +29,8 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/ascii.h"
@@ -105,7 +105,7 @@ bool AddressIncluded(const std::optional<grpc_resolved_address>& target_address,
 ///
 std::optional<std::string> GetHttpProxyServer(
     const ChannelArgs& args, std::optional<std::string>* user_cred) {
-  CHECK_NE(user_cred, nullptr);
+  ABSL_CHECK_NE(user_cred, nullptr);
   absl::StatusOr<URI> uri;
   // We check the following places to determine the HTTP proxy to use, stopping
   // at the first one that is set:
@@ -124,12 +124,12 @@ std::optional<std::string> GetHttpProxyServer(
   if (uri_str->empty()) return std::nullopt;
   uri = URI::Parse(*uri_str);
   if (!uri.ok() || uri->authority().empty()) {
-    LOG(ERROR) << "cannot parse value of 'http_proxy' env var. Error: "
+    ABSL_LOG(ERROR) << "cannot parse value of 'http_proxy' env var. Error: "
                << uri.status();
     return std::nullopt;
   }
   if (uri->scheme() != "http") {
-    LOG(ERROR) << "'" << uri->scheme() << "' scheme not supported in proxy URI";
+    ABSL_LOG(ERROR) << "'" << uri->scheme() << "' scheme not supported in proxy URI";
     return std::nullopt;
   }
   // Split on '@' to separate user credentials from host
@@ -137,7 +137,7 @@ std::optional<std::string> GetHttpProxyServer(
   size_t authority_nstrs;
   gpr_string_split(uri->authority().c_str(), "@", &authority_strs,
                    &authority_nstrs);
-  CHECK_NE(authority_nstrs, 0u);  // should have at least 1 string
+  ABSL_CHECK_NE(authority_nstrs, 0u);  // should have at least 1 string
   std::optional<std::string> proxy_name;
   if (authority_nstrs == 1) {
     // User cred not present in authority
@@ -146,7 +146,7 @@ std::optional<std::string> GetHttpProxyServer(
     // User cred found
     *user_cred = authority_strs[0];
     proxy_name = authority_strs[1];
-    VLOG(2) << "userinfo found in proxy URI";
+    ABSL_VLOG(2) << "userinfo found in proxy URI";
   } else {
     // Bad authority
     proxy_name = std::nullopt;
@@ -188,7 +188,7 @@ std::optional<grpc_resolved_address> GetAddressProxyServer(
   }
   auto address = StringToSockaddr(*address_value);
   if (!address.ok()) {
-    LOG(ERROR) << "cannot parse value of '"
+    ABSL_LOG(ERROR) << "cannot parse value of '"
                << std::string(HttpProxyMapper::kAddressProxyEnvVar)
                << "' env var. Error: " << address.status().ToString();
     return std::nullopt;
@@ -208,17 +208,17 @@ std::optional<std::string> HttpProxyMapper::MapName(
   if (!name_to_resolve.has_value()) return name_to_resolve;
   absl::StatusOr<URI> uri = URI::Parse(server_uri);
   if (!uri.ok() || uri->path().empty()) {
-    LOG(ERROR) << "'http_proxy' environment variable set, but cannot "
+    ABSL_LOG(ERROR) << "'http_proxy' environment variable set, but cannot "
                   "parse server URI '"
                << server_uri << "' -- not using proxy. Error: " << uri.status();
     return std::nullopt;
   }
   if (uri->scheme() == "unix") {
-    VLOG(2) << "not using proxy for Unix domain socket '" << server_uri << "'";
+    ABSL_VLOG(2) << "not using proxy for Unix domain socket '" << server_uri << "'";
     return std::nullopt;
   }
   if (uri->scheme() == "vsock") {
-    VLOG(2) << "not using proxy for VSock '" << server_uri << "'";
+    ABSL_VLOG(2) << "not using proxy for VSock '" << server_uri << "'";
     return std::nullopt;
   }
   // Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set.
@@ -231,7 +231,7 @@ std::optional<std::string> HttpProxyMapper::MapName(
     std::string server_port;
     if (!SplitHostPort(absl::StripPrefix(uri->path(), "/"), &server_host,
                        &server_port)) {
-      VLOG(2) << "unable to split host and port, not checking no_proxy list "
+      ABSL_VLOG(2) << "unable to split host and port, not checking no_proxy list "
                  "for host '"
               << server_uri << "'";
     } else {
@@ -240,7 +240,7 @@ std::optional<std::string> HttpProxyMapper::MapName(
                               ? std::optional<grpc_resolved_address>(*address)
                               : std::nullopt,
                           server_host, *no_proxy_str)) {
-        VLOG(2) << "not using proxy for host in no_proxy list '" << server_uri
+        ABSL_VLOG(2) << "not using proxy for host in no_proxy list '" << server_uri
                 << "'";
         return std::nullopt;
       }
@@ -266,13 +266,13 @@ std::optional<grpc_resolved_address> HttpProxyMapper::MapAddress(
   }
   auto address_string = grpc_sockaddr_to_string(&address, true);
   if (!address_string.ok()) {
-    LOG(ERROR) << "Unable to convert address to string: "
+    ABSL_LOG(ERROR) << "Unable to convert address to string: "
                << address_string.status();
     return std::nullopt;
   }
   std::string host_name, port;
   if (!SplitHostPort(*address_string, &host_name, &port)) {
-    LOG(ERROR) << "Address " << *address_string
+    ABSL_LOG(ERROR) << "Address " << *address_string
                << " cannot be split in host and port";
     return std::nullopt;
   }
diff --git a/third_party/grpc/source/src/core/handshaker/http_connect/xds_http_proxy_mapper.cc b/third_party/grpc/source/src/core/handshaker/http_connect/xds_http_proxy_mapper.cc
index 4e5287e58943f..4b874f584d29d 100644
--- a/third_party/grpc/source/src/core/handshaker/http_connect/xds_http_proxy_mapper.cc
+++ b/third_party/grpc/source/src/core/handshaker/http_connect/xds_http_proxy_mapper.cc
@@ -20,7 +20,7 @@
 #include <optional>
 #include <string>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/handshaker/http_connect/http_connect_handshaker.h"
 #include "src/core/lib/address_utils/parse_address.h"
 #include "src/core/lib/address_utils/sockaddr_utils.h"
@@ -35,13 +35,13 @@ std::optional<grpc_resolved_address> XdsHttpProxyMapper::MapAddress(
   if (!proxy_address_str.has_value()) return std::nullopt;
   auto proxy_address = StringToSockaddr(*proxy_address_str);
   if (!proxy_address.ok()) {
-    LOG(ERROR) << "error parsing address \"" << *proxy_address_str
+    ABSL_LOG(ERROR) << "error parsing address \"" << *proxy_address_str
                << "\": " << proxy_address.status();
     return std::nullopt;
   }
   auto endpoint_address_str = grpc_sockaddr_to_string(&endpoint_address, true);
   if (!endpoint_address_str.ok()) {
-    LOG(ERROR) << "error converting address to string: "
+    ABSL_LOG(ERROR) << "error converting address to string: "
                << endpoint_address_str.status();
     return std::nullopt;
   }
diff --git a/third_party/grpc/source/src/core/handshaker/security/secure_endpoint.cc b/third_party/grpc/source/src/core/handshaker/security/secure_endpoint.cc
index caeb48f58f212..99820e7c52246 100644
--- a/third_party/grpc/source/src/core/handshaker/security/secure_endpoint.cc
+++ b/third_party/grpc/source/src/core/handshaker/security/secure_endpoint.cc
@@ -35,8 +35,8 @@
 #include <utility>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/string_view.h"
 #include "src/core/lib/debug/trace.h"
@@ -156,7 +156,7 @@ static void secure_endpoint_unref(secure_endpoint* ep, const char* reason,
                                   const char* file, int line) {
   if (GRPC_TRACE_FLAG_ENABLED(secure_endpoint)) {
     gpr_atm val = gpr_atm_no_barrier_load(&ep->ref.count);
-    VLOG(2).AtLocation(file, line) << "SECENDP unref " << ep << " : " << reason
+    ABSL_VLOG(2).AtLocation(file, line) << "SECENDP unref " << ep << " : " << reason
                                    << " " << val << " -> " << val - 1;
   }
   if (gpr_unref(&ep->ref)) {
@@ -168,7 +168,7 @@ static void secure_endpoint_ref(secure_endpoint* ep, const char* reason,
                                 const char* file, int line) {
   if (GRPC_TRACE_FLAG_ENABLED(secure_endpoint)) {
     gpr_atm val = gpr_atm_no_barrier_load(&ep->ref.count);
-    VLOG(2).AtLocation(file, line) << "SECENDP   ref " << ep << " : " << reason
+    ABSL_VLOG(2).AtLocation(file, line) << "SECENDP   ref " << ep << " : " << reason
                                    << " " << val << " -> " << val + 1;
   }
   gpr_ref(&ep->ref);
@@ -233,7 +233,7 @@ static void call_read_cb(secure_endpoint* ep, grpc_error_handle error) {
     for (i = 0; i < ep->read_buffer->count; i++) {
       char* data = grpc_dump_slice(ep->read_buffer->slices[i],
                                    GPR_DUMP_HEX | GPR_DUMP_ASCII);
-      VLOG(2) << "READ " << ep << ": " << data;
+      ABSL_VLOG(2) << "READ " << ep << ": " << data;
       gpr_free(data);
     }
   }
@@ -295,7 +295,7 @@ static void on_read(void* user_data, grpc_error_handle error) {
               &unprotected_buffer_size_written);
           gpr_mu_unlock(&ep->protector_mu);
           if (result != TSI_OK) {
-            LOG(ERROR) << "Decryption error: " << tsi_result_to_string(result);
+            ABSL_LOG(ERROR) << "Decryption error: " << tsi_result_to_string(result);
             break;
           }
           message_bytes += processed_message_size;
@@ -361,7 +361,7 @@ static void endpoint_read(grpc_endpoint* secure_ep, grpc_slice_buffer* slices,
   SECURE_ENDPOINT_REF(ep, "read");
   if (ep->leftover_bytes.count) {
     grpc_slice_buffer_swap(&ep->leftover_bytes, &ep->source_buffer);
-    CHECK_EQ(ep->leftover_bytes.count, 0u);
+    ABSL_CHECK_EQ(ep->leftover_bytes.count, 0u);
     on_read(ep, absl::OkStatus());
     return;
   }
@@ -409,7 +409,7 @@ static void endpoint_write(grpc_endpoint* secure_ep, grpc_slice_buffer* slices,
       for (i = 0; i < slices->count; i++) {
         char* data =
             grpc_dump_slice(slices->slices[i], GPR_DUMP_HEX | GPR_DUMP_ASCII);
-        VLOG(2) << "WRITE " << ep << ": " << data;
+        ABSL_VLOG(2) << "WRITE " << ep << ": " << data;
         gpr_free(data);
       }
     }
@@ -450,7 +450,7 @@ static void endpoint_write(grpc_endpoint* secure_ep, grpc_slice_buffer* slices,
                                                &protected_buffer_size_to_send);
           gpr_mu_unlock(&ep->protector_mu);
           if (result != TSI_OK) {
-            LOG(ERROR) << "Encryption error: " << tsi_result_to_string(result);
+            ABSL_LOG(ERROR) << "Encryption error: " << tsi_result_to_string(result);
             break;
           }
           message_bytes += processed_message_size;
diff --git a/third_party/grpc/source/src/core/handshaker/security/security_handshaker.cc b/third_party/grpc/source/src/core/handshaker/security/security_handshaker.cc
index dc4ff5f4c6793..afd4763d6982b 100644
--- a/third_party/grpc/source/src/core/handshaker/security/security_handshaker.cc
+++ b/third_party/grpc/source/src/core/handshaker/security/security_handshaker.cc
@@ -37,7 +37,7 @@

 #include "absl/base/attributes.h"
 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
@@ -345,7 +345,7 @@ grpc_error_handle SecurityHandshaker::OnHandshakeNextDoneLocked(
   }
   // Read more if we need to.
   if (result == TSI_INCOMPLETE_DATA) {
-    CHECK_EQ(bytes_to_send_size, 0u);
+    ABSL_CHECK_EQ(bytes_to_send_size, 0u);
     grpc_endpoint_read(
         args_->endpoint.get(), args_->read_buffer.c_slice_buffer(),
         NewClosure([self = RefAsSubclass<SecurityHandshaker>()](
@@ -365,7 +365,7 @@ grpc_error_handle SecurityHandshaker::OnHandshakeNextDoneLocked(
   }
   // Update handshaker result.
   if (handshaker_result != nullptr) {
-    CHECK_EQ(handshaker_result_, nullptr);
+    ABSL_CHECK_EQ(handshaker_result_, nullptr);
     handshaker_result_ = handshaker_result;
   }
   if (bytes_to_send_size > 0) {
diff --git a/third_party/grpc/source/src/core/handshaker/tcp_connect/tcp_connect_handshaker.cc b/third_party/grpc/source/src/core/handshaker/tcp_connect/tcp_connect_handshaker.cc
index 433ed2b061f89..8f4cccec1b00c 100644
--- a/third_party/grpc/source/src/core/handshaker/tcp_connect/tcp_connect_handshaker.cc
+++ b/third_party/grpc/source/src/core/handshaker/tcp_connect/tcp_connect_handshaker.cc
@@ -29,7 +29,7 @@

 #include "absl/base/thread_annotations.h"
 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "src/core/config/core_configuration.h"
@@ -123,7 +123,7 @@ void TCPConnectHandshaker::DoHandshake(
     MutexLock lock(&mu_);
     on_handshake_done_ = std::move(on_handshake_done);
   }
-  CHECK_EQ(args->endpoint.get(), nullptr);
+  ABSL_CHECK_EQ(args->endpoint.get(), nullptr);
   args_ = args;
   absl::string_view resolved_address_text =
       args->args.GetString(GRPC_ARG_TCP_HANDSHAKER_RESOLVED_ADDRESS).value();
@@ -179,7 +179,7 @@ void TCPConnectHandshaker::Connected(void* arg, grpc_error_handle error) {
       }
       return;
     }
-    CHECK_NE(self->endpoint_to_destroy_, nullptr);
+    ABSL_CHECK_NE(self->endpoint_to_destroy_, nullptr);
     self->args_->endpoint.reset(self->endpoint_to_destroy_);
     self->endpoint_to_destroy_ = nullptr;
     if (self->bind_endpoint_to_pollset_) {
diff --git a/third_party/grpc/source/src/core/lib/address_utils/parse_address.cc b/third_party/grpc/source/src/core/lib/address_utils/parse_address.cc
index 8a3c270a3d103..70999637fa376 100644
--- a/third_party/grpc/source/src/core/lib/address_utils/parse_address.cc
+++ b/third_party/grpc/source/src/core/lib/address_utils/parse_address.cc
@@ -41,8 +41,8 @@
 #endif  // GRPC_HAVE_UNIX_SOCKET
 #include <string>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/strip.h"
@@ -60,13 +60,13 @@
 bool grpc_parse_unix(const grpc_core::URI& uri,
                      grpc_resolved_address* resolved_addr) {
   if (uri.scheme() != "unix") {
-    LOG(ERROR) << "Expected 'unix' scheme, got '" << uri.scheme() << "'";
+    ABSL_LOG(ERROR) << "Expected 'unix' scheme, got '" << uri.scheme() << "'";
     return false;
   }
   grpc_error_handle error =
       grpc_core::UnixSockaddrPopulate(uri.path(), resolved_addr);
   if (!error.ok()) {
-    LOG(ERROR) << "" << grpc_core::StatusToString(error);
+    ABSL_LOG(ERROR) << "" << grpc_core::StatusToString(error);
     return false;
   }
   return true;
@@ -75,14 +75,14 @@ bool grpc_parse_unix(const grpc_core::URI& uri,
 bool grpc_parse_unix_abstract(const grpc_core::URI& uri,
                               grpc_resolved_address* resolved_addr) {
   if (uri.scheme() != "unix-abstract") {
-    LOG(ERROR) << "Expected 'unix-abstract' scheme, got '" << uri.scheme()
+    ABSL_LOG(ERROR) << "Expected 'unix-abstract' scheme, got '" << uri.scheme()
                << "'";
     return false;
   }
   grpc_error_handle error =
       grpc_core::UnixAbstractSockaddrPopulate(uri.path(), resolved_addr);
   if (!error.ok()) {
-    LOG(ERROR) << "" << grpc_core::StatusToString(error);
+    ABSL_LOG(ERROR) << "" << grpc_core::StatusToString(error);
     return false;
   }
   return true;
@@ -159,13 +159,13 @@ grpc_error_handle UnixAbstractSockaddrPopulate(
 bool grpc_parse_vsock(const grpc_core::URI& uri,
                       grpc_resolved_address* resolved_addr) {
   if (uri.scheme() != "vsock") {
-    LOG(ERROR) << "Expected 'vsock' scheme, got '" << uri.scheme() << "'";
+    ABSL_LOG(ERROR) << "Expected 'vsock' scheme, got '" << uri.scheme() << "'";
     return false;
   }
   grpc_error_handle error =
       grpc_core::VSockaddrPopulate(uri.path(), resolved_addr);
   if (!error.ok()) {
-    LOG(ERROR) << "" << grpc_core::StatusToString(error);
+    ABSL_LOG(ERROR) << "" << grpc_core::StatusToString(error);
     return false;
   }
   return true;
@@ -215,7 +215,7 @@ bool grpc_parse_ipv4_hostport(absl::string_view hostport,
   std::string port;
   if (!grpc_core::SplitHostPort(hostport, &host, &port)) {
     if (log_errors) {
-      LOG(ERROR) << "Failed gpr_split_host_port(" << hostport << ", ...)";
+      ABSL_LOG(ERROR) << "Failed gpr_split_host_port(" << hostport << ", ...)";
     }
     return false;
   }
@@ -226,19 +226,19 @@ bool grpc_parse_ipv4_hostport(absl::string_view hostport,
   in->sin_family = GRPC_AF_INET;
   if (grpc_inet_pton(GRPC_AF_INET, host.c_str(), &in->sin_addr) == 0) {
     if (log_errors) {
-      LOG(ERROR) << "invalid ipv4 address: '" << host << "'";
+      ABSL_LOG(ERROR) << "invalid ipv4 address: '" << host << "'";
     }
     goto done;
   }
   // Parse port.
   if (port.empty()) {
-    if (log_errors) LOG(ERROR) << "no port given for ipv4 scheme";
+    if (log_errors) ABSL_LOG(ERROR) << "no port given for ipv4 scheme";
     goto done;
   }
   int port_num;
   if (sscanf(port.c_str(), "%d", &port_num) != 1 || port_num < 0 ||
       port_num > 65535) {
-    if (log_errors) LOG(ERROR) << "invalid ipv4 port: '" << port << "'";
+    if (log_errors) ABSL_LOG(ERROR) << "invalid ipv4 port: '" << port << "'";
     goto done;
   }
   in->sin_port = grpc_htons(static_cast<uint16_t>(port_num));
@@ -250,7 +250,7 @@ done:
 bool grpc_parse_ipv4(const grpc_core::URI& uri,
                      grpc_resolved_address* resolved_addr) {
   if (uri.scheme() != "ipv4") {
-    LOG(ERROR) << "Expected 'ipv4' scheme, got '" << uri.scheme() << "'";
+    ABSL_LOG(ERROR) << "Expected 'ipv4' scheme, got '" << uri.scheme() << "'";
     return false;
   }
   return grpc_parse_ipv4_hostport(absl::StripPrefix(uri.path(), "/"),
@@ -265,7 +265,7 @@ bool grpc_parse_ipv6_hostport(absl::string_view hostport,
   std::string port;
   if (!grpc_core::SplitHostPort(hostport, &host, &port)) {
     if (log_errors) {
-      LOG(ERROR) << "Failed gpr_split_host_port(" << hostport << ", ...)";
+      ABSL_LOG(ERROR) << "Failed gpr_split_host_port(" << hostport << ", ...)";
     }
     return false;
   }
@@ -278,14 +278,14 @@ bool grpc_parse_ipv6_hostport(absl::string_view hostport,
   char* host_end =
       static_cast<char*>(gpr_memrchr(host.c_str(), '%', host.size()));
   if (host_end != nullptr) {
-    CHECK(host_end >= host.c_str());
+    ABSL_CHECK(host_end >= host.c_str());
     char host_without_scope[GRPC_INET6_ADDRSTRLEN + 1];
     size_t host_without_scope_len =
         static_cast<size_t>(host_end - host.c_str());
     uint32_t sin6_scope_id = 0;
     if (host_without_scope_len > GRPC_INET6_ADDRSTRLEN) {
       if (log_errors) {
-        LOG(ERROR) << "invalid ipv6 address length " << host_without_scope_len
+        ABSL_LOG(ERROR) << "invalid ipv6 address length " << host_without_scope_len
                    << ". Length cannot be greater than "
                    << "GRPC_INET6_ADDRSTRLEN i.e " << GRPC_INET6_ADDRSTRLEN;
       }
@@ -296,7 +296,7 @@ bool grpc_parse_ipv6_hostport(absl::string_view hostport,
     if (grpc_inet_pton(GRPC_AF_INET6, host_without_scope, &in6->sin6_addr) ==
         0) {
       if (log_errors) {
-        LOG(ERROR) << "invalid ipv6 address: '" << host_without_scope << "'";
+        ABSL_LOG(ERROR) << "invalid ipv6 address: '" << host_without_scope << "'";
       }
       goto done;
     }
@@ -304,7 +304,7 @@ bool grpc_parse_ipv6_hostport(absl::string_view hostport,
                                   host.size() - host_without_scope_len - 1,
                                   &sin6_scope_id) == 0) {
       if ((sin6_scope_id = grpc_if_nametoindex(host_end + 1)) == 0) {
-        LOG(ERROR) << "Invalid interface name: '" << host_end + 1
+        ABSL_LOG(ERROR) << "Invalid interface name: '" << host_end + 1
                    << "'. Non-numeric and failed if_nametoindex.";
         goto done;
       }
@@ -314,20 +314,20 @@ bool grpc_parse_ipv6_hostport(absl::string_view hostport,
   } else {
     if (grpc_inet_pton(GRPC_AF_INET6, host.c_str(), &in6->sin6_addr) == 0) {
       if (log_errors) {
-        LOG(ERROR) << "invalid ipv6 address: '" << host << "'";
+        ABSL_LOG(ERROR) << "invalid ipv6 address: '" << host << "'";
       }
       goto done;
     }
   }
   // Parse port.
   if (port.empty()) {
-    if (log_errors) LOG(ERROR) << "no port given for ipv6 scheme";
+    if (log_errors) ABSL_LOG(ERROR) << "no port given for ipv6 scheme";
     goto done;
   }
   int port_num;
   if (sscanf(port.c_str(), "%d", &port_num) != 1 || port_num < 0 ||
       port_num > 65535) {
-    if (log_errors) LOG(ERROR) << "invalid ipv6 port: '" << port << "'";
+    if (log_errors) ABSL_LOG(ERROR) << "invalid ipv6 port: '" << port << "'";
     goto done;
   }
   in6->sin6_port = grpc_htons(static_cast<uint16_t>(port_num));
@@ -339,7 +339,7 @@ done:
 bool grpc_parse_ipv6(const grpc_core::URI& uri,
                      grpc_resolved_address* resolved_addr) {
   if (uri.scheme() != "ipv6") {
-    LOG(ERROR) << "Expected 'ipv6' scheme, got '" << uri.scheme() << "'";
+    ABSL_LOG(ERROR) << "Expected 'ipv6' scheme, got '" << uri.scheme() << "'";
     return false;
   }
   return grpc_parse_ipv6_hostport(absl::StripPrefix(uri.path(), "/"),
@@ -363,7 +363,7 @@ bool grpc_parse_uri(const grpc_core::URI& uri,
   if (uri.scheme() == "ipv6") {
     return grpc_parse_ipv6(uri, resolved_addr);
   }
-  LOG(ERROR) << "Can't parse scheme '" << uri.scheme() << "'";
+  ABSL_LOG(ERROR) << "Can't parse scheme '" << uri.scheme() << "'";
   return false;
 }

diff --git a/third_party/grpc/source/src/core/lib/address_utils/sockaddr_utils.cc b/third_party/grpc/source/src/core/lib/address_utils/sockaddr_utils.cc
index b52491637c04d..083471e0259be 100644
--- a/third_party/grpc/source/src/core/lib/address_utils/sockaddr_utils.cc
+++ b/third_party/grpc/source/src/core/lib/address_utils/sockaddr_utils.cc
@@ -22,7 +22,7 @@
 #include <grpc/support/port_platform.h>
 #include <inttypes.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #ifdef GRPC_HAVE_VSOCK
 #include <linux/vm_sockets.h>
 #endif
@@ -31,7 +31,7 @@
 #include <string>
 #include <utility>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
@@ -109,7 +109,7 @@ static const uint8_t kV4MappedPrefix[] = {0, 0, 0, 0, 0,    0,

 int grpc_sockaddr_is_v4mapped(const grpc_resolved_address* resolved_addr,
                               grpc_resolved_address* resolved_addr4_out) {
-  CHECK(resolved_addr != resolved_addr4_out);
+  ABSL_CHECK(resolved_addr != resolved_addr4_out);
   const grpc_sockaddr* addr =
       reinterpret_cast<const grpc_sockaddr*>(resolved_addr->addr);
   grpc_sockaddr_in* addr4_out =
@@ -139,7 +139,7 @@ int grpc_sockaddr_is_v4mapped(const grpc_resolved_address* resolved_addr,

 int grpc_sockaddr_to_v4mapped(const grpc_resolved_address* resolved_addr,
                               grpc_resolved_address* resolved_addr6_out) {
-  CHECK(resolved_addr != resolved_addr6_out);
+  ABSL_CHECK(resolved_addr != resolved_addr6_out);
   const grpc_sockaddr* addr =
       reinterpret_cast<const grpc_sockaddr*>(resolved_addr->addr);
   grpc_sockaddr_in6* addr6_out =
@@ -202,8 +202,8 @@ void grpc_sockaddr_make_wildcard4(int port,
                                   grpc_resolved_address* resolved_wild_out) {
   grpc_sockaddr_in* wild_out =
       reinterpret_cast<grpc_sockaddr_in*>(resolved_wild_out->addr);
-  CHECK(port >= 0);
-  CHECK(port < 65536);
+  ABSL_CHECK(port >= 0);
+  ABSL_CHECK(port < 65536);
   memset(resolved_wild_out, 0, sizeof(*resolved_wild_out));
   wild_out->sin_family = GRPC_AF_INET;
   wild_out->sin_port = grpc_htons(static_cast<uint16_t>(port));
@@ -214,8 +214,8 @@ void grpc_sockaddr_make_wildcard6(int port,
                                   grpc_resolved_address* resolved_wild_out) {
   grpc_sockaddr_in6* wild_out =
       reinterpret_cast<grpc_sockaddr_in6*>(resolved_wild_out->addr);
-  CHECK(port >= 0);
-  CHECK(port < 65536);
+  ABSL_CHECK(port >= 0);
+  ABSL_CHECK(port < 65536);
   memset(resolved_wild_out, 0, sizeof(*resolved_wild_out));
   wild_out->sin6_family = GRPC_AF_INET6;
   wild_out->sin6_port = grpc_htons(static_cast<uint16_t>(port));
@@ -369,7 +369,7 @@ int grpc_sockaddr_get_port(const grpc_resolved_address* resolved_addr) {
       return 1;
 #endif
     default:
-      LOG(ERROR) << "Unknown socket family " << addr->sa_family
+      ABSL_LOG(ERROR) << "Unknown socket family " << addr->sa_family
                  << " in grpc_sockaddr_get_port";
       return 0;
   }
@@ -379,19 +379,19 @@ int grpc_sockaddr_set_port(grpc_resolved_address* resolved_addr, int port) {
   grpc_sockaddr* addr = reinterpret_cast<grpc_sockaddr*>(resolved_addr->addr);
   switch (addr->sa_family) {
     case GRPC_AF_INET:
-      CHECK(port >= 0);
-      CHECK(port < 65536);
+      ABSL_CHECK(port >= 0);
+      ABSL_CHECK(port < 65536);
       (reinterpret_cast<grpc_sockaddr_in*>(addr))->sin_port =
           grpc_htons(static_cast<uint16_t>(port));
       return 1;
     case GRPC_AF_INET6:
-      CHECK(port >= 0);
-      CHECK(port < 65536);
+      ABSL_CHECK(port >= 0);
+      ABSL_CHECK(port < 65536);
       (reinterpret_cast<grpc_sockaddr_in6*>(addr))->sin6_port =
           grpc_htons(static_cast<uint16_t>(port));
       return 1;
     default:
-      LOG(ERROR) << "Unknown socket family " << addr->sa_family
+      ABSL_LOG(ERROR) << "Unknown socket family " << addr->sa_family
                  << " in grpc_sockaddr_set_port";
       return 0;
   }
@@ -440,7 +440,7 @@ void grpc_sockaddr_mask_bits(grpc_resolved_address* address,
     // We cannot use s6_addr32 since it is not defined on all platforms that we
     // need it on.
     uint32_t address_parts[4];
-    CHECK(sizeof(addr6->sin6_addr) == sizeof(address_parts));
+    ABSL_CHECK(sizeof(addr6->sin6_addr) == sizeof(address_parts));
     memcpy(address_parts, &addr6->sin6_addr, sizeof(grpc_in6_addr));
     if (mask_bits <= 32) {
       uint32_t mask_ip_addr = (~(uint32_t{0})) << (32 - mask_bits);
diff --git a/third_party/grpc/source/src/core/lib/channel/channel_args.cc b/third_party/grpc/source/src/core/lib/channel/channel_args.cc
index a2c6ba422618f..7093802cb9ced 100644
--- a/third_party/grpc/source/src/core/lib/channel/channel_args.cc
+++ b/third_party/grpc/source/src/core/lib/channel/channel_args.cc
@@ -32,8 +32,8 @@
 #include <string>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/match.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
@@ -262,7 +262,7 @@ std::optional<bool> ChannelArgs::GetBool(absl::string_view name) const {
   if (v == nullptr) return std::nullopt;
   auto i = v->GetIfInt();
   if (!i.has_value()) {
-    LOG(ERROR) << name << " ignored: it must be an integer";
+    ABSL_LOG(ERROR) << name << " ignored: it must be an integer";
     return std::nullopt;
   }
   switch (*i) {
@@ -271,7 +271,7 @@ std::optional<bool> ChannelArgs::GetBool(absl::string_view name) const {
     case 1:
       return true;
     default:
-      LOG(ERROR) << name << " treated as bool but set to " << *i
+      ABSL_LOG(ERROR) << name << " treated as bool but set to " << *i
                  << " (assuming true)";
       return true;
   }
@@ -425,7 +425,7 @@ grpc_channel_args* grpc_channel_args_copy_and_add_and_remove(
   for (size_t i = 0; i < num_to_add; ++i) {
     dst->args[dst_idx++] = copy_arg(&to_add[i]);
   }
-  CHECK(dst_idx == dst->num_args);
+  ABSL_CHECK(dst_idx == dst->num_args);
   return dst;
 }

@@ -554,15 +554,15 @@ int grpc_channel_arg_get_integer(const grpc_arg* arg,
                                  const grpc_integer_options options) {
   if (arg == nullptr) return options.default_value;
   if (arg->type != GRPC_ARG_INTEGER) {
-    LOG(ERROR) << arg->key << " ignored: it must be an integer";
+    ABSL_LOG(ERROR) << arg->key << " ignored: it must be an integer";
     return options.default_value;
   }
   if (arg->value.integer < options.min_value) {
-    LOG(ERROR) << arg->key << " ignored: it must be >= " << options.min_value;
+    ABSL_LOG(ERROR) << arg->key << " ignored: it must be >= " << options.min_value;
     return options.default_value;
   }
   if (arg->value.integer > options.max_value) {
-    LOG(ERROR) << arg->key << " ignored: it must be <= " << options.max_value;
+    ABSL_LOG(ERROR) << arg->key << " ignored: it must be <= " << options.max_value;
     return options.default_value;
   }
   return arg->value.integer;
@@ -578,7 +578,7 @@ int grpc_channel_args_find_integer(const grpc_channel_args* args,
 char* grpc_channel_arg_get_string(const grpc_arg* arg) {
   if (arg == nullptr) return nullptr;
   if (arg->type != GRPC_ARG_STRING) {
-    LOG(ERROR) << arg->key << " ignored: it must be an string";
+    ABSL_LOG(ERROR) << arg->key << " ignored: it must be an string";
     return nullptr;
   }
   return arg->value.string;
@@ -593,7 +593,7 @@ char* grpc_channel_args_find_string(const grpc_channel_args* args,
 bool grpc_channel_arg_get_bool(const grpc_arg* arg, bool default_value) {
   if (arg == nullptr) return default_value;
   if (arg->type != GRPC_ARG_INTEGER) {
-    LOG(ERROR) << arg->key << " ignored: it must be an integer";
+    ABSL_LOG(ERROR) << arg->key << " ignored: it must be an integer";
     return default_value;
   }
   switch (arg->value.integer) {
@@ -602,7 +602,7 @@ bool grpc_channel_arg_get_bool(const grpc_arg* arg, bool default_value) {
     case 1:
       return true;
     default:
-      LOG(ERROR) << arg->key << " treated as bool but set to "
+      ABSL_LOG(ERROR) << arg->key << " treated as bool but set to "
                  << arg->value.integer << " (assuming true)";
       return true;
   }
@@ -662,7 +662,7 @@ ChannelArgs ChannelArgsBuiltinPrecondition(const grpc_channel_args* src) {
     if (key == GRPC_ARG_PRIMARY_USER_AGENT_STRING ||
         key == GRPC_ARG_SECONDARY_USER_AGENT_STRING) {
       if (src->args[i].type != GRPC_ARG_STRING) {
-        LOG(ERROR) << "Channel argument '" << key << "' should be a string";
+        ABSL_LOG(ERROR) << "Channel argument '" << key << "' should be a string";
       } else {
         concatenated_values[key].push_back(src->args[i].value.string);
       }
@@ -694,7 +694,7 @@ grpc_channel_args_client_channel_creation_mutator g_mutator = nullptr;

 void grpc_channel_args_set_client_channel_creation_mutator(
     grpc_channel_args_client_channel_creation_mutator cb) {
-  DCHECK_EQ(g_mutator, nullptr);
+  ABSL_DCHECK_EQ(g_mutator, nullptr);
   g_mutator = cb;
 }
 grpc_channel_args_client_channel_creation_mutator
diff --git a/third_party/grpc/source/src/core/lib/channel/channel_stack.cc b/third_party/grpc/source/src/core/lib/channel/channel_stack.cc
index 0b0b0345538d3..32a754047aa15 100644
--- a/third_party/grpc/source/src/core/lib/channel/channel_stack.cc
+++ b/third_party/grpc/source/src/core/lib/channel/channel_stack.cc
@@ -24,8 +24,8 @@
 #include <memory>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/channel/channel_args.h"
 #include "src/core/lib/channel/channel_fwd.h"
 #include "src/core/lib/surface/channel_init.h"
@@ -64,7 +64,7 @@ size_t grpc_channel_stack_size(const grpc_channel_filter** filters,
                                                sizeof(grpc_channel_element));
   size_t i;

-  CHECK((GPR_MAX_ALIGNMENT & (GPR_MAX_ALIGNMENT - 1)) == 0)
+  ABSL_CHECK((GPR_MAX_ALIGNMENT & (GPR_MAX_ALIGNMENT - 1)) == 0)
       << "GPR_MAX_ALIGNMENT must be a power of two";

   // add the size for each filter
@@ -117,9 +117,9 @@ grpc_error_handle grpc_channel_stack_init(
     grpc_channel_stack* stack, const grpc_core::Blackboard* old_blackboard,
     grpc_core::Blackboard* new_blackboard) {
   if (GRPC_TRACE_FLAG_ENABLED(channel_stack)) {
-    LOG(INFO) << "CHANNEL_STACK: init " << name;
+    ABSL_LOG(INFO) << "CHANNEL_STACK: init " << name;
     for (size_t i = 0; i < filter_count; i++) {
-      LOG(INFO) << "CHANNEL_STACK:   filter " << filters[i]->name;
+      ABSL_LOG(INFO) << "CHANNEL_STACK:   filter " << filters[i]->name;
     }
   }

@@ -166,8 +166,8 @@ grpc_error_handle grpc_channel_stack_init(
     call_size += GPR_ROUND_UP_TO_ALIGNMENT_SIZE(filters[i]->sizeof_call_data);
   }

-  CHECK(user_data > (char*)stack);
-  CHECK((uintptr_t)(user_data - (char*)stack) ==
+  ABSL_CHECK(user_data > (char*)stack);
+  ABSL_CHECK((uintptr_t)(user_data - (char*)stack) ==
         grpc_channel_stack_size(filters, filter_count));

   stack->call_stack_size = call_size;
diff --git a/third_party/grpc/source/src/core/lib/channel/connected_channel.cc b/third_party/grpc/source/src/core/lib/channel/connected_channel.cc
index c4b3b41d30ef5..640e0141c11c9 100644
--- a/third_party/grpc/source/src/core/lib/channel/connected_channel.cc
+++ b/third_party/grpc/source/src/core/lib/channel/connected_channel.cc
@@ -31,7 +31,7 @@
 #include <type_traits>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "src/core/config/core_configuration.h"
@@ -220,7 +220,7 @@ static void connected_channel_destroy_call_elem(
 static grpc_error_handle connected_channel_init_channel_elem(
     grpc_channel_element* elem, grpc_channel_element_args* args) {
   channel_data* cd = static_cast<channel_data*>(elem->channel_data);
-  CHECK(args->is_last);
+  ABSL_CHECK(args->is_last);
   cd->transport = args->channel_args.GetObject<grpc_core::Transport>();
   return absl::OkStatus();
 }
diff --git a/third_party/grpc/source/src/core/lib/channel/promise_based_filter.cc b/third_party/grpc/source/src/core/lib/channel/promise_based_filter.cc
index d13e13bb19ae1..bcf3ab0787ae3 100644
--- a/third_party/grpc/source/src/core/lib/channel/promise_based_filter.cc
+++ b/third_party/grpc/source/src/core/lib/channel/promise_based_filter.cc
@@ -25,8 +25,8 @@

 #include "absl/base/attributes.h"
 #include "absl/functional/function_ref.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
@@ -172,7 +172,7 @@ BaseCallData::CapturedBatch::~CapturedBatch() {
   uintptr_t& refcnt = *RefCountField(batch_);
   if (refcnt == 0) return;  // refcnt==0 ==> cancelled
   --refcnt;
-  CHECK_NE(refcnt, 0u);
+  ABSL_CHECK_NE(refcnt, 0u);
 }

 BaseCallData::CapturedBatch::CapturedBatch(const CapturedBatch& rhs)
@@ -203,7 +203,7 @@ BaseCallData::CapturedBatch& BaseCallData::CapturedBatch::operator=(

 void BaseCallData::CapturedBatch::ResumeWith(Flusher* releaser) {
   auto* batch = std::exchange(batch_, nullptr);
-  CHECK_NE(batch, nullptr);
+  ABSL_CHECK_NE(batch, nullptr);
   uintptr_t& refcnt = *RefCountField(batch);
   if (refcnt == 0) {
     // refcnt==0 ==> cancelled
@@ -218,7 +218,7 @@ void BaseCallData::CapturedBatch::ResumeWith(Flusher* releaser) {

 void BaseCallData::CapturedBatch::CompleteWith(Flusher* releaser) {
   auto* batch = std::exchange(batch_, nullptr);
-  CHECK_NE(batch, nullptr);
+  ABSL_CHECK_NE(batch, nullptr);
   uintptr_t& refcnt = *RefCountField(batch);
   if (refcnt == 0) return;  // refcnt==0 ==> cancelled
   if (--refcnt == 0) {
@@ -229,7 +229,7 @@ void BaseCallData::CapturedBatch::CompleteWith(Flusher* releaser) {
 void BaseCallData::CapturedBatch::CancelWith(grpc_error_handle error,
                                              Flusher* releaser) {
   auto* batch = std::exchange(batch_, nullptr);
-  CHECK_NE(batch, nullptr);
+  ABSL_CHECK_NE(batch, nullptr);
   uintptr_t& refcnt = *RefCountField(batch);
   if (refcnt == 0) {
     // refcnt==0 ==> cancelled
@@ -352,7 +352,7 @@ template <typename T>
 void BaseCallData::SendMessage::GotPipe(T* pipe_end) {
   GRPC_TRACE_LOG(channel, INFO)
       << base_->LogTag() << " SendMessage.GotPipe st=" << StateString(state_);
-  CHECK_NE(pipe_end, nullptr);
+  ABSL_CHECK_NE(pipe_end, nullptr);
   switch (state_) {
     case State::kInitial:
       state_ = State::kIdle;
@@ -496,7 +496,7 @@ void BaseCallData::SendMessage::WakeInsideCombiner(Flusher* flusher,
       }
       [[fallthrough]];
     case State::kPushedToPipe: {
-      CHECK(push_.has_value());
+      ABSL_CHECK(push_.has_value());
       auto r_push = (*push_)();
       if (auto* p = r_push.value_if_ready()) {
         GRPC_TRACE_LOG(channel, INFO)
@@ -505,12 +505,12 @@ void BaseCallData::SendMessage::WakeInsideCombiner(Flusher* flusher,
                "result="
             << (*p ? "true" : "false");
         // We haven't pulled through yet, so this certainly shouldn't succeed.
-        CHECK(!*p);
+        ABSL_CHECK(!*p);
         state_ = State::kCancelled;
         batch_.CancelWith(absl::CancelledError(), flusher);
         break;
       }
-      CHECK(next_.has_value());
+      ABSL_CHECK(next_.has_value());
       auto r_next = (*next_)();
       if (auto* p = r_next.value_if_ready()) {
         GRPC_TRACE_LOG(channel, INFO)
@@ -822,12 +822,12 @@ void BaseCallData::ReceiveMessage::WakeInsideCombiner(Flusher* flusher,
                             completed_status_, "recv_message");
         break;
       }
-      CHECK(state_ == State::kPushedToPipe ||
+      ABSL_CHECK(state_ == State::kPushedToPipe ||
             state_ == State::kCompletedWhilePushedToPipe);
       [[fallthrough]];
     case State::kCompletedWhilePushedToPipe:
     case State::kPushedToPipe: {
-      CHECK(push_.has_value());
+      ABSL_CHECK(push_.has_value());
       auto r_push = (*push_)();
       if (auto* p = r_push.value_if_ready()) {
         GRPC_TRACE_LOG(channel, INFO)
@@ -835,11 +835,11 @@ void BaseCallData::ReceiveMessage::WakeInsideCombiner(Flusher* flusher,
             << " ReceiveMessage.WakeInsideCombiner push complete: "
             << (*p ? "true" : "false");
         // We haven't pulled through yet, so this certainly shouldn't succeed.
-        CHECK(!*p);
+        ABSL_CHECK(!*p);
         state_ = State::kCancelled;
         break;
       }
-      CHECK(next_.has_value());
+      ABSL_CHECK(next_.has_value());
       auto r_next = (*next_)();
       if (auto* p = r_next.value_if_ready()) {
         next_.reset();
@@ -874,7 +874,7 @@ void BaseCallData::ReceiveMessage::WakeInsideCombiner(Flusher* flusher,
       [[fallthrough]];
     case State::kCompletedWhilePulledFromPipe:
     case State::kPulledFromPipe: {
-      CHECK(push_.has_value());
+      ABSL_CHECK(push_.has_value());
       if ((*push_)().ready()) {
         GRPC_TRACE_LOG(channel, INFO)
             << base_->LogTag()
@@ -978,7 +978,7 @@ class ClientCallData::PollContext {
  public:
   explicit PollContext(ClientCallData* self, Flusher* flusher)
       : self_(self), flusher_(flusher) {
-    CHECK_EQ(self_->poll_ctx_, nullptr);
+    ABSL_CHECK_EQ(self_->poll_ctx_, nullptr);

     self_->poll_ctx_ = this;
     scoped_activity_.Init(self_);
@@ -989,11 +989,11 @@ class ClientCallData::PollContext {
   PollContext& operator=(const PollContext&) = delete;

   void Run() {
-    DCHECK(HasContext<Arena>());
+    ABSL_DCHECK(HasContext<Arena>());
     GRPC_TRACE_LOG(channel, INFO)
         << self_->LogTag() << " ClientCallData.PollContext.Run "
         << self_->DebugString();
-    CHECK(have_scoped_activity_);
+    ABSL_CHECK(have_scoped_activity_);
     repoll_ = false;
     if (self_->send_message() != nullptr) {
       self_->send_message()->WakeInsideCombiner(flusher_, true);
@@ -1028,8 +1028,8 @@ class ClientCallData::PollContext {
         case RecvInitialMetadata::kCompleteAndGotPipe:
           self_->recv_initial_metadata_->state =
               RecvInitialMetadata::kCompleteAndPushedToPipe;
-          CHECK(!self_->recv_initial_metadata_->metadata_push_.has_value());
-          CHECK(!self_->recv_initial_metadata_->metadata_next_.has_value());
+          ABSL_CHECK(!self_->recv_initial_metadata_->metadata_push_.has_value());
+          ABSL_CHECK(!self_->recv_initial_metadata_->metadata_next_.has_value());
           self_->recv_initial_metadata_->metadata_push_.emplace(
               self_->recv_initial_metadata_->server_initial_metadata_publisher
                   ->Push(ServerMetadataHandle(
@@ -1040,7 +1040,7 @@ class ClientCallData::PollContext {
               self_->server_initial_metadata_pipe()->receiver.Next());
           [[fallthrough]];
         case RecvInitialMetadata::kCompleteAndPushedToPipe: {
-          CHECK(self_->recv_initial_metadata_->metadata_next_.has_value());
+          ABSL_CHECK(self_->recv_initial_metadata_->metadata_next_.has_value());
           Poll<NextResult<ServerMetadataHandle>> p =
               (*self_->recv_initial_metadata_->metadata_next_)();
           if (NextResult<ServerMetadataHandle>* nr = p.value_if_ready()) {
@@ -1132,7 +1132,7 @@ class ClientCallData::PollContext {
             }
           } else {
             self_->cancelled_error_ = StatusFromMetadata(*md);
-            CHECK(!self_->cancelled_error_.ok());
+            ABSL_CHECK(!self_->cancelled_error_.ok());
             if (self_->recv_initial_metadata_ != nullptr) {
               switch (self_->recv_initial_metadata_->state) {
                 case RecvInitialMetadata::kInitial:
@@ -1170,7 +1170,7 @@ class ClientCallData::PollContext {
               self_->send_initial_metadata_batch_.CancelWith(
                   self_->cancelled_error_, flusher_);
             } else {
-              CHECK(
+              ABSL_CHECK(
                   self_->recv_trailing_state_ == RecvTrailingState::kInitial ||
                   self_->recv_trailing_state_ == RecvTrailingState::kForwarded);
               self_->call_combiner()->Cancel(self_->cancelled_error_);
@@ -1276,7 +1276,7 @@ ClientCallData::ClientCallData(grpc_call_element* elem,

 ClientCallData::~ClientCallData() {
   ScopedActivity scoped_activity(this);
-  CHECK_EQ(poll_ctx_, nullptr);
+  ABSL_CHECK_EQ(poll_ctx_, nullptr);
   if (recv_initial_metadata_ != nullptr) {
     recv_initial_metadata_->~RecvInitialMetadata();
   }
@@ -1290,7 +1290,7 @@ std::string ClientCallData::DebugTag() const {

 // Activity implementation.
 void ClientCallData::ForceImmediateRepoll(WakeupMask) {
-  CHECK_NE(poll_ctx_, nullptr);
+  ABSL_CHECK_NE(poll_ctx_, nullptr);
   poll_ctx_->Repoll();
 }

@@ -1358,7 +1358,7 @@ void ClientCallData::StartBatch(grpc_transport_stream_op_batch* b) {
   // If this is a cancel stream, cancel anything we have pending and propagate
   // the cancellation.
   if (batch->cancel_stream) {
-    CHECK(!batch->send_initial_metadata && !batch->send_trailing_metadata &&
+    ABSL_CHECK(!batch->send_initial_metadata && !batch->send_trailing_metadata &&
           !batch->send_message && !batch->recv_initial_metadata &&
           !batch->recv_message && !batch->recv_trailing_metadata);
     PollContext poll_ctx(this, &flusher);
@@ -1431,12 +1431,12 @@ void ClientCallData::StartBatch(grpc_transport_stream_op_batch* b) {
       batch.CancelWith(cancelled_error_, &flusher);
     } else {
       // Otherwise, we should not have seen a send_initial_metadata op yet.
-      CHECK(send_initial_state_ == SendInitialState::kInitial);
+      ABSL_CHECK(send_initial_state_ == SendInitialState::kInitial);
       // Mark ourselves as queued.
       send_initial_state_ = SendInitialState::kQueued;
       if (batch->recv_trailing_metadata) {
         // If there's a recv_trailing_metadata op, we queue that too.
-        CHECK(recv_trailing_state_ == RecvTrailingState::kInitial);
+        ABSL_CHECK(recv_trailing_state_ == RecvTrailingState::kInitial);
         recv_trailing_state_ = RecvTrailingState::kQueued;
       }
       // This is the queuing!
@@ -1451,7 +1451,7 @@ void ClientCallData::StartBatch(grpc_transport_stream_op_batch* b) {
     if (recv_trailing_state_ == RecvTrailingState::kCancelled) {
       batch.CancelWith(cancelled_error_, &flusher);
     } else {
-      CHECK(recv_trailing_state_ == RecvTrailingState::kInitial);
+      ABSL_CHECK(recv_trailing_state_ == RecvTrailingState::kInitial);
       recv_trailing_state_ = RecvTrailingState::kForwarded;
       HookRecvTrailingMetadata(batch);
     }
@@ -1527,7 +1527,7 @@ void ClientCallData::Cancel(grpc_error_handle error, Flusher* flusher) {
 // Begin running the promise - which will ultimately take some initial
 // metadata and return some trailing metadata.
 void ClientCallData::StartPromise(Flusher* flusher) {
-  CHECK(send_initial_state_ == SendInitialState::kQueued);
+  ABSL_CHECK(send_initial_state_ == SendInitialState::kQueued);
   ChannelFilter* filter = promise_filter_detail::ChannelFilterFromElem(elem());

   // Construct the promise.
@@ -1637,8 +1637,8 @@ ArenaPromise<ServerMetadataHandle> ClientCallData::MakeNextPromise(
     CallArgs call_args) {
   GRPC_TRACE_LOG(channel, INFO)
       << LogTag() << " ClientCallData.MakeNextPromise " << DebugString();
-  CHECK_NE(poll_ctx_, nullptr);
-  CHECK(send_initial_state_ == SendInitialState::kQueued);
+  ABSL_CHECK_NE(poll_ctx_, nullptr);
+  ABSL_CHECK(send_initial_state_ == SendInitialState::kQueued);
   send_initial_metadata_batch_->payload->send_initial_metadata
       .send_initial_metadata = call_args.client_initial_metadata.get();
   if (recv_initial_metadata_ != nullptr) {
@@ -1646,7 +1646,7 @@ ArenaPromise<ServerMetadataHandle> ClientCallData::MakeNextPromise(
     // It might be the one we passed in - in which case we know this filter
     // only wants to examine the metadata, or it might be a new instance, in
     // which case we know the filter wants to mutate.
-    CHECK_NE(call_args.server_initial_metadata, nullptr);
+    ABSL_CHECK_NE(call_args.server_initial_metadata, nullptr);
     recv_initial_metadata_->server_initial_metadata_publisher =
         call_args.server_initial_metadata;
     switch (recv_initial_metadata_->state) {
@@ -1675,17 +1675,17 @@ ArenaPromise<ServerMetadataHandle> ClientCallData::MakeNextPromise(
                 recv_initial_metadata_->state)));  // unreachable
     }
   } else {
-    CHECK_EQ(call_args.server_initial_metadata, nullptr);
+    ABSL_CHECK_EQ(call_args.server_initial_metadata, nullptr);
   }
   if (send_message() != nullptr) {
     send_message()->GotPipe(call_args.client_to_server_messages);
   } else {
-    CHECK_EQ(call_args.client_to_server_messages, nullptr);
+    ABSL_CHECK_EQ(call_args.client_to_server_messages, nullptr);
   }
   if (receive_message() != nullptr) {
     receive_message()->GotPipe(call_args.server_to_client_messages);
   } else {
-    CHECK_EQ(call_args.server_to_client_messages, nullptr);
+    ABSL_CHECK_EQ(call_args.server_to_client_messages, nullptr);
   }
   return ArenaPromise<ServerMetadataHandle>(
       [this]() { return PollTrailingMetadata(); });
@@ -1698,10 +1698,10 @@ ArenaPromise<ServerMetadataHandle> ClientCallData::MakeNextPromise(
 Poll<ServerMetadataHandle> ClientCallData::PollTrailingMetadata() {
   GRPC_TRACE_LOG(channel, INFO)
       << LogTag() << " ClientCallData.PollTrailingMetadata " << DebugString();
-  CHECK_NE(poll_ctx_, nullptr);
+  ABSL_CHECK_NE(poll_ctx_, nullptr);
   if (send_initial_state_ == SendInitialState::kQueued) {
     // First poll: pass the send_initial_metadata op down the stack.
-    CHECK(send_initial_metadata_batch_.is_captured());
+    ABSL_CHECK(send_initial_metadata_batch_.is_captured());
     send_initial_state_ = SendInitialState::kForwarded;
     if (recv_trailing_state_ == RecvTrailingState::kQueued) {
       // (and the recv_trailing_metadata op if it's part of the queuing)
@@ -1768,7 +1768,7 @@ void ClientCallData::RecvTrailingMetadataReady(grpc_error_handle error) {
     SetStatusFromError(recv_trailing_metadata_, error);
   }
   // Record that we've got the callback.
-  CHECK(recv_trailing_state_ == RecvTrailingState::kForwarded);
+  ABSL_CHECK(recv_trailing_state_ == RecvTrailingState::kForwarded);
   recv_trailing_state_ = RecvTrailingState::kComplete;
   if (receive_message() != nullptr) {
     receive_message()->Done(*recv_trailing_metadata_, &flusher);
@@ -1857,7 +1857,7 @@ class ServerCallData::PollContext {
           created_.line(), "; Old: ", self_->poll_ctx_->created_.file(), ":",
           self_->poll_ctx_->created_.line()));
     }
-    CHECK_EQ(self_->poll_ctx_, nullptr);
+    ABSL_CHECK_EQ(self_->poll_ctx_, nullptr);
     self_->poll_ctx_ = this;
     scoped_activity_.Init(self_);
     have_scoped_activity_ = true;
@@ -1965,7 +1965,7 @@ ServerCallData::~ServerCallData() {
   if (send_initial_metadata_ != nullptr) {
     send_initial_metadata_->~SendInitialMetadata();
   }
-  CHECK_EQ(poll_ctx_, nullptr);
+  ABSL_CHECK_EQ(poll_ctx_, nullptr);
 }

 std::string ServerCallData::DebugTag() const {
@@ -1974,7 +1974,7 @@ std::string ServerCallData::DebugTag() const {

 // Activity implementation.
 void ServerCallData::ForceImmediateRepoll(WakeupMask) {
-  CHECK_NE(poll_ctx_, nullptr);
+  ABSL_CHECK_NE(poll_ctx_, nullptr);
   poll_ctx_->Repoll();
 }

@@ -1991,7 +1991,7 @@ void ServerCallData::StartBatch(grpc_transport_stream_op_batch* b) {
   // If this is a cancel stream, cancel anything we have pending and
   // propagate the cancellation.
   if (batch->cancel_stream) {
-    CHECK(!batch->send_initial_metadata && !batch->send_trailing_metadata &&
+    ABSL_CHECK(!batch->send_initial_metadata && !batch->send_trailing_metadata &&
           !batch->send_message && !batch->recv_initial_metadata &&
           !batch->recv_message && !batch->recv_trailing_metadata);
     PollContext poll_ctx(this, &flusher);
@@ -2008,11 +2008,11 @@ void ServerCallData::StartBatch(grpc_transport_stream_op_batch* b) {
   // recv_initial_metadata: we hook the response of this so we can start the
   // promise at an appropriate time.
   if (batch->recv_initial_metadata) {
-    CHECK(!batch->send_initial_metadata && !batch->send_trailing_metadata &&
+    ABSL_CHECK(!batch->send_initial_metadata && !batch->send_trailing_metadata &&
           !batch->send_message && !batch->recv_message &&
           !batch->recv_trailing_metadata);
     // Otherwise, we should not have seen a send_initial_metadata op yet.
-    CHECK(recv_initial_state_ == RecvInitialState::kInitial);
+    ABSL_CHECK(recv_initial_state_ == RecvInitialState::kInitial);
     // Hook the callback so we know when to start the promise.
     recv_initial_metadata_ =
         batch->payload->recv_initial_metadata.recv_initial_metadata;
@@ -2190,13 +2190,13 @@ void ServerCallData::Completed(grpc_error_handle error,
 //   - return a wrapper around PollTrailingMetadata as the promise.
 ArenaPromise<ServerMetadataHandle> ServerCallData::MakeNextPromise(
     CallArgs call_args) {
-  CHECK(recv_initial_state_ == RecvInitialState::kComplete);
-  CHECK(std::move(call_args.client_initial_metadata).get() ==
+  ABSL_CHECK(recv_initial_state_ == RecvInitialState::kComplete);
+  ABSL_CHECK(std::move(call_args.client_initial_metadata).get() ==
         recv_initial_metadata_);
   forward_recv_initial_metadata_callback_ = true;
   if (send_initial_metadata_ != nullptr) {
-    CHECK(send_initial_metadata_->server_initial_metadata_publisher == nullptr);
-    CHECK_NE(call_args.server_initial_metadata, nullptr);
+    ABSL_CHECK(send_initial_metadata_->server_initial_metadata_publisher == nullptr);
+    ABSL_CHECK_NE(call_args.server_initial_metadata, nullptr);
     send_initial_metadata_->server_initial_metadata_publisher =
         call_args.server_initial_metadata;
     switch (send_initial_metadata_->state) {
@@ -2219,17 +2219,17 @@ ArenaPromise<ServerMetadataHandle> ServerCallData::MakeNextPromise(
         break;
     }
   } else {
-    CHECK_EQ(call_args.server_initial_metadata, nullptr);
+    ABSL_CHECK_EQ(call_args.server_initial_metadata, nullptr);
   }
   if (send_message() != nullptr) {
     send_message()->GotPipe(call_args.server_to_client_messages);
   } else {
-    CHECK_EQ(call_args.server_to_client_messages, nullptr);
+    ABSL_CHECK_EQ(call_args.server_to_client_messages, nullptr);
   }
   if (receive_message() != nullptr) {
     receive_message()->GotPipe(call_args.client_to_server_messages);
   } else {
-    CHECK_EQ(call_args.client_to_server_messages, nullptr);
+    ABSL_CHECK_EQ(call_args.client_to_server_messages, nullptr);
   }
   return ArenaPromise<ServerMetadataHandle>(
       [this]() { return PollTrailingMetadata(); });
@@ -2291,7 +2291,7 @@ void ServerCallData::RecvInitialMetadataReady(grpc_error_handle error) {
                             "ServerCallData::RecvInitialMetadataReady"));
   GRPC_TRACE_LOG(channel, INFO)
       << LogTag() << ": RecvInitialMetadataReady " << error;
-  CHECK(recv_initial_state_ == RecvInitialState::kForwarded);
+  ABSL_CHECK(recv_initial_state_ == RecvInitialState::kForwarded);
   // If there was an error we just propagate that through
   if (!error.ok()) {
     recv_initial_state_ = RecvInitialState::kResponded;
@@ -2361,8 +2361,8 @@ void ServerCallData::WakeInsideCombiner(Flusher* flusher) {
         SendInitialMetadata::kQueuedAndGotPipe) {
       send_initial_metadata_->state =
           SendInitialMetadata::kQueuedAndPushedToPipe;
-      CHECK(!send_initial_metadata_->metadata_push_.has_value());
-      CHECK(!send_initial_metadata_->metadata_next_.has_value());
+      ABSL_CHECK(!send_initial_metadata_->metadata_push_.has_value());
+      ABSL_CHECK(!send_initial_metadata_->metadata_next_.has_value());
       send_initial_metadata_->metadata_push_.emplace(
           send_initial_metadata_->server_initial_metadata_publisher->Push(
               ServerMetadataHandle(
@@ -2436,7 +2436,7 @@ void ServerCallData::WakeInsideCombiner(Flusher* flusher) {
     if (send_initial_metadata_ != nullptr &&
         send_initial_metadata_->state ==
             SendInitialMetadata::kQueuedAndPushedToPipe) {
-      CHECK(send_initial_metadata_->metadata_next_.has_value());
+      ABSL_CHECK(send_initial_metadata_->metadata_next_.has_value());
       auto p = (*send_initial_metadata_->metadata_next_)();
       GRPC_TRACE_LOG(channel, INFO)
           << LogTag() << ": WakeInsideCombiner send_initial_metadata poll="
@@ -2483,7 +2483,7 @@ void ServerCallData::WakeInsideCombiner(Flusher* flusher) {
               StateString(send_trailing_state_)));  // unreachable
           break;
         case SendTrailingState::kInitial: {
-          CHECK(*md->get_pointer(GrpcStatusMetadata()) != GRPC_STATUS_OK);
+          ABSL_CHECK(*md->get_pointer(GrpcStatusMetadata()) != GRPC_STATUS_OK);
           Completed(StatusFromMetadata(*md), md->get(GrpcTarPit()).has_value(),
                     flusher);
         } break;
diff --git a/third_party/grpc/source/src/core/lib/channel/promise_based_filter.h b/third_party/grpc/source/src/core/lib/channel/promise_based_filter.h
index 4622e02f2aa94..f21d06144ca0e 100644
--- a/third_party/grpc/source/src/core/lib/channel/promise_based_filter.h
+++ b/third_party/grpc/source/src/core/lib/channel/promise_based_filter.h
@@ -35,8 +35,8 @@

 #include "absl/container/inlined_vector.h"
 #include "absl/functional/function_ref.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/meta/type_traits.h"
 #include "absl/status/status.h"
 #include "absl/strings/string_view.h"
@@ -287,7 +287,7 @@ auto MapResult(const NoInterceptor*, Promise x, void*) {
 template <typename Promise, typename Derived>
 auto MapResult(absl::Status (Derived::Call::*fn)(ServerMetadata&), Promise x,
                FilterCallData<Derived>* call_data) {
-  DCHECK(fn == &Derived::Call::OnServerTrailingMetadata);
+  ABSL_DCHECK(fn == &Derived::Call::OnServerTrailingMetadata);
   return OnCancel(Map(std::move(x),
                       [call_data](ServerMetadataHandle md) {
                         auto status =
@@ -308,7 +308,7 @@ auto MapResult(absl::Status (Derived::Call::*fn)(ServerMetadata&), Promise x,
 template <typename Promise, typename Derived>
 auto MapResult(void (Derived::Call::*fn)(ServerMetadata&), Promise x,
                FilterCallData<Derived>* call_data) {
-  DCHECK(fn == &Derived::Call::OnServerTrailingMetadata);
+  ABSL_DCHECK(fn == &Derived::Call::OnServerTrailingMetadata);
   return OnCancel(Map(std::move(x),
                       [call_data](ServerMetadataHandle md) {
                         call_data->call.OnServerTrailingMetadata(*md);
@@ -325,7 +325,7 @@ auto MapResult(void (Derived::Call::*fn)(ServerMetadata&), Promise x,
 template <typename Promise, typename Derived>
 auto MapResult(void (Derived::Call::*fn)(ServerMetadata&, Derived*), Promise x,
                FilterCallData<Derived>* call_data) {
-  DCHECK(fn == &Derived::Call::OnServerTrailingMetadata);
+  ABSL_DCHECK(fn == &Derived::Call::OnServerTrailingMetadata);
   return OnCancel(
       Map(std::move(x),
           [call_data](ServerMetadataHandle md) {
@@ -466,7 +466,7 @@ template <typename Interceptor, typename Derived>
 auto RunCall(Interceptor interceptor, CallArgs call_args,
              NextPromiseFactory next_promise_factory,
              FilterCallData<Derived>* call_data) {
-  DCHECK(interceptor == &Derived::Call::OnClientInitialMetadata);
+  ABSL_DCHECK(interceptor == &Derived::Call::OnClientInitialMetadata);
   return RunCallImpl<Interceptor, Derived>::Run(
       std::move(call_args), std::move(next_promise_factory), call_data);
 }
@@ -475,7 +475,7 @@ template <typename Derived>
 inline auto InterceptClientToServerMessageHandler(
     void (Derived::Call::*fn)(const Message&),
     FilterCallData<Derived>* call_data, const CallArgs&) {
-  DCHECK(fn == &Derived::Call::OnClientToServerMessage);
+  ABSL_DCHECK(fn == &Derived::Call::OnClientToServerMessage);
   return [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
     call_data->call.OnClientToServerMessage(*msg);
     return std::move(msg);
@@ -486,7 +486,7 @@ template <typename Derived>
 inline auto InterceptClientToServerMessageHandler(
     ServerMetadataHandle (Derived::Call::*fn)(const Message&),
     FilterCallData<Derived>* call_data, const CallArgs&) {
-  DCHECK(fn == &Derived::Call::OnClientToServerMessage);
+  ABSL_DCHECK(fn == &Derived::Call::OnClientToServerMessage);
   return [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
     auto return_md = call_data->call.OnClientToServerMessage(*msg);
     if (return_md == nullptr) return std::move(msg);
@@ -500,7 +500,7 @@ template <typename Derived>
 inline auto InterceptClientToServerMessageHandler(
     ServerMetadataHandle (Derived::Call::*fn)(const Message&, Derived*),
     FilterCallData<Derived>* call_data, const CallArgs&) {
-  DCHECK(fn == &Derived::Call::OnClientToServerMessage);
+  ABSL_DCHECK(fn == &Derived::Call::OnClientToServerMessage);
   return [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
     auto return_md =
         call_data->call.OnClientToServerMessage(*msg, call_data->channel);
@@ -515,7 +515,7 @@ template <typename Derived>
 inline auto InterceptClientToServerMessageHandler(
     void (Derived::Call::*fn)(const Message&, Derived*),
     FilterCallData<Derived>* call_data, const CallArgs&) {
-  DCHECK(fn == &Derived::Call::OnClientToServerMessage);
+  ABSL_DCHECK(fn == &Derived::Call::OnClientToServerMessage);
   return [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
     call_data->call.OnClientToServerMessage(*msg, call_data->channel);
     return std::move(msg);
@@ -526,7 +526,7 @@ template <typename Derived>
 inline auto InterceptClientToServerMessageHandler(
     MessageHandle (Derived::Call::*fn)(MessageHandle, Derived*),
     FilterCallData<Derived>* call_data, const CallArgs&) {
-  DCHECK(fn == &Derived::Call::OnClientToServerMessage);
+  ABSL_DCHECK(fn == &Derived::Call::OnClientToServerMessage);
   return [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
     return call_data->call.OnClientToServerMessage(std::move(msg),
                                                    call_data->channel);
@@ -537,7 +537,7 @@ template <typename Derived>
 inline auto InterceptClientToServerMessageHandler(
     absl::StatusOr<MessageHandle> (Derived::Call::*fn)(MessageHandle, Derived*),
     FilterCallData<Derived>* call_data, const CallArgs&) {
-  DCHECK(fn == &Derived::Call::OnClientToServerMessage);
+  ABSL_DCHECK(fn == &Derived::Call::OnClientToServerMessage);
   return [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
     auto r = call_data->call.OnClientToServerMessage(std::move(msg),
                                                      call_data->channel);
@@ -581,7 +581,7 @@ template <typename Derived>
 inline void InterceptServerInitialMetadata(
     void (Derived::Call::*fn)(ServerMetadata&),
     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
-  DCHECK(fn == &Derived::Call::OnServerInitialMetadata);
+  ABSL_DCHECK(fn == &Derived::Call::OnServerInitialMetadata);
   call_args.server_initial_metadata->InterceptAndMap(
       [call_data](ServerMetadataHandle md) {
         call_data->call.OnServerInitialMetadata(*md);
@@ -593,7 +593,7 @@ template <typename Derived>
 inline void InterceptServerInitialMetadata(
     absl::Status (Derived::Call::*fn)(ServerMetadata&),
     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
-  DCHECK(fn == &Derived::Call::OnServerInitialMetadata);
+  ABSL_DCHECK(fn == &Derived::Call::OnServerInitialMetadata);
   call_args.server_initial_metadata->InterceptAndMap(
       [call_data](
           ServerMetadataHandle md) -> std::optional<ServerMetadataHandle> {
@@ -610,7 +610,7 @@ template <typename Derived>
 inline void InterceptServerInitialMetadata(
     void (Derived::Call::*fn)(ServerMetadata&, Derived*),
     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
-  DCHECK(fn == &Derived::Call::OnServerInitialMetadata);
+  ABSL_DCHECK(fn == &Derived::Call::OnServerInitialMetadata);
   call_args.server_initial_metadata->InterceptAndMap(
       [call_data](ServerMetadataHandle md) {
         call_data->call.OnServerInitialMetadata(*md, call_data->channel);
@@ -622,7 +622,7 @@ template <typename Derived>
 inline void InterceptServerInitialMetadata(
     absl::Status (Derived::Call::*fn)(ServerMetadata&, Derived*),
     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
-  DCHECK(fn == &Derived::Call::OnServerInitialMetadata);
+  ABSL_DCHECK(fn == &Derived::Call::OnServerInitialMetadata);
   call_args.server_initial_metadata->InterceptAndMap(
       [call_data](
           ServerMetadataHandle md) -> std::optional<ServerMetadataHandle> {
@@ -643,7 +643,7 @@ template <typename Derived>
 inline void InterceptServerToClientMessage(
     void (Derived::Call::*fn)(const Message&),
     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
-  DCHECK(fn == &Derived::Call::OnServerToClientMessage);
+  ABSL_DCHECK(fn == &Derived::Call::OnServerToClientMessage);
   call_args.server_to_client_messages->InterceptAndMap(
       [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
         call_data->call.OnServerToClientMessage(*msg);
@@ -655,7 +655,7 @@ template <typename Derived>
 inline void InterceptServerToClientMessage(
     ServerMetadataHandle (Derived::Call::*fn)(const Message&),
     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
-  DCHECK(fn == &Derived::Call::OnServerToClientMessage);
+  ABSL_DCHECK(fn == &Derived::Call::OnServerToClientMessage);
   call_args.server_to_client_messages->InterceptAndMap(
       [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
         auto return_md = call_data->call.OnServerToClientMessage(*msg);
@@ -670,7 +670,7 @@ template <typename Derived>
 inline void InterceptServerToClientMessage(
     void (Derived::Call::*fn)(const Message&, Derived*),
     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
-  DCHECK(fn == &Derived::Call::OnServerToClientMessage);
+  ABSL_DCHECK(fn == &Derived::Call::OnServerToClientMessage);
   call_args.server_to_client_messages->InterceptAndMap(
       [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
         call_data->call.OnServerToClientMessage(*msg, call_data->channel);
@@ -682,7 +682,7 @@ template <typename Derived>
 inline void InterceptServerToClientMessage(
     ServerMetadataHandle (Derived::Call::*fn)(const Message&, Derived*),
     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
-  DCHECK(fn == &Derived::Call::OnServerToClientMessage);
+  ABSL_DCHECK(fn == &Derived::Call::OnServerToClientMessage);
   call_args.server_to_client_messages->InterceptAndMap(
       [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
         auto return_md =
@@ -698,7 +698,7 @@ template <typename Derived>
 inline void InterceptServerToClientMessage(
     MessageHandle (Derived::Call::*fn)(MessageHandle, Derived*),
     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
-  DCHECK(fn == &Derived::Call::OnServerToClientMessage);
+  ABSL_DCHECK(fn == &Derived::Call::OnServerToClientMessage);
   call_args.server_to_client_messages->InterceptAndMap(
       [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
         return call_data->call.OnServerToClientMessage(std::move(msg),
@@ -710,7 +710,7 @@ template <typename Derived>
 inline void InterceptServerToClientMessage(
     absl::StatusOr<MessageHandle> (Derived::Call::*fn)(MessageHandle, Derived*),
     FilterCallData<Derived>* call_data, const CallArgs& call_args) {
-  DCHECK(fn == &Derived::Call::OnServerToClientMessage);
+  ABSL_DCHECK(fn == &Derived::Call::OnServerToClientMessage);
   call_args.server_to_client_messages->InterceptAndMap(
       [call_data](MessageHandle msg) -> std::optional<MessageHandle> {
         auto r = call_data->call.OnServerToClientMessage(std::move(msg),
@@ -727,7 +727,7 @@ inline void InterceptFinalize(const NoInterceptor*, void*, void*) {}
 template <class Call>
 inline void InterceptFinalize(void (Call::*fn)(const grpc_call_final_info*),
                               void*, Call* call) {
-  DCHECK(fn == &Call::OnFinalize);
+  ABSL_DCHECK(fn == &Call::OnFinalize);
   GetContext<CallFinalization>()->Add(
       [call](const grpc_call_final_info* final_info) {
         call->OnFinalize(final_info);
@@ -738,7 +738,7 @@ template <class Derived>
 inline void InterceptFinalize(
     void (Derived::Call::*fn)(const grpc_call_final_info*, Derived*),
     Derived* channel, typename Derived::Call* call) {
-  DCHECK(fn == &Derived::Call::OnFinalize);
+  ABSL_DCHECK(fn == &Derived::Call::OnFinalize);
   GetContext<CallFinalization>()->Add(
       [call, channel](const grpc_call_final_info* final_info) {
         call->OnFinalize(final_info, channel);
@@ -906,7 +906,7 @@ class BaseCallData : public Activity, private Wakeable {
   ~BaseCallData() override;

   void set_pollent(grpc_polling_entity* pollent) {
-    CHECK(nullptr == pollent_.exchange(pollent, std::memory_order_release));
+    ABSL_CHECK(nullptr == pollent_.exchange(pollent, std::memory_order_release));
   }

   // Activity implementation (partial).
@@ -949,7 +949,7 @@ class BaseCallData : public Activity, private Wakeable {
     ~Flusher();

     void Resume(grpc_transport_stream_op_batch* batch) {
-      CHECK(!call_->is_last());
+      ABSL_CHECK(!call_->is_last());
       if (batch->HasOp()) {
         release_.push_back(batch);
       } else if (batch->on_complete != nullptr) {
@@ -1028,7 +1028,7 @@ class BaseCallData : public Activity, private Wakeable {
     PipeSender<MessageHandle>* original_sender() override { abort(); }

     void GotPipe(PipeReceiver<MessageHandle>* receiver) override {
-      CHECK_EQ(receiver_, nullptr);
+      ABSL_CHECK_EQ(receiver_, nullptr);
       receiver_ = receiver;
     }

@@ -1036,7 +1036,7 @@ class BaseCallData : public Activity, private Wakeable {

     PipeSender<MessageHandle>* Push() override { return &pipe_.sender; }
     PipeReceiver<MessageHandle>* Pull() override {
-      CHECK_NE(receiver_, nullptr);
+      ABSL_CHECK_NE(receiver_, nullptr);
       return receiver_;
     }

@@ -1057,12 +1057,12 @@ class BaseCallData : public Activity, private Wakeable {
     void GotPipe(PipeReceiver<MessageHandle>*) override { abort(); }

     void GotPipe(PipeSender<MessageHandle>* sender) override {
-      CHECK_EQ(sender_, nullptr);
+      ABSL_CHECK_EQ(sender_, nullptr);
       sender_ = sender;
     }

     PipeSender<MessageHandle>* Push() override {
-      CHECK_NE(sender_, nullptr);
+      ABSL_CHECK_NE(sender_, nullptr);
       return sender_;
     }
     PipeReceiver<MessageHandle>* Pull() override { return &pipe_.receiver; }
@@ -1577,7 +1577,7 @@ struct CallDataFilterWithFlagsMethods {
     if ((kFlags & kFilterIsLast) != 0) {
       ExecCtx::Run(DEBUG_LOCATION, then_schedule_closure, absl::OkStatus());
     } else {
-      CHECK_EQ(then_schedule_closure, nullptr);
+      ABSL_CHECK_EQ(then_schedule_closure, nullptr);
     }
   }
 };
@@ -1614,7 +1614,7 @@ template <typename F, uint8_t kFlags>
 struct ChannelFilterWithFlagsMethods {
   static absl::Status InitChannelElem(grpc_channel_element* elem,
                                       grpc_channel_element_args* args) {
-    CHECK(args->is_last == ((kFlags & kFilterIsLast) != 0));
+    ABSL_CHECK(args->is_last == ((kFlags & kFilterIsLast) != 0));
     auto status = F::Create(
         args->channel_args,
         ChannelFilter::Args(args->channel_stack, elem,
diff --git a/third_party/grpc/source/src/core/lib/compression/compression_internal.cc b/third_party/grpc/source/src/core/lib/compression/compression_internal.cc
index ae09cf3e7e3b1..472341aba79f8 100644
--- a/third_party/grpc/source/src/core/lib/compression/compression_internal.cc
+++ b/third_party/grpc/source/src/core/lib/compression/compression_internal.cc
@@ -25,7 +25,7 @@
 #include <string>

 #include "absl/container/inlined_vector.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/ascii.h"
 #include "absl/strings/str_format.h"
 #include "absl/strings/str_split.h"
@@ -118,7 +118,7 @@ CompressionAlgorithmSet::CompressionAlgorithmForLevel(
     return GRPC_COMPRESS_NONE;
   }

-  CHECK_GT(level, 0);
+  ABSL_CHECK_GT(level, 0);

   // Establish a "ranking" or compression algorithms in increasing order of
   // compression.
diff --git a/third_party/grpc/source/src/core/lib/compression/message_compress.cc b/third_party/grpc/source/src/core/lib/compression/message_compress.cc
index 7a731495e4a68..6f62c318eda24 100644
--- a/third_party/grpc/source/src/core/lib/compression/message_compress.cc
+++ b/third_party/grpc/source/src/core/lib/compression/message_compress.cc
@@ -25,8 +25,8 @@
 #include <zconf.h>
 #include <zlib.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/slice/slice.h"

 #define OUTPUT_BLOCK_SIZE 1024
@@ -40,40 +40,40 @@ static int zlib_body(z_stream* zs, grpc_slice_buffer* input,
   grpc_slice outbuf = GRPC_SLICE_MALLOC(OUTPUT_BLOCK_SIZE);
   const uInt uint_max = ~uInt{0};

-  CHECK(GRPC_SLICE_LENGTH(outbuf) <= uint_max);
+  ABSL_CHECK(GRPC_SLICE_LENGTH(outbuf) <= uint_max);
   zs->avail_out = static_cast<uInt> GRPC_SLICE_LENGTH(outbuf);
   zs->next_out = GRPC_SLICE_START_PTR(outbuf);
   flush = Z_NO_FLUSH;
   for (i = 0; i < input->count; i++) {
     if (i == input->count - 1) flush = Z_FINISH;
-    CHECK(GRPC_SLICE_LENGTH(input->slices[i]) <= uint_max);
+    ABSL_CHECK(GRPC_SLICE_LENGTH(input->slices[i]) <= uint_max);
     zs->avail_in = static_cast<uInt> GRPC_SLICE_LENGTH(input->slices[i]);
     zs->next_in = GRPC_SLICE_START_PTR(input->slices[i]);
     do {
       if (zs->avail_out == 0) {
         grpc_slice_buffer_add_indexed(output, outbuf);
         outbuf = GRPC_SLICE_MALLOC(OUTPUT_BLOCK_SIZE);
-        CHECK(GRPC_SLICE_LENGTH(outbuf) <= uint_max);
+        ABSL_CHECK(GRPC_SLICE_LENGTH(outbuf) <= uint_max);
         zs->avail_out = static_cast<uInt> GRPC_SLICE_LENGTH(outbuf);
         zs->next_out = GRPC_SLICE_START_PTR(outbuf);
       }
       r = flate(zs, flush);
       if (r < 0 && r != Z_BUF_ERROR /* not fatal */) {
-        VLOG(2) << "zlib error (" << r << ")";
+        ABSL_VLOG(2) << "zlib error (" << r << ")";
         goto error;
       }
     } while (zs->avail_out == 0);
     if (zs->avail_in) {
-      VLOG(2) << "zlib: not all input consumed";
+      ABSL_VLOG(2) << "zlib: not all input consumed";
       goto error;
     }
   }
   if (r != Z_STREAM_END) {
-    VLOG(2) << "zlib: Data error";
+    ABSL_VLOG(2) << "zlib: Data error";
     goto error;
   }

-  CHECK(outbuf.refcount);
+  ABSL_CHECK(outbuf.refcount);
   outbuf.data.refcounted.length -= zs->avail_out;
   grpc_slice_buffer_add_indexed(output, outbuf);

@@ -103,7 +103,7 @@ static int zlib_compress(grpc_slice_buffer* input, grpc_slice_buffer* output,
   zs.zfree = zfree_gpr;
   r = deflateInit2(&zs, Z_DEFAULT_COMPRESSION, Z_DEFLATED, 15 | (gzip ? 16 : 0),
                    8, Z_DEFAULT_STRATEGY);
-  CHECK(r == Z_OK);
+  ABSL_CHECK(r == Z_OK);
   r = zlib_body(&zs, input, output, deflate) && output->length < input->length;
   if (!r) {
     for (i = count_before; i < output->count; i++) {
@@ -127,7 +127,7 @@ static int zlib_decompress(grpc_slice_buffer* input, grpc_slice_buffer* output,
   zs.zalloc = zalloc_gpr;
   zs.zfree = zfree_gpr;
   r = inflateInit2(&zs, 15 | (gzip ? 16 : 0));
-  CHECK(r == Z_OK);
+  ABSL_CHECK(r == Z_OK);
   r = zlib_body(&zs, input, output, inflate);
   if (!r) {
     for (i = count_before; i < output->count; i++) {
@@ -162,7 +162,7 @@ static int compress_inner(grpc_compression_algorithm algorithm,
     case GRPC_COMPRESS_ALGORITHMS_COUNT:
       break;
   }
-  LOG(ERROR) << "invalid compression algorithm " << algorithm;
+  ABSL_LOG(ERROR) << "invalid compression algorithm " << algorithm;
   return 0;
 }

@@ -187,6 +187,6 @@ int grpc_msg_decompress(grpc_compression_algorithm algorithm,
     case GRPC_COMPRESS_ALGORITHMS_COUNT:
       break;
   }
-  LOG(ERROR) << "invalid compression algorithm " << algorithm;
+  ABSL_LOG(ERROR) << "invalid compression algorithm " << algorithm;
   return 0;
 }
diff --git a/third_party/grpc/source/src/core/lib/debug/trace.cc b/third_party/grpc/source/src/core/lib/debug/trace.cc
index bd4a81b8ffe39..a1f74e1a262f8 100644
--- a/third_party/grpc/source/src/core/lib/debug/trace.cc
+++ b/third_party/grpc/source/src/core/lib/debug/trace.cc
@@ -25,7 +25,7 @@
 #include <type_traits>
 #include <utility>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/match.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_split.h"
@@ -39,9 +39,9 @@ int grpc_tracer_set_enabled(const char* name, int enabled);
 namespace grpc_core {
 namespace {
 void LogAllTracers() {
-  VLOG(2) << "available tracers:";
+  ABSL_VLOG(2) << "available tracers:";
   for (const auto& name : GetAllTraceFlags()) {
-    LOG(INFO) << "  " << name.first;
+    ABSL_LOG(INFO) << "  " << name.first;
   }
 }

@@ -86,12 +86,12 @@ bool ParseTracers(absl::string_view tracers) {
         some_trace_was_found = true;
       }
     }
-    if (!found) LOG(ERROR) << "Unknown tracer: " << trace_glob;
+    if (!found) ABSL_LOG(ERROR) << "Unknown tracer: " << trace_glob;
   }
   if (!enabled_tracers.empty()) {
     absl::string_view enabled_tracers_view(enabled_tracers);
     absl::ConsumeSuffix(&enabled_tracers_view, ", ");
-    LOG(INFO) << "gRPC Tracers: " << enabled_tracers_view;
+    ABSL_LOG(INFO) << "gRPC Tracers: " << enabled_tracers_view;
   }
   return some_trace_was_found;
 }
diff --git a/third_party/grpc/source/src/core/lib/debug/trace_impl.h b/third_party/grpc/source/src/core/lib/debug/trace_impl.h
index 5d43e103433a8..15b996dcb32fd 100644
--- a/third_party/grpc/source/src/core/lib/debug/trace_impl.h
+++ b/third_party/grpc/source/src/core/lib/debug/trace_impl.h
@@ -22,7 +22,7 @@
 #include <string>

 #include "absl/container/flat_hash_map.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/string_view.h"

 #ifdef _WIN32
@@ -86,13 +86,13 @@ class TraceFlag {
   GPR_UNLIKELY((grpc_core::tracer##_trace).enabled())

 #define GRPC_TRACE_LOG(tracer, level) \
-  LOG_IF(level, GRPC_TRACE_FLAG_ENABLED(tracer))
+  ABSL_LOG_IF(level, GRPC_TRACE_FLAG_ENABLED(tracer))

 #define GRPC_TRACE_DLOG(tracer, level) \
-  DLOG_IF(level, GRPC_TRACE_FLAG_ENABLED(tracer))
+  ABSL_DLOG_IF(level, GRPC_TRACE_FLAG_ENABLED(tracer))

 #define GRPC_TRACE_VLOG(tracer, level) \
-  if (GRPC_TRACE_FLAG_ENABLED(tracer)) VLOG(level)
+  if (GRPC_TRACE_FLAG_ENABLED(tracer)) ABSL_VLOG(level)

 #ifndef NDEBUG
 typedef TraceFlag DebugOnlyTraceFlag;
diff --git a/third_party/grpc/source/src/core/lib/event_engine/ares_resolver.cc b/third_party/grpc/source/src/core/lib/event_engine/ares_resolver.cc
index b34b1448641a0..fee813a6020d2 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/ares_resolver.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/ares_resolver.cc
@@ -54,8 +54,8 @@

 #include "absl/functional/any_invocable.h"
 #include "absl/hash/hash.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/match.h"
 #include "absl/strings/numbers.h"
 #include "absl/strings/str_cat.h"
@@ -204,7 +204,7 @@ AresResolver::CreateAresResolver(
   ares_channel channel;
   int status = ares_init_options(&channel, &opts, ARES_OPT_FLAGS);
   if (status != ARES_SUCCESS) {
-    LOG(ERROR) << "ares_init_options failed, status: " << status;
+    ABSL_LOG(ERROR) << "ares_init_options failed, status: " << status;
     return AresStatusToAbslStatus(
         status,
         absl::StrCat("Failed to init c-ares channel: ", ares_strerror(status)));
@@ -233,8 +233,8 @@ AresResolver::AresResolver(
 }

 AresResolver::~AresResolver() {
-  CHECK(fd_node_list_.empty());
-  CHECK(callback_map_.empty());
+  ABSL_CHECK(fd_node_list_.empty());
+  ABSL_CHECK(callback_map_.empty());
   ares_destroy(channel_);
 }

@@ -251,7 +251,7 @@ void AresResolver::Orphan() {
         GRPC_TRACE_LOG(cares_resolver, INFO)
             << "(EventEngine c-ares resolver) resolver: " << this
             << " shutdown fd: " << fd_node->polled_fd->GetName();
-        CHECK(fd_node->polled_fd->ShutdownLocked(
+        ABSL_CHECK(fd_node->polled_fd->ShutdownLocked(
             absl::CancelledError("AresResolver::Orphan")));
         fd_node->already_shutdown = true;
       }
@@ -525,7 +525,7 @@ void AresResolver::MaybeStartTimerLocked() {

 void AresResolver::OnReadable(FdNode* fd_node, absl::Status status) {
   grpc_core::MutexLock lock(&mutex_);
-  CHECK(fd_node->readable_registered);
+  ABSL_CHECK(fd_node->readable_registered);
   fd_node->readable_registered = false;
   GRPC_TRACE_LOG(cares_resolver, INFO)
       << "(EventEngine c-ares resolver) OnReadable: fd: " << fd_node->as
@@ -545,7 +545,7 @@ void AresResolver::OnReadable(FdNode* fd_node, absl::Status status) {

 void AresResolver::OnWritable(FdNode* fd_node, absl::Status status) {
   grpc_core::MutexLock lock(&mutex_);
-  CHECK(fd_node->writable_registered);
+  ABSL_CHECK(fd_node->writable_registered);
   fd_node->writable_registered = false;
   GRPC_TRACE_LOG(cares_resolver, INFO)
       << "(EventEngine c-ares resolver) OnWritable: fd: " << fd_node->as
@@ -597,7 +597,7 @@ void AresResolver::OnHostbynameDoneLocked(void* arg, int status,
                                           int /*timeouts*/,
                                           struct hostent* hostent) {
   auto* hostname_qa = static_cast<HostnameQueryArg*>(arg);
-  CHECK_GT(hostname_qa->pending_requests--, 0);
+  ABSL_CHECK_GT(hostname_qa->pending_requests--, 0);
   auto* ares_resolver = hostname_qa->ares_resolver;
   if (status != ARES_SUCCESS) {
     std::string error_msg =
@@ -614,7 +614,7 @@ void AresResolver::OnHostbynameDoneLocked(void* arg, int status,
         << " ARES_SUCCESS";
     for (size_t i = 0; hostent->h_addr_list[i] != nullptr; i++) {
       if (hostname_qa->result.size() == kMaxRecordSize) {
-        LOG(ERROR) << "A/AAAA response exceeds maximum record size of 65536";
+        ABSL_LOG(ERROR) << "A/AAAA response exceeds maximum record size of 65536";
         break;
       }
       switch (hostent->h_addrtype) {
@@ -665,8 +665,8 @@ void AresResolver::OnHostbynameDoneLocked(void* arg, int status,
   if (hostname_qa->pending_requests == 0) {
     auto nh =
         ares_resolver->callback_map_.extract(hostname_qa->callback_map_id);
-    CHECK(!nh.empty());
-    CHECK(std::holds_alternative<
+    ABSL_CHECK(!nh.empty());
+    ABSL_CHECK(std::holds_alternative<
           EventEngine::DNSResolver::LookupHostnameCallback>(nh.mapped()));
     auto callback = std::get<EventEngine::DNSResolver::LookupHostnameCallback>(
         std::move(nh.mapped()));
@@ -692,8 +692,8 @@ void AresResolver::OnSRVQueryDoneLocked(void* arg, int status, int /*timeouts*/,
   std::unique_ptr<QueryArg> qa(static_cast<QueryArg*>(arg));
   auto* ares_resolver = qa->ares_resolver;
   auto nh = ares_resolver->callback_map_.extract(qa->callback_map_id);
-  CHECK(!nh.empty());
-  CHECK(std::holds_alternative<EventEngine::DNSResolver::LookupSRVCallback>(
+  ABSL_CHECK(!nh.empty());
+  ABSL_CHECK(std::holds_alternative<EventEngine::DNSResolver::LookupSRVCallback>(
       nh.mapped()));
   auto callback = std::get<EventEngine::DNSResolver::LookupSRVCallback>(
       std::move(nh.mapped()));
@@ -729,7 +729,7 @@ void AresResolver::OnSRVQueryDoneLocked(void* arg, int status, int /*timeouts*/,
   for (struct ares_srv_reply* srv_it = reply; srv_it != nullptr;
        srv_it = srv_it->next) {
     if (result.size() == kMaxRecordSize) {
-      LOG(ERROR) << "SRV response exceeds maximum record size of 65536";
+      ABSL_LOG(ERROR) << "SRV response exceeds maximum record size of 65536";
       break;
     }
     EventEngine::DNSResolver::SRVRecord record;
@@ -753,8 +753,8 @@ void AresResolver::OnTXTDoneLocked(void* arg, int status, int /*timeouts*/,
   std::unique_ptr<QueryArg> qa(static_cast<QueryArg*>(arg));
   auto* ares_resolver = qa->ares_resolver;
   auto nh = ares_resolver->callback_map_.extract(qa->callback_map_id);
-  CHECK(!nh.empty());
-  CHECK(std::holds_alternative<EventEngine::DNSResolver::LookupTXTCallback>(
+  ABSL_CHECK(!nh.empty());
+  ABSL_CHECK(std::holds_alternative<EventEngine::DNSResolver::LookupTXTCallback>(
       nh.mapped()));
   auto callback = std::get<EventEngine::DNSResolver::LookupTXTCallback>(
       std::move(nh.mapped()));
@@ -798,7 +798,7 @@ void AresResolver::OnTXTDoneLocked(void* arg, int status, int /*timeouts*/,
       << result.size() << " TXT records";
   if (GRPC_TRACE_FLAG_ENABLED(cares_resolver)) {
     for (const auto& record : result) {
-      LOG(INFO) << record;
+      ABSL_LOG(INFO) << record;
     }
   }
   // Clean up.
diff --git a/third_party/grpc/source/src/core/lib/event_engine/cf_engine/cf_engine.cc b/third_party/grpc/source/src/core/lib/event_engine/cf_engine/cf_engine.cc
index 1ec17efdc39d6..e1c6ed0496d31 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/cf_engine/cf_engine.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/cf_engine/cf_engine.cc
@@ -21,8 +21,8 @@
 #include <CoreFoundation/CoreFoundation.h>
 #include <grpc/support/cpu.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/event_engine/cf_engine/cf_engine.h"
 #include "src/core/lib/event_engine/cf_engine/cfstream_endpoint.h"
 #include "src/core/lib/event_engine/cf_engine/dns_service_resolver.h"
@@ -62,12 +62,12 @@ CFEventEngine::~CFEventEngine() {
     grpc_core::MutexLock lock(&task_mu_);
     if (GRPC_TRACE_FLAG_ENABLED(event_engine)) {
       for (auto handle : known_handles_) {
-        LOG(ERROR) << "CFEventEngine:" << this
+        ABSL_LOG(ERROR) << "CFEventEngine:" << this
                    << " uncleared TaskHandle at shutdown:"
                    << HandleToString(handle);
       }
     }
-    CHECK(GPR_LIKELY(known_handles_.empty()));
+    ABSL_CHECK(GPR_LIKELY(known_handles_.empty()));
     timer_manager_.Shutdown();
   }
   thread_pool_->Quiesce();
diff --git a/third_party/grpc/source/src/core/lib/event_engine/cf_engine/dns_service_resolver.cc b/third_party/grpc/source/src/core/lib/event_engine/cf_engine/dns_service_resolver.cc
index f60101ff08bee..b1ed86fec56bd 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/cf_engine/dns_service_resolver.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/cf_engine/dns_service_resolver.cc
@@ -18,7 +18,7 @@
 #include <AvailabilityMacros.h>
 #ifdef AVAILABLE_MAC_OS_X_VERSION_10_12_AND_LATER

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
 #include "src/core/lib/address_utils/parse_address.h"
@@ -148,7 +148,7 @@ void DNSServiceResolverImpl::ResolveCallback(

   grpc_core::ReleasableMutexLock lock(&that->request_mu_);
   auto request_it = that->requests_.find(sdRef);
-  CHECK(request_it != that->requests_.end());
+  ABSL_CHECK(request_it != that->requests_.end());

   if (errorCode != kDNSServiceErr_NoError &&
       errorCode != kDNSServiceErr_NoSuchRecord) {
diff --git a/third_party/grpc/source/src/core/lib/event_engine/cf_engine/dns_service_resolver.h b/third_party/grpc/source/src/core/lib/event_engine/cf_engine/dns_service_resolver.h
index fdf4f799ab9dd..42e65e181e752 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/cf_engine/dns_service_resolver.h
+++ b/third_party/grpc/source/src/core/lib/event_engine/cf_engine/dns_service_resolver.h
@@ -24,7 +24,7 @@
 #include <grpc/event_engine/event_engine.h>

 #include "absl/container/flat_hash_map.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/event_engine/cf_engine/cf_engine.h"
 #include "src/core/util/ref_counted.h"
 #include "src/core/util/ref_counted_ptr.h"
@@ -45,7 +45,7 @@ class DNSServiceResolverImpl
   explicit DNSServiceResolverImpl(std::shared_ptr<CFEventEngine> engine)
       : engine_(std::move((engine))) {}
   ~DNSServiceResolverImpl() override {
-    CHECK(requests_.empty());
+    ABSL_CHECK(requests_.empty());
     dispatch_release(queue_);
   }

diff --git a/third_party/grpc/source/src/core/lib/event_engine/forkable.cc b/third_party/grpc/source/src/core/lib/event_engine/forkable.cc
index 012c2cce1ca67..56d144a88cf0f 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/forkable.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/forkable.cc
@@ -16,7 +16,7 @@

 #include <grpc/support/port_platform.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 #ifdef GRPC_POSIX_FORK_ALLOW_PTHREAD_ATFORK
 #include <pthread.h>
@@ -42,7 +42,7 @@ void ObjectGroupForkHandler::RegisterForkable(
     std::shared_ptr<Forkable> forkable, GRPC_UNUSED void (*prepare)(void),
     GRPC_UNUSED void (*parent)(void), GRPC_UNUSED void (*child)(void)) {
   if (IsForkEnabled()) {
-    CHECK(!is_forking_);
+    ABSL_CHECK(!is_forking_);
     forkables_.emplace_back(forkable);
 #ifdef GRPC_POSIX_FORK_ALLOW_PTHREAD_ATFORK
     if (!std::exchange(registered_, true)) {
@@ -54,7 +54,7 @@ void ObjectGroupForkHandler::RegisterForkable(

 void ObjectGroupForkHandler::Prefork() {
   if (IsForkEnabled()) {
-    CHECK(!std::exchange(is_forking_, true));
+    ABSL_CHECK(!std::exchange(is_forking_, true));
     GRPC_TRACE_LOG(fork, INFO) << "PrepareFork";
     for (auto it = forkables_.begin(); it != forkables_.end();) {
       auto shared = it->lock();
@@ -70,7 +70,7 @@ void ObjectGroupForkHandler::Prefork() {

 void ObjectGroupForkHandler::PostforkParent() {
   if (IsForkEnabled()) {
-    CHECK(is_forking_);
+    ABSL_CHECK(is_forking_);
     GRPC_TRACE_LOG(fork, INFO) << "PostforkParent";
     for (auto it = forkables_.begin(); it != forkables_.end();) {
       auto shared = it->lock();
@@ -87,7 +87,7 @@ void ObjectGroupForkHandler::PostforkParent() {

 void ObjectGroupForkHandler::PostforkChild() {
   if (IsForkEnabled()) {
-    CHECK(is_forking_);
+    ABSL_CHECK(is_forking_);
     GRPC_TRACE_LOG(fork, INFO) << "PostforkChild";
     for (auto it = forkables_.begin(); it != forkables_.end();) {
       auto shared = it->lock();
diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/ev_epoll1_linux.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/ev_epoll1_linux.cc
index 3c5b8be63af11..0452991e0433f 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/ev_epoll1_linux.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/ev_epoll1_linux.cc
@@ -22,8 +22,8 @@
 #include <atomic>
 #include <memory>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_format.h"
@@ -161,14 +161,14 @@ int EpollCreateAndCloexec() {
 #ifdef GRPC_LINUX_EPOLL_CREATE1
   int fd = epoll_create1(EPOLL_CLOEXEC);
   if (fd < 0) {
-    LOG(ERROR) << "epoll_create1 unavailable";
+    ABSL_LOG(ERROR) << "epoll_create1 unavailable";
   }
 #else
   int fd = epoll_create(MAX_EPOLL_EVENTS);
   if (fd < 0) {
-    LOG(ERROR) << "epoll_create unavailable";
+    ABSL_LOG(ERROR) << "epoll_create unavailable";
   } else if (fcntl(fd, F_SETFD, FD_CLOEXEC) != 0) {
-    LOG(ERROR) << "fcntl following epoll_create failed";
+    ABSL_LOG(ERROR) << "fcntl following epoll_create failed";
     return -1;
   }
 #endif
@@ -254,7 +254,7 @@ void Epoll1EventHandle::OrphanHandle(PosixEngineClosure* on_done,
       epoll_event phony_event;
       if (epoll_ctl(poller_->g_epoll_set_.epfd, EPOLL_CTL_DEL, fd_,
                     &phony_event) != 0) {
-        LOG(ERROR) << "OrphanHandle: epoll_ctl failed: "
+        ABSL_LOG(ERROR) << "OrphanHandle: epoll_ctl failed: "
                    << grpc_core::StrError(errno);
       }
     }
@@ -297,7 +297,7 @@ void Epoll1EventHandle::HandleShutdownInternal(absl::Status why,
       epoll_event phony_event;
       if (epoll_ctl(poller_->g_epoll_set_.epfd, EPOLL_CTL_DEL, fd_,
                     &phony_event) != 0) {
-        LOG(ERROR) << "HandleShutdownInternal: epoll_ctl failed: "
+        ABSL_LOG(ERROR) << "HandleShutdownInternal: epoll_ctl failed: "
                    << grpc_core::StrError(errno);
       }
     }
@@ -310,14 +310,14 @@ Epoll1Poller::Epoll1Poller(Scheduler* scheduler)
     : scheduler_(scheduler), was_kicked_(false), closed_(false) {
   g_epoll_set_.epfd = EpollCreateAndCloexec();
   wakeup_fd_ = *CreateWakeupFd();
-  CHECK(wakeup_fd_ != nullptr);
-  CHECK_GE(g_epoll_set_.epfd, 0);
+  ABSL_CHECK(wakeup_fd_ != nullptr);
+  ABSL_CHECK_GE(g_epoll_set_.epfd, 0);
   GRPC_TRACE_LOG(event_engine_poller, INFO)
       << "grpc epoll fd: " << g_epoll_set_.epfd;
   struct epoll_event ev{};
   ev.events = static_cast<uint32_t>(EPOLLIN | EPOLLET);
   ev.data.ptr = wakeup_fd_.get();
-  CHECK(epoll_ctl(g_epoll_set_.epfd, EPOLL_CTL_ADD, wakeup_fd_->ReadFd(),
+  ABSL_CHECK(epoll_ctl(g_epoll_set_.epfd, EPOLL_CTL_ADD, wakeup_fd_->ReadFd(),
                   &ev) == 0);
   g_epoll_set_.num_events = 0;
   g_epoll_set_.cursor = 0;
@@ -370,7 +370,7 @@ EventHandle* Epoll1Poller::CreateHandle(int fd, absl::string_view /*name*/,
   ev.data.ptr = reinterpret_cast<void*>(reinterpret_cast<intptr_t>(new_handle) |
                                         (track_err ? 1 : 0));
   if (epoll_ctl(g_epoll_set_.epfd, EPOLL_CTL_ADD, fd, &ev) != 0) {
-    LOG(ERROR) << "epoll_ctl failed: " << grpc_core::StrError(errno);
+    ABSL_LOG(ERROR) << "epoll_ctl failed: " << grpc_core::StrError(errno);
   }

   return new_handle;
@@ -394,7 +394,7 @@ bool Epoll1Poller::ProcessEpollEvents(int max_epoll_events_to_handle,
     struct epoll_event* ev = &g_epoll_set_.events[c];
     void* data_ptr = ev->data.ptr;
     if (data_ptr == wakeup_fd_.get()) {
-      CHECK(wakeup_fd_->ConsumeWakeup().ok());
+      ABSL_CHECK(wakeup_fd_->ConsumeWakeup().ok());
       was_kicked = true;
     } else {
       Epoll1EventHandle* handle = reinterpret_cast<Epoll1EventHandle*>(
@@ -513,7 +513,7 @@ void Epoll1Poller::Kick() {
     return;
   }
   was_kicked_ = true;
-  CHECK(wakeup_fd_->Wakeup().ok());
+  ABSL_CHECK(wakeup_fd_->Wakeup().ok());
 }

 std::shared_ptr<Epoll1Poller> MakeEpoll1Poller(Scheduler* scheduler) {
diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/ev_poll_posix.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/ev_poll_posix.cc
index 6d7d54c62eecf..f2ea5804eedb4 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/ev_poll_posix.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/ev_poll_posix.cc
@@ -28,7 +28,7 @@

 #include "absl/container/inlined_vector.h"
 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_format.h"
@@ -294,7 +294,7 @@ EventHandle* PollPoller::CreateHandle(int fd, absl::string_view /*name*/,
                                       bool track_err) {
   // Avoid unused-parameter warning for debug-only parameter
   (void)track_err;
-  DCHECK(track_err == false);
+  ABSL_DCHECK(track_err == false);
   PollEventHandle* handle = new PollEventHandle(fd, shared_from_this());
   // We need to send a kick to the thread executing Work(..) so that it can
   // add this new Fd into the list of Fds to poll.
@@ -312,7 +312,7 @@ void PollEventHandle::OrphanHandle(PosixEngineClosure* on_done, int* release_fd,
     if (release_fd != nullptr) {
       *release_fd = fd_;
     }
-    CHECK(!is_orphaned_);
+    ABSL_CHECK(!is_orphaned_);
     is_orphaned_ = true;
     // Perform shutdown operations if not already done so.
     if (!is_shutdown_) {
@@ -526,7 +526,7 @@ void PollPoller::KickExternal(bool ext) {
   }
   was_kicked_ = true;
   was_kicked_ext_ = ext;
-  CHECK(wakeup_fd_->Wakeup().ok());
+  ABSL_CHECK(wakeup_fd_->Wakeup().ok());
 }

 void PollPoller::Kick() { KickExternal(true); }
@@ -565,7 +565,7 @@ PollPoller::PollPoller(Scheduler* scheduler)
       poll_handles_list_head_(nullptr),
       closed_(false) {
   wakeup_fd_ = *CreateWakeupFd();
-  CHECK(wakeup_fd_ != nullptr);
+  ABSL_CHECK(wakeup_fd_ != nullptr);
   ForkPollerListAddPoller(this);
 }

@@ -578,15 +578,15 @@ PollPoller::PollPoller(Scheduler* scheduler, bool use_phony_poll)
       poll_handles_list_head_(nullptr),
       closed_(false) {
   wakeup_fd_ = *CreateWakeupFd();
-  CHECK(wakeup_fd_ != nullptr);
+  ABSL_CHECK(wakeup_fd_ != nullptr);
   ForkPollerListAddPoller(this);
 }

 PollPoller::~PollPoller() {
   // Assert that no active handles are present at the time of destruction.
   // They should have been orphaned before reaching this state.
-  CHECK_EQ(num_poll_handles_, 0);
-  CHECK_EQ(poll_handles_list_head_, nullptr);
+  ABSL_CHECK_EQ(num_poll_handles_, 0);
+  ABSL_CHECK_EQ(poll_handles_list_head_, nullptr);
 }

 Poller::WorkResult PollPoller::Work(
@@ -638,7 +638,7 @@ Poller::WorkResult PollPoller::Work(
         // There shouldn't be any orphaned fds at this point. This is because
         // prior to marking a handle as orphaned it is first removed from
         // poll handle list for the poller under the poller lock.
-        CHECK(!head->IsOrphaned());
+        ABSL_CHECK(!head->IsOrphaned());
         if (!head->IsPollhup()) {
           pfds[pfd_count].fd = head->WrappedFd();
           watchers[pfd_count] = head;
@@ -714,7 +714,7 @@ Poller::WorkResult PollPoller::Work(
       }
     } else {
       if (pfds[0].revents & kPollinCheck) {
-        CHECK(wakeup_fd_->ConsumeWakeup().ok());
+        ABSL_CHECK(wakeup_fd_->ConsumeWakeup().ok());
       }
       for (i = 1; i < pfd_count; i++) {
         PollEventHandle* head = watchers[i];
diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/internal_errqueue.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/internal_errqueue.cc
index c5fa3db25b9a8..f60f8655b38fd 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/internal_errqueue.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/internal_errqueue.cc
@@ -16,7 +16,7 @@

 #include <grpc/support/port_platform.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/iomgr/port.h"

 #ifdef GRPC_POSIX_SOCKET_TCP
@@ -48,7 +48,7 @@ bool KernelSupportsErrqueue() {
     // least 4.0.0
     struct utsname buffer;
     if (uname(&buffer) != 0) {
-      LOG(ERROR) << "uname: " << grpc_core::StrError(errno);
+      ABSL_LOG(ERROR) << "uname: " << grpc_core::StrError(errno);
       return false;
     }
     char* release = buffer.release;
@@ -59,7 +59,7 @@ bool KernelSupportsErrqueue() {
     if (strtol(release, nullptr, 10) >= 4) {
       return true;
     } else {
-      VLOG(2) << "ERRQUEUE support not enabled";
+      ABSL_VLOG(2) << "ERRQUEUE support not enabled";
     }
 #endif  // GRPC_LINUX_ERRQUEUE
     return false;
diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/lockfree_event.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/lockfree_event.cc
index eda19bb2dc6ce..8ff625ed8ad0f 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/lockfree_event.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/lockfree_event.cc
@@ -19,7 +19,7 @@
 #include <atomic>
 #include <cstdint>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "src/core/lib/event_engine/posix_engine/event_poller.h"
 #include "src/core/lib/event_engine/posix_engine/posix_engine_closure.h"
@@ -76,7 +76,7 @@ void LockfreeEvent::DestroyEvent() {
     if (curr & kShutdownBit) {
       grpc_core::internal::StatusFreeHeapPtr(curr & ~kShutdownBit);
     } else {
-      CHECK(curr == kClosureNotReady || curr == kClosureReady);
+      ABSL_CHECK(curr == kClosureNotReady || curr == kClosureReady);
     }
     // we CAS in a shutdown, no error value here. If this event is interacted
     // with post-deletion (see the note in the constructor) we want the bit
diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_endpoint.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_endpoint.cc
index 75ab2799ee003..3a0a0a1c837dc 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_endpoint.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_endpoint.cc
@@ -32,8 +32,8 @@
 #include <type_traits>

 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -241,7 +241,7 @@ msg_iovlen_type TcpZerocopySendRecord::PopulateIovs(size_t* unwind_slice_idx,
     ++(out_offset_.slice_idx);
     out_offset_.byte_idx = 0;
   }
-  DCHECK_GT(iov_size, 0u);
+  ABSL_DCHECK_GT(iov_size, 0u);
   return iov_size;
 }

@@ -307,8 +307,8 @@ bool PosixEndpointImpl::TcpDoRead(absl::Status& status) {
     iov[i].iov_len = slice.length();
   }

-  CHECK_NE(incoming_buffer_->Length(), 0u);
-  DCHECK_GT(min_progress_size_, 0);
+  ABSL_CHECK_NE(incoming_buffer_->Length(), 0u);
+  ABSL_DCHECK_GT(min_progress_size_, 0);

   do {
     // Assume there is something on the queue. If we receive TCP_INQ from
@@ -368,11 +368,11 @@ bool PosixEndpointImpl::TcpDoRead(absl::Status& status) {

     grpc_core::global_stats().IncrementTcpReadSize(read_bytes);
     AddToEstimate(static_cast<size_t>(read_bytes));
-    DCHECK((size_t)read_bytes <= incoming_buffer_->Length() - total_read_bytes);
+    ABSL_DCHECK((size_t)read_bytes <= incoming_buffer_->Length() - total_read_bytes);

 #ifdef GRPC_HAVE_TCP_INQ
     if (inq_capable_) {
-      DCHECK(!(msg.msg_flags & MSG_CTRUNC));
+      ABSL_DCHECK(!(msg.msg_flags & MSG_CTRUNC));
       struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg);
       for (; cmsg != nullptr; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
         if (cmsg->cmsg_level == SOL_TCP && cmsg->cmsg_type == TCP_CM_INQ &&
@@ -421,7 +421,7 @@ bool PosixEndpointImpl::TcpDoRead(absl::Status& status) {
     inq_ = 1;
   }

-  DCHECK_GT(total_read_bytes, 0u);
+  ABSL_DCHECK_GT(total_read_bytes, 0u);
   status = absl::OkStatus();
   if (grpc_core::IsTcpFrameSizeTuningEnabled()) {
     // Update min progress size based on the total number of bytes read in
@@ -514,7 +514,7 @@ void PosixEndpointImpl::UpdateRcvLowat() {
   if (result.ok()) {
     set_rcvlowat_ = *result;
   } else {
-    LOG(ERROR) << "ERROR in SO_RCVLOWAT: " << result.status().message();
+    ABSL_LOG(ERROR) << "ERROR in SO_RCVLOWAT: " << result.status().message();
   }
 }

@@ -599,7 +599,7 @@ bool PosixEndpointImpl::Read(absl::AnyInvocable<void(absl::Status)> on_read,
   grpc_core::ReleasableMutexLock lock(&read_mu_);
   GRPC_TRACE_LOG(event_engine_endpoint, INFO)
       << "Endpoint[" << this << "]: Read";
-  CHECK(read_cb_ == nullptr);
+  ABSL_CHECK(read_cb_ == nullptr);
   incoming_buffer_ = buffer;
   incoming_buffer_->Clear();
   incoming_buffer_->Swap(last_read_buffer_);
@@ -673,8 +673,8 @@ TcpZerocopySendRecord* PosixEndpointImpl::TcpGetSendZerocopyRecord(
     }
     if (zerocopy_send_record != nullptr) {
       zerocopy_send_record->PrepareForSends(buf);
-      DCHECK_EQ(buf.Count(), 0u);
-      DCHECK_EQ(buf.Length(), 0u);
+      ABSL_DCHECK_EQ(buf.Count(), 0u);
+      ABSL_DCHECK_EQ(buf.Length(), 0u);
       outgoing_byte_idx_ = 0;
       outgoing_buffer_ = nullptr;
     }
@@ -721,7 +721,7 @@ bool PosixEndpointImpl::ProcessErrors() {
       return processed_err;
     }
     if (GPR_UNLIKELY((msg.msg_flags & MSG_CTRUNC) != 0)) {
-      LOG(ERROR) << "Error message was truncated.";
+      ABSL_LOG(ERROR) << "Error message was truncated.";
     }

     if (msg.msg_controllen == 0) {
@@ -761,10 +761,10 @@ void PosixEndpointImpl::ZerocopyDisableAndWaitForRemaining() {

 // Reads \a cmsg to process zerocopy control messages.
 void PosixEndpointImpl::ProcessZerocopy(struct cmsghdr* cmsg) {
-  DCHECK(cmsg);
+  ABSL_DCHECK(cmsg);
   auto serr = reinterpret_cast<struct sock_extended_err*>(CMSG_DATA(cmsg));
-  DCHECK_EQ(serr->ee_errno, 0u);
-  DCHECK(serr->ee_origin == SO_EE_ORIGIN_ZEROCOPY);
+  ABSL_DCHECK_EQ(serr->ee_errno, 0u);
+  ABSL_DCHECK(serr->ee_origin == SO_EE_ORIGIN_ZEROCOPY);
   const uint32_t lo = serr->ee_info;
   const uint32_t hi = serr->ee_data;
   for (uint32_t seq = lo; seq <= hi; ++seq) {
@@ -774,7 +774,7 @@ void PosixEndpointImpl::ProcessZerocopy(struct cmsghdr* cmsg) {
     // both; if so, batch the unref/put.
     TcpZerocopySendRecord* record =
         tcp_zerocopy_send_ctx_->ReleaseSendRecord(seq);
-    DCHECK(record);
+    ABSL_DCHECK(record);
     UnrefMaybePutZerocopySendRecord(record);
   }
   if (tcp_zerocopy_send_ctx_->UpdateZeroCopyOptMemStateAfterFree()) {
@@ -816,7 +816,7 @@ struct cmsghdr* PosixEndpointImpl::ProcessTimestamp(msghdr* msg,
   auto serr = reinterpret_cast<struct sock_extended_err*>(CMSG_DATA(next_cmsg));
   if (serr->ee_errno != ENOMSG ||
       serr->ee_origin != SO_EE_ORIGIN_TIMESTAMPING) {
-    LOG(ERROR) << "Unexpected control message";
+    ABSL_LOG(ERROR) << "Unexpected control message";
     return cmsg;
   }
   traced_buffers_.ProcessTimestamp(serr, opt_stats, tss);
@@ -987,7 +987,7 @@ bool PosixEndpointImpl::DoFlushZerocopy(TcpZerocopySendRecord* record,
         handle_->SetWritable();
       } else {
 #ifdef GRPC_LINUX_ERRQUEUE
-        LOG_EVERY_N_SEC(INFO, 1)
+        ABSL_LOG_EVERY_N_SEC(INFO, 1)
             << "Tx0cp encountered an ENOBUFS error possibly because one or "
                "both of RLIMIT_MEMLOCK or hard memlock ulimit values are too "
                "small for the intended user. Current system value of "
@@ -1063,7 +1063,7 @@ bool PosixEndpointImpl::TcpFlush(absl::Status& status) {
       outgoing_slice_idx++;
       outgoing_byte_idx_ = 0;
     }
-    CHECK_GT(iov_size, 0u);
+    ABSL_CHECK_GT(iov_size, 0u);

     msg.msg_name = nullptr;
     msg.msg_namelen = 0;
@@ -1108,7 +1108,7 @@ bool PosixEndpointImpl::TcpFlush(absl::Status& status) {
       }
     }

-    CHECK_EQ(outgoing_byte_idx_, 0u);
+    ABSL_CHECK_EQ(outgoing_byte_idx_, 0u);
     bytes_counter_ += sent_length;
     trailing = sending_length - static_cast<size_t>(sent_length);
     while (trailing > 0) {
@@ -1147,7 +1147,7 @@ void PosixEndpointImpl::HandleWrite(absl::Status status) {
                           ? TcpFlushZerocopy(current_zerocopy_send_, status)
                           : TcpFlush(status);
   if (!flush_result) {
-    DCHECK(status.ok());
+    ABSL_DCHECK(status.ok());
     handle_->NotifyOnWrite(on_write_);
   } else {
     GRPC_TRACE_LOG(event_engine_endpoint, INFO)
@@ -1166,9 +1166,9 @@ bool PosixEndpointImpl::Write(
   absl::Status status = absl::OkStatus();
   TcpZerocopySendRecord* zerocopy_send_record = nullptr;

-  CHECK(write_cb_ == nullptr);
-  DCHECK_EQ(current_zerocopy_send_, nullptr);
-  DCHECK_NE(data, nullptr);
+  ABSL_CHECK(write_cb_ == nullptr);
+  ABSL_DCHECK_EQ(current_zerocopy_send_, nullptr);
+  ABSL_DCHECK_NE(data, nullptr);

   GRPC_TRACE_LOG(event_engine_endpoint, INFO)
       << "Endpoint[" << this << "]: Write " << data->Length() << " bytes";
@@ -1200,7 +1200,7 @@ bool PosixEndpointImpl::Write(
     outgoing_buffer_arg_ = args->google_specific;
   }
   if (outgoing_buffer_arg_) {
-    CHECK(poller_->CanTrackErrors());
+    ABSL_CHECK(poller_->CanTrackErrors());
   }

   bool flush_result = zerocopy_send_record != nullptr
@@ -1275,7 +1275,7 @@ PosixEndpointImpl::PosixEndpointImpl(EventHandle* handle,
       engine_(engine) {
   PosixSocketWrapper sock(handle->WrappedFd());
   fd_ = handle_->WrappedFd();
-  CHECK(options.resource_quota != nullptr);
+  ABSL_CHECK(options.resource_quota != nullptr);
   auto peer_addr_string = sock.PeerAddressString();
   mem_quota_ = options.resource_quota->memory_quota();
   memory_owner_ = mem_quota_->CreateMemoryOwner();
@@ -1298,12 +1298,12 @@ PosixEndpointImpl::PosixEndpointImpl(EventHandle* handle,
   if (zerocopy_enabled) {
     if (GetRLimitMemLockMax() == 0) {
       zerocopy_enabled = false;
-      LOG(ERROR) << "Tx zero-copy will not be used by gRPC since RLIMIT_MEMLOCK"
+      ABSL_LOG(ERROR) << "Tx zero-copy will not be used by gRPC since RLIMIT_MEMLOCK"
                  << " value is not set. Consider raising its value with "
                  << "setrlimit().";
     } else if (GetUlimitHardMemLock() == 0) {
       zerocopy_enabled = false;
-      LOG(ERROR) << "Tx zero-copy will not be used by gRPC since hard memlock "
+      ABSL_LOG(ERROR) << "Tx zero-copy will not be used by gRPC since hard memlock "
                  << "ulimit value is not set. Use ulimit -l <value> to set its "
                  << "value.";
     } else {
@@ -1311,12 +1311,12 @@ PosixEndpointImpl::PosixEndpointImpl(EventHandle* handle,
       if (setsockopt(fd_, SOL_SOCKET, SO_ZEROCOPY, &enable, sizeof(enable)) !=
           0) {
         zerocopy_enabled = false;
-        LOG(ERROR) << "Failed to set zerocopy options on the socket.";
+        ABSL_LOG(ERROR) << "Failed to set zerocopy options on the socket.";
       }
     }

     if (zerocopy_enabled) {
-      VLOG(2) << "Tx-zero copy enabled for gRPC sends. RLIMIT_MEMLOCK value "
+      ABSL_VLOG(2) << "Tx-zero copy enabled for gRPC sends. RLIMIT_MEMLOCK value "
               << "=" << GetRLimitMemLockMax()
               << ",ulimit hard memlock value = " << GetUlimitHardMemLock();
     }
@@ -1330,7 +1330,7 @@ PosixEndpointImpl::PosixEndpointImpl(EventHandle* handle,
   if (setsockopt(fd_, SOL_TCP, TCP_INQ, &one, sizeof(one)) == 0) {
     inq_capable_ = true;
   } else {
-    VLOG(2) << "cannot set inq fd=" << fd_ << " errno=" << errno;
+    ABSL_VLOG(2) << "cannot set inq fd=" << fd_ << " errno=" << errno;
     inq_capable_ = false;
   }
 #else
@@ -1355,7 +1355,7 @@ std::unique_ptr<PosixEndpoint> CreatePosixEndpoint(
     EventHandle* handle, PosixEngineClosure* on_shutdown,
     std::shared_ptr<EventEngine> engine, MemoryAllocator&& allocator,
     const PosixTcpOptions& options) {
-  DCHECK_NE(handle, nullptr);
+  ABSL_DCHECK_NE(handle, nullptr);
   return std::make_unique<PosixEndpoint>(handle, on_shutdown, std::move(engine),
                                          std::move(allocator), options);
 }
diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_endpoint.h b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_endpoint.h
index 3ddd318af7542..aea0b61e6adf0 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_endpoint.h
+++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_endpoint.h
@@ -34,8 +34,8 @@
 #include "absl/container/flat_hash_map.h"
 #include "absl/functional/any_invocable.h"
 #include "absl/hash/hash.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "src/core/lib/event_engine/extensions/supports_fd.h"
@@ -129,7 +129,7 @@ class TcpZerocopySendRecord {
   //  sendmsg() failed or when tcp_write() is done.
   bool Unref() {
     const intptr_t prior = ref_.fetch_sub(1, std::memory_order_acq_rel);
-    DCHECK_GT(prior, 0);
+    ABSL_DCHECK_GT(prior, 0);
     if (prior == 1) {
       AllSendsComplete();
       return true;
@@ -144,9 +144,9 @@ class TcpZerocopySendRecord {
   };

   void DebugAssertEmpty() {
-    DCHECK_EQ(buf_.Count(), 0u);
-    DCHECK_EQ(buf_.Length(), 0u);
-    DCHECK_EQ(ref_.load(std::memory_order_relaxed), 0);
+    ABSL_DCHECK_EQ(buf_.Count(), 0u);
+    ABSL_DCHECK_EQ(buf_.Length(), 0u);
+    ABSL_DCHECK_EQ(ref_.load(std::memory_order_relaxed), 0);
   }

   // When all sendmsg() calls associated with this tcp_write() have been
@@ -154,7 +154,7 @@ class TcpZerocopySendRecord {
   // for each sendmsg()) and all reference counts have been dropped, drop our
   // reference to the underlying data since we no longer need it.
   void AllSendsComplete() {
-    DCHECK_EQ(ref_.load(std::memory_order_relaxed), 0);
+    ABSL_DCHECK_EQ(ref_.load(std::memory_order_relaxed), 0);
     buf_.Clear();
   }

@@ -181,7 +181,7 @@ class TcpZerocopySendCtx {
     if (send_records_ == nullptr || free_send_records_ == nullptr) {
       gpr_free(send_records_);
       gpr_free(free_send_records_);
-      VLOG(2) << "Disabling TCP TX zerocopy due to memory pressure.\n";
+      ABSL_VLOG(2) << "Disabling TCP TX zerocopy due to memory pressure.\n";
       memory_limited_ = true;
       enabled_ = false;
     } else {
@@ -235,7 +235,7 @@ class TcpZerocopySendCtx {
     --last_send_;
     if (ReleaseSendRecord(last_send_)->Unref()) {
       // We should still be holding the ref taken by tcp_write().
-      DCHECK(0);
+      ABSL_DCHECK(0);
     }
   }

@@ -273,7 +273,7 @@ class TcpZerocopySendCtx {
   // same time.
   void PutSendRecord(TcpZerocopySendRecord* record) {
     grpc_core::MutexLock lock(&mu_);
-    DCHECK(record >= send_records_ && record < send_records_ + max_sends_);
+    ABSL_DCHECK(record >= send_records_ && record < send_records_ + max_sends_);
     PutSendRecordLocked(record);
   }

@@ -330,7 +330,7 @@ class TcpZerocopySendCtx {
       zcopy_enobuf_state_ = OptMemState::kCheck;
       return false;
     }
-    DCHECK(zcopy_enobuf_state_ != OptMemState::kCheck);
+    ABSL_DCHECK(zcopy_enobuf_state_ != OptMemState::kCheck);
     if (zcopy_enobuf_state_ == OptMemState::kFull) {
       // A previous sendmsg attempt was blocked by ENOBUFS. Return true to
       // mark the fd as writable so the next write attempt could be made.
@@ -421,7 +421,7 @@ class TcpZerocopySendCtx {
   TcpZerocopySendRecord* ReleaseSendRecordLocked(uint32_t seq)
       ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
     auto iter = ctx_lookup_.find(seq);
-    DCHECK(iter != ctx_lookup_.end());
+    ABSL_DCHECK(iter != ctx_lookup_.end());
     TcpZerocopySendRecord* record = iter->second;
     ctx_lookup_.erase(iter);
     return record;
@@ -441,7 +441,7 @@ class TcpZerocopySendCtx {

   void PutSendRecordLocked(TcpZerocopySendRecord* record)
       ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
-    DCHECK(free_send_records_size_ < max_sends_);
+    ABSL_DCHECK(free_send_records_size_ < max_sends_);
     free_send_records_[free_send_records_size_] = record;
     free_send_records_size_++;
   }
diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine.cc
index 739f228e7d1d6..1d6339a9fa4f1 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine.cc
@@ -31,8 +31,8 @@

 #include "absl/cleanup/cleanup.h"
 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/match.h"
 #include "absl/strings/str_cat.h"
@@ -131,7 +131,7 @@ void AsyncConnect::OnWritable(absl::Status status)
   absl::StatusOr<std::unique_ptr<EventEngine::Endpoint>> ep;

   mu_.Lock();
-  CHECK_NE(fd_, nullptr);
+  ABSL_CHECK_NE(fd_, nullptr);
   fd = std::exchange(fd_, nullptr);
   bool connect_cancelled = connect_cancelled_;
   if (fd->IsHandleShutdown() && status.ok()) {
@@ -219,7 +219,7 @@ void AsyncConnect::OnWritable(absl::Status status)
       // your program or another program on the same computer
       // opened too many network connections.  The "easy" fix:
       // don't do that!
-      LOG(ERROR) << "kernel out of buffers";
+      ABSL_LOG(ERROR) << "kernel out of buffers";
       mu_.Unlock();
       fd->NotifyOnWrite(on_writable_);
       // Don't run the cleanup function for this case.
@@ -325,7 +325,7 @@ PosixEnginePollerManager::PosixEnginePollerManager(
       poller_state_(PollerState::kExternal),
       executor_(nullptr),
       trigger_shutdown_called_(false) {
-  DCHECK_NE(poller_, nullptr);
+  ABSL_DCHECK_NE(poller_, nullptr);
 }

 void PosixEnginePollerManager::Run(
@@ -342,7 +342,7 @@ void PosixEnginePollerManager::Run(absl::AnyInvocable<void()> cb) {
 }

 void PosixEnginePollerManager::TriggerShutdown() {
-  DCHECK(trigger_shutdown_called_ == false);
+  ABSL_DCHECK(trigger_shutdown_called_ == false);
   trigger_shutdown_called_ = true;
   // If the poller is external, dont try to shut it down. Otherwise
   // set poller state to PollerState::kShuttingDown.
@@ -455,12 +455,12 @@ PosixEventEngine::~PosixEventEngine() {
     grpc_core::MutexLock lock(&mu_);
     if (GRPC_TRACE_FLAG_ENABLED(event_engine)) {
       for (auto handle : known_handles_) {
-        LOG(ERROR) << "(event_engine) PosixEventEngine:" << this
+        ABSL_LOG(ERROR) << "(event_engine) PosixEventEngine:" << this
                    << " uncleared TaskHandle at shutdown:"
                    << HandleToString(handle);
       }
     }
-    CHECK(GPR_LIKELY(known_handles_.empty()));
+    ABSL_CHECK(GPR_LIKELY(known_handles_.empty()));
   }
   timer_manager_->Shutdown();
 #if GRPC_PLATFORM_SUPPORTS_POSIX_POLLING
@@ -585,7 +585,7 @@ bool PosixEventEngine::CancelConnect(EventEngine::ConnectionHandle handle) {
     auto it = shard->pending_connections.find(connection_handle);
     if (it != shard->pending_connections.end()) {
       ac = it->second;
-      CHECK_NE(ac, nullptr);
+      ABSL_CHECK_NE(ac, nullptr);
       // Trying to acquire ac->mu here would could cause a deadlock because
       // the OnWritable method tries to acquire the two mutexes used
       // here in the reverse order. But we dont need to acquire ac->mu before
@@ -632,7 +632,7 @@ EventEngine::ConnectionHandle PosixEventEngine::Connect(
     const EndpointConfig& args, MemoryAllocator memory_allocator,
     Duration timeout) {
 #if GRPC_PLATFORM_SUPPORTS_POSIX_POLLING
-  CHECK_NE(poller_manager_, nullptr);
+  ABSL_CHECK_NE(poller_manager_, nullptr);
   PosixTcpOptions options = TcpOptionsFromEndpointConfig(args);
   absl::StatusOr<PosixSocketWrapper::PosixSocketCreateResult> socket =
       PosixSocketWrapper::CreateAndPrepareTcpClientSocket(options, addr);
@@ -669,9 +669,9 @@ PosixEventEngine::CreatePosixEndpointFromFd(int fd,
                                             const EndpointConfig& config,
                                             MemoryAllocator memory_allocator) {
 #if GRPC_PLATFORM_SUPPORTS_POSIX_POLLING
-  DCHECK_GT(fd, 0);
+  ABSL_DCHECK_GT(fd, 0);
   PosixEventPoller* poller = poller_manager_->Poller();
-  DCHECK_NE(poller, nullptr);
+  ABSL_DCHECK_NE(poller, nullptr);
   EventHandle* handle =
       poller->CreateHandle(fd, "tcp-client", poller->CanTrackErrors());
   return CreatePosixEndpoint(handle, nullptr, shared_from_this(),
diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
index 8906df34f0169..28fa27acebc91 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine_listener.cc
@@ -34,8 +34,8 @@
 #include <utility>

 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/lib/debug/trace.h"
@@ -77,7 +77,7 @@ absl::StatusOr<int> PosixEngineListenerImpl::Bind(
   EventEngine::ResolvedAddress res_addr = addr;
   EventEngine::ResolvedAddress addr6_v4mapped;
   int requested_port = ResolvedAddressGetPort(res_addr);
-  CHECK(addr.size() <= EventEngine::ResolvedAddress::MAX_SIZE_BYTES);
+  ABSL_CHECK(addr.size() <= EventEngine::ResolvedAddress::MAX_SIZE_BYTES);
   UnlinkIfUnixDomainSocket(addr);

   /// Check if this is a wildcard port, and if so, try to keep the port the same
@@ -152,7 +152,7 @@ void PosixEngineListenerImpl::AsyncConnectionAcceptor::NotifyOnAccept(
           // nothing to accept. This is not a performant code path, but if an fd
           // limit has been reached, the system is likely in an unhappy state
           // regardless.
-          LOG_EVERY_N_SEC(ERROR, 1)
+          ABSL_LOG_EVERY_N_SEC(ERROR, 1)
               << "File descriptor limit reached. Retrying.";
           handle_->NotifyOnRead(notify_on_accept_);
           // Do not schedule another timer if one is already armed.
@@ -174,7 +174,7 @@ void PosixEngineListenerImpl::AsyncConnectionAcceptor::NotifyOnAccept(
           handle_->NotifyOnRead(notify_on_accept_);
           return;
         default:
-          LOG(ERROR) << "Closing acceptor. Failed accept4: "
+          ABSL_LOG(ERROR) << "Closing acceptor. Failed accept4: "
                      << grpc_core::StrError(errno);
           // Shutting down the acceptor. Unref the ref grabbed in
           // AsyncConnectionAcceptor::Start().
@@ -189,7 +189,7 @@ void PosixEngineListenerImpl::AsyncConnectionAcceptor::NotifyOnAccept(
       socklen_t len = EventEngine::ResolvedAddress::MAX_SIZE_BYTES;
       if (getpeername(fd, const_cast<sockaddr*>(addr.address()), &len) < 0) {
         auto listener_addr_uri = ResolvedAddressToURI(socket_.addr);
-        LOG(ERROR) << "Failed getpeername: " << grpc_core::StrError(errno)
+        ABSL_LOG(ERROR) << "Failed getpeername: " << grpc_core::StrError(errno)
                    << ". Dropping the connection, and continuing "
                       "to listen on "
                    << (listener_addr_uri.ok() ? *listener_addr_uri
@@ -207,7 +207,7 @@ void PosixEngineListenerImpl::AsyncConnectionAcceptor::NotifyOnAccept(
     auto result = sock.ApplySocketMutatorInOptions(
         GRPC_FD_SERVER_CONNECTION_USAGE, listener_->options_);
     if (!result.ok()) {
-      LOG(ERROR) << "Closing acceptor. Failed to apply socket mutator: "
+      ABSL_LOG(ERROR) << "Closing acceptor. Failed to apply socket mutator: "
                  << result;
       // Shutting down the acceptor. Unref the ref grabbed in
       // AsyncConnectionAcceptor::Start().
@@ -218,7 +218,7 @@ void PosixEngineListenerImpl::AsyncConnectionAcceptor::NotifyOnAccept(
     // Create an Endpoint here.
     auto peer_name = ResolvedAddressToURI(addr);
     if (!peer_name.ok()) {
-      LOG(ERROR) << "Invalid address: " << peer_name.status();
+      ABSL_LOG(ERROR) << "Invalid address: " << peer_name.status();
       // Shutting down the acceptor. Unref the ref grabbed in
       // AsyncConnectionAcceptor::Start().
       Unref();
@@ -299,7 +299,7 @@ void PosixEngineListenerImpl::AsyncConnectionAcceptor::Shutdown() {
 absl::Status PosixEngineListenerImpl::Start() {
   grpc_core::MutexLock lock(&this->mu_);
   // Start each asynchronous acceptor.
-  CHECK(!this->started_);
+  ABSL_CHECK(!this->started_);
   this->started_ = true;
   for (auto it = acceptors_.begin(); it != acceptors_.end(); it++) {
     (*it)->Start();
diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine_listener_utils.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine_listener_utils.cc
index 23ad660870f9d..20c7f8a4d3eb6 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine_listener_utils.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/posix_engine_listener_utils.cc
@@ -24,8 +24,8 @@
 #include <string>

 #include "absl/cleanup/cleanup.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_replace.h"
@@ -117,7 +117,7 @@ int InitMaxAcceptQueueSize() {
   max_accept_queue_size = n;

   if (max_accept_queue_size < MIN_SAFE_ACCEPT_QUEUE_SIZE) {
-    LOG(INFO) << "Suspiciously small accept queue (" << max_accept_queue_size
+    ABSL_LOG(INFO) << "Suspiciously small accept queue (" << max_accept_queue_size
               << ") will probably lead to connection drops";
   }
   return max_accept_queue_size;
@@ -133,7 +133,7 @@ absl::Status PrepareSocket(const PosixTcpOptions& options,
                            ListenerSocket& socket) {
   ResolvedAddress sockname_temp;
   int fd = socket.sock.Fd();
-  CHECK_GE(fd, 0);
+  ABSL_CHECK_GE(fd, 0);
   bool close_fd = true;
   socket.zero_copy_enabled = false;
   socket.port = 0;
@@ -151,7 +151,7 @@ absl::Status PrepareSocket(const PosixTcpOptions& options,
 #ifdef GRPC_LINUX_ERRQUEUE
   if (!socket.sock.SetSocketZeroCopy().ok()) {
     // it's not fatal, so just log it.
-    VLOG(2) << "Node does not support SO_ZEROCOPY, continuing.";
+    ABSL_VLOG(2) << "Node does not support SO_ZEROCOPY, continuing.";
   } else {
     socket.zero_copy_enabled = true;
   }
@@ -174,7 +174,7 @@ absl::Status PrepareSocket(const PosixTcpOptions& options,
   if (bind(fd, socket.addr.address(), socket.addr.size()) < 0) {
     auto sockaddr_str = ResolvedAddressToString(socket.addr);
     if (!sockaddr_str.ok()) {
-      LOG(ERROR) << "Could not convert sockaddr to string: "
+      ABSL_LOG(ERROR) << "Could not convert sockaddr to string: "
                  << sockaddr_str.status();
       sockaddr_str = "<unparsable>";
     }
@@ -222,7 +222,7 @@ absl::StatusOr<ListenerSocket> CreateAndPrepareListenerSocket(
     socket.addr = addr;
   }
   GRPC_RETURN_IF_ERROR(PrepareSocket(options, socket));
-  CHECK_GT(socket.port, 0);
+  ABSL_CHECK_GT(socket.port, 0);
   return socket;
 }

@@ -239,7 +239,7 @@ absl::StatusOr<int> ListenerContainerAddAllLocalAddresses(
     auto result = GetUnusedPort();
     GRPC_RETURN_IF_ERROR(result.status());
     requested_port = *result;
-    VLOG(2) << "Picked unused port " << requested_port;
+    ABSL_VLOG(2) << "Picked unused port " << requested_port;
   }
   if (getifaddrs(&ifa) != 0 || ifa == nullptr) {
     return absl::FailedPreconditionError(
@@ -271,13 +271,13 @@ absl::StatusOr<int> ListenerContainerAddAllLocalAddresses(
     addr = EventEngine::ResolvedAddress(ifa_it->ifa_addr, len);
     ResolvedAddressSetPort(addr, requested_port);
     std::string addr_str = *ResolvedAddressToString(addr);
-    VLOG(2) << absl::StrFormat(
+    ABSL_VLOG(2) << absl::StrFormat(
         "Adding local addr from interface %s flags 0x%x to server: %s",
         ifa_name, ifa_it->ifa_flags, addr_str.c_str());
     // We could have multiple interfaces with the same address (e.g.,
     // bonding), so look for duplicates.
     if (listener_sockets.Find(addr).ok()) {
-      VLOG(2) << "Skipping duplicate addr " << addr_str << " on interface "
+      ABSL_VLOG(2) << "Skipping duplicate addr " << addr_str << " on interface "
               << ifa_name;
       continue;
     }
@@ -342,19 +342,19 @@ absl::StatusOr<int> ListenerContainerAddWildcardAddresses(
   }
   if (assigned_port > 0) {
     if (!v6_sock.ok()) {
-      VLOG(2) << "Failed to add :: listener, the environment may not support "
+      ABSL_VLOG(2) << "Failed to add :: listener, the environment may not support "
                  "IPv6: "
               << v6_sock.status();
     }
     if (!v4_sock.ok()) {
-      VLOG(2) << "Failed to add 0.0.0.0 listener, "
+      ABSL_VLOG(2) << "Failed to add 0.0.0.0 listener, "
                  "the environment may not support IPv4: "
               << v4_sock.status();
     }
     return assigned_port;
   } else {
-    CHECK(!v6_sock.ok());
-    CHECK(!v4_sock.ok());
+    ABSL_CHECK(!v6_sock.ok());
+    ABSL_CHECK(!v4_sock.ok());
     return absl::FailedPreconditionError(absl::StrCat(
         "Failed to add any wildcard listeners: ", v6_sock.status().message(),
         v4_sock.status().message()));
diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/tcp_socket_utils.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/tcp_socket_utils.cc
index 7cce3548323a7..4add0063bc07c 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/tcp_socket_utils.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/tcp_socket_utils.cc
@@ -47,8 +47,8 @@
 #include <atomic>
 #include <cstring>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "src/core/lib/event_engine/tcp_socket_utils.h"
 #include "src/core/util/status_helper.h"
@@ -103,7 +103,7 @@ int CreateSocket(std::function<int(int, int, int)> socket_factory, int family,
                                       : socket(family, type, protocol);
   if (res < 0 && errno == EMFILE) {
     int saved_errno = errno;
-    LOG_EVERY_N_SEC(ERROR, 10)
+    ABSL_LOG_EVERY_N_SEC(ERROR, 10)
         << "socket(" << family << ", " << type << ", " << protocol
         << ") returned " << res << " with error: |"
         << grpc_core::StrError(errno)
@@ -647,18 +647,18 @@ void PosixSocketWrapper::TrySetSocketTcpUserTimeout(
     if (g_socket_supports_tcp_user_timeout.load() > 0) {
       if (0 != setsockopt(fd_, IPPROTO_TCP, TCP_USER_TIMEOUT, &timeout,
                           sizeof(timeout))) {
-        LOG(ERROR) << "setsockopt(TCP_USER_TIMEOUT) "
+        ABSL_LOG(ERROR) << "setsockopt(TCP_USER_TIMEOUT) "
                    << grpc_core::StrError(errno);
         return;
       }
       if (0 != getsockopt(fd_, IPPROTO_TCP, TCP_USER_TIMEOUT, &newval, &len)) {
-        LOG(ERROR) << "getsockopt(TCP_USER_TIMEOUT) "
+        ABSL_LOG(ERROR) << "getsockopt(TCP_USER_TIMEOUT) "
                    << grpc_core::StrError(errno);
         return;
       }
       if (newval != timeout) {
         // Do not fail on failing to set TCP_USER_TIMEOUT
-        LOG(ERROR) << "Failed to set TCP_USER_TIMEOUT";
+        ABSL_LOG(ERROR) << "Failed to set TCP_USER_TIMEOUT";
         return;
       }
     }
@@ -668,7 +668,7 @@ void PosixSocketWrapper::TrySetSocketTcpUserTimeout(
 // Set a socket using a grpc_socket_mutator
 absl::Status PosixSocketWrapper::SetSocketMutator(
     grpc_fd_usage usage, grpc_socket_mutator* mutator) {
-  CHECK(mutator);
+  ABSL_CHECK(mutator);
   if (!grpc_socket_mutator_mutate_fd(mutator, fd_, usage)) {
     return absl::Status(absl::StatusCode::kInternal,
                         "grpc_socket_mutator failed.");
diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/tcp_socket_utils.h b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/tcp_socket_utils.h
index 2b07e16f5e276..cf72c86f57cd1 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/tcp_socket_utils.h
+++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/tcp_socket_utils.h
@@ -25,7 +25,7 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "src/core/lib/iomgr/port.h"
@@ -159,7 +159,7 @@ void UnlinkIfUnixDomainSocket(

 class PosixSocketWrapper {
  public:
-  explicit PosixSocketWrapper(int fd) : fd_(fd) { CHECK_GT(fd_, 0); }
+  explicit PosixSocketWrapper(int fd) : fd_(fd) { ABSL_CHECK_GT(fd_, 0); }

   PosixSocketWrapper() : fd_(-1) {};

diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/timer_manager.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/timer_manager.cc
index 2ce6087b74092..9fba763116729 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/timer_manager.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/timer_manager.cc
@@ -25,8 +25,8 @@
 #include <optional>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/time/time.h"
 #include "src/core/lib/debug/trace.h"

@@ -65,7 +65,7 @@ void TimerManager::MainLoop() {
   grpc_core::Timestamp next = grpc_core::Timestamp::InfFuture();
   std::optional<std::vector<experimental::EventEngine::Closure*>> check_result =
       timer_list_->TimerCheck(&next);
-  CHECK(check_result.has_value())
+  ABSL_CHECK(check_result.has_value())
       << "ERROR: More than one MainLoop is running.";
   bool timers_found = !check_result->empty();
   if (timers_found) {
@@ -100,7 +100,7 @@ void TimerManager::TimerInit(Timer* timer, grpc_core::Timestamp deadline,
   if (GRPC_TRACE_FLAG_ENABLED(timer)) {
     grpc_core::MutexLock lock(&mu_);
     if (shutdown_) {
-      LOG(ERROR) << "WARNING: TimerManager::" << this
+      ABSL_LOG(ERROR) << "WARNING: TimerManager::" << this
                  << ": scheduling Closure::" << closure
                  << " after TimerManager has been shut down.";
     }
@@ -137,7 +137,7 @@ void TimerManager::Kick() {

 void TimerManager::RestartPostFork() {
   grpc_core::MutexLock lock(&mu_);
-  CHECK(GPR_LIKELY(shutdown_));
+  ABSL_CHECK(GPR_LIKELY(shutdown_));
   GRPC_TRACE_VLOG(timer, 2)
       << "TimerManager::" << this << " restarting after shutdown";
   shutdown_ = false;
diff --git a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/traced_buffer_list.cc b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/traced_buffer_list.cc
index 6db28efd6faf6..1b688aa5fd512 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/posix_engine/traced_buffer_list.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/posix_engine/traced_buffer_list.cc
@@ -24,7 +24,7 @@
 #include <utility>

 #include "absl/functional/any_invocable.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/iomgr/port.h"
 #include "src/core/util/sync.h"

@@ -45,7 +45,7 @@ void FillGprFromTimestamp(gpr_timespec* gts, const struct timespec* ts) {

 void DefaultTimestampsCallback(void* /*arg*/, Timestamps* /*ts*/,
                                absl::Status /*shutdown_err*/) {
-  VLOG(2) << "Timestamps callback has not been registered";
+  ABSL_VLOG(2) << "Timestamps callback has not been registered";
 }

 // The saved callback function that will be invoked when we get all the
diff --git a/third_party/grpc/source/src/core/lib/event_engine/resolved_address.cc b/third_party/grpc/source/src/core/lib/event_engine/resolved_address.cc
index ac7ba92563096..416530eab0036 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/resolved_address.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/resolved_address.cc
@@ -18,7 +18,7 @@
 #include <grpc/support/port_platform.h>
 #include <string.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/event_engine/resolved_address_internal.h"

 // IWYU pragma: no_include <sys/socket.h>
@@ -28,8 +28,8 @@ namespace grpc_event_engine::experimental {
 EventEngine::ResolvedAddress::ResolvedAddress(const sockaddr* address,
                                               socklen_t size)
     : size_(size) {
-  DCHECK_GE(size, 0u);
-  CHECK(static_cast<size_t>(size) <= sizeof(address_));
+  ABSL_DCHECK_GE(size, 0u);
+  ABSL_CHECK(static_cast<size_t>(size) <= sizeof(address_));
   memcpy(&address_, address, size);
 }

diff --git a/third_party/grpc/source/src/core/lib/event_engine/slice.cc b/third_party/grpc/source/src/core/lib/event_engine/slice.cc
index 851d3f7de4900..4ba072263d482 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/slice.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/slice.cc
@@ -22,7 +22,7 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/slice/slice_internal.h"
 #include "src/core/lib/slice/slice_refcount.h"

@@ -46,7 +46,7 @@ Slice CopyConstructors<Slice>::FromCopiedString(std::string s) {

 MutableSlice::MutableSlice(const grpc_slice& slice)
     : slice_detail::BaseSlice(slice) {
-  DCHECK(slice.refcount == nullptr || slice.refcount->IsUnique());
+  ABSL_DCHECK(slice.refcount == nullptr || slice.refcount->IsUnique());
 }

 MutableSlice::~MutableSlice() { grpc_core::CSliceUnref(c_slice()); }
diff --git a/third_party/grpc/source/src/core/lib/event_engine/tcp_socket_utils.cc b/third_party/grpc/source/src/core/lib/event_engine/tcp_socket_utils.cc
index 2ba754595868b..823952402180f 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/tcp_socket_utils.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/tcp_socket_utils.cc
@@ -53,8 +53,8 @@

 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
@@ -215,7 +215,7 @@ bool ResolvedAddressIsV4Mapped(
 bool ResolvedAddressToV4Mapped(
     const EventEngine::ResolvedAddress& resolved_addr,
     EventEngine::ResolvedAddress* resolved_addr6_out) {
-  CHECK(&resolved_addr != resolved_addr6_out);
+  ABSL_CHECK(&resolved_addr != resolved_addr6_out);
   const sockaddr* addr = resolved_addr.address();
   sockaddr_in6* addr6_out = const_cast<sockaddr_in6*>(
       reinterpret_cast<const sockaddr_in6*>(resolved_addr6_out->address()));
@@ -237,8 +237,8 @@ EventEngine::ResolvedAddress ResolvedAddressMakeWild6(int port) {
   EventEngine::ResolvedAddress resolved_wild_out;
   sockaddr_in6* wild_out = reinterpret_cast<sockaddr_in6*>(
       const_cast<sockaddr*>(resolved_wild_out.address()));
-  CHECK_GE(port, 0);
-  CHECK_LT(port, 65536);
+  ABSL_CHECK_GE(port, 0);
+  ABSL_CHECK_LT(port, 65536);
   memset(wild_out, 0, sizeof(sockaddr_in6));
   wild_out->sin6_family = AF_INET6;
   wild_out->sin6_port = htons(static_cast<uint16_t>(port));
@@ -251,8 +251,8 @@ EventEngine::ResolvedAddress ResolvedAddressMakeWild4(int port) {
   EventEngine::ResolvedAddress resolved_wild_out;
   sockaddr_in* wild_out = reinterpret_cast<sockaddr_in*>(
       const_cast<sockaddr*>(resolved_wild_out.address()));
-  CHECK_GE(port, 0);
-  CHECK_LT(port, 65536);
+  ABSL_CHECK_GE(port, 0);
+  ABSL_CHECK_LT(port, 65536);
   memset(wild_out, 0, sizeof(sockaddr_in));
   wild_out->sin_family = AF_INET;
   wild_out->sin_port = htons(static_cast<uint16_t>(port));
@@ -277,7 +277,7 @@ int ResolvedAddressGetPort(const EventEngine::ResolvedAddress& resolved_addr) {
       return 1;
 #endif
     default:
-      LOG(ERROR) << "Unknown socket family " << addr->sa_family
+      ABSL_LOG(ERROR) << "Unknown socket family " << addr->sa_family
                  << " in ResolvedAddressGetPort";
       abort();
   }
@@ -288,19 +288,19 @@ void ResolvedAddressSetPort(EventEngine::ResolvedAddress& resolved_addr,
   sockaddr* addr = const_cast<sockaddr*>(resolved_addr.address());
   switch (addr->sa_family) {
     case AF_INET:
-      CHECK_GE(port, 0);
-      CHECK_LT(port, 65536);
+      ABSL_CHECK_GE(port, 0);
+      ABSL_CHECK_LT(port, 65536);
       (reinterpret_cast<sockaddr_in*>(addr))->sin_port =
           htons(static_cast<uint16_t>(port));
       return;
     case AF_INET6:
-      CHECK_GE(port, 0);
-      CHECK_LT(port, 65536);
+      ABSL_CHECK_GE(port, 0);
+      ABSL_CHECK_LT(port, 65536);
       (reinterpret_cast<sockaddr_in6*>(addr))->sin6_port =
           htons(static_cast<uint16_t>(port));
       return;
     default:
-      LOG(ERROR) << "Unknown socket family " << addr->sa_family
+      ABSL_LOG(ERROR) << "Unknown socket family " << addr->sa_family
                  << " in grpc_sockaddr_set_port";
       abort();
   }
@@ -437,10 +437,10 @@ absl::StatusOr<EventEngine::ResolvedAddress> URIToResolvedAddress(
   grpc_resolved_address addr;
   absl::StatusOr<grpc_core::URI> uri = grpc_core::URI::Parse(address_str);
   if (!uri.ok()) {
-    LOG(ERROR) << "Failed to parse URI. Error: " << uri.status();
+    ABSL_LOG(ERROR) << "Failed to parse URI. Error: " << uri.status();
   }
   GRPC_RETURN_IF_ERROR(uri.status());
-  CHECK(grpc_parse_uri(*uri, &addr));
+  ABSL_CHECK(grpc_parse_uri(*uri, &addr));
   return EventEngine::ResolvedAddress(
       reinterpret_cast<const sockaddr*>(addr.addr), addr.len);
 }
diff --git a/third_party/grpc/source/src/core/lib/event_engine/thread_pool/thread_count.cc b/third_party/grpc/source/src/core/lib/event_engine/thread_pool/thread_count.cc
index 3bf4885eb5b1a..326701427b3cb 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/thread_pool/thread_count.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/thread_pool/thread_count.cc
@@ -18,7 +18,7 @@

 #include <cstddef>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_format.h"
 #include "absl/time/clock.h"
diff --git a/third_party/grpc/source/src/core/lib/event_engine/thread_pool/work_stealing_thread_pool.cc b/third_party/grpc/source/src/core/lib/event_engine/thread_pool/work_stealing_thread_pool.cc
index 955881a52cc50..83324c9247816 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/thread_pool/work_stealing_thread_pool.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/thread_pool/work_stealing_thread_pool.cc
@@ -29,8 +29,8 @@
 #include <utility>

 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/time/clock.h"
 #include "absl/time/time.h"
 #include "src/core/lib/debug/trace.h"
@@ -153,10 +153,10 @@ std::atomic<size_t> g_reported_dump_count{0};
 void DumpSignalHandler(int /* sig */) {
   const auto trace = grpc_core::GetCurrentStackTrace();
   if (!trace.has_value()) {
-    LOG(ERROR) << "DumpStack::" << gpr_thd_currentid()
+    ABSL_LOG(ERROR) << "DumpStack::" << gpr_thd_currentid()
                << ": Stack trace not available";
   } else {
-    LOG(ERROR) << "DumpStack::" << gpr_thd_currentid() << ": " << trace.value();
+    ABSL_LOG(ERROR) << "DumpStack::" << gpr_thd_currentid() << ": " << trace.value();
   }
   g_reported_dump_count.fetch_add(1);
   grpc_core::Thread::Kill(gpr_thd_currentid());
@@ -180,7 +180,7 @@ WorkStealingThreadPool::WorkStealingThreadPool(size_t reserve_threads)
 void WorkStealingThreadPool::Quiesce() { pool_->Quiesce(); }

 WorkStealingThreadPool::~WorkStealingThreadPool() {
-  CHECK(pool_->IsQuiesced());
+  ABSL_CHECK(pool_->IsQuiesced());
 }

 void WorkStealingThreadPool::Run(absl::AnyInvocable<void()> callback) {
@@ -235,7 +235,7 @@ void WorkStealingThreadPool::WorkStealingThreadPoolImpl::Start() {

 void WorkStealingThreadPool::WorkStealingThreadPoolImpl::Run(
     EventEngine::Closure* closure) {
-  CHECK(!IsQuiesced());
+  ABSL_CHECK(!IsQuiesced());
   if (g_local_queue != nullptr && g_local_queue->owner() == this) {
     g_local_queue->Add(closure);
   } else {
@@ -277,7 +277,7 @@ void WorkStealingThreadPool::WorkStealingThreadPoolImpl::Quiesce() {
   if (!threads_were_shut_down.ok() && g_log_verbose_failures) {
     DumpStacksAndCrash();
   }
-  CHECK(queue_.Empty());
+  ABSL_CHECK(queue_.Empty());
   quiesced_.store(true, std::memory_order_relaxed);
   grpc_core::MutexLock lock(&lifeguard_ptr_mu_);
   lifeguard_.reset();
@@ -291,14 +291,14 @@ bool WorkStealingThreadPool::WorkStealingThreadPoolImpl::SetThrottled(
 void WorkStealingThreadPool::WorkStealingThreadPoolImpl::SetShutdown(
     bool is_shutdown) {
   auto was_shutdown = shutdown_.exchange(is_shutdown);
-  CHECK(is_shutdown != was_shutdown);
+  ABSL_CHECK(is_shutdown != was_shutdown);
   work_signal_.SignalAll();
 }

 void WorkStealingThreadPool::WorkStealingThreadPoolImpl::SetForking(
     bool is_forking) {
   auto was_forking = forking_.exchange(is_forking);
-  CHECK(is_forking != was_forking);
+  ABSL_CHECK(is_forking != was_forking);
 }

 bool WorkStealingThreadPool::WorkStealingThreadPoolImpl::IsForking() {
@@ -346,7 +346,7 @@ void WorkStealingThreadPool::WorkStealingThreadPoolImpl::UntrackThread(

 void WorkStealingThreadPool::WorkStealingThreadPoolImpl::DumpStacksAndCrash() {
   grpc_core::MutexLock lock(&thd_set_mu_);
-  LOG(ERROR) << "Pool did not quiesce in time, gRPC will not shut down "
+  ABSL_LOG(ERROR) << "Pool did not quiesce in time, gRPC will not shut down "
                 "cleanly. Dumping all "
              << thds_.size() << " thread stacks.";
   for (const auto tid : thds_) {
@@ -500,7 +500,7 @@ void WorkStealingThreadPool::ThreadState::ThreadBody() {
   } else if (pool_->IsShutdown()) {
     FinishDraining();
   }
-  CHECK(g_local_queue->Empty());
+  ABSL_CHECK(g_local_queue->Empty());
   pool_->theft_registry()->Unenroll(g_local_queue);
   delete g_local_queue;
   if (g_log_verbose_failures) {
diff --git a/third_party/grpc/source/src/core/lib/event_engine/windows/grpc_polled_fd_windows.cc b/third_party/grpc/source/src/core/lib/event_engine/windows/grpc_polled_fd_windows.cc
index c022e35d0ece0..61f710a7b72db 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/windows/grpc_polled_fd_windows.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/windows/grpc_polled_fd_windows.cc
@@ -23,7 +23,7 @@
 #include <winsock2.h>

 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_format.h"
 #include "src/core/lib/address_utils/sockaddr_utils.h"
@@ -129,8 +129,8 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
         << "| ~GrpcPolledFdWindows shutdown_called_: " << shutdown_called_;
     grpc_core::CSliceUnref(read_buf_);
     grpc_core::CSliceUnref(write_buf_);
-    CHECK(read_closure_ == nullptr);
-    CHECK(write_closure_ == nullptr);
+    ABSL_CHECK(read_closure_ == nullptr);
+    ABSL_CHECK(write_closure_ == nullptr);
     if (!shutdown_called_) {
       winsocket_->Shutdown(DEBUG_LOCATION, "~GrpcPolledFdWindows");
     }
@@ -138,15 +138,15 @@ class GrpcPolledFdWindows : public GrpcPolledFd {

   void RegisterForOnReadableLocked(
       absl::AnyInvocable<void(absl::Status)> read_closure) override {
-    CHECK(read_closure_ == nullptr);
+    ABSL_CHECK(read_closure_ == nullptr);
     read_closure_ = std::move(read_closure);
     grpc_core::CSliceUnref(read_buf_);
-    CHECK(!read_buf_has_data_);
+    ABSL_CHECK(!read_buf_has_data_);
     read_buf_ = GRPC_SLICE_MALLOC(kReadBufferSize);
     if (connect_done_) {
       ContinueRegisterForOnReadableLocked();
     } else {
-      CHECK(pending_continue_register_for_on_readable_locked_ == false);
+      ABSL_CHECK(pending_continue_register_for_on_readable_locked_ == false);
       pending_continue_register_for_on_readable_locked_ = true;
     }
   }
@@ -158,17 +158,17 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
           << "(EventEngine c-ares resolver) fd:|" << GetName()
           << "| RegisterForOnWriteableLocked called";
     } else {
-      CHECK(socket_type_ == SOCK_STREAM);
+      ABSL_CHECK(socket_type_ == SOCK_STREAM);
       GRPC_TRACE_LOG(cares_resolver, INFO)
           << "(EventEngine c-ares resolver) fd:|" << GetName()
           << "| RegisterForOnWriteableLocked called tcp_write_state_: "
           << static_cast<int>(tcp_write_state_)
           << " connect_done_: " << connect_done_;
     }
-    CHECK(write_closure_ == nullptr);
+    ABSL_CHECK(write_closure_ == nullptr);
     write_closure_ = std::move(write_closure);
     if (!connect_done_) {
-      CHECK(!pending_continue_register_for_on_writeable_locked_);
+      ABSL_CHECK(!pending_continue_register_for_on_writeable_locked_);
       pending_continue_register_for_on_writeable_locked_ = true;
     } else {
       ContinueRegisterForOnWriteableLocked();
@@ -178,7 +178,7 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
   bool IsFdStillReadableLocked() override { return read_buf_has_data_; }

   bool ShutdownLocked(absl::Status error) override {
-    CHECK(!shutdown_called_);
+    ABSL_CHECK(!shutdown_called_);
     if (!absl::IsCancelled(error)) {
       return false;
     }
@@ -223,7 +223,7 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
     // c-ares overloads this recv_from virtual socket function to receive
     // data on both UDP and TCP sockets, and from is nullptr for TCP.
     if (from != nullptr) {
-      CHECK(*from_len >= recv_from_source_addr_len_);
+      ABSL_CHECK(*from_len >= recv_from_source_addr_len_);
       memcpy(from, &recv_from_source_addr_, recv_from_source_addr_len_);
       *from_len = recv_from_source_addr_len_;
     }
@@ -292,7 +292,7 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
         << "(EventEngine c-ares resolver) fd:|" << GetName()
         << "| ContinueRegisterForOnReadableLocked wsa_connect_error_:"
         << wsa_connect_error_;
-    CHECK(connect_done_);
+    ABSL_CHECK(connect_done_);
     if (wsa_connect_error_ != 0) {
       ScheduleAndNullReadClosure(GRPC_WSA_ERROR(wsa_connect_error_, "connect"));
       return;
@@ -329,7 +329,7 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
         << "(EventEngine c-ares resolver) fd:|" << GetName()
         << "| ContinueRegisterForOnWriteableLocked wsa_connect_error_:"
         << wsa_connect_error_;
-    CHECK(connect_done_);
+    ABSL_CHECK(connect_done_);
     if (wsa_connect_error_ != 0) {
       ScheduleAndNullWriteClosure(
           GRPC_WSA_ERROR(wsa_connect_error_, "connect"));
@@ -339,7 +339,7 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
       ScheduleAndNullWriteClosure(absl::OkStatus());
       return;
     }
-    CHECK(socket_type_ == SOCK_STREAM);
+    ABSL_CHECK(socket_type_ == SOCK_STREAM);
     int wsa_error_code = 0;
     switch (tcp_write_state_) {
       case WRITE_IDLE:
@@ -388,7 +388,7 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
     // to write everything inline.
     GRPC_TRACE_LOG(cares_resolver, INFO) << "(EventEngine c-ares resolver) fd:|"
                                          << GetName() << "| SendVUDP called";
-    CHECK_EQ(GRPC_SLICE_LENGTH(write_buf_), 0);
+    ABSL_CHECK_EQ(GRPC_SLICE_LENGTH(write_buf_), 0);
     grpc_core::CSliceUnref(write_buf_);
     write_buf_ = FlattenIovec(iov, iov_count);
     DWORD bytes_sent = 0;
@@ -439,11 +439,11 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
         // send again. If c-ares still needs to send even more data, we'll get
         // to it eventually.
         grpc_slice currently_attempted = FlattenIovec(iov, iov_count);
-        CHECK(GRPC_SLICE_LENGTH(currently_attempted) >=
+        ABSL_CHECK(GRPC_SLICE_LENGTH(currently_attempted) >=
               GRPC_SLICE_LENGTH(write_buf_));
         ares_ssize_t total_sent = 0;
         for (size_t i = 0; i < GRPC_SLICE_LENGTH(write_buf_); i++) {
-          CHECK(GRPC_SLICE_START_PTR(currently_attempted)[i] ==
+          ABSL_CHECK(GRPC_SLICE_START_PTR(currently_attempted)[i] ==
                 GRPC_SLICE_START_PTR(write_buf_)[i]);
           total_sent++;
         }
@@ -463,9 +463,9 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
         << pending_continue_register_for_on_readable_locked_
         << " pending_register_for_writeable:"
         << pending_continue_register_for_on_writeable_locked_;
-    CHECK(!connect_done_);
+    ABSL_CHECK(!connect_done_);
     connect_done_ = true;
-    CHECK_EQ(wsa_connect_error_, 0);
+    ABSL_CHECK_EQ(wsa_connect_error_, 0);
     if (shutdown_called_) {
       wsa_connect_error_ = WSA_OPERATION_ABORTED;
     } else {
@@ -474,7 +474,7 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
       BOOL wsa_success = WSAGetOverlappedResult(
           winsocket_->raw_socket(), winsocket_->write_info()->overlapped(),
           &transferred_bytes, FALSE, &flags);
-      CHECK_EQ(transferred_bytes, 0);
+      ABSL_CHECK_EQ(transferred_bytes, 0);
       if (!wsa_success) {
         wsa_connect_error_ = WSAGetLastError();
         char* msg = gpr_format_message(wsa_connect_error_);
@@ -497,8 +497,8 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
                  ares_socklen_t target_len) {
     GRPC_TRACE_LOG(cares_resolver, INFO)
         << "(EventEngine c-ares resolver) fd:" << GetName() << " ConnectUDP";
-    CHECK(!connect_done_);
-    CHECK_EQ(wsa_connect_error_, 0);
+    ABSL_CHECK(!connect_done_);
+    ABSL_CHECK_EQ(wsa_connect_error_, 0);
     SOCKET s = winsocket_->raw_socket();
     int out =
         WSAConnect(s, target, target_len, nullptr, nullptr, nullptr, nullptr);
@@ -636,7 +636,7 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
     GRPC_TRACE_LOG(cares_resolver, INFO)
         << "(EventEngine c-ares resolver) OnIocpWriteableInner. fd:|"
         << GetName() << "|";
-    CHECK(socket_type_ == SOCK_STREAM);
+    ABSL_CHECK(socket_type_ == SOCK_STREAM);
     absl::Status error;
     if (winsocket_->write_info()->result().wsa_error != 0) {
       error = GRPC_WSA_ERROR(winsocket_->write_info()->result().wsa_error,
@@ -648,7 +648,7 @@ class GrpcPolledFdWindows : public GrpcPolledFd {
           << winsocket_->write_info()->result().wsa_error << "| msg:|"
           << grpc_core::StatusToString(error) << "|";
     }
-    CHECK(tcp_write_state_ == WRITE_PENDING);
+    ABSL_CHECK(tcp_write_state_ == WRITE_PENDING);
     if (error.ok()) {
       tcp_write_state_ = WRITE_WAITING_FOR_VERIFICATION_UPON_RETRY;
       write_buf_ = grpc_slice_sub_no_ref(
@@ -735,7 +735,7 @@ class CustomSockFuncs {
         << "(EventEngine c-ares resolver) fd:" << polled_fd->GetName()
         << " created with params af:" << af << " type:" << type
         << " protocol:" << protocol;
-    CHECK(self->sockets_.insert({s, std::move(polled_fd)}).second);
+    ABSL_CHECK(self->sockets_.insert({s, std::move(polled_fd)}).second);
     return s;
   }

@@ -745,7 +745,7 @@ class CustomSockFuncs {
     GrpcPolledFdFactoryWindows* self =
         static_cast<GrpcPolledFdFactoryWindows*>(user_data);
     auto it = self->sockets_.find(as);
-    CHECK(it != self->sockets_.end());
+    ABSL_CHECK(it != self->sockets_.end());
     return it->second->Connect(&wsa_error_ctx, target, target_len);
   }

@@ -755,7 +755,7 @@ class CustomSockFuncs {
     GrpcPolledFdFactoryWindows* self =
         static_cast<GrpcPolledFdFactoryWindows*>(user_data);
     auto it = self->sockets_.find(as);
-    CHECK(it != self->sockets_.end());
+    ABSL_CHECK(it != self->sockets_.end());
     return it->second->SendV(&wsa_error_ctx, iov, iovec_count);
   }

@@ -766,7 +766,7 @@ class CustomSockFuncs {
     GrpcPolledFdFactoryWindows* self =
         static_cast<GrpcPolledFdFactoryWindows*>(user_data);
     auto it = self->sockets_.find(as);
-    CHECK(it != self->sockets_.end());
+    ABSL_CHECK(it != self->sockets_.end());
     return it->second->RecvFrom(&wsa_error_ctx, data, data_len, flags, from,
                                 from_len);
   }
@@ -827,7 +827,7 @@ void GrpcPolledFdFactoryWindows::Initialize(grpc_core::Mutex* mutex,
 std::unique_ptr<GrpcPolledFd> GrpcPolledFdFactoryWindows::NewGrpcPolledFdLocked(
     ares_socket_t as) {
   auto it = sockets_.find(as);
-  CHECK(it != sockets_.end());
+  ABSL_CHECK(it != sockets_.end());
   return std::make_unique<GrpcPolledFdWrapper>(it->second.get());
 }

diff --git a/third_party/grpc/source/src/core/lib/event_engine/windows/iocp.cc b/third_party/grpc/source/src/core/lib/event_engine/windows/iocp.cc
index 45da92053764a..b7e6776580e53 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/windows/iocp.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/windows/iocp.cc
@@ -20,7 +20,7 @@

 #include <chrono>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_format.h"
 #include "src/core/lib/event_engine/thread_pool/thread_pool.h"
 #include "src/core/lib/event_engine/time_util.h"
@@ -35,7 +35,7 @@ IOCP::IOCP(ThreadPool* thread_pool) noexcept
     : thread_pool_(thread_pool),
       iocp_handle_(CreateIoCompletionPort(INVALID_HANDLE_VALUE, nullptr,
                                           (ULONG_PTR) nullptr, 0)) {
-  CHECK(iocp_handle_);
+  ABSL_CHECK(iocp_handle_);
   WSASocketFlagsInit();
 }

@@ -52,7 +52,7 @@ std::unique_ptr<WinSocket> IOCP::Watch(SOCKET socket) {
         GRPC_WSA_ERROR(WSAGetLastError(), "Unable to add socket to iocp")
             .ToString());
   }
-  CHECK(ret == iocp_handle_);
+  ABSL_CHECK(ret == iocp_handle_);
   return wrapped_socket;
 }

@@ -63,7 +63,7 @@ void IOCP::Shutdown() {
   while (outstanding_kicks_.load() > 0) {
     Work(std::chrono::hours(42), []() {});
   }
-  CHECK(CloseHandle(iocp_handle_));
+  ABSL_CHECK(CloseHandle(iocp_handle_));
 }

 Poller::WorkResult IOCP::Work(EventEngine::Duration timeout,
@@ -81,8 +81,8 @@ Poller::WorkResult IOCP::Work(EventEngine::Duration timeout,
         << "IOCP::" << this << " deadline exceeded";
     return Poller::WorkResult::kDeadlineExceeded;
   }
-  CHECK(completion_key);
-  CHECK(overlapped);
+  ABSL_CHECK(completion_key);
+  ABSL_CHECK(overlapped);
   if (overlapped == &kick_overlap_) {
     GRPC_TRACE_LOG(event_engine_poller, INFO) << "IOCP::" << this << " kicked";
     outstanding_kicks_.fetch_sub(1);
@@ -101,7 +101,7 @@ Poller::WorkResult IOCP::Work(EventEngine::Duration timeout,
   // about to register for notification of an overlapped event.
   auto* socket = reinterpret_cast<WinSocket*>(completion_key);
   WinSocket::OpState* info = socket->GetOpInfoForOverlapped(overlapped);
-  CHECK_NE(info, nullptr);
+  ABSL_CHECK_NE(info, nullptr);
   info->GetOverlappedResult();
   info->SetReady();
   schedule_poll_again();
@@ -110,7 +110,7 @@ Poller::WorkResult IOCP::Work(EventEngine::Duration timeout,

 void IOCP::Kick() {
   outstanding_kicks_.fetch_add(1);
-  CHECK(PostQueuedCompletionStatus(iocp_handle_, 0,
+  ABSL_CHECK(PostQueuedCompletionStatus(iocp_handle_, 0,
                                    reinterpret_cast<ULONG_PTR>(&kick_token_),
                                    &kick_overlap_));
 }
diff --git a/third_party/grpc/source/src/core/lib/event_engine/windows/win_socket.cc b/third_party/grpc/source/src/core/lib/event_engine/windows/win_socket.cc
index afc40e5d1150b..e81673b55b503 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/windows/win_socket.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/windows/win_socket.cc
@@ -17,8 +17,8 @@
 #include <grpc/support/alloc.h>
 #include <grpc/support/log_windows.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/event_engine/tcp_socket_utils.h"
 #include "src/core/lib/event_engine/thread_pool/thread_pool.h"
 #include "src/core/lib/event_engine/windows/win_socket.h"
@@ -45,7 +45,7 @@ WinSocket::WinSocket(SOCKET socket, ThreadPool* thread_pool) noexcept
       write_info_(this) {}

 WinSocket::~WinSocket() {
-  CHECK(is_shutdown_.load());
+  ABSL_CHECK(is_shutdown_.load());
   GRPC_TRACE_LOG(event_engine_endpoint, INFO)
       << "WinSocket::" << this << " destroyed";
 }
@@ -103,7 +103,7 @@ void WinSocket::NotifyOnReady(OpState& info, EventEngine::Closure* closure) {
     return;
   };
   // It is an error if any notification is already registered for this socket.
-  CHECK_EQ(std::exchange(info.closure_, closure), nullptr);
+  ABSL_CHECK_EQ(std::exchange(info.closure_, closure), nullptr);
 }

 void WinSocket::NotifyOnRead(EventEngine::Closure* on_read) {
@@ -115,11 +115,11 @@ void WinSocket::NotifyOnWrite(EventEngine::Closure* on_write) {
 }

 void WinSocket::UnregisterReadCallback() {
-  CHECK_NE(std::exchange(read_info_.closure_, nullptr), nullptr);
+  ABSL_CHECK_NE(std::exchange(read_info_.closure_, nullptr), nullptr);
 }

 void WinSocket::UnregisterWriteCallback() {
-  CHECK_NE(std::exchange(write_info_.closure_, nullptr), nullptr);
+  ABSL_CHECK_NE(std::exchange(write_info_.closure_, nullptr), nullptr);
 }

 // ---- WinSocket::OpState ----
@@ -133,7 +133,7 @@ void WinSocket::OpState::SetReady() {
   auto* closure = std::exchange(closure_, nullptr);
   // If an IOCP event is returned for a socket, and no callback has been
   // registered for notification, this is invalid usage.
-  CHECK_NE(closure, nullptr);
+  ABSL_CHECK_NE(closure, nullptr);
   win_socket_->thread_pool_->Run(closure);
 }

diff --git a/third_party/grpc/source/src/core/lib/event_engine/windows/windows_endpoint.cc b/third_party/grpc/source/src/core/lib/event_engine/windows/windows_endpoint.cc
index 38ba017e12e2a..b90c377b1f453 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/windows/windows_endpoint.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/windows/windows_endpoint.cc
@@ -20,8 +20,8 @@

 #include "absl/cleanup/cleanup.h"
 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_format.h"
 #include "src/core/lib/event_engine/tcp_socket_utils.h"
@@ -86,7 +86,7 @@ void WindowsEndpoint::AsyncIOState::DoTcpRead(SliceBuffer* buffer) {
     return;
   }
   // Prepare the WSABUF struct
-  CHECK(buffer->Count() <= kMaxWSABUFCount);
+  ABSL_CHECK(buffer->Count() <= kMaxWSABUFCount);
   WSABUF wsa_buffers[kMaxWSABUFCount];
   for (size_t i = 0; i < buffer->Count(); i++) {
     auto& slice = buffer->MutableSliceAt(i);
@@ -165,11 +165,11 @@ bool WindowsEndpoint::Write(absl::AnyInvocable<void(absl::Status)> on_writable,
           << " WRITE (peer=" << peer_address_string_ << "): " << str;
     }
   }
-  CHECK(data->Count() <= UINT_MAX);
+  ABSL_CHECK(data->Count() <= UINT_MAX);
   absl::InlinedVector<WSABUF, kMaxWSABUFCount> buffers(data->Count());
   for (size_t i = 0; i < data->Count(); i++) {
     auto& slice = data->MutableSliceAt(i);
-    CHECK(slice.size() <= ULONG_MAX);
+    ABSL_CHECK(slice.size() <= ULONG_MAX);
     buffers[i].len = slice.size();
     buffers[i].buf = (char*)slice.begin();
   }
@@ -294,10 +294,10 @@ void WindowsEndpoint::HandleReadClosure::Run() {
     return ResetAndReturnCallback()(status);
   }
   if (result.bytes_transferred == 0) {
-    DCHECK_GT(io_state.use_count(), 0);
+    ABSL_DCHECK_GT(io_state.use_count(), 0);
     // Either the endpoint is shut down or we've seen the end of the stream
     if (GRPC_TRACE_FLAG_ENABLED(event_engine_endpoint_data)) {
-      LOG(INFO) << "WindowsEndpoint::" << this << " read 0 bytes.";
+      ABSL_LOG(INFO) << "WindowsEndpoint::" << this << " read 0 bytes.";
       DumpSliceBuffer(
           &last_read_buffer_,
           absl::StrFormat("WindowsEndpoint::%p READ last_read_buffer_: ",
@@ -313,8 +313,8 @@ void WindowsEndpoint::HandleReadClosure::Run() {
     }
     return ResetAndReturnCallback()(status);
   }
-  DCHECK_GT(result.bytes_transferred, 0);
-  DCHECK(result.bytes_transferred <= buffer_->Length());
+  ABSL_DCHECK_GT(result.bytes_transferred, 0);
+  ABSL_DCHECK(result.bytes_transferred <= buffer_->Length());
   buffer_->MoveFirstNBytesIntoSliceBuffer(result.bytes_transferred,
                                           last_read_buffer_);
   if (buffer_->Length() == 0) {
@@ -345,9 +345,9 @@ bool WindowsEndpoint::HandleReadClosure::MaybeFinishIfDataHasAlreadyBeenRead() {
 void WindowsEndpoint::HandleReadClosure::DonateSpareSlices(
     SliceBuffer* buffer) {
   // Donee buffer must be empty.
-  CHECK_EQ(buffer->Length(), 0);
+  ABSL_CHECK_EQ(buffer->Length(), 0);
   // HandleReadClosure must be in the reset state.
-  CHECK_EQ(buffer_, nullptr);
+  ABSL_CHECK_EQ(buffer_, nullptr);
   buffer->Swap(last_read_buffer_);
 }

@@ -365,7 +365,7 @@ void WindowsEndpoint::HandleWriteClosure::Run() {
   if (result.wsa_error != 0) {
     status = GRPC_WSA_ERROR(result.wsa_error, "WSASend");
   } else {
-    CHECK(result.bytes_transferred == buffer_->Length());
+    ABSL_CHECK(result.bytes_transferred == buffer_->Length());
   }
   return ResetAndReturnCallback()(status);
 }
diff --git a/third_party/grpc/source/src/core/lib/event_engine/windows/windows_engine.cc b/third_party/grpc/source/src/core/lib/event_engine/windows/windows_engine.cc
index c58779a16d31d..03556c57ecde2 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/windows/windows_engine.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/windows/windows_engine.cc
@@ -24,8 +24,8 @@
 #include <memory>
 #include <ostream>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/string_view.h"
@@ -75,7 +75,7 @@ WindowsEventEngine::ConnectionState::ConnectionState(
       allocator_(std::move(allocator)),
       on_connect_user_callback_(std::move(on_connect_user_callback)),
       engine_(std::move(engine)) {
-  CHECK(socket_ != nullptr);
+  ABSL_CHECK(socket_ != nullptr);
   connection_handle_ = ConnectionHandle{reinterpret_cast<intptr_t>(this),
                                         engine_->aba_token_.fetch_add(1)};
 }
@@ -112,7 +112,7 @@ void WindowsEventEngine::ConnectionState::AbortDeadlineTimer() {
 }

 void WindowsEventEngine::ConnectionState::OnConnectedCallback::Run() {
-  DCHECK_NE(connection_state_, nullptr)
+  ABSL_DCHECK_NE(connection_state_, nullptr)
       << "ConnectionState::OnConnectedCallback::" << this
       << " has already run. It should only ever run once.";
   bool has_run;
@@ -131,7 +131,7 @@ void WindowsEventEngine::ConnectionState::OnConnectedCallback::Run() {
 }

 void WindowsEventEngine::ConnectionState::DeadlineTimerCallback::Run() {
-  DCHECK_NE(connection_state_, nullptr)
+  ABSL_DCHECK_NE(connection_state_, nullptr)
       << "ConnectionState::DeadlineTimerCallback::" << this
       << " has already run. It should only ever run once.";
   bool has_run;
@@ -207,7 +207,7 @@ WindowsEventEngine::WindowsEventEngine()
       iocp_worker_(thread_pool_.get(), &iocp_) {
   WSADATA wsaData;
   int status = WSAStartup(MAKEWORD(2, 0), &wsaData);
-  CHECK_EQ(status, 0);
+  ABSL_CHECK_EQ(status, 0);
 }

 WindowsEventEngine::~WindowsEventEngine() {
@@ -217,7 +217,7 @@ WindowsEventEngine::~WindowsEventEngine() {
     if (!known_handles_.empty()) {
       if (GRPC_TRACE_FLAG_ENABLED(event_engine)) {
         for (auto handle : known_handles_) {
-          LOG(ERROR) << "WindowsEventEngine:" << this
+          ABSL_LOG(ERROR) << "WindowsEventEngine:" << this
                      << " uncleared TaskHandle at shutdown:"
                      << HandleToString<EventEngine::TaskHandle>(handle);
         }
@@ -227,7 +227,7 @@ WindowsEventEngine::~WindowsEventEngine() {
           timer_manager_.Now() + grpc_core::Duration::FromSecondsAsDouble(10);
       while (!known_handles_.empty() && timer_manager_.Now() < deadline) {
         if (GRPC_TRACE_FLAG_ENABLED(event_engine)) {
-          VLOG_EVERY_N_SEC(2, 1) << "Waiting for timers. "
+          ABSL_VLOG_EVERY_N_SEC(2, 1) << "Waiting for timers. "
                                  << known_handles_.size() << " remaining";
         }
         task_mu_.Unlock();
@@ -235,13 +235,13 @@ WindowsEventEngine::~WindowsEventEngine() {
         task_mu_.Lock();
       }
     }
-    CHECK(GPR_LIKELY(known_handles_.empty()));
+    ABSL_CHECK(GPR_LIKELY(known_handles_.empty()));
     task_mu_.Unlock();
   }
   iocp_.Kick();
   iocp_worker_.WaitForShutdown();
   iocp_.Shutdown();
-  CHECK_EQ(WSACleanup(), 0);
+  ABSL_CHECK_EQ(WSACleanup(), 0);
   timer_manager_.Shutdown();
   thread_pool_->Quiesce();
 }
@@ -511,7 +511,7 @@ EventEngine::ConnectionHandle WindowsEventEngine::Connect(
     erased_handles =
         known_connection_handles_.erase(connection_state->connection_handle());
   }
-  CHECK_EQ(erased_handles, 1) << "Did not find connection handle "
+  ABSL_CHECK_EQ(erased_handles, 1) << "Did not find connection handle "
                               << connection_state->connection_handle()
                               << " after a synchronous connection failure. "
                                  "This should not be possible.";
diff --git a/third_party/grpc/source/src/core/lib/event_engine/windows/windows_listener.cc b/third_party/grpc/source/src/core/lib/event_engine/windows/windows_listener.cc
index f7414f48f693b..36d0241421494 100644
--- a/third_party/grpc/source/src/core/lib/event_engine/windows/windows_listener.cc
+++ b/third_party/grpc/source/src/core/lib/event_engine/windows/windows_listener.cc
@@ -15,8 +15,8 @@

 #ifdef GPR_WINDOWS

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_format.h"
 #include "src/core/lib/event_engine/tcp_socket_utils.h"
@@ -46,7 +46,7 @@ WindowsEventEngineListener::SinglePortSocketListener::AsyncIOState::

 void WindowsEventEngineListener::SinglePortSocketListener::
     OnAcceptCallbackWrapper::Run() {
-  CHECK_NE(io_state_, nullptr);
+  ABSL_CHECK_NE(io_state_, nullptr);
   grpc_core::ReleasableMutexLock lock(&io_state_->mu);
   if (io_state_->listener_socket->IsShutdown()) {
     GRPC_TRACE_LOG(event_engine, INFO)
@@ -122,7 +122,7 @@ WindowsEventEngineListener::SinglePortSocketListener::Create(
   }
   auto result = SinglePortSocketListener::PrepareListenerSocket(sock, addr);
   GRPC_RETURN_IF_ERROR(result.status());
-  CHECK_GE(result->port, 0);
+  ABSL_CHECK_GE(result->port, 0);
   // Using `new` to access non-public constructor
   return absl::WrapUnique(new SinglePortSocketListener(
       listener, AcceptEx, /*win_socket=*/listener->iocp_->Watch(sock),
@@ -188,13 +188,13 @@ void WindowsEventEngineListener::SinglePortSocketListener::
           ABSL_EXCLUSIVE_LOCKS_REQUIRED(io_state_->mu) {
             if (do_close_socket) closesocket(io_state_->accept_socket);
             io_state_->accept_socket = INVALID_SOCKET;
-            CHECK(GRPC_LOG_IF_ERROR("SinglePortSocketListener::Start",
+            ABSL_CHECK(GRPC_LOG_IF_ERROR("SinglePortSocketListener::Start",
                                     StartLocked()));
           };
   const auto& overlapped_result =
       io_state_->listener_socket->read_info()->result();
   if (overlapped_result.wsa_error != 0) {
-    LOG(ERROR) << GRPC_WSA_ERROR(overlapped_result.wsa_error,
+    ABSL_LOG(ERROR) << GRPC_WSA_ERROR(overlapped_result.wsa_error,
                                  "Skipping on_accept due to error");
     return close_socket_and_restart();
   }
@@ -204,7 +204,7 @@ void WindowsEventEngineListener::SinglePortSocketListener::
                  reinterpret_cast<char*>(&tmp_listener_socket),
                  sizeof(tmp_listener_socket));
   if (err != 0) {
-    LOG(ERROR) << GRPC_WSA_ERROR(WSAGetLastError(), "setsockopt");
+    ABSL_LOG(ERROR) << GRPC_WSA_ERROR(WSAGetLastError(), "setsockopt");
     return close_socket_and_restart();
   }
   EventEngine::ResolvedAddress peer_address;
@@ -213,7 +213,7 @@ void WindowsEventEngineListener::SinglePortSocketListener::
                     const_cast<sockaddr*>(peer_address.address()),
                     &peer_name_len);
   if (err != 0) {
-    LOG(ERROR) << GRPC_WSA_ERROR(WSAGetLastError(), "getpeername");
+    ABSL_LOG(ERROR) << GRPC_WSA_ERROR(WSAGetLastError(), "getpeername");
     return close_socket_and_restart();
   }
   peer_address =
@@ -222,7 +222,7 @@ void WindowsEventEngineListener::SinglePortSocketListener::
   std::string peer_name = "unknown";
   if (!addr_uri.ok()) {
     // TODO(hork): test an early exit/restart here with end2end tests
-    LOG(ERROR) << "invalid peer name: " << addr_uri.status();
+    ABSL_LOG(ERROR) << "invalid peer name: " << addr_uri.status();
   } else {
     peer_name = *addr_uri;
   }
@@ -256,7 +256,7 @@ absl::StatusOr<WindowsEventEngineListener::SinglePortSocketListener::
 WindowsEventEngineListener::SinglePortSocketListener::PrepareListenerSocket(
     SOCKET sock, const EventEngine::ResolvedAddress& addr) {
   auto fail = [&](absl::Status error) -> absl::Status {
-    CHECK(!error.ok());
+    ABSL_CHECK(!error.ok());
     error = grpc_error_set_int(
         GRPC_ERROR_CREATE_REFERENCING("Failed to prepare server socket", &error,
                                       1),
@@ -360,7 +360,7 @@ absl::StatusOr<int> WindowsEventEngineListener::Bind(
 }

 absl::Status WindowsEventEngineListener::Start() {
-  CHECK(!started_.exchange(true));
+  ABSL_CHECK(!started_.exchange(true));
   grpc_core::MutexLock lock(&port_listeners_mu_);
   for (auto& port_listener : port_listeners_) {
     GRPC_RETURN_IF_ERROR(port_listener->Start());
@@ -387,7 +387,7 @@ WindowsEventEngineListener::AddSinglePortSocketListener(
   grpc_core::MutexLock lock(&port_listeners_mu_);
   port_listeners_.emplace_back(std::move(*single_port_listener));
   if (started_.load()) {
-    LOG(ERROR) << "WindowsEventEngineListener::" << this
+    ABSL_LOG(ERROR) << "WindowsEventEngineListener::" << this
                << " Bind was called concurrently while the Listener was "
                   "starting. This is invalid usage, all ports must be bound "
                   "before the Listener is started.";
diff --git a/third_party/grpc/source/src/core/lib/experiments/config.cc b/third_party/grpc/source/src/core/lib/experiments/config.cc
index 0488c5a5da11b..cab0a3556d9d2 100644
--- a/third_party/grpc/source/src/core/lib/experiments/config.cc
+++ b/third_party/grpc/source/src/core/lib/experiments/config.cc
@@ -25,8 +25,8 @@
 #include <vector>

 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_join.h"
 #include "absl/strings/str_split.h"
 #include "absl/strings/string_view.h"
@@ -134,7 +134,7 @@ GPR_ATTRIBUTE_NOINLINE Experiments LoadExperimentsFromConfigVariableInner() {
     // If not found log an error, but don't take any other action.
     // Allows us an easy path to disabling experiments.
     if (!found) {
-      LOG(ERROR) << "Unknown experiment: " << experiment;
+      ABSL_LOG(ERROR) << "Unknown experiment: " << experiment;
     }
   }
   for (size_t i = 0; i < kNumExperiments; i++) {
@@ -143,7 +143,7 @@ GPR_ATTRIBUTE_NOINLINE Experiments LoadExperimentsFromConfigVariableInner() {
          j++) {
       // Require that we can check dependent requirements with a linear sweep
       // (implies the experiments generator must DAG sort the experiments)
-      CHECK(g_experiment_metadata[i].required_experiments[j] < i);
+      ABSL_CHECK(g_experiment_metadata[i].required_experiments[j] < i);
       if (!experiments
                .enabled[g_experiment_metadata[i].required_experiments[j]]) {
         experiments.enabled[i] = false;
@@ -217,7 +217,7 @@ bool IsTestExperimentEnabled(size_t experiment_id) {
   return (*g_test_experiments)[experiment_id];
 }

-#define GRPC_EXPERIMENT_LOG VLOG(2)
+#define GRPC_EXPERIMENT_LOG ABSL_VLOG(2)

 void PrintExperimentsList() {
   std::map<std::string, std::string> experiment_status;
@@ -272,18 +272,18 @@ void PrintExperimentsList() {
 }

 void ForceEnableExperiment(absl::string_view experiment, bool enable) {
-  CHECK(Loaded()->load(std::memory_order_relaxed) == false);
+  ABSL_CHECK(Loaded()->load(std::memory_order_relaxed) == false);
   for (size_t i = 0; i < kNumExperiments; i++) {
     if (g_experiment_metadata[i].name != experiment) continue;
     if (ForcedExperiments()[i].forced) {
-      CHECK(ForcedExperiments()[i].value == enable);
+      ABSL_CHECK(ForcedExperiments()[i].value == enable);
     } else {
       ForcedExperiments()[i].forced = true;
       ForcedExperiments()[i].value = enable;
     }
     return;
   }
-  LOG(INFO) << "gRPC EXPERIMENT " << experiment << " not found to force "
+  ABSL_LOG(INFO) << "gRPC EXPERIMENT " << experiment << " not found to force "
             << (enable ? "enable" : "disable");
 }

diff --git a/third_party/grpc/source/src/core/lib/iomgr/buffer_list.cc b/third_party/grpc/source/src/core/lib/iomgr/buffer_list.cc
index 73d225a99b081..b9e8c8070b34e 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/buffer_list.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/buffer_list.cc
@@ -21,7 +21,7 @@
 #include <grpc/support/port_platform.h>
 #include <grpc/support/time.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/iomgr/port.h"
 #include "src/core/util/crash.h"
 #include "src/core/util/sync.h"
@@ -42,7 +42,7 @@ void FillGprFromTimestamp(gpr_timespec* gts, const struct timespec* ts) {

 void DefaultTimestampsCallback(void* /*arg*/, Timestamps* /*ts*/,
                                absl::Status /*shutdown_err*/) {
-  VLOG(2) << "Timestamps callback has not been registered";
+  ABSL_VLOG(2) << "Timestamps callback has not been registered";
 }

 // The saved callback function that will be invoked when we get all the
@@ -321,7 +321,7 @@ void grpc_tcp_set_write_timestamps_callback(
   // Can't comment out the name because some compilers and formatters don't
   // like the sequence */* , which would arise from */*fn*/.
   (void)fn;
-  VLOG(2) << "Timestamps callback is not enabled for this platform";
+  ABSL_VLOG(2) << "Timestamps callback is not enabled for this platform";
 }
 }  // namespace grpc_core

diff --git a/third_party/grpc/source/src/core/lib/iomgr/call_combiner.cc b/third_party/grpc/source/src/core/lib/iomgr/call_combiner.cc
index 8459f415157db..f527ec3f286bb 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/call_combiner.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/call_combiner.cc
@@ -21,8 +21,8 @@
 #include <grpc/support/port_platform.h>
 #include <inttypes.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/telemetry/stats.h"
 #include "src/core/telemetry/stats_data.h"
 #include "src/core/util/crash.h"
@@ -84,7 +84,7 @@ void CallCombiner::TsanClosure(void* arg, grpc_error_handle error) {
   if (lock != nullptr) {
     TSAN_ANNOTATE_RWLOCK_RELEASED(&lock->taken, true);
     bool prev = true;
-    CHECK(lock->taken.compare_exchange_strong(prev, false));
+    ABSL_CHECK(lock->taken.compare_exchange_strong(prev, false));
   }
 }
 #endif
@@ -141,7 +141,7 @@ void CallCombiner::Stop(DEBUG_ARGS const char* reason) {
       static_cast<size_t>(gpr_atm_full_fetch_add(&size_, (gpr_atm)-1));
   GRPC_TRACE_LOG(call_combiner, INFO)
       << "  size: " << prev_size << " -> " << prev_size - 1;
-  CHECK_GE(prev_size, 1u);
+  ABSL_CHECK_GE(prev_size, 1u);
   if (prev_size > 1) {
     while (true) {
       GRPC_TRACE_LOG(call_combiner, INFO) << "  checking queue";
diff --git a/third_party/grpc/source/src/core/lib/iomgr/call_combiner.h b/third_party/grpc/source/src/core/lib/iomgr/call_combiner.h
index 9bb8c0ed6fcb9..f661195eb0d12 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/call_combiner.h
+++ b/third_party/grpc/source/src/core/lib/iomgr/call_combiner.h
@@ -24,7 +24,7 @@
 #include <stddef.h>

 #include "absl/container/inlined_vector.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/iomgr/closure.h"
 #include "src/core/lib/iomgr/dynamic_annotations.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
diff --git a/third_party/grpc/source/src/core/lib/iomgr/cfstream_handle.cc b/third_party/grpc/source/src/core/lib/iomgr/cfstream_handle.cc
index 0b64b87f3ddf2..22d1b33ac9568 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/cfstream_handle.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/cfstream_handle.cc
@@ -27,7 +27,7 @@
 #include <grpc/support/atm.h>
 #include <grpc/support/sync.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/debug/trace.h"
 #import "src/core/lib/iomgr/cfstream_handle.h"
 #include "src/core/lib/iomgr/closure.h"
@@ -174,7 +174,7 @@ void CFStreamHandle::Shutdown(grpc_error_handle error) {
 void CFStreamHandle::Ref(const char* file, int line, const char* reason) {
   if (GRPC_TRACE_FLAG_ENABLED(tcp)) {
     gpr_atm val = gpr_atm_no_barrier_load(&refcount_.count);
-    VLOG(2).AtLocation(file, line) << "CFStream Handle ref " << this << " : "
+    ABSL_VLOG(2).AtLocation(file, line) << "CFStream Handle ref " << this << " : "
                                    << reason << " " << val << " -> " << val + 1;
   }
   gpr_ref(&refcount_);
@@ -183,7 +183,7 @@ void CFStreamHandle::Ref(const char* file, int line, const char* reason) {
 void CFStreamHandle::Unref(const char* file, int line, const char* reason) {
   if (GRPC_TRACE_FLAG_ENABLED(tcp)) {
     gpr_atm val = gpr_atm_no_barrier_load(&refcount_.count);
-    VLOG(2).AtLocation(file, line) << "CFStream Handle unref " << this << " : "
+    ABSL_VLOG(2).AtLocation(file, line) << "CFStream Handle unref " << this << " : "
                                    << reason << " " << val << " -> " << val - 1;
   }
   if (gpr_unref(&refcount_)) {
diff --git a/third_party/grpc/source/src/core/lib/iomgr/closure.h b/third_party/grpc/source/src/core/lib/iomgr/closure.h
index e8f7a0b7812b5..a058c636007d4 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/closure.h
+++ b/third_party/grpc/source/src/core/lib/iomgr/closure.h
@@ -24,8 +24,8 @@
 #include <grpc/support/port_platform.h>
 #include <stdbool.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/iomgr/error.h"
 #include "src/core/util/crash.h"
 #include "src/core/util/debug_location.h"
@@ -293,7 +293,7 @@ class Closure {
         << "running closure " << closure << ": created ["
         << closure->file_created << ":" << closure->line_created << "]: run ["
         << location.file() << ":" << location.line() << "]";
-    CHECK_NE(closure->cb, nullptr);
+    ABSL_CHECK_NE(closure->cb, nullptr);
 #endif
     closure->cb(closure->cb_arg, error);
 #ifndef NDEBUG
diff --git a/third_party/grpc/source/src/core/lib/iomgr/combiner.cc b/third_party/grpc/source/src/core/lib/iomgr/combiner.cc
index 81f33c70a2b94..b7cc7f9ca0bc3 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/combiner.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/combiner.cc
@@ -24,8 +24,8 @@
 #include <inttypes.h>
 #include <string.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/experiments/experiments.h"
 #include "src/core/lib/iomgr/executor.h"
 #include "src/core/lib/iomgr/iomgr_internal.h"
@@ -55,7 +55,7 @@ grpc_core::Combiner* grpc_combiner_create(

 static void really_destroy(grpc_core::Combiner* lock) {
   GRPC_TRACE_LOG(combiner, INFO) << "C:" << lock << " really_destroy";
-  CHECK_EQ(gpr_atm_no_barrier_load(&lock->state), 0);
+  ABSL_CHECK_EQ(gpr_atm_no_barrier_load(&lock->state), 0);
   delete lock;
 }

@@ -137,7 +137,7 @@ static void combiner_exec(grpc_core::Combiner* lock, grpc_closure* cl,
       gpr_atm_no_barrier_store(&lock->initiating_exec_ctx_or_null, 0);
     }
   }
-  CHECK(last & STATE_UNORPHANED);  // ensure lock has not been destroyed
+  ABSL_CHECK(last & STATE_UNORPHANED);  // ensure lock has not been destroyed
   assert(cl->cb);
   cl->error_data.error = grpc_core::internal::StatusAllocHeapPtr(error);
   lock->queue.Push(cl->next_data.mpscq_node.get());
@@ -217,7 +217,7 @@ bool grpc_combiner_continue_exec_ctx() {
     cl->cb(cl->cb_arg, std::move(cl_err));
   } else {
     grpc_closure* c = lock->final_list.head;
-    CHECK_NE(c, nullptr);
+    ABSL_CHECK_NE(c, nullptr);
     grpc_closure_list_init(&lock->final_list);
     int loops = 0;
     while (c != nullptr) {
@@ -280,7 +280,7 @@ static void enqueue_finally(void* closure, grpc_error_handle error);
 static void combiner_finally_exec(grpc_core::Combiner* lock,
                                   grpc_closure* closure,
                                   grpc_error_handle error) {
-  CHECK_NE(lock, nullptr);
+  ABSL_CHECK_NE(lock, nullptr);
   GRPC_TRACE_LOG(combiner, INFO)
       << "C:" << lock << " grpc_combiner_execute_finally c=" << closure
       << "; ac=" << grpc_core::ExecCtx::Get()->combiner_data()->active_combiner;
diff --git a/third_party/grpc/source/src/core/lib/iomgr/endpoint_cfstream.cc b/third_party/grpc/source/src/core/lib/iomgr/endpoint_cfstream.cc
index 3177567e94829..244c06ea2bbfe 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/endpoint_cfstream.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/endpoint_cfstream.cc
@@ -27,8 +27,8 @@
 #include <grpc/support/alloc.h>
 #include <grpc/support/string_util.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/address_utils/sockaddr_utils.h"
 #include "src/core/lib/iomgr/cfstream_handle.h"
 #include "src/core/lib/iomgr/closure.h"
@@ -74,7 +74,7 @@ static void CFStreamUnref(CFStreamEndpoint* ep, const char* reason,
                           const char* file, int line) {
   if (GRPC_TRACE_FLAG_ENABLED(tcp)) {
     gpr_atm val = gpr_atm_no_barrier_load(&ep->refcount.count);
-    VLOG(2).AtLocation(file, line) << "CFStream endpoint unref " << ep << " : "
+    ABSL_VLOG(2).AtLocation(file, line) << "CFStream endpoint unref " << ep << " : "
                                    << reason << " " << val << " -> " << val - 1;
   }
   if (gpr_unref(&ep->refcount)) {
@@ -85,7 +85,7 @@ static void CFStreamRef(CFStreamEndpoint* ep, const char* reason,
                         const char* file, int line) {
   if (GRPC_TRACE_FLAG_ENABLED(tcp)) {
     gpr_atm val = gpr_atm_no_barrier_load(&ep->refcount.count);
-    VLOG(2).AtLocation(file, line) << "CFStream endpoint ref " << ep << " : "
+    ABSL_VLOG(2).AtLocation(file, line) << "CFStream endpoint ref " << ep << " : "
                                    << reason << " " << val << " -> " << val + 1;
   }
   gpr_ref(&ep->refcount);
@@ -108,15 +108,15 @@ static grpc_error_handle CFStreamAnnotateError(grpc_error_handle src_error) {

 static void CallReadCb(CFStreamEndpoint* ep, grpc_error_handle error) {
   if (GRPC_TRACE_FLAG_ENABLED(tcp) && ABSL_VLOG_IS_ON(2)) {
-    VLOG(2) << "CFStream endpoint:" << ep << " call_read_cb " << ep->read_cb
+    ABSL_VLOG(2) << "CFStream endpoint:" << ep << " call_read_cb " << ep->read_cb
             << " " << ep->read_cb->cb << ":" << ep->read_cb->cb_arg;
     size_t i;
-    VLOG(2) << "read: error=" << grpc_core::StatusToString(error);
+    ABSL_VLOG(2) << "read: error=" << grpc_core::StatusToString(error);

     for (i = 0; i < ep->read_slices->count; i++) {
       char* dump = grpc_dump_slice(ep->read_slices->slices[i],
                                    GPR_DUMP_HEX | GPR_DUMP_ASCII);
-      VLOG(2) << "READ " << ep << " (peer=" << ep->peer_string << "): " << dump;
+      ABSL_VLOG(2) << "READ " << ep << " (peer=" << ep->peer_string << "): " << dump;
       gpr_free(dump);
     }
   }
@@ -139,7 +139,7 @@ static void CallWriteCb(CFStreamEndpoint* ep, grpc_error_handle error) {

 static void ReadAction(void* arg, grpc_error_handle error) {
   CFStreamEndpoint* ep = static_cast<CFStreamEndpoint*>(arg);
-  CHECK_NE(ep->read_cb, nullptr);
+  ABSL_CHECK_NE(ep->read_cb, nullptr);
   if (!error.ok()) {
     grpc_slice_buffer_reset_and_unref(ep->read_slices);
     CallReadCb(ep, error);
@@ -147,7 +147,7 @@ static void ReadAction(void* arg, grpc_error_handle error) {
     return;
   }

-  CHECK_EQ(ep->read_slices->count, 1);
+  ABSL_CHECK_EQ(ep->read_slices->count, 1);
   grpc_slice slice = ep->read_slices->slices[0];
   size_t len = GRPC_SLICE_LENGTH(slice);
   CFIndex read_size =
@@ -179,7 +179,7 @@ static void ReadAction(void* arg, grpc_error_handle error) {

 static void WriteAction(void* arg, grpc_error_handle error) {
   CFStreamEndpoint* ep = static_cast<CFStreamEndpoint*>(arg);
-  CHECK_NE(ep->write_cb, nullptr);
+  ABSL_CHECK_NE(ep->write_cb, nullptr);
   if (!error.ok()) {
     grpc_slice_buffer_reset_and_unref(ep->write_slices);
     CallWriteCb(ep, error);
@@ -217,7 +217,7 @@ static void WriteAction(void* arg, grpc_error_handle error) {
     if (GRPC_TRACE_FLAG_ENABLED(tcp) && ABSL_VLOG_IS_ON(2)) {
       grpc_slice trace_slice = grpc_slice_sub(slice, 0, write_size);
       char* dump = grpc_dump_slice(trace_slice, GPR_DUMP_HEX | GPR_DUMP_ASCII);
-      VLOG(2) << "WRITE " << ep << " (peer=" << ep->peer_string
+      ABSL_VLOG(2) << "WRITE " << ep << " (peer=" << ep->peer_string
               << "): " << dump;
       gpr_free(dump);
       grpc_core::CSliceUnref(trace_slice);
@@ -233,7 +233,7 @@ static void CFStreamRead(grpc_endpoint* ep, grpc_slice_buffer* slices,
   GRPC_TRACE_VLOG(tcp, 2) << "CFStream endpoint:" << ep_impl << " read ("
                           << slices << ", " << cb
                           << ") length:" << slices->length;
-  CHECK_EQ(ep_impl->read_cb, nullptr);
+  ABSL_CHECK_EQ(ep_impl->read_cb, nullptr);
   ep_impl->read_cb = cb;
   ep_impl->read_slices = slices;
   grpc_slice_buffer_reset_and_unref(slices);
@@ -250,7 +250,7 @@ static void CFStreamWrite(grpc_endpoint* ep, grpc_slice_buffer* slices,
   GRPC_TRACE_VLOG(tcp, 2) << "CFStream endpoint:" << ep_impl << " write ("
                           << slices << ", " << cb
                           << ") length:" << slices->length;
-  CHECK_EQ(ep_impl->write_cb, nullptr);
+  ABSL_CHECK_EQ(ep_impl->write_cb, nullptr);
   ep_impl->write_cb = cb;
   ep_impl->write_slices = slices;
   EP_REF(ep_impl, "write");
diff --git a/third_party/grpc/source/src/core/lib/iomgr/endpoint_pair_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/endpoint_pair_posix.cc
index 04c574560c0f6..a0ce910c2e4f4 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/endpoint_pair_posix.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/endpoint_pair_posix.cc
@@ -31,7 +31,7 @@

 #include <string>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/lib/event_engine/channel_args_endpoint_config.h"
 #include "src/core/lib/iomgr/endpoint_pair.h"
@@ -46,11 +46,11 @@ static void create_sockets(int sv[2]) {
   int flags;
   grpc_create_socketpair_if_unix(sv);
   flags = fcntl(sv[0], F_GETFL, 0);
-  CHECK_EQ(fcntl(sv[0], F_SETFL, flags | O_NONBLOCK), 0);
+  ABSL_CHECK_EQ(fcntl(sv[0], F_SETFL, flags | O_NONBLOCK), 0);
   flags = fcntl(sv[1], F_GETFL, 0);
-  CHECK_EQ(fcntl(sv[1], F_SETFL, flags | O_NONBLOCK), 0);
-  CHECK(grpc_set_socket_no_sigpipe_if_possible(sv[0]) == absl::OkStatus());
-  CHECK(grpc_set_socket_no_sigpipe_if_possible(sv[1]) == absl::OkStatus());
+  ABSL_CHECK_EQ(fcntl(sv[1], F_SETFL, flags | O_NONBLOCK), 0);
+  ABSL_CHECK(grpc_set_socket_no_sigpipe_if_possible(sv[0]) == absl::OkStatus());
+  ABSL_CHECK(grpc_set_socket_no_sigpipe_if_possible(sv[1]) == absl::OkStatus());
 }

 grpc_endpoint_pair grpc_iomgr_create_endpoint_pair(
diff --git a/third_party/grpc/source/src/core/lib/iomgr/endpoint_pair_windows.cc b/third_party/grpc/source/src/core/lib/iomgr/endpoint_pair_windows.cc
index f30f691323d39..bab7b2b0095ee 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/endpoint_pair_windows.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/endpoint_pair_windows.cc
@@ -25,8 +25,8 @@
 #include <fcntl.h>
 #include <string.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/address_utils/sockaddr_utils.h"
 #include "src/core/lib/iomgr/endpoint_pair.h"
 #include "src/core/lib/iomgr/sockaddr.h"
@@ -43,34 +43,34 @@ static void create_sockets(SOCKET sv[2]) {

   lst_sock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0,
                        grpc_get_default_wsa_socket_flags());
-  CHECK(lst_sock != INVALID_SOCKET);
+  ABSL_CHECK(lst_sock != INVALID_SOCKET);

   memset(&addr, 0, sizeof(addr));
   addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
   addr.sin_family = AF_INET;
-  CHECK(bind(lst_sock, (grpc_sockaddr*)&addr, sizeof(addr)) != SOCKET_ERROR);
-  CHECK(listen(lst_sock, SOMAXCONN) != SOCKET_ERROR);
-  CHECK(getsockname(lst_sock, (grpc_sockaddr*)&addr, &addr_len) !=
+  ABSL_CHECK(bind(lst_sock, (grpc_sockaddr*)&addr, sizeof(addr)) != SOCKET_ERROR);
+  ABSL_CHECK(listen(lst_sock, SOMAXCONN) != SOCKET_ERROR);
+  ABSL_CHECK(getsockname(lst_sock, (grpc_sockaddr*)&addr, &addr_len) !=
         SOCKET_ERROR);

   cli_sock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0,
                        grpc_get_default_wsa_socket_flags());
-  CHECK(cli_sock != INVALID_SOCKET);
+  ABSL_CHECK(cli_sock != INVALID_SOCKET);

-  CHECK(WSAConnect(cli_sock, (grpc_sockaddr*)&addr, addr_len, NULL, NULL, NULL,
+  ABSL_CHECK(WSAConnect(cli_sock, (grpc_sockaddr*)&addr, addr_len, NULL, NULL, NULL,
                    NULL) == 0);
   svr_sock = accept(lst_sock, (grpc_sockaddr*)&addr, &addr_len);
-  CHECK(svr_sock != INVALID_SOCKET);
+  ABSL_CHECK(svr_sock != INVALID_SOCKET);

   closesocket(lst_sock);
   grpc_error_handle error = grpc_tcp_prepare_socket(cli_sock);
   if (!error.ok()) {
-    VLOG(2) << "Prepare cli_sock failed with error: "
+    ABSL_VLOG(2) << "Prepare cli_sock failed with error: "
             << grpc_core::StatusToString(error);
   }
   error = grpc_tcp_prepare_socket(svr_sock);
   if (!error.ok()) {
-    VLOG(2) << "Prepare svr_sock failed with error: "
+    ABSL_VLOG(2) << "Prepare svr_sock failed with error: "
             << grpc_core::StatusToString(error);
   }

diff --git a/third_party/grpc/source/src/core/lib/iomgr/error.cc b/third_party/grpc/source/src/core/lib/iomgr/error.cc
index f163947fb3a56..8d95690e0780b 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/error.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/error.cc
@@ -24,8 +24,8 @@
 #include <inttypes.h>
 #include <string.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
 #include "src/core/util/crash.h"
@@ -218,8 +218,8 @@ grpc_error_handle grpc_error_add_child(grpc_error_handle src,

 bool grpc_log_error(const char* what, grpc_error_handle error, const char* file,
                     int line) {
-  DCHECK(!error.ok());
-  LOG(ERROR).AtLocation(file, line)
+  ABSL_DCHECK(!error.ok());
+  ABSL_LOG(ERROR).AtLocation(file, line)
       << what << ": " << grpc_core::StatusToString(error);
   return false;
 }
diff --git a/third_party/grpc/source/src/core/lib/iomgr/error.h b/third_party/grpc/source/src/core/lib/iomgr/error.h
index 0171c5048113f..643ec58bc869b 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/error.h
+++ b/third_party/grpc/source/src/core/lib/iomgr/error.h
@@ -26,7 +26,7 @@
 #include <inttypes.h>
 #include <stdbool.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/lib/slice/slice_internal.h"
@@ -72,7 +72,7 @@ absl::Status grpc_os_error(const grpc_core::DebugLocation& location, int err,
                            const char* call_name);

 inline absl::Status grpc_assert_never_ok(absl::Status error) {
-  CHECK(!error.ok());
+  ABSL_CHECK(!error.ok());
   return error;
 }

diff --git a/third_party/grpc/source/src/core/lib/iomgr/ev_epoll1_linux.cc b/third_party/grpc/source/src/core/lib/iomgr/ev_epoll1_linux.cc
index bc7c3b4b5564e..f441b451f3b80 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/ev_epoll1_linux.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/ev_epoll1_linux.cc
@@ -40,8 +40,8 @@
 #include <string>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
 #include "absl/strings/str_join.h"
@@ -97,14 +97,14 @@ static int epoll_create_and_cloexec() {
 #ifdef GRPC_LINUX_EPOLL_CREATE1
   int fd = epoll_create1(EPOLL_CLOEXEC);
   if (fd < 0) {
-    LOG(ERROR) << "epoll_create1 unavailable";
+    ABSL_LOG(ERROR) << "epoll_create1 unavailable";
   }
 #else
   int fd = epoll_create(MAX_EPOLL_EVENTS);
   if (fd < 0) {
-    LOG(ERROR) << "epoll_create unavailable";
+    ABSL_LOG(ERROR) << "epoll_create unavailable";
   } else if (fcntl(fd, F_SETFD, FD_CLOEXEC) != 0) {
-    LOG(ERROR) << "fcntl following epoll_create failed";
+    ABSL_LOG(ERROR) << "fcntl following epoll_create failed";
     return -1;
   }
 #endif
@@ -372,7 +372,7 @@ static grpc_fd* fd_create(int fd, const char* name, bool track_err) {
   ev.data.ptr = reinterpret_cast<void*>(reinterpret_cast<intptr_t>(new_fd) |
                                         (track_err ? 1 : 0));
   if (epoll_ctl(g_epoll_set.epfd, EPOLL_CTL_ADD, fd, &ev) != 0) {
-    LOG(ERROR) << "epoll_ctl failed: " << grpc_core::StrError(errno);
+    ABSL_LOG(ERROR) << "epoll_ctl failed: " << grpc_core::StrError(errno);
   }

   return new_fd;
@@ -395,7 +395,7 @@ static void fd_shutdown_internal(grpc_fd* fd, grpc_error_handle why,
       epoll_event phony_event;
       if (epoll_ctl(g_epoll_set.epfd, EPOLL_CTL_DEL, fd->fd, &phony_event) !=
           0) {
-        LOG(ERROR) << "epoll_ctl failed: " << grpc_core::StrError(errno);
+        ABSL_LOG(ERROR) << "epoll_ctl failed: " << grpc_core::StrError(errno);
       }
     }
     fd->write_closure->SetShutdown(why);
@@ -630,8 +630,8 @@ static void pollset_maybe_finish_shutdown(grpc_pollset* pollset) {
 }

 static void pollset_shutdown(grpc_pollset* pollset, grpc_closure* closure) {
-  CHECK_EQ(pollset->shutdown_closure, nullptr);
-  CHECK(!pollset->shutting_down);
+  ABSL_CHECK_EQ(pollset->shutdown_closure, nullptr);
+  ABSL_CHECK(!pollset->shutting_down);
   pollset->shutdown_closure = closure;
   pollset->shutting_down = true;
   GRPC_LOG_IF_ERROR("pollset_shutdown", pollset_kick_all(pollset));
@@ -799,7 +799,7 @@ static bool begin_worker(grpc_pollset* pollset, grpc_pollset_worker* worker,
       }
     }
     if (is_reassigning) {
-      CHECK(pollset->reassigning_neighborhood);
+      ABSL_CHECK(pollset->reassigning_neighborhood);
       pollset->reassigning_neighborhood = false;
     }
     gpr_mu_unlock(&neighborhood->mu);
@@ -808,7 +808,7 @@ static bool begin_worker(grpc_pollset* pollset, grpc_pollset_worker* worker,
   worker_insert(pollset, worker);
   pollset->begin_refs--;
   if (worker->state == UNKICKED && !pollset->kicked_without_poller) {
-    CHECK(gpr_atm_no_barrier_load(&g_active_poller) != (gpr_atm)worker);
+    ABSL_CHECK(gpr_atm_no_barrier_load(&g_active_poller) != (gpr_atm)worker);
     worker->initialized_cv = true;
     gpr_cv_init(&worker->cv);
     while (worker->state == UNKICKED && !pollset->shutting_down) {
@@ -860,7 +860,7 @@ static bool check_neighborhood_for_available_poller(
       break;
     }
     gpr_mu_lock(&inspect->mu);
-    CHECK(!inspect->seen_inactive);
+    ABSL_CHECK(!inspect->seen_inactive);
     grpc_pollset_worker* inspect_worker = inspect->root_worker;
     if (inspect_worker != nullptr) {
       do {
@@ -922,7 +922,7 @@ static void end_worker(grpc_pollset* pollset, grpc_pollset_worker* worker,
     if (worker->next != worker && worker->next->state == UNKICKED) {
       GRPC_TRACE_LOG(polling, INFO)
           << " .. choose next poller to be peer " << worker;
-      CHECK(worker->next->initialized_cv);
+      ABSL_CHECK(worker->next->initialized_cv);
       gpr_atm_no_barrier_store(&g_active_poller, (gpr_atm)worker->next);
       SET_KICK_STATE(worker->next, DESIGNATED_POLLER);
       gpr_cv_signal(&worker->next->cv);
@@ -974,7 +974,7 @@ static void end_worker(grpc_pollset* pollset, grpc_pollset_worker* worker,
   if (EMPTIED == worker_remove(pollset, worker)) {
     pollset_maybe_finish_shutdown(pollset);
   }
-  CHECK(gpr_atm_no_barrier_load(&g_active_poller) != (gpr_atm)worker);
+  ABSL_CHECK(gpr_atm_no_barrier_load(&g_active_poller) != (gpr_atm)worker);
 }

 // pollset->po.mu lock must be held by the caller before calling this.
@@ -995,8 +995,8 @@ static grpc_error_handle pollset_work(grpc_pollset* ps,
   if (begin_worker(ps, &worker, worker_hdl, deadline)) {
     g_current_thread_pollset = ps;
     g_current_thread_worker = &worker;
-    CHECK(!ps->shutting_down);
-    CHECK(!ps->seen_inactive);
+    ABSL_CHECK(!ps->shutting_down);
+    ABSL_CHECK(!ps->seen_inactive);

     gpr_mu_unlock(&ps->mu);  // unlock
     // This is the designated polling thread at this point and should ideally do
@@ -1051,7 +1051,7 @@ static grpc_error_handle pollset_kick(grpc_pollset* pollset,
       log.push_back(absl::StrFormat(" worker_kick_state=%s",
                                     kick_state_string(specific_worker->state)));
     }
-    VLOG(2) << absl::StrJoin(log, "");
+    ABSL_VLOG(2) << absl::StrJoin(log, "");
   }

   if (specific_worker == nullptr) {
@@ -1082,7 +1082,7 @@ static grpc_error_handle pollset_kick(grpc_pollset* pollset,
         goto done;
       } else if (next_worker->state == UNKICKED) {
         GRPC_TRACE_LOG(polling, INFO) << " .. kicked " << next_worker;
-        CHECK(next_worker->initialized_cv);
+        ABSL_CHECK(next_worker->initialized_cv);
         SET_KICK_STATE(next_worker, KICKED);
         gpr_cv_signal(&next_worker->cv);
         goto done;
@@ -1105,7 +1105,7 @@ static grpc_error_handle pollset_kick(grpc_pollset* pollset,
           goto done;
         }
       } else {
-        CHECK(next_worker->state == KICKED);
+        ABSL_CHECK(next_worker->state == KICKED);
         SET_KICK_STATE(next_worker, KICKED);
         goto done;
       }
@@ -1234,7 +1234,7 @@ const grpc_event_engine_vtable grpc_ev_epoll1_posix = {
     /* check_engine_available = */
     [](bool) { return init_epoll1_linux(); },
     /* init_engine = */
-    []() { CHECK(init_epoll1_linux()); },
+    []() { ABSL_CHECK(init_epoll1_linux()); },
     shutdown_background_closure,
     /* shutdown_engine = */
     []() { shutdown_engine(); },
@@ -1265,7 +1265,7 @@ static void reset_event_manager_on_fork() {
 static bool init_epoll1_linux() {
   if (!g_is_shutdown) return true;
   if (!grpc_has_wakeup_fd()) {
-    LOG(ERROR) << "Skipping epoll1 because of no wakeup fd.";
+    ABSL_LOG(ERROR) << "Skipping epoll1 because of no wakeup fd.";
     return false;
   }

diff --git a/third_party/grpc/source/src/core/lib/iomgr/ev_poll_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/ev_poll_posix.cc
index 32d42c36e27d4..abc91578aac53 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/ev_poll_posix.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/ev_poll_posix.cc
@@ -34,8 +34,8 @@

 #include <string>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
 #include "src/core/lib/iomgr/block_annotate.h"
@@ -348,7 +348,7 @@ static void ref_by(grpc_fd* fd, int n, const char* reason, const char* file,
   } while (0)
 static void ref_by(grpc_fd* fd, int n) {
 #endif
-  CHECK_GT(gpr_atm_no_barrier_fetch_add(&fd->refst, n), 0);
+  ABSL_CHECK_GT(gpr_atm_no_barrier_fetch_add(&fd->refst, n), 0);
 }

 #ifndef NDEBUG
@@ -372,14 +372,14 @@ static void unref_by(grpc_fd* fd, int n) {
     fd->shutdown_error.~Status();
     gpr_free(fd);
   } else {
-    CHECK(old > n);
+    ABSL_CHECK(old > n);
   }
 }

 static grpc_fd* fd_create(int fd, const char* name, bool track_err) {
   // Avoid unused-parameter warning for debug-only parameter
   (void)track_err;
-  DCHECK(track_err == false);
+  ABSL_DCHECK(track_err == false);
   grpc_fd* r = static_cast<grpc_fd*>(gpr_malloc(sizeof(*r)));
   gpr_mu_init(&r->mu);
   gpr_atm_rel_store(&r->refst, 1);
@@ -409,7 +409,7 @@ static bool fd_is_orphaned(grpc_fd* fd) {

 static grpc_error_handle pollset_kick_locked(grpc_fd_watcher* watcher) {
   gpr_mu_lock(&watcher->pollset->mu);
-  CHECK(watcher->worker);
+  ABSL_CHECK(watcher->worker);
   grpc_error_handle err =
       pollset_kick_ext(watcher->pollset, watcher->worker,
                        GRPC_POLLSET_REEVALUATE_POLLING_ON_WAKEUP);
@@ -783,7 +783,7 @@ static grpc_error_handle pollset_kick_ext(grpc_pollset* p,
   // pollset->mu already held
   if (specific_worker != nullptr) {
     if (specific_worker == GRPC_POLLSET_KICK_BROADCAST) {
-      CHECK_EQ((flags & GRPC_POLLSET_REEVALUATE_POLLING_ON_WAKEUP), 0u);
+      ABSL_CHECK_EQ((flags & GRPC_POLLSET_REEVALUATE_POLLING_ON_WAKEUP), 0u);
       for (specific_worker = p->root_worker.next;
            specific_worker != &p->root_worker;
            specific_worker = specific_worker->next) {
@@ -807,7 +807,7 @@ static grpc_error_handle pollset_kick_ext(grpc_pollset* p,
                         grpc_wakeup_fd_wakeup(&specific_worker->wakeup_fd->fd));
     }
   } else if (g_current_thread_poller != p) {
-    CHECK_EQ((flags & GRPC_POLLSET_REEVALUATE_POLLING_ON_WAKEUP), 0u);
+    ABSL_CHECK_EQ((flags & GRPC_POLLSET_REEVALUATE_POLLING_ON_WAKEUP), 0u);
     specific_worker = pop_front_worker(p);
     if (specific_worker != nullptr) {
       if (g_current_thread_worker == specific_worker) {
@@ -860,7 +860,7 @@ static void pollset_init(grpc_pollset* pollset, gpr_mu** mu) {
 }

 static void pollset_destroy(grpc_pollset* pollset) {
-  CHECK(!pollset_has_workers(pollset));
+  ABSL_CHECK(!pollset_has_workers(pollset));
   while (pollset->local_wakeup_cache) {
     grpc_cached_wakeup_fd* next = pollset->local_wakeup_cache->next;
     fork_fd_list_remove_wakeup_fd(pollset->local_wakeup_cache);
@@ -1138,7 +1138,7 @@ static grpc_error_handle pollset_work(grpc_pollset* pollset,
 }

 static void pollset_shutdown(grpc_pollset* pollset, grpc_closure* closure) {
-  CHECK(!pollset->shutting_down);
+  ABSL_CHECK(!pollset->shutting_down);
   pollset->shutting_down = 1;
   pollset->shutdown_done = closure;
   (void)pollset_kick(pollset, GRPC_POLLSET_KICK_BROADCAST);
@@ -1397,7 +1397,7 @@ const grpc_event_engine_vtable grpc_ev_poll_posix = {
     // check_engine_available =
     [](bool) {
       if (!grpc_has_wakeup_fd()) {
-        LOG(ERROR) << "Skipping poll because of no wakeup fd.";
+        ABSL_LOG(ERROR) << "Skipping poll because of no wakeup fd.";
         return false;
       }
       if (!GRPC_LOG_IF_ERROR("pollset_global_init", pollset_global_init())) {
diff --git a/third_party/grpc/source/src/core/lib/iomgr/ev_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/ev_posix.cc
index 532a611d3304d..2f6b844a93bf7 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/ev_posix.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/ev_posix.cc
@@ -27,7 +27,7 @@
 #include <grpc/support/string_util.h>
 #include <string.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_format.h"
 #include "absl/strings/str_split.h"
 #include "src/core/config/config_vars.h"
diff --git a/third_party/grpc/source/src/core/lib/iomgr/event_engine_shims/closure.cc b/third_party/grpc/source/src/core/lib/iomgr/event_engine_shims/closure.cc
index 921401941cf88..98ffb0fdc6205 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/event_engine_shims/closure.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/event_engine_shims/closure.cc
@@ -17,7 +17,7 @@
 #include <grpc/support/port_platform.h>

 #include "absl/functional/any_invocable.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "src/core/lib/iomgr/closure.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
diff --git a/third_party/grpc/source/src/core/lib/iomgr/event_engine_shims/endpoint.cc b/third_party/grpc/source/src/core/lib/iomgr/event_engine_shims/endpoint.cc
index c368db6fa0f3e..d87960ccf9026 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/event_engine_shims/endpoint.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/event_engine_shims/endpoint.cc
@@ -25,8 +25,8 @@
 #include <utility>

 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/string_view.h"
@@ -118,12 +118,12 @@ class EventEngineEndpointWrapper {
     read_buffer->~SliceBuffer();
     if (GRPC_TRACE_FLAG_ENABLED(tcp)) {
       size_t i;
-      LOG(INFO) << "TCP: " << eeep_->wrapper << " READ error=" << status;
+      ABSL_LOG(INFO) << "TCP: " << eeep_->wrapper << " READ error=" << status;
       if (ABSL_VLOG_IS_ON(2)) {
         for (i = 0; i < pending_read_buffer_->count; i++) {
           char* dump = grpc_dump_slice(pending_read_buffer_->slices[i],
                                        GPR_DUMP_HEX | GPR_DUMP_ASCII);
-          VLOG(2) << "READ DATA: " << dump;
+          ABSL_VLOG(2) << "READ DATA: " << dump;
           gpr_free(dump);
         }
       }
@@ -148,12 +148,12 @@ class EventEngineEndpointWrapper {
     Ref();
     if (GRPC_TRACE_FLAG_ENABLED(tcp)) {
       size_t i;
-      LOG(INFO) << "TCP: " << this << " WRITE (peer=" << PeerAddress() << ")";
+      ABSL_LOG(INFO) << "TCP: " << this << " WRITE (peer=" << PeerAddress() << ")";
       if (ABSL_VLOG_IS_ON(2)) {
         for (i = 0; i < slices->count; i++) {
           char* dump =
               grpc_dump_slice(slices->slices[i], GPR_DUMP_HEX | GPR_DUMP_ASCII);
-          VLOG(2) << "WRITE DATA: " << dump;
+          ABSL_VLOG(2) << "WRITE DATA: " << dump;
           gpr_free(dump);
         }
       }
@@ -414,7 +414,7 @@ EventEngineEndpointWrapper::EventEngineEndpointWrapper(

 grpc_endpoint* grpc_event_engine_endpoint_create(
     std::unique_ptr<EventEngine::Endpoint> ee_endpoint) {
-  DCHECK(ee_endpoint != nullptr);
+  ABSL_DCHECK(ee_endpoint != nullptr);
   auto wrapper = new EventEngineEndpointWrapper(std::move(ee_endpoint));
   return wrapper->GetGrpcEndpoint();
 }
diff --git a/third_party/grpc/source/src/core/lib/iomgr/exec_ctx.cc b/third_party/grpc/source/src/core/lib/iomgr/exec_ctx.cc
index 23d4248eaa948..dd17e688b3cca 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/exec_ctx.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/exec_ctx.cc
@@ -21,8 +21,8 @@
 #include <grpc/support/port_platform.h>
 #include <grpc/support/sync.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_format.h"
 #include "src/core/lib/iomgr/combiner.h"
 #include "src/core/lib/iomgr/error.h"
@@ -84,7 +84,7 @@ bool ExecCtx::Flush() {
       break;
     }
   }
-  CHECK_EQ(combiner_data_.active_combiner, nullptr);
+  ABSL_CHECK_EQ(combiner_data_.active_combiner, nullptr);
   return did_something;
 }

@@ -107,7 +107,7 @@ void ExecCtx::Run(const DebugLocation& location, grpc_closure* closure,
   closure->file_initiated = location.file();
   closure->line_initiated = location.line();
   closure->run = false;
-  CHECK_NE(closure->cb, nullptr);
+  ABSL_CHECK_NE(closure->cb, nullptr);
 #endif
   closure->error_data.error = internal::StatusAllocHeapPtr(error);
   exec_ctx_sched(closure);
@@ -130,7 +130,7 @@ void ExecCtx::RunList(const DebugLocation& location, grpc_closure_list* list) {
     c->file_initiated = location.file();
     c->line_initiated = location.line();
     c->run = false;
-    CHECK_NE(c->cb, nullptr);
+    ABSL_CHECK_NE(c->cb, nullptr);
 #endif
     exec_ctx_sched(c);
     c = next;
diff --git a/third_party/grpc/source/src/core/lib/iomgr/exec_ctx.h b/third_party/grpc/source/src/core/lib/iomgr/exec_ctx.h
index dc61faa9e82e5..86b77baf8fdba 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/exec_ctx.h
+++ b/third_party/grpc/source/src/core/lib/iomgr/exec_ctx.h
@@ -33,7 +33,7 @@
 #include <grpc/support/cpu.h>
 #include <grpc/support/time.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/experiments/experiments.h"
 #include "src/core/lib/iomgr/closure.h"
 #include "src/core/util/debug_location.h"
@@ -314,8 +314,8 @@ class GRPC_DLL ApplicationCallbackExecCtx {
         Fork::DecExecCtxCount();
       }
     } else {
-      DCHECK_EQ(head_, nullptr);
-      DCHECK_EQ(tail_, nullptr);
+      ABSL_DCHECK_EQ(head_, nullptr);
+      ABSL_DCHECK_EQ(tail_, nullptr);
     }
   }

diff --git a/third_party/grpc/source/src/core/lib/iomgr/executor.cc b/third_party/grpc/source/src/core/lib/iomgr/executor.cc
index b9ff3a5f78fac..9bb3dad2d1012 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/executor.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/executor.cc
@@ -24,8 +24,8 @@
 #include <grpc/support/sync.h>
 #include <string.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_format.h"
 #include "src/core/lib/debug/trace_impl.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
@@ -137,7 +137,7 @@ void Executor::SetThreading(bool threading) {
       return;
     }

-    CHECK_EQ(num_threads_, 0);
+    ABSL_CHECK_EQ(num_threads_, 0);
     gpr_atm_rel_store(&num_threads_, 1);
     thd_state_ = static_cast<ThreadState*>(
         gpr_zalloc(sizeof(ThreadState) * max_threads_));
@@ -372,7 +372,7 @@ void Executor::InitAll() {

   // Return if Executor::InitAll() is already called earlier
   if (executors[static_cast<size_t>(ExecutorType::DEFAULT)] != nullptr) {
-    CHECK(executors[static_cast<size_t>(ExecutorType::RESOLVER)] != nullptr);
+    ABSL_CHECK(executors[static_cast<size_t>(ExecutorType::RESOLVER)] != nullptr);
     return;
   }

@@ -398,7 +398,7 @@ void Executor::ShutdownAll() {

   // Return if Executor:SshutdownAll() is already called earlier
   if (executors[static_cast<size_t>(ExecutorType::DEFAULT)] == nullptr) {
-    CHECK(executors[static_cast<size_t>(ExecutorType::RESOLVER)] == nullptr);
+    ABSL_CHECK(executors[static_cast<size_t>(ExecutorType::RESOLVER)] == nullptr);
     return;
   }

@@ -426,7 +426,7 @@ void Executor::ShutdownAll() {
 }

 bool Executor::IsThreaded(ExecutorType executor_type) {
-  CHECK(executor_type < ExecutorType::NUM_EXECUTORS);
+  ABSL_CHECK(executor_type < ExecutorType::NUM_EXECUTORS);
   return executors[static_cast<size_t>(executor_type)]->IsThreaded();
 }

diff --git a/third_party/grpc/source/src/core/lib/iomgr/fork_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/fork_posix.cc
index 0d784ea53ccf5..e211010a26b4b 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/fork_posix.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/fork_posix.cc
@@ -30,7 +30,7 @@
 #include <grpc/grpc.h>
 #include <string.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/iomgr/ev_posix.h"
 #include "src/core/lib/iomgr/executor.h"
 #include "src/core/lib/iomgr/timer_manager.h"
@@ -59,7 +59,7 @@ void grpc_prefork() {
   }
   grpc_core::ExecCtx exec_ctx;
   if (!grpc_core::Fork::Enabled()) {
-    LOG(ERROR) << "Fork support not enabled; try running with the "
+    ABSL_LOG(ERROR) << "Fork support not enabled; try running with the "
                   "environment variable GRPC_ENABLE_FORK_SUPPORT=1";
     return;
   }
@@ -67,12 +67,12 @@ void grpc_prefork() {
   if (poll_strategy_name == nullptr ||
       (strcmp(poll_strategy_name, "epoll1") != 0 &&
        strcmp(poll_strategy_name, "poll") != 0)) {
-    LOG(INFO) << "Fork support is only compatible with the epoll1 and poll "
+    ABSL_LOG(INFO) << "Fork support is only compatible with the epoll1 and poll "
                  "polling strategies";
     return;
   }
   if (!grpc_core::Fork::BlockExecCtx()) {
-    LOG(INFO) << "Other threads are currently calling into gRPC, skipping "
+    ABSL_LOG(INFO) << "Other threads are currently calling into gRPC, skipping "
                  "fork() handlers";
     return;
   }
diff --git a/third_party/grpc/source/src/core/lib/iomgr/fork_windows.cc b/third_party/grpc/source/src/core/lib/iomgr/fork_windows.cc
index baf9e2124692d..dbc0025a8938b 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/fork_windows.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/fork_windows.cc
@@ -24,14 +24,14 @@

 #include <grpc/fork.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"

 //
 // NOTE: FORKING IS NOT GENERALLY SUPPORTED, THIS IS ONLY INTENDED TO WORK
 //       AROUND VERY SPECIFIC USE CASES.
 //

-void grpc_prefork() { LOG(ERROR) << "Forking not supported on Windows"; }
+void grpc_prefork() { ABSL_LOG(ERROR) << "Forking not supported on Windows"; }

 void grpc_postfork_parent() {}

diff --git a/third_party/grpc/source/src/core/lib/iomgr/internal_errqueue.cc b/third_party/grpc/source/src/core/lib/iomgr/internal_errqueue.cc
index d5386498a53e6..0025222800549 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/internal_errqueue.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/internal_errqueue.cc
@@ -16,7 +16,7 @@

 #include <grpc/support/port_platform.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/iomgr/port.h"

 #ifdef GRPC_POSIX_SOCKET_TCP
@@ -37,7 +37,7 @@ bool KernelSupportsErrqueue() {
     // least 4.0.0
     struct utsname buffer;
     if (uname(&buffer) != 0) {
-      LOG(ERROR) << "uname: " << StrError(errno);
+      ABSL_LOG(ERROR) << "uname: " << StrError(errno);
       return false;
     }
     char* release = buffer.release;
@@ -48,7 +48,7 @@ bool KernelSupportsErrqueue() {
     if (strtol(release, nullptr, 10) >= 4) {
       return true;
     } else {
-      VLOG(2) << "ERRQUEUE support not enabled";
+      ABSL_VLOG(2) << "ERRQUEUE support not enabled";
     }
 #endif  // GRPC_LINUX_ERRQUEUE
     return false;
diff --git a/third_party/grpc/source/src/core/lib/iomgr/iocp_windows.cc b/third_party/grpc/source/src/core/lib/iomgr/iocp_windows.cc
index 12b8cb31c6326..b722e1f5427b2 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/iocp_windows.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/iocp_windows.cc
@@ -28,8 +28,8 @@

 #include <limits>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/iomgr/iocp_windows.h"
 #include "src/core/lib/iomgr/iomgr_internal.h"
 #include "src/core/lib/iomgr/socket_windows.h"
@@ -73,8 +73,8 @@ grpc_iocp_work_status grpc_iocp_work(grpc_core::Timestamp deadline) {
   if (success == 0 && overlapped == NULL) {
     return GRPC_IOCP_WORK_TIMEOUT;
   }
-  CHECK(completion_key);
-  CHECK(overlapped);
+  ABSL_CHECK(completion_key);
+  ABSL_CHECK(overlapped);
   if (overlapped == &g_iocp_custom_overlap) {
     gpr_atm_full_fetch_add(&g_custom_events, -1);
     if (completion_key == (ULONG_PTR)&g_iocp_kick_token) {
@@ -102,7 +102,7 @@ grpc_iocp_work_status grpc_iocp_work(grpc_core::Timestamp deadline) {
     info->bytes_transferred = bytes;
     info->wsa_error = success ? 0 : WSAGetLastError();
   }
-  CHECK(overlapped == &info->overlapped);
+  ABSL_CHECK(overlapped == &info->overlapped);
   bool should_destroy = grpc_socket_become_ready(socket, info);
   gpr_mu_unlock(&socket->state_mu);
   if (should_destroy) {
@@ -114,7 +114,7 @@ grpc_iocp_work_status grpc_iocp_work(grpc_core::Timestamp deadline) {
 void grpc_iocp_init(void) {
   g_iocp =
       CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, (ULONG_PTR)NULL, 0);
-  CHECK(g_iocp);
+  ABSL_CHECK(g_iocp);
 }

 void grpc_iocp_kick(void) {
@@ -123,7 +123,7 @@ void grpc_iocp_kick(void) {
   gpr_atm_full_fetch_add(&g_custom_events, 1);
   success = PostQueuedCompletionStatus(g_iocp, 0, (ULONG_PTR)&g_iocp_kick_token,
                                        &g_iocp_custom_overlap);
-  CHECK(success);
+  ABSL_CHECK(success);
 }

 void grpc_iocp_flush(void) {
@@ -145,7 +145,7 @@ void grpc_iocp_shutdown(void) {
     grpc_core::ExecCtx::Get()->Flush();
   }

-  CHECK(CloseHandle(g_iocp));
+  ABSL_CHECK(CloseHandle(g_iocp));
 }

 void grpc_iocp_add_socket(grpc_winsocket* socket) {
@@ -155,13 +155,13 @@ void grpc_iocp_add_socket(grpc_winsocket* socket) {
                                (uintptr_t)socket, 0);
   if (!ret) {
     char* utf8_message = gpr_format_message(WSAGetLastError());
-    LOG(ERROR) << "Unable to add socket to iocp: " << utf8_message;
+    ABSL_LOG(ERROR) << "Unable to add socket to iocp: " << utf8_message;
     gpr_free(utf8_message);
     __debugbreak();
     abort();
   }
   socket->added_to_iocp = 1;
-  CHECK(ret == g_iocp);
+  ABSL_CHECK(ret == g_iocp);
 }

 void grpc_iocp_register_socket_shutdown_socket_locked(grpc_winsocket* socket) {
diff --git a/third_party/grpc/source/src/core/lib/iomgr/iomgr.cc b/third_party/grpc/source/src/core/lib/iomgr/iomgr.cc
index 3b571df5687e6..c9abbbdada41f 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/iomgr.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/iomgr.cc
@@ -26,7 +26,7 @@
 #include <stdlib.h>
 #include <string.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/config/config_vars.h"
 #include "src/core/lib/iomgr/buffer_list.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
@@ -81,7 +81,7 @@ size_t grpc_iomgr_count_objects_for_testing(void) {
 static void dump_objects(const char* kind) {
   grpc_iomgr_object* obj;
   for (obj = g_root_object.next; obj != &g_root_object; obj = obj->next) {
-    VLOG(2) << kind << " OBJECT: " << obj->name << " " << obj;
+    ABSL_VLOG(2) << kind << " OBJECT: " << obj->name << " " << obj;
   }
 }

@@ -101,7 +101,7 @@ void grpc_iomgr_shutdown() {
               gpr_time_sub(gpr_now(GPR_CLOCK_REALTIME), last_warning_time),
               gpr_time_from_seconds(1, GPR_TIMESPAN)) >= 0) {
         if (g_root_object.next != &g_root_object) {
-          VLOG(2) << "Waiting for " << count_objects()
+          ABSL_VLOG(2) << "Waiting for " << count_objects()
                   << " iomgr objects to be destroyed";
         }
         last_warning_time = gpr_now(GPR_CLOCK_REALTIME);
@@ -116,7 +116,7 @@ void grpc_iomgr_shutdown() {
       }
       if (g_root_object.next != &g_root_object) {
         if (grpc_iomgr_abort_on_leaks()) {
-          VLOG(2) << "Failed to free " << count_objects()
+          ABSL_VLOG(2) << "Failed to free " << count_objects()
                   << " iomgr objects before shutdown deadline: "
                   << "memory leaks are likely";
           dump_objects("LEAKED");
@@ -129,7 +129,7 @@ void grpc_iomgr_shutdown() {
           if (gpr_time_cmp(gpr_now(GPR_CLOCK_REALTIME), shutdown_deadline) >
               0) {
             if (g_root_object.next != &g_root_object) {
-              VLOG(2) << "Failed to free " << count_objects()
+              ABSL_VLOG(2) << "Failed to free " << count_objects()
                       << " iomgr objects before shutdown deadline: "
                       << "memory leaks are likely";
               dump_objects("LEAKED");
diff --git a/third_party/grpc/source/src/core/lib/iomgr/iomgr_windows.cc b/third_party/grpc/source/src/core/lib/iomgr/iomgr_windows.cc
index 38e61b8122547..a7d8c9b9567aa 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/iomgr_windows.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/iomgr_windows.cc
@@ -22,7 +22,7 @@

 #ifdef GRPC_WINSOCK_SOCKET

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/experiments/experiments.h"
 #include "src/core/lib/iomgr/iocp_windows.h"
 #include "src/core/lib/iomgr/iomgr.h"
@@ -50,12 +50,12 @@ extern grpc_pollset_set_vtable grpc_windows_pollset_set_vtable;
 static void winsock_init(void) {
   WSADATA wsaData;
   int status = WSAStartup(MAKEWORD(2, 0), &wsaData);
-  CHECK_EQ(status, 0);
+  ABSL_CHECK_EQ(status, 0);
 }

 static void winsock_shutdown(void) {
   int status = WSACleanup();
-  CHECK_EQ(status, 0);
+  ABSL_CHECK_EQ(status, 0);
 }

 static void iomgr_platform_init(void) {
diff --git a/third_party/grpc/source/src/core/lib/iomgr/lockfree_event.cc b/third_party/grpc/source/src/core/lib/iomgr/lockfree_event.cc
index 42023ef4615e2..eec7ade9f7e6d 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/lockfree_event.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/lockfree_event.cc
@@ -20,8 +20,8 @@

 #include <grpc/support/port_platform.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
 #include "src/core/util/crash.h"
@@ -78,7 +78,7 @@ void LockfreeEvent::DestroyEvent() {
     if (curr & kShutdownBit) {
       internal::StatusFreeHeapPtr(curr & ~kShutdownBit);
     } else {
-      CHECK(curr == kClosureNotReady || curr == kClosureReady);
+      ABSL_CHECK(curr == kClosureNotReady || curr == kClosureReady);
     }
     // we CAS in a shutdown, no error value here. If this event is interacted
     // with post-deletion (see the note in the constructor) we want the bit
diff --git a/third_party/grpc/source/src/core/lib/iomgr/polling_entity.cc b/third_party/grpc/source/src/core/lib/iomgr/polling_entity.cc
index 8a5ad277f24a5..8ee128244e2c3 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/polling_entity.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/polling_entity.cc
@@ -21,7 +21,7 @@
 #include <grpc/support/alloc.h>
 #include <grpc/support/port_platform.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_format.h"
 #include "src/core/util/crash.h"

@@ -73,7 +73,7 @@ void grpc_polling_entity_add_to_pollset_set(grpc_polling_entity* pollent,
       grpc_pollset_set_add_pollset(pss_dst, pollent->pollent.pollset);
     }
   } else if (pollent->tag == GRPC_POLLS_POLLSET_SET) {
-    CHECK_NE(pollent->pollent.pollset_set, nullptr);
+    ABSL_CHECK_NE(pollent->pollent.pollset_set, nullptr);
     grpc_pollset_set_add_pollset_set(pss_dst, pollent->pollent.pollset_set);
   } else if (pollent->tag == GRPC_POLLS_NONE) {
     // Do nothing.
@@ -91,11 +91,11 @@ void grpc_polling_entity_del_from_pollset_set(grpc_polling_entity* pollent,
       grpc_pollset_set_del_pollset(pss_dst, pollent->pollent.pollset);
     }
 #else
-    CHECK_NE(pollent->pollent.pollset, nullptr);
+    ABSL_CHECK_NE(pollent->pollent.pollset, nullptr);
     grpc_pollset_set_del_pollset(pss_dst, pollent->pollent.pollset);
 #endif
   } else if (pollent->tag == GRPC_POLLS_POLLSET_SET) {
-    CHECK_NE(pollent->pollent.pollset_set, nullptr);
+    ABSL_CHECK_NE(pollent->pollent.pollset_set, nullptr);
     grpc_pollset_set_del_pollset_set(pss_dst, pollent->pollent.pollset_set);
   } else if (pollent->tag == GRPC_POLLS_NONE) {
     // Do nothing.
diff --git a/third_party/grpc/source/src/core/lib/iomgr/sockaddr_utils_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/sockaddr_utils_posix.cc
index a522df8aecda0..82f26aa7a594a 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/sockaddr_utils_posix.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/sockaddr_utils_posix.cc
@@ -39,7 +39,7 @@

 #include <string>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/iomgr/sockaddr.h"
 #include "src/core/util/crash.h"

@@ -56,7 +56,7 @@ int grpc_inet_pton(int af, const char* src, void* dst) {
 }

 const char* grpc_inet_ntop(int af, const void* src, char* dst, size_t size) {
-  CHECK(size <= (socklen_t)-1);
+  ABSL_CHECK(size <= (socklen_t)-1);
   return inet_ntop(af, src, dst, static_cast<socklen_t>(size));
 }

diff --git a/third_party/grpc/source/src/core/lib/iomgr/socket_utils_common_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/socket_utils_common_posix.cc
index 8b1af9db7298d..b5160c4ea7f34 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/socket_utils_common_posix.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/socket_utils_common_posix.cc
@@ -46,8 +46,8 @@

 #include <string>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/lib/address_utils/sockaddr_utils.h"
 #include "src/core/lib/iomgr/sockaddr.h"
@@ -388,12 +388,12 @@ grpc_error_handle grpc_set_socket_tcp_user_timeout(
             << " ms";
         if (0 != setsockopt(fd, IPPROTO_TCP, TCP_USER_TIMEOUT, &timeout,
                             sizeof(timeout))) {
-          LOG(ERROR) << "setsockopt(TCP_USER_TIMEOUT) "
+          ABSL_LOG(ERROR) << "setsockopt(TCP_USER_TIMEOUT) "
                      << grpc_core::StrError(errno);
           return absl::OkStatus();
         }
         if (0 != getsockopt(fd, IPPROTO_TCP, TCP_USER_TIMEOUT, &newval, &len)) {
-          LOG(ERROR) << "getsockopt(TCP_USER_TIMEOUT) "
+          ABSL_LOG(ERROR) << "getsockopt(TCP_USER_TIMEOUT) "
                      << grpc_core::StrError(errno);
           return absl::OkStatus();
         }
@@ -415,7 +415,7 @@ grpc_error_handle grpc_set_socket_tcp_user_timeout(
 // set a socket using a grpc_socket_mutator
 grpc_error_handle grpc_set_socket_with_mutator(int fd, grpc_fd_usage usage,
                                                grpc_socket_mutator* mutator) {
-  CHECK(mutator);
+  ABSL_CHECK(mutator);
   if (!grpc_socket_mutator_mutate_fd(mutator, fd, usage)) {
     return GRPC_ERROR_CREATE("grpc_socket_mutator failed.");
   }
@@ -478,7 +478,7 @@ static int create_socket(grpc_socket_factory* factory, int domain, int type,
                 : socket(domain, type, protocol);
   if (res < 0 && errno == EMFILE) {
     int saved_errno = errno;
-    LOG_EVERY_N_SEC(ERROR, 10)
+    ABSL_LOG_EVERY_N_SEC(ERROR, 10)
         << "socket(" << domain << ", " << type << ", " << protocol
         << ") returned " << res << " with error: |"
         << grpc_core::StrError(errno)
diff --git a/third_party/grpc/source/src/core/lib/iomgr/socket_windows.cc b/third_party/grpc/source/src/core/lib/iomgr/socket_windows.cc
index 8ec4eaa1366f2..8816d94a72d5d 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/socket_windows.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/socket_windows.cc
@@ -29,8 +29,8 @@
 #include <grpc/support/log_windows.h>
 #include <mswsock.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_format.h"
 #include "src/core/lib/iomgr/iocp_windows.h"
 #include "src/core/lib/iomgr/iomgr_internal.h"
@@ -130,7 +130,7 @@ void grpc_winsocket_shutdown(grpc_winsocket* winsocket) {
     DisconnectEx(winsocket->socket, NULL, 0, 0);
   } else {
     char* utf8_message = gpr_format_message(WSAGetLastError());
-    VLOG(2) << "Unable to retrieve DisconnectEx pointer : " << utf8_message;
+    ABSL_VLOG(2) << "Unable to retrieve DisconnectEx pointer : " << utf8_message;
     gpr_free(utf8_message);
   }
   // Calling closesocket triggers invocation of any pending I/O operations with
@@ -157,7 +157,7 @@ void grpc_winsocket_finish(grpc_winsocket* winsocket) {

 void grpc_winsocket_destroy(grpc_winsocket* winsocket) {
   gpr_mu_lock(&winsocket->state_mu);
-  CHECK(!winsocket->destroy_called);
+  ABSL_CHECK(!winsocket->destroy_called);
   winsocket->destroy_called = true;
   bool should_destroy = check_destroyable(winsocket);
   gpr_mu_unlock(&winsocket->state_mu);
@@ -172,7 +172,7 @@ void grpc_winsocket_destroy(grpc_winsocket* winsocket) {
 //-) The IOCP hasn't completed yet, and we're queuing it for later.
 static void socket_notify_on_iocp(grpc_winsocket* socket, grpc_closure* closure,
                                   grpc_winsocket_callback_info* info) {
-  CHECK(info->closure == NULL);
+  ABSL_CHECK(info->closure == NULL);
   gpr_mu_lock(&socket->state_mu);
   if (info->has_pending_iocp) {
     info->has_pending_iocp = 0;
@@ -194,7 +194,7 @@ void grpc_socket_notify_on_read(grpc_winsocket* socket, grpc_closure* closure) {

 bool grpc_socket_become_ready(grpc_winsocket* socket,
                               grpc_winsocket_callback_info* info) {
-  CHECK(!info->has_pending_iocp);
+  ABSL_CHECK(!info->has_pending_iocp);
   if (info->closure) {
     // Only run the closure once at shutdown.
     if (!info->closure_already_executed_at_shutdown) {
@@ -214,7 +214,7 @@ static void probe_ipv6_once(void) {
   SOCKET s = socket(AF_INET6, SOCK_STREAM, 0);
   g_ipv6_loopback_available = 0;
   if (s == INVALID_SOCKET) {
-    VLOG(2) << "Disabling AF_INET6 sockets because socket() failed.";
+    ABSL_VLOG(2) << "Disabling AF_INET6 sockets because socket() failed.";
   } else {
     grpc_sockaddr_in6 addr;
     memset(&addr, 0, sizeof(addr));
@@ -223,7 +223,7 @@ static void probe_ipv6_once(void) {
     if (bind(s, reinterpret_cast<grpc_sockaddr*>(&addr), sizeof(addr)) == 0) {
       g_ipv6_loopback_available = 1;
     } else {
-      VLOG(2) << "Disabling AF_INET6 sockets because ::1 is not available.";
+      ABSL_VLOG(2) << "Disabling AF_INET6 sockets because ::1 is not available.";
     }
     closesocket(s);
   }
diff --git a/third_party/grpc/source/src/core/lib/iomgr/tcp_client_cfstream.cc b/third_party/grpc/source/src/core/lib/iomgr/tcp_client_cfstream.cc
index 141a9c76f5242..5242895ffcb29 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/tcp_client_cfstream.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/tcp_client_cfstream.cc
@@ -30,7 +30,7 @@
 #include <netinet/in.h>
 #include <string.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/address_utils/sockaddr_utils.h"
 #include "src/core/lib/event_engine/shim.h"
 #include "src/core/lib/iomgr/cfstream_handle.h"
diff --git a/third_party/grpc/source/src/core/lib/iomgr/tcp_client_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/tcp_client_posix.cc
index 4a01cf5a969cf..9b04859db2608 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/tcp_client_posix.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/tcp_client_posix.cc
@@ -31,8 +31,8 @@
 #include <unistd.h>

 #include "absl/container/flat_hash_map.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/lib/address_utils/sockaddr_utils.h"
 #include "src/core/lib/event_engine/resolved_address_internal.h"
@@ -99,7 +99,7 @@ static grpc_error_handle prepare_socket(
     const grpc_core::PosixTcpOptions& options) {
   grpc_error_handle err;

-  CHECK_GE(fd, 0);
+  ABSL_CHECK_GE(fd, 0);

   err = grpc_set_socket_nonblocking(fd, 1);
   if (!err.ok()) goto error;
@@ -182,7 +182,7 @@ static void on_writable(void* acp, grpc_error_handle error) {
       << ": on_writable: error=" << grpc_core::StatusToString(error);

   gpr_mu_lock(&ac->mu);
-  CHECK(ac->fd);
+  ABSL_CHECK(ac->fd);
   fd = ac->fd;
   ac->fd = nullptr;
   bool connect_cancelled = ac->connect_cancelled;
@@ -233,7 +233,7 @@ static void on_writable(void* acp, grpc_error_handle error) {
       // your program or another program on the same computer
       // opened too many network connections.  The "easy" fix:
       // don't do that!
-      LOG(ERROR) << "kernel out of buffers";
+      ABSL_LOG(ERROR) << "kernel out of buffers";
       gpr_mu_unlock(&ac->mu);
       grpc_fd_notify_on_write(fd, &ac->write_closure);
       return;
@@ -268,7 +268,7 @@ finish:
     std::string str;
     bool ret = grpc_error_get_str(
         error, grpc_core::StatusStrProperty::kDescription, &str);
-    CHECK(ret);
+    ABSL_CHECK(ret);
     std::string description =
         absl::StrCat("Failed to connect to remote host: ", str);
     error = grpc_error_set_str(
@@ -434,7 +434,7 @@ static bool tcp_cancel_connect(int64_t connection_handle) {
     auto it = shard->pending_connections.find(connection_handle);
     if (it != shard->pending_connections.end()) {
       ac = it->second;
-      CHECK_NE(ac, nullptr);
+      ABSL_CHECK_NE(ac, nullptr);
       // Trying to acquire ac->mu here would could cause a deadlock because
       // the on_writable method tries to acquire the two mutexes used
       // here in the reverse order. But we dont need to acquire ac->mu before
diff --git a/third_party/grpc/source/src/core/lib/iomgr/tcp_client_windows.cc b/third_party/grpc/source/src/core/lib/iomgr/tcp_client_windows.cc
index 7d464759575ab..4749875c19de8 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/tcp_client_windows.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/tcp_client_windows.cc
@@ -28,7 +28,7 @@
 #include <grpc/support/alloc.h>
 #include <grpc/support/log_windows.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/address_utils/sockaddr_utils.h"
 #include "src/core/lib/event_engine/shim.h"
 #include "src/core/lib/iomgr/event_engine_shims/tcp_client.h"
@@ -82,7 +82,7 @@ static void on_alarm(void* acp, grpc_error_handle /* error */) {
 static void on_connect(void* acp, grpc_error_handle error) {
   async_connect* ac = (async_connect*)acp;
   grpc_endpoint** ep = ac->endpoint;
-  CHECK(*ep == NULL);
+  ABSL_CHECK(*ep == NULL);
   grpc_closure* on_done = ac->on_done;

   gpr_mu_lock(&ac->mu);
@@ -101,7 +101,7 @@ static void on_connect(void* acp, grpc_error_handle error) {
       BOOL wsa_success =
           WSAGetOverlappedResult(socket->socket, &socket->write_info.overlapped,
                                  &transferred_bytes, FALSE, &flags);
-      CHECK_EQ(transferred_bytes, 0);
+      ABSL_CHECK_EQ(transferred_bytes, 0);
       if (!wsa_success) {
         error = GRPC_WSA_ERROR(WSAGetLastError(), "ConnectEx");
         closesocket(socket->socket);
@@ -242,7 +242,7 @@ static int64_t tcp_connect(grpc_closure* on_done, grpc_endpoint** endpoint,
   return 0;

 failure:
-  CHECK(!error.ok());
+  ABSL_CHECK(!error.ok());
   grpc_error_handle final_error =
       GRPC_ERROR_CREATE_REFERENCING("Failed to connect", &error, 1);
   if (socket != NULL) {
diff --git a/third_party/grpc/source/src/core/lib/iomgr/tcp_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/tcp_posix.cc
index 9da71b5b2cd87..0147ad52e9190 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/tcp_posix.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/tcp_posix.cc
@@ -50,8 +50,8 @@
 #include <algorithm>
 #include <unordered_map>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/address_utils/sockaddr_utils.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/lib/experiments/experiments.h"
@@ -155,7 +155,7 @@ class TcpZerocopySendRecord {
   //  sendmsg() failed or when tcp_write() is done.
   bool Unref() {
     const intptr_t prior = ref_.fetch_sub(1, std::memory_order_acq_rel);
-    DCHECK_GT(prior, 0);
+    ABSL_DCHECK_GT(prior, 0);
     if (prior == 1) {
       AllSendsComplete();
       return true;
@@ -170,9 +170,9 @@ class TcpZerocopySendRecord {
   };

   void AssertEmpty() {
-    DCHECK_EQ(buf_.count, 0u);
-    DCHECK_EQ(buf_.length, 0u);
-    DCHECK_EQ(ref_.load(std::memory_order_relaxed), 0);
+    ABSL_DCHECK_EQ(buf_.count, 0u);
+    ABSL_DCHECK_EQ(buf_.length, 0u);
+    ABSL_DCHECK_EQ(ref_.load(std::memory_order_relaxed), 0);
   }

   // When all sendmsg() calls associated with this tcp_write() have been
@@ -180,7 +180,7 @@ class TcpZerocopySendRecord {
   // for each sendmsg()) and all reference counts have been dropped, drop our
   // reference to the underlying data since we no longer need it.
   void AllSendsComplete() {
-    DCHECK_EQ(ref_.load(std::memory_order_relaxed), 0);
+    ABSL_DCHECK_EQ(ref_.load(std::memory_order_relaxed), 0);
     grpc_slice_buffer_reset_and_unref(&buf_);
   }

@@ -260,7 +260,7 @@ class TcpZerocopySendCtx {
     --last_send_;
     if (ReleaseSendRecord(last_send_)->Unref()) {
       // We should still be holding the ref taken by tcp_write().
-      DCHECK(0);
+      ABSL_DCHECK(0);
     }
   }

@@ -296,8 +296,8 @@ class TcpZerocopySendCtx {
   // max_sends_ tcp_write() instances with zerocopy enabled in flight at the
   // same time.
   void PutSendRecord(TcpZerocopySendRecord* record) {
-    DCHECK(record >= send_records_);
-    DCHECK(record < send_records_ + max_sends_);
+    ABSL_DCHECK(record >= send_records_);
+    ABSL_DCHECK(record < send_records_ + max_sends_);
     MutexLock guard(&lock_);
     PutSendRecordLocked(record);
   }
@@ -316,7 +316,7 @@ class TcpZerocopySendCtx {
   bool enabled() const { return enabled_; }

   void set_enabled(bool enabled) {
-    DCHECK(!enabled || !memory_limited());
+    ABSL_DCHECK(!enabled || !memory_limited());
     enabled_ = enabled;
   }

@@ -354,7 +354,7 @@ class TcpZerocopySendCtx {
       zcopy_enobuf_state_ = OMemState::CHECK;
       return false;
     }
-    DCHECK(zcopy_enobuf_state_ != OMemState::CHECK);
+    ABSL_DCHECK(zcopy_enobuf_state_ != OMemState::CHECK);
     if (zcopy_enobuf_state_ == OMemState::FULL) {
       // A previous sendmsg attempt was blocked by ENOBUFS. Return true to
       // mark the fd as writable so the next write attempt could be made.
@@ -428,7 +428,7 @@ class TcpZerocopySendCtx {

   TcpZerocopySendRecord* ReleaseSendRecordLocked(uint32_t seq) {
     auto iter = ctx_lookup_.find(seq);
-    DCHECK(iter != ctx_lookup_.end());
+    ABSL_DCHECK(iter != ctx_lookup_.end());
     TcpZerocopySendRecord* record = iter->second;
     ctx_lookup_.erase(iter);
     return record;
@@ -446,7 +446,7 @@ class TcpZerocopySendCtx {
   }

   void PutSendRecordLocked(TcpZerocopySendRecord* record) {
-    DCHECK(free_send_records_size_ < max_sends_);
+    ABSL_DCHECK(free_send_records_size_ < max_sends_);
     free_send_records_[free_send_records_size_] = record;
     free_send_records_size_++;
   }
@@ -591,7 +591,7 @@ void LogCommonIOErrors(absl::string_view prefix, int error_no) {
       return;
     default:
       grpc_core::global_stats().IncrementUncommonIoErrorCount();
-      LOG_EVERY_N_SEC(ERROR, 1)
+      ABSL_LOG_EVERY_N_SEC(ERROR, 1)
           << prefix.data()
           << " encountered uncommon error: " << grpc_core::StrError(error_no);
       return;
@@ -634,7 +634,7 @@ static void run_poller(void* bp, grpc_error_handle /*error_ignored*/) {
   g_backup_poller_mu->Lock();
   // last "uncovered" notification is the ref that keeps us polling
   if (g_uncovered_notifications_pending == 1) {
-    CHECK(g_backup_poller == p);
+    ABSL_CHECK(g_backup_poller == p);
     g_backup_poller = nullptr;
     g_uncovered_notifications_pending = 0;
     g_backup_poller_mu->Unlock();
@@ -658,7 +658,7 @@ static void drop_uncovered(grpc_tcp* /*tcp*/) {
   p = g_backup_poller;
   old_count = g_uncovered_notifications_pending--;
   g_backup_poller_mu->Unlock();
-  CHECK_GT(old_count, 1);
+  ABSL_CHECK_GT(old_count, 1);
   GRPC_TRACE_LOG(tcp, INFO) << "BACKUP_POLLER:" << p << " uncover cnt "
                             << old_count << "->" << old_count - 1;
 }
@@ -829,16 +829,16 @@ static void tcp_trace_read(grpc_tcp* tcp, grpc_error_handle error)
     ABSL_EXCLUSIVE_LOCKS_REQUIRED(tcp->read_mu) {
   grpc_closure* cb = tcp->read_cb;
   if (GRPC_TRACE_FLAG_ENABLED(tcp)) {
-    LOG(INFO) << "TCP:" << tcp << " call_cb " << cb << " " << cb->cb << ":"
+    ABSL_LOG(INFO) << "TCP:" << tcp << " call_cb " << cb << " " << cb->cb << ":"
               << cb->cb_arg;
     size_t i;
-    LOG(INFO) << "READ " << tcp << " (peer=" << tcp->peer_string
+    ABSL_LOG(INFO) << "READ " << tcp << " (peer=" << tcp->peer_string
               << ") error=" << grpc_core::StatusToString(error);
     if (ABSL_VLOG_IS_ON(2)) {
       for (i = 0; i < tcp->incoming_buffer->count; i++) {
         char* dump = grpc_dump_slice(tcp->incoming_buffer->slices[i],
                                      GPR_DUMP_HEX | GPR_DUMP_ASCII);
-        VLOG(2) << "READ DATA: " << dump;
+        ABSL_VLOG(2) << "READ DATA: " << dump;
         gpr_free(dump);
       }
     }
@@ -881,7 +881,7 @@ static void update_rcvlowat(grpc_tcp* tcp)
   }
   if (setsockopt(tcp->fd, SOL_SOCKET, SO_RCVLOWAT, &remaining,
                  sizeof(remaining)) != 0) {
-    LOG(ERROR) << "Cannot set SO_RCVLOWAT on fd=" << tcp->fd
+    ABSL_LOG(ERROR) << "Cannot set SO_RCVLOWAT on fd=" << tcp->fd
                << " err=" << grpc_core::StrError(errno);
     return;
   }
@@ -912,8 +912,8 @@ static bool tcp_do_read(grpc_tcp* tcp, grpc_error_handle* error)
     iov[i].iov_len = GRPC_SLICE_LENGTH(tcp->incoming_buffer->slices[i]);
   }

-  CHECK_NE(tcp->incoming_buffer->length, 0u);
-  DCHECK_GT(tcp->min_progress_size, 0);
+  ABSL_CHECK_NE(tcp->incoming_buffer->length, 0u);
+  ABSL_DCHECK_GT(tcp->min_progress_size, 0);

   do {
     // Assume there is something on the queue. If we receive TCP_INQ from
@@ -981,12 +981,12 @@ static bool tcp_do_read(grpc_tcp* tcp, grpc_error_handle* error)

     grpc_core::global_stats().IncrementTcpReadSize(read_bytes);
     add_to_estimate(tcp, static_cast<size_t>(read_bytes));
-    DCHECK((size_t)read_bytes <=
+    ABSL_DCHECK((size_t)read_bytes <=
            tcp->incoming_buffer->length - total_read_bytes);

 #ifdef GRPC_HAVE_TCP_INQ
     if (tcp->inq_capable) {
-      DCHECK(!(msg.msg_flags & MSG_CTRUNC));
+      ABSL_DCHECK(!(msg.msg_flags & MSG_CTRUNC));
       struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg);
       for (; cmsg != nullptr; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
         if (cmsg->cmsg_level == SOL_TCP && cmsg->cmsg_type == TCP_CM_INQ &&
@@ -1029,7 +1029,7 @@ static bool tcp_do_read(grpc_tcp* tcp, grpc_error_handle* error)
     finish_estimate(tcp);
   }

-  DCHECK_GT(total_read_bytes, 0u);
+  ABSL_DCHECK_GT(total_read_bytes, 0u);
   *error = absl::OkStatus();
   if (grpc_core::IsTcpFrameSizeTuningEnabled()) {
     // Update min progress size based on the total number of bytes read in
@@ -1147,7 +1147,7 @@ static void tcp_handle_read(void* arg /* grpc_tcp */, grpc_error_handle error) {
 static void tcp_read(grpc_endpoint* ep, grpc_slice_buffer* incoming_buffer,
                      grpc_closure* cb, bool urgent, int min_progress_size) {
   grpc_tcp* tcp = reinterpret_cast<grpc_tcp*>(ep);
-  CHECK_EQ(tcp->read_cb, nullptr);
+  ABSL_CHECK_EQ(tcp->read_cb, nullptr);
   tcp->read_cb = cb;
   tcp->read_mu.Lock();
   tcp->incoming_buffer = incoming_buffer;
@@ -1229,8 +1229,8 @@ static TcpZerocopySendRecord* tcp_get_send_zerocopy_record(
     }
     if (zerocopy_send_record != nullptr) {
       zerocopy_send_record->PrepareForSends(buf);
-      DCHECK_EQ(buf->count, 0u);
-      DCHECK_EQ(buf->length, 0u);
+      ABSL_DCHECK_EQ(buf->count, 0u);
+      ABSL_DCHECK_EQ(buf->length, 0u);
       tcp->outgoing_byte_idx = 0;
       tcp->outgoing_buffer = nullptr;
     }
@@ -1291,10 +1291,10 @@ static void UnrefMaybePutZerocopySendRecord(grpc_tcp* tcp,
                                             uint32_t seq, const char* tag);
 // Reads \a cmsg to process zerocopy control messages.
 static void process_zerocopy(grpc_tcp* tcp, struct cmsghdr* cmsg) {
-  DCHECK(cmsg);
+  ABSL_DCHECK(cmsg);
   auto serr = reinterpret_cast<struct sock_extended_err*>(CMSG_DATA(cmsg));
-  DCHECK_EQ(serr->ee_errno, 0u);
-  DCHECK(serr->ee_origin == SO_EE_ORIGIN_ZEROCOPY);
+  ABSL_DCHECK_EQ(serr->ee_errno, 0u);
+  ABSL_DCHECK(serr->ee_origin == SO_EE_ORIGIN_ZEROCOPY);
   const uint32_t lo = serr->ee_info;
   const uint32_t hi = serr->ee_data;
   for (uint32_t seq = lo; seq <= hi; ++seq) {
@@ -1304,7 +1304,7 @@ static void process_zerocopy(grpc_tcp* tcp, struct cmsghdr* cmsg) {
     // both; if so, batch the unref/put.
     TcpZerocopySendRecord* record =
         tcp->tcp_zerocopy_send_ctx.ReleaseSendRecord(seq);
-    DCHECK(record);
+    ABSL_DCHECK(record);
     UnrefMaybePutZerocopySendRecord(tcp, record, seq, "CALLBACK RCVD");
   }
   if (tcp->tcp_zerocopy_send_ctx.UpdateZeroCopyOMemStateAfterFree()) {
@@ -1365,7 +1365,7 @@ struct cmsghdr* process_timestamp(grpc_tcp* tcp, msghdr* msg,
   auto serr = reinterpret_cast<struct sock_extended_err*>(CMSG_DATA(next_cmsg));
   if (serr->ee_errno != ENOMSG ||
       serr->ee_origin != SO_EE_ORIGIN_TIMESTAMPING) {
-    LOG(ERROR) << "Unexpected control message";
+    ABSL_LOG(ERROR) << "Unexpected control message";
     return cmsg;
   }
   tcp->tb_list.ProcessTimestamp(serr, opt_stats, tss);
@@ -1416,7 +1416,7 @@ static bool process_errors(grpc_tcp* tcp) {
       return processed_err;
     }
     if (GPR_UNLIKELY((msg.msg_flags & MSG_CTRUNC) != 0)) {
-      LOG(ERROR) << "Error message was truncated.";
+      ABSL_LOG(ERROR) << "Error message was truncated.";
     }

     if (msg.msg_controllen == 0) {
@@ -1488,15 +1488,15 @@ static bool tcp_write_with_timestamps(grpc_tcp* /*tcp*/, struct msghdr* /*msg*/,
                                       ssize_t* /*sent_length*/,
                                       int* /* saved_errno */,
                                       int /*additional_flags*/) {
-  LOG(ERROR) << "Write with timestamps not supported for this platform";
-  CHECK(0);
+  ABSL_LOG(ERROR) << "Write with timestamps not supported for this platform";
+  ABSL_CHECK(0);
   return false;
 }

 static void tcp_handle_error(void* /*arg*/ /* grpc_tcp */,
                              grpc_error_handle /*error*/) {
-  LOG(ERROR) << "Error handling is not supported for this platform";
-  CHECK(0);
+  ABSL_LOG(ERROR) << "Error handling is not supported for this platform";
+  ABSL_CHECK(0);
 }
 #endif  // GRPC_LINUX_ERRQUEUE

@@ -1535,7 +1535,7 @@ msg_iovlen_type TcpZerocopySendRecord::PopulateIovs(size_t* unwind_slice_idx,
     ++(out_offset_.slice_idx);
     out_offset_.byte_idx = 0;
   }
-  DCHECK_GT(iov_size, 0u);
+  ABSL_DCHECK_GT(iov_size, 0u);
   return iov_size;
 }

@@ -1686,7 +1686,7 @@ static bool tcp_flush(grpc_tcp* tcp, grpc_error_handle* error) {
       outgoing_slice_idx++;
       tcp->outgoing_byte_idx = 0;
     }
-    CHECK_GT(iov_size, 0u);
+    ABSL_CHECK_GT(iov_size, 0u);

     msg.msg_name = nullptr;
     msg.msg_namelen = 0;
@@ -1734,7 +1734,7 @@ static bool tcp_flush(grpc_tcp* tcp, grpc_error_handle* error) {
       }
     }

-    CHECK_EQ(tcp->outgoing_byte_idx, 0u);
+    ABSL_CHECK_EQ(tcp->outgoing_byte_idx, 0u);
     grpc_core::EventLog::Append("tcp-write-outstanding", -sent_length);
     tcp->bytes_counter += sent_length;
     trailing = sending_length - static_cast<size_t>(sent_length);
@@ -1784,7 +1784,7 @@ static void tcp_handle_write(void* arg /* grpc_tcp */,
     GRPC_TRACE_LOG(tcp, INFO) << "write: delayed";
     notify_on_write(tcp);
     // tcp_flush does not populate error if it has returned false.
-    DCHECK(error.ok());
+    ABSL_DCHECK(error.ok());
   } else {
     cb = tcp->write_cb;
     tcp->write_cb = nullptr;
@@ -1808,18 +1808,18 @@ static void tcp_write(grpc_endpoint* ep, grpc_slice_buffer* buf,
     size_t i;

     for (i = 0; i < buf->count; i++) {
-      LOG(INFO) << "WRITE " << tcp << " (peer=" << tcp->peer_string << ")";
+      ABSL_LOG(INFO) << "WRITE " << tcp << " (peer=" << tcp->peer_string << ")";
       if (ABSL_VLOG_IS_ON(2)) {
         char* data =
             grpc_dump_slice(buf->slices[i], GPR_DUMP_HEX | GPR_DUMP_ASCII);
-        VLOG(2) << "WRITE DATA: " << data;
+        ABSL_VLOG(2) << "WRITE DATA: " << data;
         gpr_free(data);
       }
     }
   }

-  CHECK_EQ(tcp->write_cb, nullptr);
-  DCHECK_EQ(tcp->current_zerocopy_send, nullptr);
+  ABSL_CHECK_EQ(tcp->write_cb, nullptr);
+  ABSL_DCHECK_EQ(tcp->current_zerocopy_send, nullptr);

   if (buf->length == 0) {
     grpc_core::Closure::Run(
@@ -1839,7 +1839,7 @@ static void tcp_write(grpc_endpoint* ep, grpc_slice_buffer* buf,
   }
   tcp->outgoing_buffer_arg = arg;
   if (arg) {
-    CHECK(grpc_event_engine_can_track_errors());
+    ABSL_CHECK(grpc_event_engine_can_track_errors());
   }

   bool flush_result =
@@ -1921,7 +1921,7 @@ grpc_endpoint* grpc_tcp_create(grpc_fd* em_fd,
   tcp->base.vtable = &vtable;
   tcp->peer_string = std::string(peer_string);
   tcp->fd = grpc_fd_wrapped_fd(em_fd);
-  CHECK(options.resource_quota != nullptr);
+  ABSL_CHECK(options.resource_quota != nullptr);
   tcp->memory_owner =
       options.resource_quota->memory_quota()->CreateMemoryOwner();
   tcp->self_reservation = tcp->memory_owner.MakeReservation(sizeof(grpc_tcp));
@@ -1960,7 +1960,7 @@ grpc_endpoint* grpc_tcp_create(grpc_fd* em_fd,
     if (err == 0) {
       tcp->tcp_zerocopy_send_ctx.set_enabled(true);
     } else {
-      LOG(ERROR) << "Failed to set zerocopy options on the socket.";
+      ABSL_LOG(ERROR) << "Failed to set zerocopy options on the socket.";
     }
 #endif
   }
@@ -1989,7 +1989,7 @@ grpc_endpoint* grpc_tcp_create(grpc_fd* em_fd,
   if (setsockopt(tcp->fd, SOL_TCP, TCP_INQ, &one, sizeof(one)) == 0) {
     tcp->inq_capable = true;
   } else {
-    VLOG(2) << "cannot set inq fd=" << tcp->fd << " errno=" << errno;
+    ABSL_VLOG(2) << "cannot set inq fd=" << tcp->fd << " errno=" << errno;
     tcp->inq_capable = false;
   }
 #else
@@ -2012,7 +2012,7 @@ grpc_endpoint* grpc_tcp_create(grpc_fd* em_fd,

 int grpc_tcp_fd(grpc_endpoint* ep) {
   grpc_tcp* tcp = reinterpret_cast<grpc_tcp*>(ep);
-  CHECK(ep->vtable == &vtable);
+  ABSL_CHECK(ep->vtable == &vtable);
   return grpc_fd_wrapped_fd(tcp->em_fd);
 }

@@ -2023,7 +2023,7 @@ void grpc_tcp_destroy_and_release_fd(grpc_endpoint* ep, int* fd,
         grpc_event_engine_endpoint_destroy_and_release_fd(ep, fd, done);
   }
   grpc_tcp* tcp = reinterpret_cast<grpc_tcp*>(ep);
-  CHECK(ep->vtable == &vtable);
+  ABSL_CHECK(ep->vtable == &vtable);
   tcp->release_fd = fd;
   tcp->release_fd_cb = done;
   grpc_slice_buffer_reset_and_unref(&tcp->last_read_buffer);
diff --git a/third_party/grpc/source/src/core/lib/iomgr/tcp_server_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/tcp_server_posix.cc
index 357412fa9eefe..9497baba69f7a 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/tcp_server_posix.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/tcp_server_posix.cc
@@ -49,8 +49,8 @@

 #include <string>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
 #include "src/core/lib/address_utils/sockaddr_utils.h"
@@ -88,7 +88,7 @@ using ::grpc_event_engine::experimental::SliceBuffer;

 static void finish_shutdown(grpc_tcp_server* s) {
   gpr_mu_lock(&s->mu);
-  CHECK(s->shutdown);
+  ABSL_CHECK(s->shutdown);
   gpr_mu_unlock(&s->mu);
   if (s->shutdown_complete != nullptr) {
     grpc_core::ExecCtx::Run(DEBUG_LOCATION, s->shutdown_complete,
@@ -163,7 +163,7 @@ static grpc_error_handle CreateEventEngineListener(
                       ->GetWrappedFd();
               if (getpeername(fd, reinterpret_cast<struct sockaddr*>(addr.addr),
                               &(addr.len)) < 0) {
-                LOG(ERROR) << "Failed getpeername: "
+                ABSL_LOG(ERROR) << "Failed getpeername: "
                            << grpc_core::StrError(errno);
                 close(fd);
                 return;
@@ -171,7 +171,7 @@ static grpc_error_handle CreateEventEngineListener(
               (void)grpc_set_socket_no_sigpipe_if_possible(fd);
               auto addr_uri = grpc_sockaddr_to_uri(&addr);
               if (!addr_uri.ok()) {
-                LOG(ERROR) << "Invalid address: "
+                ABSL_LOG(ERROR) << "Invalid address: "
                            << addr_uri.status().ToString();
                 return;
               }
@@ -231,7 +231,7 @@ static grpc_error_handle CreateEventEngineListener(
     listener = engine->CreateListener(
         std::move(accept_cb),
         [s, ee = keeper, shutdown_complete](absl::Status status) {
-          CHECK_EQ(gpr_atm_no_barrier_load(&s->refs.count), 0);
+          ABSL_CHECK_EQ(gpr_atm_no_barrier_load(&s->refs.count), 0);
           grpc_event_engine::experimental::RunEventEngineClosure(
               shutdown_complete, absl_status_to_grpc_error(status));
           finish_shutdown(s);
@@ -284,8 +284,8 @@ static grpc_error_handle tcp_server_create(grpc_closure* shutdown_complete,
   s->nports = 0;
   s->options = ::TcpOptionsFromEndpointConfig(config);
   s->fd_handler = nullptr;
-  CHECK(s->options.resource_quota != nullptr);
-  CHECK(s->on_accept_cb);
+  ABSL_CHECK(s->options.resource_quota != nullptr);
+  ABSL_CHECK(s->on_accept_cb);
   s->memory_quota = s->options.resource_quota->memory_quota();
   s->pre_allocated_fd = -1;
   gpr_atm_no_barrier_store(&s->next_pollset_to_assign, 0);
@@ -307,7 +307,7 @@ static void destroyed_port(void* server, grpc_error_handle /*error*/) {
     gpr_mu_unlock(&s->mu);
     finish_shutdown(s);
   } else {
-    CHECK(s->destroyed_ports < s->nports);
+    ABSL_CHECK(s->destroyed_ports < s->nports);
     gpr_mu_unlock(&s->mu);
   }
 }
@@ -319,7 +319,7 @@ static void deactivated_all_ports(grpc_tcp_server* s) {
   // delete ALL the things
   gpr_mu_lock(&s->mu);

-  CHECK(s->shutdown);
+  ABSL_CHECK(s->shutdown);

   if (s->head) {
     grpc_tcp_listener* sp;
@@ -348,7 +348,7 @@ static void deactivated_all_ports(grpc_tcp_server* s) {

 static void tcp_server_destroy(grpc_tcp_server* s) {
   gpr_mu_lock(&s->mu);
-  CHECK(!s->shutdown);
+  ABSL_CHECK(!s->shutdown);
   s->shutdown = true;
   // shutdown all fd's
   if (s->active_ports) {
@@ -391,7 +391,7 @@ static void on_read(void* arg, grpc_error_handle err) {
       // This is not a performant code path, but if an fd limit has been
       // reached, the system is likely in an unhappy state regardless.
       if (errno == EMFILE) {
-        LOG_EVERY_N_SEC(ERROR, 1) << "File descriptor limit reached. Retrying.";
+        ABSL_LOG_EVERY_N_SEC(ERROR, 1) << "File descriptor limit reached. Retrying.";
         grpc_fd_notify_on_read(sp->emfd, &sp->read_closure);
         if (gpr_atm_full_xchg(&sp->retry_timer_armed, true)) return;
         grpc_timer_init(&sp->retry_timer,
@@ -405,7 +405,7 @@ static void on_read(void* arg, grpc_error_handle err) {
       }
       gpr_mu_lock(&sp->server->mu);
       if (!sp->server->shutdown_listeners) {
-        LOG(ERROR) << "Failed accept4: " << grpc_core::StrError(errno);
+        ABSL_LOG(ERROR) << "Failed accept4: " << grpc_core::StrError(errno);
       } else {
         // if we have shutdown listeners, accept4 could fail, and we
         // needn't notify users
@@ -434,7 +434,7 @@ static void on_read(void* arg, grpc_error_handle err) {
       if (getpeername(fd, reinterpret_cast<struct sockaddr*>(addr.addr),
                       &(addr.len)) < 0) {
         auto listener_addr_uri = grpc_sockaddr_to_uri(&sp->addr);
-        LOG(ERROR) << "Failed getpeername: " << grpc_core::StrError(errno)
+        ABSL_LOG(ERROR) << "Failed getpeername: " << grpc_core::StrError(errno)
                    << ". Dropping the connection, and continuing to listen on "
                    << (listener_addr_uri.ok() ? *listener_addr_uri
                                               : "<unknown>")
@@ -454,7 +454,7 @@ static void on_read(void* arg, grpc_error_handle err) {

     auto addr_uri = grpc_sockaddr_to_uri(&addr);
     if (!addr_uri.ok()) {
-      LOG(ERROR) << "Invalid address: " << addr_uri.status();
+      ABSL_LOG(ERROR) << "Invalid address: " << addr_uri.status();
       goto error;
     }
     GRPC_TRACE_LOG(tcp, INFO)
@@ -550,8 +550,8 @@ static grpc_error_handle add_wildcard_addrs_to_server(grpc_tcp_server* s,
   } else {
     grpc_error_handle root_err =
         GRPC_ERROR_CREATE("Failed to add any wildcard listeners");
-    CHECK(!v6_err.ok());
-    CHECK(!v4_err.ok());
+    ABSL_CHECK(!v6_err.ok());
+    ABSL_CHECK(!v4_err.ok());
     root_err = grpc_error_add_child(root_err, v6_err);
     root_err = grpc_error_add_child(root_err, v4_err);
     return root_err;
@@ -602,7 +602,7 @@ static grpc_error_handle clone_port(grpc_tcp_listener* listener,
     sp->port = port;
     sp->port_index = listener->port_index;
     sp->fd_index = listener->fd_index + count - i;
-    CHECK(sp->emfd);
+    ABSL_CHECK(sp->emfd);
     grpc_tcp_server_listener_initialize_retry_timer(sp);
     while (listener->server->tail->next != nullptr) {
       listener->server->tail = listener->server->tail->next;
@@ -634,7 +634,7 @@ static grpc_error_handle tcp_server_add_port(grpc_tcp_server* s,
             if (!listen_fd.ok()) {
               return;
             }
-            DCHECK_GT(*listen_fd, 0);
+            ABSL_DCHECK_GT(*listen_fd, 0);
             s->listen_fd_to_index_map.insert_or_assign(
                 *listen_fd, std::make_tuple(s->n_bind_ports, fd_index++));
           });
@@ -649,7 +649,7 @@ static grpc_error_handle tcp_server_add_port(grpc_tcp_server* s,
     gpr_mu_unlock(&s->mu);
     return port.status();
   }
-  CHECK(addr->len <= GRPC_MAX_SOCKADDR_SIZE);
+  ABSL_CHECK(addr->len <= GRPC_MAX_SOCKADDR_SIZE);
   grpc_tcp_listener* sp;
   grpc_resolved_address sockname_temp;
   grpc_resolved_address addr6_v4mapped;
@@ -777,12 +777,12 @@ static void tcp_server_start(grpc_tcp_server* s,
   size_t i;
   grpc_tcp_listener* sp;
   gpr_mu_lock(&s->mu);
-  CHECK(s->on_accept_cb);
-  CHECK_EQ(s->active_ports, 0u);
+  ABSL_CHECK(s->on_accept_cb);
+  ABSL_CHECK_EQ(s->active_ports, 0u);
   s->pollsets = pollsets;
   if (grpc_event_engine::experimental::UseEventEngineListener()) {
-    CHECK(!s->shutdown_listeners);
-    CHECK(GRPC_LOG_IF_ERROR("listener_start", s->ee_listener->Start()));
+    ABSL_CHECK(!s->shutdown_listeners);
+    ABSL_CHECK(GRPC_LOG_IF_ERROR("listener_start", s->ee_listener->Start()));
     gpr_mu_unlock(&s->mu);
     return;
   }
@@ -790,7 +790,7 @@ static void tcp_server_start(grpc_tcp_server* s,
   while (sp != nullptr) {
     if (s->so_reuseport && !grpc_is_unix_socket(&sp->addr) &&
         !grpc_is_vsock(&sp->addr) && pollsets->size() > 1) {
-      CHECK(GRPC_LOG_IF_ERROR(
+      ABSL_CHECK(GRPC_LOG_IF_ERROR(
           "clone_port", clone_port(sp, (unsigned)(pollsets->size() - 1))));
       for (i = 0; i < pollsets->size(); i++) {
         grpc_pollset_add_fd((*pollsets)[i], sp->emfd);
@@ -882,14 +882,14 @@ class ExternalConnectionHandler : public grpc_core::TcpServerFdHandler {
           grpc_event_engine::experimental::QueryExtension<
               grpc_event_engine::experimental::ListenerSupportsFdExtension>(
               s_->ee_listener.get());
-      CHECK_NE(listener_supports_fd, nullptr);
+      ABSL_CHECK_NE(listener_supports_fd, nullptr);
       grpc_event_engine::experimental::SliceBuffer pending_data;
       if (buf != nullptr) {
         pending_data =
             grpc_event_engine::experimental::SliceBuffer::TakeCSliceBuffer(
                 buf->data.raw.slice_buffer);
       }
-      CHECK(GRPC_LOG_IF_ERROR("listener_handle_external_connection",
+      ABSL_CHECK(GRPC_LOG_IF_ERROR("listener_handle_external_connection",
                               listener_supports_fd->HandleExternalConnection(
                                   listener_fd, fd, &pending_data)));
       return;
@@ -902,14 +902,14 @@ class ExternalConnectionHandler : public grpc_core::TcpServerFdHandler {

     if (getpeername(fd, reinterpret_cast<struct sockaddr*>(addr.addr),
                     &(addr.len)) < 0) {
-      LOG(ERROR) << "Failed getpeername: " << grpc_core::StrError(errno);
+      ABSL_LOG(ERROR) << "Failed getpeername: " << grpc_core::StrError(errno);
       close(fd);
       return;
     }
     (void)grpc_set_socket_no_sigpipe_if_possible(fd);
     auto addr_uri = grpc_sockaddr_to_uri(&addr);
     if (!addr_uri.ok()) {
-      LOG(ERROR) << "Invalid address: " << addr_uri.status();
+      ABSL_LOG(ERROR) << "Invalid address: " << addr_uri.status();
       return;
     }
     GRPC_TRACE_LOG(tcp, INFO)
diff --git a/third_party/grpc/source/src/core/lib/iomgr/tcp_server_utils_posix_common.cc b/third_party/grpc/source/src/core/lib/iomgr/tcp_server_utils_posix_common.cc
index 638e32216143f..f2b790b690570 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/tcp_server_utils_posix_common.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/tcp_server_utils_posix_common.cc
@@ -33,8 +33,8 @@

 #include <string>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/lib/address_utils/sockaddr_utils.h"
 #include "src/core/lib/iomgr/error.h"
@@ -70,7 +70,7 @@ static void init_max_accept_queue_size(void) {
   s_max_accept_queue_size = n;

   if (s_max_accept_queue_size < MIN_SAFE_ACCEPT_QUEUE_SIZE) {
-    LOG(INFO) << "Suspiciously small accept queue (" << s_max_accept_queue_size
+    ABSL_LOG(INFO) << "Suspiciously small accept queue (" << s_max_accept_queue_size
               << ") will probably lead to connection drops";
   }
 }
@@ -109,7 +109,7 @@ static grpc_error_handle add_socket_to_server(grpc_tcp_server* s, int fd,
   grpc_error_handle err =
       grpc_tcp_server_prepare_socket(s, fd, addr, s->so_reuseport, &port);
   if (!err.ok()) return err;
-  CHECK_GT(port, 0);
+  ABSL_CHECK_GT(port, 0);
   absl::StatusOr<std::string> addr_str = grpc_sockaddr_to_string(addr, true);
   if (!addr_str.ok()) {
     return GRPC_ERROR_CREATE(addr_str.status().ToString());
@@ -142,7 +142,7 @@ static grpc_error_handle add_socket_to_server(grpc_tcp_server* s, int fd,
   sp->fd_index = fd_index;
   sp->is_sibling = 0;
   sp->sibling = nullptr;
-  CHECK(sp->emfd);
+  ABSL_CHECK(sp->emfd);
   gpr_mu_unlock(&s->mu);

   *listener = sp;
@@ -206,7 +206,7 @@ grpc_error_handle grpc_tcp_server_prepare_socket(
   grpc_resolved_address sockname_temp;
   grpc_error_handle err;

-  CHECK_GE(fd, 0);
+  ABSL_CHECK_GE(fd, 0);

   if (so_reuseport && !grpc_is_unix_socket(addr) && !grpc_is_vsock(addr)) {
     err = grpc_set_socket_reuse_port(fd, 1);
@@ -217,7 +217,7 @@ grpc_error_handle grpc_tcp_server_prepare_socket(
   err = grpc_set_socket_zerocopy(fd);
   if (!err.ok()) {
     // it's not fatal, so just log it.
-    VLOG(2) << "Node does not support SO_ZEROCOPY, continuing.";
+    ABSL_VLOG(2) << "Node does not support SO_ZEROCOPY, continuing.";
   }
 #endif
   err = grpc_set_socket_nonblocking(fd, 1);
@@ -269,7 +269,7 @@ grpc_error_handle grpc_tcp_server_prepare_socket(
   return absl::OkStatus();

 error:
-  CHECK(!err.ok());
+  ABSL_CHECK(!err.ok());
   if (fd >= 0) {
     close(fd);
   }
diff --git a/third_party/grpc/source/src/core/lib/iomgr/tcp_server_utils_posix_ifaddrs.cc b/third_party/grpc/source/src/core/lib/iomgr/tcp_server_utils_posix_ifaddrs.cc
index 1f130682fbc33..c8d5a8e650ef0 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/tcp_server_utils_posix_ifaddrs.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/tcp_server_utils_posix_ifaddrs.cc
@@ -31,8 +31,8 @@

 #include <string>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/lib/address_utils/sockaddr_utils.h"
 #include "src/core/lib/iomgr/error.h"
@@ -113,7 +113,7 @@ grpc_error_handle grpc_tcp_server_add_all_local_addrs(grpc_tcp_server* s,
     } else if (requested_port <= 0) {
       return GRPC_ERROR_CREATE("Bad get_unused_port()");
     }
-    VLOG(2) << "Picked unused port " << requested_port;
+    ABSL_VLOG(2) << "Picked unused port " << requested_port;
   }

   static bool v4_available = grpc_is_ipv4_available();
@@ -148,13 +148,13 @@ grpc_error_handle grpc_tcp_server_add_all_local_addrs(grpc_tcp_server* s,
     if (!addr_str.ok()) {
       return GRPC_ERROR_CREATE(addr_str.status().ToString());
     }
-    VLOG(2) << absl::StrFormat(
+    ABSL_VLOG(2) << absl::StrFormat(
         "Adding local addr from interface %s flags 0x%x to server: %s",
         ifa_name, ifa_it->ifa_flags, addr_str->c_str());
     // We could have multiple interfaces with the same address (e.g., bonding),
     // so look for duplicates.
     if (find_listener_with_addr(s, &addr) != nullptr) {
-      VLOG(2) << "Skipping duplicate addr " << *addr_str << " on interface "
+      ABSL_VLOG(2) << "Skipping duplicate addr " << *addr_str << " on interface "
               << ifa_name;
       continue;
     }
@@ -165,7 +165,7 @@ grpc_error_handle grpc_tcp_server_add_all_local_addrs(grpc_tcp_server* s,
       err = grpc_error_add_child(root_err, err);
       break;
     } else {
-      CHECK(requested_port == new_sp->port);
+      ABSL_CHECK(requested_port == new_sp->port);
       ++fd_index;
       if (sp != nullptr) {
         new_sp->is_sibling = 1;
diff --git a/third_party/grpc/source/src/core/lib/iomgr/tcp_server_windows.cc b/third_party/grpc/source/src/core/lib/iomgr/tcp_server_windows.cc
index e4abafb296cc2..dcd580f9f189f 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/tcp_server_windows.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/tcp_server_windows.cc
@@ -35,8 +35,8 @@

 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/lib/address_utils/sockaddr_utils.h"
 #include "src/core/lib/event_engine/memory_allocator_factory.h"
@@ -291,7 +291,7 @@ static grpc_error_handle prepare_socket(SOCKET sock,
   return absl::OkStatus();

 failure:
-  CHECK(!error.ok());
+  ABSL_CHECK(!error.ok());
   error = grpc_error_set_int(GRPC_ERROR_CREATE_REFERENCING(
                                  "Failed to prepare server socket", &error, 1),
                              grpc_core::StatusIntProperty::kFd, (intptr_t)sock);
@@ -301,7 +301,7 @@ failure:

 static void decrement_active_ports_and_notify_locked(grpc_tcp_listener* sp) {
   sp->shutting_down = 0;
-  CHECK_GT(sp->server->active_ports, 0u);
+  ABSL_CHECK_GT(sp->server->active_ports, 0u);
   if (0 == --sp->server->active_ports) {
     finish_shutdown_locked(sp->server);
   }
@@ -359,7 +359,7 @@ static grpc_error_handle start_accept_locked(grpc_tcp_listener* port) {
   return error;

 failure:
-  CHECK(!error.ok());
+  ABSL_CHECK(!error.ok());
   if (sock != INVALID_SOCKET) closesocket(sock);
   return error;
 }
@@ -384,7 +384,7 @@ static void on_accept(void* arg, grpc_error_handle error) {
   // this is necessary in the read/write case, it's useless for the accept
   // case. We only need to adjust the pending callback count
   if (!error.ok()) {
-    VLOG(2) << "Skipping on_accept due to error: "
+    ABSL_VLOG(2) << "Skipping on_accept due to error: "
             << grpc_core::StatusToString(error);

     gpr_mu_unlock(&sp->server->mu);
@@ -398,7 +398,7 @@ static void on_accept(void* arg, grpc_error_handle error) {
   if (!wsa_success) {
     if (!sp->shutting_down) {
       char* utf8_message = gpr_format_message(WSAGetLastError());
-      LOG(ERROR) << "on_accept error: " << utf8_message;
+      ABSL_LOG(ERROR) << "on_accept error: " << utf8_message;
       gpr_free(utf8_message);
     }
     closesocket(sock);
@@ -408,7 +408,7 @@ static void on_accept(void* arg, grpc_error_handle error) {
                        (char*)&sp->socket->socket, sizeof(sp->socket->socket));
       if (err) {
         char* utf8_message = gpr_format_message(WSAGetLastError());
-        LOG(ERROR) << "setsockopt error: " << utf8_message;
+        ABSL_LOG(ERROR) << "setsockopt error: " << utf8_message;
         gpr_free(utf8_message);
       }
       int peer_name_len = (int)peer_name.len;
@@ -420,11 +420,11 @@ static void on_accept(void* arg, grpc_error_handle error) {
         if (addr_uri.ok()) {
           peer_name_string = addr_uri.value();
         } else {
-          LOG(ERROR) << "invalid peer name: " << addr_uri.status();
+          ABSL_LOG(ERROR) << "invalid peer name: " << addr_uri.status();
         }
       } else {
         char* utf8_message = gpr_format_message(WSAGetLastError());
-        LOG(ERROR) << "getpeername error: " << utf8_message;
+        ABSL_LOG(ERROR) << "getpeername error: " << utf8_message;
         gpr_free(utf8_message);
       }
       std::string fd_name = absl::StrCat("tcp_server:", peer_name_string);
@@ -451,7 +451,7 @@ static void on_accept(void* arg, grpc_error_handle error) {
   // the former socked we created has now either been destroy or assigned
   // to the new connection. We need to create a new one for the next
   // connection.
-  CHECK(GRPC_LOG_IF_ERROR("start_accept", start_accept_locked(sp)));
+  ABSL_CHECK(GRPC_LOG_IF_ERROR("start_accept", start_accept_locked(sp)));
   if (0 == --sp->outstanding_calls) {
     decrement_active_ports_and_notify_locked(sp);
   }
@@ -487,7 +487,7 @@ static grpc_error_handle add_socket_to_server(grpc_tcp_server* s, SOCKET sock,
     return error;
   }

-  CHECK_GE(port, 0);
+  ABSL_CHECK_GE(port, 0);
   gpr_mu_lock(&s->mu);
   sp = (grpc_tcp_listener*)gpr_malloc(sizeof(grpc_tcp_listener));
   sp->next = NULL;
@@ -507,7 +507,7 @@ static grpc_error_handle add_socket_to_server(grpc_tcp_server* s, SOCKET sock,
   sp->port = port;
   sp->port_index = port_index;
   GRPC_CLOSURE_INIT(&sp->on_accept, on_accept, sp, grpc_schedule_on_exec_ctx);
-  CHECK(sp->socket);
+  ABSL_CHECK(sp->socket);
   gpr_mu_unlock(&s->mu);
   *listener = sp;

@@ -584,7 +584,7 @@ done:
     error = error_out;
     *port = -1;
   } else {
-    CHECK(sp != NULL);
+    ABSL_CHECK(sp != NULL);
     *port = sp->port;
   }
   return error;
@@ -594,9 +594,9 @@ static void tcp_server_start(grpc_tcp_server* s,
                              const std::vector<grpc_pollset*>* /*pollsets*/) {
   grpc_tcp_listener* sp;
   gpr_mu_lock(&s->mu);
-  CHECK_EQ(s->active_ports, 0u);
+  ABSL_CHECK_EQ(s->active_ports, 0u);
   for (sp = s->head; sp; sp = sp->next) {
-    CHECK(GRPC_LOG_IF_ERROR("start_accept", start_accept_locked(sp)));
+    ABSL_CHECK(GRPC_LOG_IF_ERROR("start_accept", start_accept_locked(sp)));
     s->active_ports++;
   }
   gpr_mu_unlock(&s->mu);
@@ -646,7 +646,7 @@ static grpc_error_handle event_engine_create(grpc_closure* shutdown_complete,
   WindowsEventEngine* engine_ptr = reinterpret_cast<WindowsEventEngine*>(
       config.GetVoidPointer(GRPC_INTERNAL_ARG_EVENT_ENGINE));
   grpc_tcp_server* s = (grpc_tcp_server*)gpr_malloc(sizeof(grpc_tcp_server));
-  CHECK_NE(on_accept_cb, nullptr);
+  ABSL_CHECK_NE(on_accept_cb, nullptr);
   auto accept_cb = [s, on_accept_cb, on_accept_cb_arg](
                        std::unique_ptr<EventEngine::Endpoint> endpoint,
                        MemoryAllocator memory_allocator) {
@@ -668,7 +668,7 @@ static grpc_error_handle event_engine_create(grpc_closure* shutdown_complete,
   grpc_core::RefCountedPtr<grpc_core::ResourceQuota> resource_quota;
   {
     void* tmp_quota = config.GetVoidPointer(GRPC_ARG_RESOURCE_QUOTA);
-    CHECK_NE(tmp_quota, nullptr);
+    ABSL_CHECK_NE(tmp_quota, nullptr);
     resource_quota =
         reinterpret_cast<grpc_core::ResourceQuota*>(tmp_quota)->Ref();
   }
@@ -699,13 +699,13 @@ static grpc_error_handle event_engine_create(grpc_closure* shutdown_complete,

 static void event_engine_start(grpc_tcp_server* s,
                                const std::vector<grpc_pollset*>* /*pollsets*/) {
-  CHECK(s->ee_listener->Start().ok());
+  ABSL_CHECK(s->ee_listener->Start().ok());
 }

 static grpc_error_handle event_engine_add_port(
     grpc_tcp_server* s, const grpc_resolved_address* addr, int* port) {
-  CHECK_NE(addr, nullptr);
-  CHECK_NE(port, nullptr);
+  ABSL_CHECK_NE(addr, nullptr);
+  ABSL_CHECK_NE(port, nullptr);
   auto ee_addr = CreateResolvedAddress(*addr);
   auto out_port = s->ee_listener->Bind(ee_addr);
   *port = out_port.ok() ? *out_port : -1;
diff --git a/third_party/grpc/source/src/core/lib/iomgr/tcp_windows.cc b/third_party/grpc/source/src/core/lib/iomgr/tcp_windows.cc
index e52ca28089f3d..bc9ccc91226e5 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/tcp_windows.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/tcp_windows.cc
@@ -27,8 +27,8 @@
 #include <grpc/support/string_util.h>
 #include <limits.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/address_utils/sockaddr_utils.h"
 #include "src/core/lib/iomgr/iocp_windows.h"
 #include "src/core/lib/iomgr/sockaddr.h"
@@ -138,7 +138,7 @@ static void tcp_unref(grpc_tcp* tcp, const char* reason, const char* file,
                       int line) {
   if (GRPC_TRACE_FLAG_ENABLED(tcp)) {
     gpr_atm val = gpr_atm_no_barrier_load(&tcp->refcount.count);
-    VLOG(2).AtLocation(file, line) << "TCP unref " << tcp << " : " << reason
+    ABSL_VLOG(2).AtLocation(file, line) << "TCP unref " << tcp << " : " << reason
                                    << " " << val << " -> " << val - 1;
   }
   if (gpr_unref(&tcp->refcount)) {
@@ -150,7 +150,7 @@ static void tcp_ref(grpc_tcp* tcp, const char* reason, const char* file,
                     int line) {
   if (GRPC_TRACE_FLAG_ENABLED(tcp)) {
     gpr_atm val = gpr_atm_no_barrier_load(&tcp->refcount.count);
-    VLOG(2).AtLocation(file, line) << "TCP   ref " << tcp << " : " << reason
+    ABSL_VLOG(2).AtLocation(file, line) << "TCP   ref " << tcp << " : " << reason
                                    << " " << val << " -> " << val + 1;
   }
   gpr_ref(&tcp->refcount);
@@ -182,7 +182,7 @@ static void on_read(void* tcpp, grpc_error_handle error) {
       grpc_slice_buffer_reset_and_unref(tcp->read_slices);
     } else {
       if (info->bytes_transferred != 0 && !tcp->shutting_down) {
-        CHECK((size_t)info->bytes_transferred <= tcp->read_slices->length);
+        ABSL_CHECK((size_t)info->bytes_transferred <= tcp->read_slices->length);
         if (static_cast<size_t>(info->bytes_transferred) !=
             tcp->read_slices->length) {
           grpc_slice_buffer_trim_end(
@@ -191,14 +191,14 @@ static void on_read(void* tcpp, grpc_error_handle error) {
                   static_cast<size_t>(info->bytes_transferred),
               &tcp->last_read_buffer);
         }
-        CHECK((size_t)info->bytes_transferred == tcp->read_slices->length);
+        ABSL_CHECK((size_t)info->bytes_transferred == tcp->read_slices->length);

         if (GRPC_TRACE_FLAG_ENABLED(tcp) && ABSL_VLOG_IS_ON(2)) {
           size_t i;
           for (i = 0; i < tcp->read_slices->count; i++) {
             char* dump = grpc_dump_slice(tcp->read_slices->slices[i],
                                          GPR_DUMP_HEX | GPR_DUMP_ASCII);
-            VLOG(2) << "READ " << tcp << " (peer=" << tcp->peer_string
+            ABSL_VLOG(2) << "READ " << tcp << " (peer=" << tcp->peer_string
                     << "): " << dump;
             gpr_free(dump);
           }
@@ -256,7 +256,7 @@ static void win_read(grpc_endpoint* ep, grpc_slice_buffer* read_slices,
                           GRPC_SLICE_MALLOC(DEFAULT_TARGET_READ_SIZE));
   }

-  CHECK(tcp->read_slices->count <= MAX_WSABUF_COUNT);
+  ABSL_CHECK(tcp->read_slices->count <= MAX_WSABUF_COUNT);
   for (i = 0; i < tcp->read_slices->count; i++) {
     buffers[i].len = (ULONG)GRPC_SLICE_LENGTH(
         tcp->read_slices->slices[i]);  // we know slice size fits in 32bit.
@@ -313,7 +313,7 @@ static void on_write(void* tcpp, grpc_error_handle error) {
     if (info->wsa_error != 0) {
       error = GRPC_WSA_ERROR(info->wsa_error, "WSASend");
     } else {
-      CHECK(info->bytes_transferred <= tcp->write_slices->length);
+      ABSL_CHECK(info->bytes_transferred <= tcp->write_slices->length);
     }
   }

@@ -341,7 +341,7 @@ static void win_write(grpc_endpoint* ep, grpc_slice_buffer* slices,
     for (i = 0; i < slices->count; i++) {
       char* data =
           grpc_dump_slice(slices->slices[i], GPR_DUMP_HEX | GPR_DUMP_ASCII);
-      VLOG(2) << "WRITE " << tcp << " (peer=" << tcp->peer_string
+      ABSL_VLOG(2) << "WRITE " << tcp << " (peer=" << tcp->peer_string
               << "): " << data;
       gpr_free(data);
     }
@@ -358,7 +358,7 @@ static void win_write(grpc_endpoint* ep, grpc_slice_buffer* slices,

   tcp->write_cb = cb;
   tcp->write_slices = slices;
-  CHECK(tcp->write_slices->count <= UINT_MAX);
+  ABSL_CHECK(tcp->write_slices->count <= UINT_MAX);
   if (tcp->write_slices->count > GPR_ARRAY_SIZE(local_buffers)) {
     buffers = (WSABUF*)gpr_malloc(sizeof(WSABUF) * tcp->write_slices->count);
     allocated = buffers;
@@ -366,7 +366,7 @@ static void win_write(grpc_endpoint* ep, grpc_slice_buffer* slices,

   for (i = 0; i < tcp->write_slices->count; i++) {
     len = GRPC_SLICE_LENGTH(tcp->write_slices->slices[i]);
-    CHECK(len <= ULONG_MAX);
+    ABSL_CHECK(len <= ULONG_MAX);
     buffers[i].len = (ULONG)len;
     buffers[i].buf = (char*)GRPC_SLICE_START_PTR(tcp->write_slices->slices[i]);
   }
diff --git a/third_party/grpc/source/src/core/lib/iomgr/timer_generic.cc b/third_party/grpc/source/src/core/lib/iomgr/timer_generic.cc
index 19f9e67f22cf0..f6fc400fe90a0 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/timer_generic.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/timer_generic.cc
@@ -24,8 +24,8 @@

 #include <string>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
 #include "src/core/lib/debug/trace.h"
@@ -116,7 +116,7 @@ static bool is_in_ht(grpc_timer* t) {
 }

 static void add_to_ht(grpc_timer* t) {
-  CHECK(!t->hash_table_next);
+  ABSL_CHECK(!t->hash_table_next);
   size_t i = grpc_core::HashPointer(t, NUM_HASH_BUCKETS);

   gpr_mu_lock(&g_hash_mu[i]);
@@ -661,7 +661,7 @@ static grpc_timer_check_result timer_check(grpc_core::Timestamp* next) {
       next_str = absl::StrCat(next->milliseconds_after_process_epoch());
     }
 #if GPR_ARCH_64
-    VLOG(2) << "TIMER CHECK BEGIN: now="
+    ABSL_VLOG(2) << "TIMER CHECK BEGIN: now="
             << now.milliseconds_after_process_epoch() << " next=" << next_str
             << " tls_min=" << min_timer.milliseconds_after_process_epoch()
             << " glob_min="
@@ -670,7 +670,7 @@ static grpc_timer_check_result timer_check(grpc_core::Timestamp* next) {
                        (gpr_atm*)(&g_shared_mutables.min_timer)))
                    .milliseconds_after_process_epoch();
 #else
-    VLOG(2) << "TIMER CHECK BEGIN: now="
+    ABSL_VLOG(2) << "TIMER CHECK BEGIN: now="
             << now.milliseconds_after_process_epoch() << " next=" << next_str
             << " min=" << min_timer.milliseconds_after_process_epoch();
 #endif
@@ -686,7 +686,7 @@ static grpc_timer_check_result timer_check(grpc_core::Timestamp* next) {
     } else {
       next_str = absl::StrCat(next->milliseconds_after_process_epoch());
     }
-    VLOG(2) << "TIMER CHECK END: r=" << r << "; next=" << next_str.c_str();
+    ABSL_VLOG(2) << "TIMER CHECK END: r=" << r << "; next=" << next_str.c_str();
   }
   return r;
 }
diff --git a/third_party/grpc/source/src/core/lib/iomgr/timer_manager.cc b/third_party/grpc/source/src/core/lib/iomgr/timer_manager.cc
index 81d1e8816c0d2..edcd7cbb26a8d 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/timer_manager.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/timer_manager.cc
@@ -22,8 +22,8 @@
 #include <grpc/support/port_platform.h>
 #include <inttypes.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/lib/iomgr/timer.h"
 #include "src/core/util/crash.h"
@@ -80,7 +80,7 @@ static void gc_completed_threads(void) {
 }

 static void start_timer_thread_and_unlock(void) {
-  CHECK(g_threaded);
+  ABSL_CHECK(g_threaded);
   ++g_waiter_count;
   ++g_thread_count;
   gpr_mu_unlock(&g_mu);
@@ -179,7 +179,7 @@ static bool wait_until(grpc_core::Timestamp next) {

         if (GRPC_TRACE_FLAG_ENABLED(timer_check)) {
           grpc_core::Duration wait_time = next - grpc_core::Timestamp::Now();
-          LOG(INFO) << "sleep for a " << wait_time.millis() << " milliseconds";
+          ABSL_LOG(INFO) << "sleep for a " << wait_time.millis() << " milliseconds";
         }
       } else {  // g_timed_waiter == true && next >= g_timed_waiter_deadline
         next = grpc_core::Timestamp::InfFuture();
@@ -188,7 +188,7 @@ static bool wait_until(grpc_core::Timestamp next) {

     if (GRPC_TRACE_FLAG_ENABLED(timer_check) &&
         next == grpc_core::Timestamp::InfFuture()) {
-      LOG(INFO) << "sleep until kicked";
+      ABSL_LOG(INFO) << "sleep until kicked";
     }

     gpr_cv_wait(&g_cv_wait, &g_mu, next.as_timespec(GPR_CLOCK_MONOTONIC));
diff --git a/third_party/grpc/source/src/core/lib/iomgr/unix_sockets_posix.cc b/third_party/grpc/source/src/core/lib/iomgr/unix_sockets_posix.cc
index 90ae7817d7818..6a81053a13a07 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/unix_sockets_posix.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/unix_sockets_posix.cc
@@ -35,7 +35,7 @@

 #include <grpc/support/alloc.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/lib/address_utils/parse_address.h"
 #include "src/core/lib/iomgr/sockaddr.h"
@@ -48,7 +48,7 @@ void grpc_create_socketpair_if_unix(int sv[2]) {
 #ifdef GPR_WINDOWS
   grpc_core::Crash("AF_UNIX socket pairs are not supported on Windows");
 #else
-  CHECK_EQ(socketpair(AF_UNIX, SOCK_STREAM, 0, sv), 0);
+  ABSL_CHECK_EQ(socketpair(AF_UNIX, SOCK_STREAM, 0, sv), 0);
 #endif
 }

diff --git a/third_party/grpc/source/src/core/lib/iomgr/unix_sockets_posix_noop.cc b/third_party/grpc/source/src/core/lib/iomgr/unix_sockets_posix_noop.cc
index ca5086d9f70d6..24c1bea974eea 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/unix_sockets_posix_noop.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/unix_sockets_posix_noop.cc
@@ -24,13 +24,13 @@

 #include <string>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 void grpc_create_socketpair_if_unix(int /* sv */[2]) {
   // TODO: Either implement this for the non-Unix socket case or make
   // sure that it is never called in any such case. Until then, leave an
   // assertion to notify if this gets called inadvertently
-  CHECK(0);
+  ABSL_CHECK(0);
 }

 absl::StatusOr<std::vector<grpc_resolved_address>>
diff --git a/third_party/grpc/source/src/core/lib/iomgr/wakeup_fd_pipe.cc b/third_party/grpc/source/src/core/lib/iomgr/wakeup_fd_pipe.cc
index e48aafaf361c6..e1bec23c39a52 100644
--- a/third_party/grpc/source/src/core/lib/iomgr/wakeup_fd_pipe.cc
+++ b/third_party/grpc/source/src/core/lib/iomgr/wakeup_fd_pipe.cc
@@ -26,7 +26,7 @@
 #include <string.h>
 #include <unistd.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/iomgr/socket_utils_posix.h"
 #include "src/core/lib/iomgr/wakeup_fd_pipe.h"
 #include "src/core/lib/iomgr/wakeup_fd_posix.h"
@@ -37,7 +37,7 @@ static grpc_error_handle pipe_init(grpc_wakeup_fd* fd_info) {
   int pipefd[2];
   int r = pipe(pipefd);
   if (0 != r) {
-    LOG(ERROR) << "pipe creation failed (" << errno
+    ABSL_LOG(ERROR) << "pipe creation failed (" << errno
                << "): " << grpc_core::StrError(errno);
     return GRPC_OS_ERROR(errno, "pipe");
   }
diff --git a/third_party/grpc/source/src/core/lib/promise/activity.cc b/third_party/grpc/source/src/core/lib/promise/activity.cc
index 5c067f46c7933..50f95ee00bed8 100644
--- a/third_party/grpc/source/src/core/lib/promise/activity.cc
+++ b/third_party/grpc/source/src/core/lib/promise/activity.cc
@@ -19,7 +19,7 @@

 #include <vector>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
 #include "absl/strings/str_join.h"
@@ -55,7 +55,7 @@ class FreestandingActivity::Handle final : public Wakeable {
   // Activity is going away... drop its reference and sever the connection back.
   void DropActivity() ABSL_LOCKS_EXCLUDED(mu_) {
     mu_.Lock();
-    CHECK_NE(activity_, nullptr);
+    ABSL_CHECK_NE(activity_, nullptr);
     activity_ = nullptr;
     mu_.Unlock();
     Unref();
diff --git a/third_party/grpc/source/src/core/lib/promise/activity.h b/third_party/grpc/source/src/core/lib/promise/activity.h
index d08ef2dd6a4d4..362ce86d5364b 100644
--- a/third_party/grpc/source/src/core/lib/promise/activity.h
+++ b/third_party/grpc/source/src/core/lib/promise/activity.h
@@ -26,7 +26,7 @@
 #include <utility>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/lib/debug/trace.h"
@@ -511,11 +511,11 @@ class PromiseActivity final
     // We shouldn't destruct without calling Cancel() first, and that must get
     // us to be done_, so we assume that and have no logic to destruct the
     // promise here.
-    CHECK(done_);
+    ABSL_CHECK(done_);
   }

   void RunScheduledWakeup() {
-    CHECK(wakeup_scheduled_.exchange(false, std::memory_order_acq_rel));
+    ABSL_CHECK(wakeup_scheduled_.exchange(false, std::memory_order_acq_rel));
     Step();
     WakeupComplete();
   }
@@ -581,7 +581,7 @@ class PromiseActivity final
   // Notification that we're no longer executing - it's ok to destruct the
   // promise.
   void MarkDone() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu()) {
-    CHECK(!std::exchange(done_, true));
+    ABSL_CHECK(!std::exchange(done_, true));
     ScopedContext contexts(this);
     Destruct(&promise_holder_.promise);
   }
@@ -628,10 +628,10 @@ class PromiseActivity final
   // Until there are no wakeups from within and the promise is incomplete:
   // poll the promise.
   std::optional<ResultType> StepLoop() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu()) {
-    CHECK(is_current());
+    ABSL_CHECK(is_current());
     while (true) {
       // Run the promise.
-      CHECK(!done_);
+      ABSL_CHECK(!done_);
       auto r = promise_holder_.promise();
       if (auto* status = r.value_if_ready()) {
         // If complete, destroy the promise, flag done, and exit this loop.
diff --git a/third_party/grpc/source/src/core/lib/promise/context.h b/third_party/grpc/source/src/core/lib/promise/context.h
index 65ee6f1a4a8ab..ab806ae72df1e 100644
--- a/third_party/grpc/source/src/core/lib/promise/context.h
+++ b/third_party/grpc/source/src/core/lib/promise/context.h
@@ -19,7 +19,7 @@

 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/meta/type_traits.h"
 #include "src/core/util/down_cast.h"

@@ -113,7 +113,7 @@ GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline bool HasContext() {
 template <typename T>
 GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline T* GetContext() {
   auto* p = promise_detail::Context<T>::get();
-  DCHECK_NE(p, nullptr);
+  ABSL_DCHECK_NE(p, nullptr);
   return p;
 }

diff --git a/third_party/grpc/source/src/core/lib/promise/detail/join_state.h b/third_party/grpc/source/src/core/lib/promise/detail/join_state.h
index 767ca8d787dfe..44695690d150b 100644
--- a/third_party/grpc/source/src/core/lib/promise/detail/join_state.h
+++ b/third_party/grpc/source/src/core/lib/promise/detail/join_state.h
@@ -23,8 +23,8 @@
 #include <type_traits>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/lib/promise/detail/promise_like.h"
 #include "src/core/lib/promise/poll.h"
@@ -58,14 +58,14 @@ struct JoinState<Traits, P0, P1> {
     Construct(&promise1, std::forward<P1>(p1));
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(const JoinState& other) {
-    DCHECK(other.ready.none());
+    ABSL_DCHECK(other.ready.none());
     Construct(&promise0, other.promise0);
     Construct(&promise1, other.promise1);
   }
   JoinState& operator=(const JoinState& other) = delete;
   JoinState& operator=(JoinState&& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(JoinState&& other) noexcept {
-    DCHECK(other.ready.none());
+    ABSL_DCHECK(other.ready.none());
     Construct(&promise0, std::move(other.promise0));
     Construct(&promise1, std::move(other.promise1));
   }
@@ -164,7 +164,7 @@ struct JoinState<Traits, P0, P1, P2> {
     Construct(&promise2, std::forward<P2>(p2));
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(const JoinState& other) {
-    DCHECK(other.ready.none());
+    ABSL_DCHECK(other.ready.none());
     Construct(&promise0, other.promise0);
     Construct(&promise1, other.promise1);
     Construct(&promise2, other.promise2);
@@ -172,7 +172,7 @@ struct JoinState<Traits, P0, P1, P2> {
   JoinState& operator=(const JoinState& other) = delete;
   JoinState& operator=(JoinState&& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(JoinState&& other) noexcept {
-    DCHECK(other.ready.none());
+    ABSL_DCHECK(other.ready.none());
     Construct(&promise0, std::move(other.promise0));
     Construct(&promise1, std::move(other.promise1));
     Construct(&promise2, std::move(other.promise2));
@@ -308,7 +308,7 @@ struct JoinState<Traits, P0, P1, P2, P3> {
     Construct(&promise3, std::forward<P3>(p3));
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(const JoinState& other) {
-    DCHECK(other.ready.none());
+    ABSL_DCHECK(other.ready.none());
     Construct(&promise0, other.promise0);
     Construct(&promise1, other.promise1);
     Construct(&promise2, other.promise2);
@@ -317,7 +317,7 @@ struct JoinState<Traits, P0, P1, P2, P3> {
   JoinState& operator=(const JoinState& other) = delete;
   JoinState& operator=(JoinState&& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(JoinState&& other) noexcept {
-    DCHECK(other.ready.none());
+    ABSL_DCHECK(other.ready.none());
     Construct(&promise0, std::move(other.promise0));
     Construct(&promise1, std::move(other.promise1));
     Construct(&promise2, std::move(other.promise2));
@@ -489,7 +489,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4> {
     Construct(&promise4, std::forward<P4>(p4));
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(const JoinState& other) {
-    DCHECK(other.ready.none());
+    ABSL_DCHECK(other.ready.none());
     Construct(&promise0, other.promise0);
     Construct(&promise1, other.promise1);
     Construct(&promise2, other.promise2);
@@ -499,7 +499,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4> {
   JoinState& operator=(const JoinState& other) = delete;
   JoinState& operator=(JoinState&& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(JoinState&& other) noexcept {
-    DCHECK(other.ready.none());
+    ABSL_DCHECK(other.ready.none());
     Construct(&promise0, std::move(other.promise0));
     Construct(&promise1, std::move(other.promise1));
     Construct(&promise2, std::move(other.promise2));
@@ -707,7 +707,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4, P5> {
     Construct(&promise5, std::forward<P5>(p5));
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(const JoinState& other) {
-    DCHECK(other.ready.none());
+    ABSL_DCHECK(other.ready.none());
     Construct(&promise0, other.promise0);
     Construct(&promise1, other.promise1);
     Construct(&promise2, other.promise2);
@@ -718,7 +718,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4, P5> {
   JoinState& operator=(const JoinState& other) = delete;
   JoinState& operator=(JoinState&& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(JoinState&& other) noexcept {
-    DCHECK(other.ready.none());
+    ABSL_DCHECK(other.ready.none());
     Construct(&promise0, std::move(other.promise0));
     Construct(&promise1, std::move(other.promise1));
     Construct(&promise2, std::move(other.promise2));
@@ -962,7 +962,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4, P5, P6> {
     Construct(&promise6, std::forward<P6>(p6));
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(const JoinState& other) {
-    DCHECK(other.ready.none());
+    ABSL_DCHECK(other.ready.none());
     Construct(&promise0, other.promise0);
     Construct(&promise1, other.promise1);
     Construct(&promise2, other.promise2);
@@ -974,7 +974,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4, P5, P6> {
   JoinState& operator=(const JoinState& other) = delete;
   JoinState& operator=(JoinState&& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(JoinState&& other) noexcept {
-    DCHECK(other.ready.none());
+    ABSL_DCHECK(other.ready.none());
     Construct(&promise0, std::move(other.promise0));
     Construct(&promise1, std::move(other.promise1));
     Construct(&promise2, std::move(other.promise2));
@@ -1254,7 +1254,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4, P5, P6, P7> {
     Construct(&promise7, std::forward<P7>(p7));
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(const JoinState& other) {
-    DCHECK(other.ready.none());
+    ABSL_DCHECK(other.ready.none());
     Construct(&promise0, other.promise0);
     Construct(&promise1, other.promise1);
     Construct(&promise2, other.promise2);
@@ -1267,7 +1267,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4, P5, P6, P7> {
   JoinState& operator=(const JoinState& other) = delete;
   JoinState& operator=(JoinState&& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(JoinState&& other) noexcept {
-    DCHECK(other.ready.none());
+    ABSL_DCHECK(other.ready.none());
     Construct(&promise0, std::move(other.promise0));
     Construct(&promise1, std::move(other.promise1));
     Construct(&promise2, std::move(other.promise2));
@@ -1582,7 +1582,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4, P5, P6, P7, P8> {
     Construct(&promise8, std::forward<P8>(p8));
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(const JoinState& other) {
-    DCHECK(other.ready.none());
+    ABSL_DCHECK(other.ready.none());
     Construct(&promise0, other.promise0);
     Construct(&promise1, other.promise1);
     Construct(&promise2, other.promise2);
@@ -1596,7 +1596,7 @@ struct JoinState<Traits, P0, P1, P2, P3, P4, P5, P6, P7, P8> {
   JoinState& operator=(const JoinState& other) = delete;
   JoinState& operator=(JoinState&& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION JoinState(JoinState&& other) noexcept {
-    DCHECK(other.ready.none());
+    ABSL_DCHECK(other.ready.none());
     Construct(&promise0, std::move(other.promise0));
     Construct(&promise1, std::move(other.promise1));
     Construct(&promise2, std::move(other.promise2));
diff --git a/third_party/grpc/source/src/core/lib/promise/detail/seq_state.h b/third_party/grpc/source/src/core/lib/promise/detail/seq_state.h
index db42681018c40..d2d2b5ad4f6ac 100644
--- a/third_party/grpc/source/src/core/lib/promise/detail/seq_state.h
+++ b/third_party/grpc/source/src/core/lib/promise/detail/seq_state.h
@@ -23,8 +23,8 @@
 #include <utility>

 #include "absl/base/attributes.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/lib/promise/detail/promise_factory.h"
@@ -120,14 +120,14 @@ struct SeqState<Traits, P, F0> {
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(&prior.current_promise, other.prior.current_promise);
     Construct(&prior.next_factory, other.prior.next_factory);
   }
   SeqState& operator=(const SeqState& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(&prior.current_promise, std::move(other.prior.current_promise));
     Construct(&prior.next_factory, std::move(other.prior.next_factory));
   }
@@ -244,7 +244,7 @@ struct SeqState<Traits, P, F0, F1> {
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(&prior.prior.current_promise, other.prior.prior.current_promise);
     Construct(&prior.prior.next_factory, other.prior.prior.next_factory);
     Construct(&prior.next_factory, other.prior.next_factory);
@@ -252,7 +252,7 @@ struct SeqState<Traits, P, F0, F1> {
   SeqState& operator=(const SeqState& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(&prior.prior.current_promise,
               std::move(other.prior.prior.current_promise));
     Construct(&prior.prior.next_factory,
@@ -420,7 +420,7 @@ struct SeqState<Traits, P, F0, F1, F2> {
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(&prior.prior.prior.current_promise,
               other.prior.prior.prior.current_promise);
     Construct(&prior.prior.prior.next_factory,
@@ -431,7 +431,7 @@ struct SeqState<Traits, P, F0, F1, F2> {
   SeqState& operator=(const SeqState& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(&prior.prior.prior.current_promise,
               std::move(other.prior.prior.prior.current_promise));
     Construct(&prior.prior.prior.next_factory,
@@ -648,7 +648,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3> {
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(&prior.prior.prior.prior.current_promise,
               other.prior.prior.prior.prior.current_promise);
     Construct(&prior.prior.prior.prior.next_factory,
@@ -661,7 +661,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3> {
   SeqState& operator=(const SeqState& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(&prior.prior.prior.prior.current_promise,
               std::move(other.prior.prior.prior.prior.current_promise));
     Construct(&prior.prior.prior.prior.next_factory,
@@ -936,7 +936,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4> {
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(&prior.prior.prior.prior.prior.current_promise,
               other.prior.prior.prior.prior.prior.current_promise);
     Construct(&prior.prior.prior.prior.prior.next_factory,
@@ -951,7 +951,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4> {
   SeqState& operator=(const SeqState& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(&prior.prior.prior.prior.prior.current_promise,
               std::move(other.prior.prior.prior.prior.prior.current_promise));
     Construct(&prior.prior.prior.prior.prior.next_factory,
@@ -1279,7 +1279,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5> {
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(&prior.prior.prior.prior.prior.prior.current_promise,
               other.prior.prior.prior.prior.prior.prior.current_promise);
     Construct(&prior.prior.prior.prior.prior.prior.next_factory,
@@ -1296,7 +1296,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5> {
   SeqState& operator=(const SeqState& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(
         &prior.prior.prior.prior.prior.prior.current_promise,
         std::move(other.prior.prior.prior.prior.prior.prior.current_promise));
@@ -1679,7 +1679,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6> {
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(&prior.prior.prior.prior.prior.prior.prior.current_promise,
               other.prior.prior.prior.prior.prior.prior.prior.current_promise);
     Construct(&prior.prior.prior.prior.prior.prior.prior.next_factory,
@@ -1698,7 +1698,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6> {
   SeqState& operator=(const SeqState& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(
         &prior.prior.prior.prior.prior.prior.prior.current_promise,
         std::move(
@@ -2139,7 +2139,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7> {
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(
         &prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
         other.prior.prior.prior.prior.prior.prior.prior.prior.current_promise);
@@ -2162,7 +2162,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7> {
   SeqState& operator=(const SeqState& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(&prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
               std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
                             .current_promise));
@@ -2663,7 +2663,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8> {
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(
         &prior.prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
         other.prior.prior.prior.prior.prior.prior.prior.prior.prior
@@ -2691,7 +2691,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8> {
   SeqState& operator=(const SeqState& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(
         &prior.prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
         std::move(other.prior.prior.prior.prior.prior.prior.prior.prior.prior
@@ -3255,7 +3255,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9> {
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                    .current_promise,
               other.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
@@ -3287,7 +3287,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9> {
   SeqState& operator=(const SeqState& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                    .current_promise,
               std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
@@ -3914,7 +3914,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> {
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                    .current_promise,
               other.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
@@ -3950,7 +3950,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> {
   SeqState& operator=(const SeqState& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                    .current_promise,
               std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
@@ -4643,7 +4643,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11> {
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(const SeqState& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                    .prior.current_promise,
               other.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
@@ -4683,7 +4683,7 @@ struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11> {
   SeqState& operator=(const SeqState& other) = delete;
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION SeqState(SeqState&& other) noexcept
       : state(other.state), whence(other.whence) {
-    DCHECK(state == State::kState0);
+    ABSL_DCHECK(state == State::kState0);
     Construct(&prior.prior.prior.prior.prior.prior.prior.prior.prior.prior.prior
                    .prior.current_promise,
               std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
diff --git a/third_party/grpc/source/src/core/lib/promise/detail/status.h b/third_party/grpc/source/src/core/lib/promise/detail/status.h
index 335c5365c2bc4..33096b5620243 100644
--- a/third_party/grpc/source/src/core/lib/promise/detail/status.h
+++ b/third_party/grpc/source/src/core/lib/promise/detail/status.h
@@ -19,7 +19,7 @@

 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"

@@ -128,7 +128,7 @@ struct FailureStatusCastImpl<absl::StatusOr<T>, const absl::Status&> {

 template <typename To, typename From>
 GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline To FailureStatusCast(From&& from) {
-  DCHECK(!IsStatusOk(from));
+  ABSL_DCHECK(!IsStatusOk(from));
   return FailureStatusCastImpl<To, From>::Cast(std::forward<From>(from));
 }

diff --git a/third_party/grpc/source/src/core/lib/promise/event_engine_wakeup_scheduler.h b/third_party/grpc/source/src/core/lib/promise/event_engine_wakeup_scheduler.h
index 3e494beaa6fe1..0193564f15b04 100644
--- a/third_party/grpc/source/src/core/lib/promise/event_engine_wakeup_scheduler.h
+++ b/third_party/grpc/source/src/core/lib/promise/event_engine_wakeup_scheduler.h
@@ -21,7 +21,7 @@
 #include <memory>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/iomgr/exec_ctx.h"

 namespace grpc_core {
@@ -34,7 +34,7 @@ class EventEngineWakeupScheduler {
       std::shared_ptr<grpc_event_engine::experimental::EventEngine>
           event_engine)
       : event_engine_(std::move(event_engine)) {
-    CHECK_NE(event_engine_, nullptr);
+    ABSL_CHECK_NE(event_engine_, nullptr);
   }

   template <typename ActivityType>
diff --git a/third_party/grpc/source/src/core/lib/promise/for_each.h b/third_party/grpc/source/src/core/lib/promise/for_each.h
index 5219995962bca..2801b7238d6a0 100644
--- a/third_party/grpc/source/src/core/lib/promise/for_each.h
+++ b/third_party/grpc/source/src/core/lib/promise/for_each.h
@@ -21,8 +21,8 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/lib/debug/trace.h"
@@ -145,13 +145,13 @@ class ForEach {
       : reader_(std::move(other.reader_)),
         action_factory_(std::move(other.action_factory_)),
         whence_(other.whence_) {
-    DCHECK(reading_next_);
-    DCHECK(other.reading_next_);
+    ABSL_DCHECK(reading_next_);
+    ABSL_DCHECK(other.reading_next_);
     Construct(&reader_next_, std::move(other.reader_next_));
   }
   ForEach& operator=(ForEach&& other) noexcept {
-    DCHECK(reading_next_);
-    DCHECK(other.reading_next_);
+    ABSL_DCHECK(reading_next_);
+    ABSL_DCHECK(other.reading_next_);
     reader_ = std::move(other.reader_);
     action_factory_ = std::move(other.action_factory_);
     reader_next_ = std::move(other.reader_next_);
diff --git a/third_party/grpc/source/src/core/lib/promise/inter_activity_latch.h b/third_party/grpc/source/src/core/lib/promise/inter_activity_latch.h
index a5a614dcf9f54..926be7a2e2580 100644
--- a/third_party/grpc/source/src/core/lib/promise/inter_activity_latch.h
+++ b/third_party/grpc/source/src/core/lib/promise/inter_activity_latch.h
@@ -21,7 +21,7 @@
 #include <string>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/lib/promise/activity.h"
diff --git a/third_party/grpc/source/src/core/lib/promise/interceptor_list.h b/third_party/grpc/source/src/core/lib/promise/interceptor_list.h
index dbdd738e648da..2b4820111391d 100644
--- a/third_party/grpc/source/src/core/lib/promise/interceptor_list.h
+++ b/third_party/grpc/source/src/core/lib/promise/interceptor_list.h
@@ -24,8 +24,8 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
 #include "src/core/lib/promise/context.h"
@@ -64,7 +64,7 @@ class InterceptorList {
     // Update the next pointer stored with this map.
     // This is only valid to call once, and only before the map is used.
     void SetNext(Map* next) {
-      DCHECK_EQ(next_, nullptr);
+      ABSL_DCHECK_EQ(next_, nullptr);
       next_ = next;
     }

diff --git a/third_party/grpc/source/src/core/lib/promise/latch.h b/third_party/grpc/source/src/core/lib/promise/latch.h
index 772204547d609..f1f97a836fb44 100644
--- a/third_party/grpc/source/src/core/lib/promise/latch.h
+++ b/third_party/grpc/source/src/core/lib/promise/latch.h
@@ -22,8 +22,8 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/lib/promise/activity.h"
@@ -54,12 +54,12 @@ class Latch {
   Latch(Latch&& other) noexcept
       : value_(std::move(other.value_)), has_value_(other.has_value_) {
 #ifndef NDEBUG
-    DCHECK(!other.has_had_waiters_);
+    ABSL_DCHECK(!other.has_had_waiters_);
 #endif
   }
   Latch& operator=(Latch&& other) noexcept {
 #ifndef NDEBUG
-    DCHECK(!other.has_had_waiters_);
+    ABSL_DCHECK(!other.has_had_waiters_);
 #endif
     value_ = std::move(other.value_);
     has_value_ = other.has_value_;
@@ -104,7 +104,7 @@ class Latch {
   void Set(T value) {
     GRPC_TRACE_LOG(promise_primitives, INFO)
         << DebugTag() << "Set " << StateString();
-    DCHECK(!has_value_);
+    ABSL_DCHECK(!has_value_);
     value_ = std::move(value);
     has_value_ = true;
     waiter_.Wake();
@@ -147,12 +147,12 @@ class Latch<void> {
   Latch& operator=(const Latch&) = delete;
   Latch(Latch&& other) noexcept : is_set_(other.is_set_) {
 #ifndef NDEBUG
-    DCHECK(!other.has_had_waiters_);
+    ABSL_DCHECK(!other.has_had_waiters_);
 #endif
   }
   Latch& operator=(Latch&& other) noexcept {
 #ifndef NDEBUG
-    DCHECK(!other.has_had_waiters_);
+    ABSL_DCHECK(!other.has_had_waiters_);
 #endif
     is_set_ = other.is_set_;
     return *this;
@@ -178,7 +178,7 @@ class Latch<void> {
   void Set() {
     GRPC_TRACE_LOG(promise_primitives, INFO)
         << DebugTag() << "Set " << StateString();
-    DCHECK(!is_set_);
+    ABSL_DCHECK(!is_set_);
     is_set_ = true;
     waiter_.Wake();
   }
diff --git a/third_party/grpc/source/src/core/lib/promise/map_pipe.h b/third_party/grpc/source/src/core/lib/promise/map_pipe.h
index 13ab7a688bca6..f46ca7c6e4fb8 100644
--- a/third_party/grpc/source/src/core/lib/promise/map_pipe.h
+++ b/third_party/grpc/source/src/core/lib/promise/map_pipe.h
@@ -17,7 +17,7 @@

 #include <grpc/support/port_platform.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "src/core/lib/promise/detail/promise_factory.h"
 #include "src/core/lib/promise/for_each.h"
diff --git a/third_party/grpc/source/src/core/lib/promise/mpsc.h b/third_party/grpc/source/src/core/lib/promise/mpsc.h
index 3b51274a1f76b..b290604153246 100644
--- a/third_party/grpc/source/src/core/lib/promise/mpsc.h
+++ b/third_party/grpc/source/src/core/lib/promise/mpsc.h
@@ -25,7 +25,7 @@
 #include <vector>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/promise/activity.h"
 #include "src/core/lib/promise/poll.h"
 #include "src/core/lib/promise/status_flag.h"
@@ -172,7 +172,7 @@ class MpscSender {
       if (center == nullptr) return false;
       if (batch == 0) {
         batch = center->Send(std::move(t), kAwaitReceipt);
-        CHECK_NE(batch, 0u);
+        ABSL_CHECK_NE(batch, 0u);
         if (batch == mpscpipe_detail::Center<T>::kClosedBatch) return false;
       }
       auto p = center->PollReceiveBatch(batch);
@@ -212,10 +212,10 @@ class MpscReceiver {
   // a non-empty buffer during a legal move!
   MpscReceiver(MpscReceiver&& other) noexcept
       : center_(std::move(other.center_)) {
-    DCHECK(other.buffer_.empty());
+    ABSL_DCHECK(other.buffer_.empty());
   }
   MpscReceiver& operator=(MpscReceiver&& other) noexcept {
-    DCHECK(other.buffer_.empty());
+    ABSL_DCHECK(other.buffer_.empty());
     center_ = std::move(other.center_);
     return *this;
   }
diff --git a/third_party/grpc/source/src/core/lib/promise/observable.h b/third_party/grpc/source/src/core/lib/promise/observable.h
index 671348ff9a25c..bed3a9607b620 100644
--- a/third_party/grpc/source/src/core/lib/promise/observable.h
+++ b/third_party/grpc/source/src/core/lib/promise/observable.h
@@ -19,7 +19,7 @@

 #include "absl/container/flat_hash_set.h"
 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/promise/activity.h"
 #include "src/core/lib/promise/poll.h"
 #include "src/core/util/sync.h"
@@ -123,9 +123,9 @@ class Observable {
     Observer(const Observer&) = delete;
     Observer& operator=(const Observer&) = delete;
     Observer(Observer&& other) noexcept : state_(std::move(other.state_)) {
-      CHECK(other.waker_.is_unwakeable());
-      DCHECK(waker_.is_unwakeable());
-      CHECK(!other.saw_pending_);
+      ABSL_CHECK(other.waker_.is_unwakeable());
+      ABSL_DCHECK(waker_.is_unwakeable());
+      ABSL_CHECK(!other.saw_pending_);
     }
     Observer& operator=(Observer&& other) noexcept = delete;

diff --git a/third_party/grpc/source/src/core/lib/promise/party.cc b/third_party/grpc/source/src/core/lib/promise/party.cc
index 28a7ac8724932..26c6fa05e58a0 100644
--- a/third_party/grpc/source/src/core/lib/promise/party.cc
+++ b/third_party/grpc/source/src/core/lib/promise/party.cc
@@ -21,8 +21,8 @@
 #include <limits>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_format.h"
 #include "src/core/lib/event_engine/event_engine_context.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
@@ -72,7 +72,7 @@ class Party::Handle final : public Wakeable {
   // Activity is going away... drop its reference and sever the connection back.
   void DropActivity() ABSL_LOCKS_EXCLUDED(mu_) {
     mu_.Lock();
-    CHECK_NE(party_, nullptr);
+    ABSL_CHECK_NE(party_, nullptr);
     party_ = nullptr;
     mu_.Unlock();
     Unref();
@@ -213,13 +213,13 @@ std::string Party::ActivityDebugTag(WakeupMask wakeup_mask) const {
 }

 Waker Party::MakeOwningWaker() {
-  DCHECK(currently_polling_ != kNotPolling);
+  ABSL_DCHECK(currently_polling_ != kNotPolling);
   IncrementRefCount();
   return Waker(this, 1u << currently_polling_);
 }

 Waker Party::MakeNonOwningWaker() {
-  DCHECK(currently_polling_ != kNotPolling);
+  ABSL_DCHECK(currently_polling_ != kNotPolling);
   return Waker(participants_[currently_polling_]
                    .load(std::memory_order_relaxed)
                    ->MakeNonOwningWakeable(this),
@@ -227,7 +227,7 @@ Waker Party::MakeNonOwningWaker() {
 }

 void Party::ForceImmediateRepoll(WakeupMask mask) {
-  DCHECK(is_current());
+  ABSL_DCHECK(is_current());
   wakeup_mask_ |= mask;
 }

@@ -264,7 +264,7 @@ void Party::RunLockedAndUnref(Party* party, uint64_t prev_state) {
         first.party->RunPartyAndUnref(first.prev_state);
         first = std::exchange(next, PartyWakeup{});
       } while (first.party != nullptr);
-      DCHECK(g_run_state == this);
+      ABSL_DCHECK(g_run_state == this);
       g_run_state = nullptr;
     }
   };
@@ -294,7 +294,7 @@ void Party::RunLockedAndUnref(Party* party, uint64_t prev_state) {
       auto arena = party->arena_.get();
       auto* event_engine =
           arena->GetContext<grpc_event_engine::experimental::EventEngine>();
-      CHECK(event_engine != nullptr) << "; " << GRPC_DUMP_ARGS(party, arena);
+      ABSL_CHECK(event_engine != nullptr) << "; " << GRPC_DUMP_ARGS(party, arena);
       event_engine->Run([wakeup]() {
         GRPC_LATENT_SEE_PARENT_SCOPE("Party::RunLocked offload");
         ApplicationCallbackExecCtx app_exec_ctx;
@@ -313,11 +313,11 @@ void Party::RunLockedAndUnref(Party* party, uint64_t prev_state) {
 void Party::RunPartyAndUnref(uint64_t prev_state) {
   ScopedActivity activity(this);
   promise_detail::Context<Arena> arena_ctx(arena_.get());
-  DCHECK_EQ(prev_state & kLocked, 0u)
+  ABSL_DCHECK_EQ(prev_state & kLocked, 0u)
       << "Party should be unlocked prior to first wakeup";
-  DCHECK_GE(prev_state & kRefMask, kOneRef);
+  ABSL_DCHECK_GE(prev_state & kRefMask, kOneRef);
   // Now update prev_state to be what we want the CAS to see below.
-  DCHECK_EQ(prev_state & ~(kRefMask | kAllocatedMask), 0u)
+  ABSL_DCHECK_EQ(prev_state & ~(kRefMask | kAllocatedMask), 0u)
       << "Party should have contained no wakeups on lock";
   prev_state |= kLocked;
 #if !TARGET_OS_IPHONE
@@ -385,9 +385,9 @@ void Party::RunPartyAndUnref(uint64_t prev_state) {
     }
     LogStateChange("Run:Continue", prev_state,
                    prev_state & (kRefMask | kLocked | keep_allocated_mask));
-    DCHECK(prev_state & kLocked)
+    ABSL_DCHECK(prev_state & kLocked)
         << "Party should be locked; prev_state=" << prev_state;
-    DCHECK_GE(prev_state & kRefMask, kOneRef);
+    ABSL_DCHECK_GE(prev_state & kRefMask, kOneRef);
     // From the previous state, extract which participants we're to wakeup.
     wakeup_mask_ |= prev_state & kWakeupMask;
     // Now update prev_state to be what we want the CAS to see once wakeups
@@ -410,7 +410,7 @@ uint64_t Party::NextAllocationMask(uint64_t current_allocation_mask) {
 }
 #else
 uint64_t Party::NextAllocationMask(uint64_t current_allocation_mask) {
-  CHECK_EQ(current_allocation_mask & ~kWakeupMask, 0);
+  ABSL_CHECK_EQ(current_allocation_mask & ~kWakeupMask, 0);
   if (current_allocation_mask == kWakeupMask) return kWakeupMask + 1;
   // Count number of unset bits in the wakeup mask
   size_t unset_bits = 0;
@@ -418,7 +418,7 @@ uint64_t Party::NextAllocationMask(uint64_t current_allocation_mask) {
     if (current_allocation_mask & (1ull << i)) continue;
     ++unset_bits;
   }
-  CHECK_GT(unset_bits, 0);
+  ABSL_CHECK_GT(unset_bits, 0);
   absl::BitGen bitgen;
   size_t selected = absl::Uniform<size_t>(bitgen, 0, unset_bits);
   for (size_t i = 0; i < party_detail::kMaxParticipants; i++) {
@@ -426,7 +426,7 @@ uint64_t Party::NextAllocationMask(uint64_t current_allocation_mask) {
     if (selected == 0) return 1ull << i;
     --selected;
   }
-  LOG(FATAL) << "unreachable";
+  ABSL_LOG(FATAL) << "unreachable";
 }
 #endif

@@ -447,7 +447,7 @@ size_t Party::AddParticipant(Participant* participant) {
     if (GPR_UNLIKELY((wakeup_mask & kWakeupMask) == 0)) {
       return std::numeric_limits<size_t>::max();
     }
-    DCHECK_NE(wakeup_mask & kWakeupMask, 0u)
+    ABSL_DCHECK_NE(wakeup_mask & kWakeupMask, 0u)
         << "No available slots for new participant; allocated=" << allocated
         << " state=" << state << " wakeup_mask=" << wakeup_mask;
     allocated |= wakeup_mask;
@@ -473,7 +473,7 @@ void Party::MaybeAsyncAddParticipant(Participant* participant) {
   if (slot != std::numeric_limits<size_t>::max()) return;
   // We need to delay the addition of participants.
   IncrementRefCount();
-  VLOG_EVERY_N_SEC(2, 10) << "Delaying addition of participant to party "
+  ABSL_VLOG_EVERY_N_SEC(2, 10) << "Delaying addition of participant to party "
                           << this << " because it is full.";
   arena_->GetContext<grpc_event_engine::experimental::EventEngine>()->Run(
       [this, participant]() mutable {
diff --git a/third_party/grpc/source/src/core/lib/promise/party.h b/third_party/grpc/source/src/core/lib/promise/party.h
index c53d5f774bc4d..59d71a3d976a9 100644
--- a/third_party/grpc/source/src/core/lib/promise/party.h
+++ b/third_party/grpc/source/src/core/lib/promise/party.h
@@ -26,7 +26,7 @@
 #include <utility>

 #include "absl/base/attributes.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/string_view.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/lib/event_engine/event_engine_context.h"
@@ -97,7 +97,7 @@ class Party : public Activity, private Wakeable {
           party->state_.compare_exchange_weak(prev_state_,
                                               (prev_state_ | kLocked) + kOneRef,
                                               std::memory_order_relaxed)) {
-        DCHECK_EQ(prev_state_ & ~(kRefMask | kAllocatedMask), 0u)
+        ABSL_DCHECK_EQ(prev_state_ & ~(kRefMask | kAllocatedMask), 0u)
             << "Party should have contained no wakeups on lock";
         // If we win, record that fact for the destructor
         party->LogStateChange("WakeupHold", prev_state_,
@@ -223,7 +223,7 @@ class Party : public Activity, private Wakeable {
   // Activity implementation: not allowed to be overridden by derived types.
   void ForceImmediateRepoll(WakeupMask mask) final;
   WakeupMask CurrentParticipant() const final {
-    DCHECK(currently_polling_ != kNotPolling);
+    ABSL_DCHECK(currently_polling_ != kNotPolling);
     return 1u << currently_polling_;
   }
   Waker MakeOwningWaker() final;
@@ -257,7 +257,7 @@ class Party : public Activity, private Wakeable {
   SpawnSerializer* MakeSpawnSerializer() {
     auto* const serializer = arena_->New<SpawnSerializer>(this);
     const size_t slot = AddParticipant(serializer);
-    DCHECK_NE(slot, std::numeric_limits<size_t>::max());
+    ABSL_DCHECK_NE(slot, std::numeric_limits<size_t>::max());
     serializer->wakeup_mask_ = 1ull << slot;
     return serializer;
   }
@@ -267,7 +267,7 @@ class Party : public Activity, private Wakeable {

   // Derived types should be constructed upon `arena`.
   explicit Party(RefCountedPtr<Arena> arena) : arena_(std::move(arena)) {
-    CHECK(arena_->GetContext<grpc_event_engine::experimental::EventEngine>() !=
+    ABSL_CHECK(arena_->GetContext<grpc_event_engine::experimental::EventEngine>() !=
           nullptr);
   }
   ~Party() override;
@@ -468,7 +468,7 @@ class Party : public Activity, private Wakeable {
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION void WakeupFromState(
       uint64_t cur_state, WakeupMask wakeup_mask) {
     GRPC_LATENT_SEE_INNER_SCOPE("Party::WakeupFromState");
-    DCHECK_NE(wakeup_mask & kWakeupMask, 0u)
+    ABSL_DCHECK_NE(wakeup_mask & kWakeupMask, 0u)
         << "Wakeup mask must be non-zero: " << wakeup_mask;
     while (true) {
       if (cur_state & kLocked) {
@@ -476,9 +476,9 @@ class Party : public Activity, private Wakeable {
         // we'll immediately unref. Since something is running this should never
         // bring the refcount to zero.
         if (kReffed) {
-          DCHECK_GT(cur_state & kRefMask, kOneRef);
+          ABSL_DCHECK_GT(cur_state & kRefMask, kOneRef);
         } else {
-          DCHECK_GE(cur_state & kRefMask, kOneRef);
+          ABSL_DCHECK_GE(cur_state & kRefMask, kOneRef);
         }
         const uint64_t new_state =
             (cur_state | wakeup_mask) - (kReffed ? kOneRef : 0);
@@ -489,7 +489,7 @@ class Party : public Activity, private Wakeable {
         }
       } else {
         // If the party is not locked, we need to lock it and run.
-        DCHECK_EQ(cur_state & kWakeupMask, 0u);
+        ABSL_DCHECK_EQ(cur_state & kWakeupMask, 0u);
         const uint64_t new_state =
             (cur_state | kLocked) + (kReffed ? 0 : kOneRef);
         if (state_.compare_exchange_weak(cur_state, new_state,
diff --git a/third_party/grpc/source/src/core/lib/promise/pipe.h b/third_party/grpc/source/src/core/lib/promise/pipe.h
index 95799f39ef472..ec6f4f3b922ac 100644
--- a/third_party/grpc/source/src/core/lib/promise/pipe.h
+++ b/third_party/grpc/source/src/core/lib/promise/pipe.h
@@ -25,8 +25,8 @@
 #include <utility>
 #include <variant>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/lib/promise/activity.h"
 #include "src/core/lib/promise/context.h"
@@ -61,7 +61,7 @@ class NextResult final {
   NextResult() : center_(nullptr) {}
   explicit NextResult(RefCountedPtr<pipe_detail::Center<T>> center)
       : center_(std::move(center)) {
-    CHECK(center_ != nullptr);
+    ABSL_CHECK(center_ != nullptr);
   }
   explicit NextResult(bool cancelled)
       : center_(nullptr), cancelled_(cancelled) {}
@@ -77,11 +77,11 @@ class NextResult final {
   bool has_value() const;
   // Only valid if has_value()
   const T& value() const {
-    CHECK(has_value());
+    ABSL_CHECK(has_value());
     return **this;
   }
   T& value() {
-    CHECK(has_value());
+    ABSL_CHECK(has_value());
     return **this;
   }
   const T& operator*() const;
@@ -118,7 +118,7 @@ class Center : public InterceptorList<T> {
     GRPC_TRACE_VLOG(promise_primitives, 2)
         << DebugOpString("IncrementRefCount");
     refs_++;
-    DCHECK_NE(refs_, 0);
+    ABSL_DCHECK_NE(refs_, 0);
   }

   RefCountedPtr<Center> Ref() {
@@ -130,7 +130,7 @@ class Center : public InterceptorList<T> {
   // If no refs remain, destroy this object
   void Unref() {
     GRPC_TRACE_VLOG(promise_primitives, 2) << DebugOpString("Unref");
-    DCHECK_GT(refs_, 0);
+    ABSL_DCHECK_GT(refs_, 0);
     refs_--;
     if (0 == refs_) {
       this->~Center();
@@ -143,7 +143,7 @@ class Center : public InterceptorList<T> {
   // Return false if the recv end is closed.
   Poll<bool> Push(T* value) {
     GRPC_TRACE_LOG(promise_primitives, INFO) << DebugOpString("Push");
-    DCHECK_NE(refs_, 0);
+    ABSL_DCHECK_NE(refs_, 0);
     switch (value_state_) {
       case ValueState::kClosed:
       case ValueState::kReadyClosed:
@@ -165,7 +165,7 @@ class Center : public InterceptorList<T> {

   Poll<bool> PollAck() {
     GRPC_TRACE_LOG(promise_primitives, INFO) << DebugOpString("PollAck");
-    DCHECK_NE(refs_, 0);
+    ABSL_DCHECK_NE(refs_, 0);
     switch (value_state_) {
       case ValueState::kClosed:
         return true;
@@ -191,7 +191,7 @@ class Center : public InterceptorList<T> {
   // Return nullopt if the send end is closed and no value had been pushed.
   Poll<std::optional<T>> Next() {
     GRPC_TRACE_LOG(promise_primitives, INFO) << DebugOpString("Next");
-    DCHECK_NE(refs_, 0);
+    ABSL_DCHECK_NE(refs_, 0);
     switch (value_state_) {
       case ValueState::kEmpty:
       case ValueState::kAcked:
@@ -216,7 +216,7 @@ class Center : public InterceptorList<T> {
   Poll<bool> PollClosedForSender() {
     GRPC_TRACE_LOG(promise_primitives, INFO)
         << DebugOpString("PollClosedForSender");
-    DCHECK_NE(refs_, 0);
+    ABSL_DCHECK_NE(refs_, 0);
     switch (value_state_) {
       case ValueState::kEmpty:
       case ValueState::kAcked:
@@ -238,7 +238,7 @@ class Center : public InterceptorList<T> {
   Poll<bool> PollClosedForReceiver() {
     GRPC_TRACE_LOG(promise_primitives, INFO)
         << DebugOpString("PollClosedForReceiver");
-    DCHECK_NE(refs_, 0);
+    ABSL_DCHECK_NE(refs_, 0);
     switch (value_state_) {
       case ValueState::kEmpty:
       case ValueState::kAcked:
@@ -257,7 +257,7 @@ class Center : public InterceptorList<T> {

   Poll<Empty> PollEmpty() {
     GRPC_TRACE_LOG(promise_primitives, INFO) << DebugOpString("PollEmpty");
-    DCHECK_NE(refs_, 0);
+    ABSL_DCHECK_NE(refs_, 0);
     switch (value_state_) {
       case ValueState::kReady:
       case ValueState::kReadyClosed:
@@ -646,7 +646,7 @@ class Push {
         return Pending{};
       }
     }
-    DCHECK(std::holds_alternative<AwaitingAck>(state_));
+    ABSL_DCHECK(std::holds_alternative<AwaitingAck>(state_));
     return center_->PollAck();
   }

diff --git a/third_party/grpc/source/src/core/lib/promise/poll.h b/third_party/grpc/source/src/core/lib/promise/poll.h
index b530bf32fd3b5..1bbf3627afb39 100644
--- a/third_party/grpc/source/src/core/lib/promise/poll.h
+++ b/third_party/grpc/source/src/core/lib/promise/poll.h
@@ -21,7 +21,7 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_format.h"
 #include "src/core/util/construct_destruct.h"

@@ -111,12 +111,12 @@ class Poll {
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION bool ready() const { return ready_; }

   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION T& value() {
-    DCHECK(ready());
+    ABSL_DCHECK(ready());
     return value_;
   }

   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION const T& value() const {
-    DCHECK(ready());
+    ABSL_DCHECK(ready());
     return value_;
   }

@@ -173,7 +173,7 @@ class Poll<Empty> {
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION bool ready() const { return ready_; }

   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Empty value() const {
-    DCHECK(ready());
+    ABSL_DCHECK(ready());
     return Empty{};
   }

diff --git a/third_party/grpc/source/src/core/lib/promise/promise_mutex.h b/third_party/grpc/source/src/core/lib/promise/promise_mutex.h
index c17750ff06625..9a9515c94fcec 100644
--- a/third_party/grpc/source/src/core/lib/promise/promise_mutex.h
+++ b/third_party/grpc/source/src/core/lib/promise/promise_mutex.h
@@ -19,7 +19,7 @@

 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/promise/activity.h"
 #include "src/core/lib/promise/poll.h"

@@ -35,7 +35,7 @@ class PromiseMutex {
     Lock() {}
     ~Lock() {
       if (mutex_ != nullptr) {
-        CHECK(mutex_->locked_);
+        ABSL_CHECK(mutex_->locked_);
         mutex_->locked_ = false;
         mutex_->waiter_.Wake();
       }
@@ -52,18 +52,18 @@ class PromiseMutex {
     Lock& operator=(const Lock&) noexcept = delete;

     T* operator->() {
-      DCHECK_NE(mutex_, nullptr);
+      ABSL_DCHECK_NE(mutex_, nullptr);
       return &mutex_->value_;
     }
     T& operator*() {
-      DCHECK_NE(mutex_, nullptr);
+      ABSL_DCHECK_NE(mutex_, nullptr);
       return mutex_->value_;
     }

    private:
     friend class PromiseMutex;
     explicit Lock(PromiseMutex* mutex) : mutex_(mutex) {
-      DCHECK(!mutex_->locked_);
+      ABSL_DCHECK(!mutex_->locked_);
       mutex_->locked_ = true;
     }
     PromiseMutex* mutex_ = nullptr;
@@ -71,7 +71,7 @@ class PromiseMutex {

   PromiseMutex() = default;
   explicit PromiseMutex(T value) : value_(std::move(value)) {}
-  ~PromiseMutex() { DCHECK(!locked_); }
+  ~PromiseMutex() { ABSL_DCHECK(!locked_); }

   auto Acquire() {
     return [this]() -> Poll<Lock> {
diff --git a/third_party/grpc/source/src/core/lib/promise/status_flag.h b/third_party/grpc/source/src/core/lib/promise/status_flag.h
index 13419817b4576..232b2d366e995 100644
--- a/third_party/grpc/source/src/core/lib/promise/status_flag.h
+++ b/third_party/grpc/source/src/core/lib/promise/status_flag.h
@@ -20,7 +20,7 @@
 #include <optional>
 #include <ostream>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -197,7 +197,7 @@ template <typename T>
 struct FailureStatusCastImpl<absl::StatusOr<T>, StatusFlag> {
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION static absl::StatusOr<T> Cast(
       StatusFlag flag) {
-    DCHECK(!flag.ok());
+    ABSL_DCHECK(!flag.ok());
     return absl::CancelledError();
   }
 };
@@ -206,7 +206,7 @@ template <typename T>
 struct FailureStatusCastImpl<absl::StatusOr<T>, StatusFlag&> {
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION static absl::StatusOr<T> Cast(
       StatusFlag flag) {
-    DCHECK(!flag.ok());
+    ABSL_DCHECK(!flag.ok());
     return absl::CancelledError();
   }
 };
@@ -215,7 +215,7 @@ template <typename T>
 struct FailureStatusCastImpl<absl::StatusOr<T>, const StatusFlag&> {
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION static absl::StatusOr<T> Cast(
       StatusFlag flag) {
-    DCHECK(!flag.ok());
+    ABSL_DCHECK(!flag.ok());
     return absl::CancelledError();
   }
 };
@@ -229,7 +229,7 @@ class ValueOrFailure {
   // NOLINTNEXTLINE(google-explicit-constructor)
   ValueOrFailure(Failure) {}
   // NOLINTNEXTLINE(google-explicit-constructor)
-  ValueOrFailure(StatusFlag status) { CHECK(!status.ok()); }
+  ValueOrFailure(StatusFlag status) { ABSL_CHECK(!status.ok()); }

   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION static ValueOrFailure FromOptional(
       std::optional<T> value) {
@@ -331,7 +331,7 @@ template <typename T>
 struct StatusCastImpl<ValueOrFailure<T>, StatusFlag&> {
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION static ValueOrFailure<T> Cast(
       StatusFlag f) {
-    CHECK(!f.ok());
+    ABSL_CHECK(!f.ok());
     return ValueOrFailure<T>(Failure{});
   }
 };
@@ -340,7 +340,7 @@ template <typename T>
 struct StatusCastImpl<ValueOrFailure<T>, StatusFlag> {
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION static ValueOrFailure<T> Cast(
       StatusFlag f) {
-    CHECK(!f.ok());
+    ABSL_CHECK(!f.ok());
     return ValueOrFailure<T>(Failure{});
   }
 };
diff --git a/third_party/grpc/source/src/core/lib/promise/try_join.h b/third_party/grpc/source/src/core/lib/promise/try_join.h
index 6a7b3fd256714..12f649db22279 100644
--- a/third_party/grpc/source/src/core/lib/promise/try_join.h
+++ b/third_party/grpc/source/src/core/lib/promise/try_join.h
@@ -20,7 +20,7 @@
 #include <tuple>
 #include <variant>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/meta/type_traits.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
@@ -212,7 +212,7 @@ struct TryJoinTraits {
   template <typename R, typename T>
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION static R EarlyReturn(
       const ValueOrFailure<T>& x) {
-    CHECK(!x.ok());
+    ABSL_CHECK(!x.ok());
     return FailureStatusCast<R>(Failure{});
   }
   template <typename... A>
diff --git a/third_party/grpc/source/src/core/lib/promise/try_seq.h b/third_party/grpc/source/src/core/lib/promise/try_seq.h
index 7501af89055ff..69830d85169e5 100644
--- a/third_party/grpc/source/src/core/lib/promise/try_seq.h
+++ b/third_party/grpc/source/src/core/lib/promise/try_seq.h
@@ -21,7 +21,7 @@
 #include <type_traits>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/meta/type_traits.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
@@ -208,7 +208,7 @@ struct TrySeqTraitsWithSfinae<
   }
   template <typename R>
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION static R ReturnValue(T&& status) {
-    DCHECK(!IsStatusOk(status));
+    ABSL_DCHECK(!IsStatusOk(status));
     return FailureStatusCast<R>(status.status());
   }
   template <typename Result, typename RunNext>
diff --git a/third_party/grpc/source/src/core/lib/resource_quota/arena.cc b/third_party/grpc/source/src/core/lib/resource_quota/arena.cc
index e3b24dc739b3e..8bb1756952911 100644
--- a/third_party/grpc/source/src/core/lib/resource_quota/arena.cc
+++ b/third_party/grpc/source/src/core/lib/resource_quota/arena.cc
@@ -24,7 +24,7 @@
 #include <atomic>
 #include <new>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/resource_quota/resource_quota.h"
 #include "src/core/util/alloc.h"
 namespace grpc_core {
@@ -82,7 +82,7 @@ Arena::Arena(size_t initial_size, RefCountedPtr<ArenaFactory> arena_factory)
        ++i) {
     contexts()[i] = nullptr;
   }
-  CHECK_GE(initial_size, arena_detail::BaseArenaContextTraits::ContextSize());
+  ABSL_CHECK_GE(initial_size, arena_detail::BaseArenaContextTraits::ContextSize());
   arena_factory_->allocator().Reserve(initial_size);
 }

diff --git a/third_party/grpc/source/src/core/lib/resource_quota/arena.h b/third_party/grpc/source/src/core/lib/resource_quota/arena.h
index 4ad87ec6afcff..dd915a2720158 100644
--- a/third_party/grpc/source/src/core/lib/resource_quota/arena.h
+++ b/third_party/grpc/source/src/core/lib/resource_quota/arena.h
@@ -303,7 +303,7 @@ class Arena final : public RefCounted<Arena, NonPolymorphicRefCount,
       ArenaContextType<T>::Destroy(static_cast<T*>(slot));
     }
     slot = context;
-    DCHECK_EQ(GetContext<T>(), context);
+    ABSL_DCHECK_EQ(GetContext<T>(), context);
   }

   static size_t ArenaOverhead() {
diff --git a/third_party/grpc/source/src/core/lib/resource_quota/connection_quota.cc b/third_party/grpc/source/src/core/lib/resource_quota/connection_quota.cc
index 021628c3695e9..a0fd6f5d1af5d 100644
--- a/third_party/grpc/source/src/core/lib/resource_quota/connection_quota.cc
+++ b/third_party/grpc/source/src/core/lib/resource_quota/connection_quota.cc
@@ -19,7 +19,7 @@
 #include <atomic>
 #include <cstdint>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 namespace grpc_core {

@@ -27,8 +27,8 @@ ConnectionQuota::ConnectionQuota() = default;

 void ConnectionQuota::SetMaxIncomingConnections(int max_incoming_connections) {
   // The maximum can only be configured once.
-  CHECK_LT(max_incoming_connections, INT_MAX);
-  CHECK(max_incoming_connections_.exchange(
+  ABSL_CHECK_LT(max_incoming_connections, INT_MAX);
+  ABSL_CHECK(max_incoming_connections_.exchange(
             max_incoming_connections, std::memory_order_release) == INT_MAX);
 }

@@ -62,7 +62,7 @@ void ConnectionQuota::ReleaseConnections(int num_connections) {
   if (max_incoming_connections_.load(std::memory_order_relaxed) == INT_MAX) {
     return;
   }
-  CHECK(active_incoming_connections_.fetch_sub(
+  ABSL_CHECK(active_incoming_connections_.fetch_sub(
             num_connections, std::memory_order_acq_rel) >= num_connections);
 }

diff --git a/third_party/grpc/source/src/core/lib/resource_quota/memory_quota.cc b/third_party/grpc/source/src/core/lib/resource_quota/memory_quota.cc
index 92e4d38caf4fe..19268f8911042 100644
--- a/third_party/grpc/source/src/core/lib/resource_quota/memory_quota.cc
+++ b/third_party/grpc/source/src/core/lib/resource_quota/memory_quota.cc
@@ -28,8 +28,8 @@
 #include <tuple>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/lib/debug/trace.h"
@@ -261,7 +261,7 @@ GrpcMemoryAllocatorImpl::GrpcMemoryAllocatorImpl(
 }

 GrpcMemoryAllocatorImpl::~GrpcMemoryAllocatorImpl() {
-  CHECK_EQ(free_bytes_.load(std::memory_order_acquire) +
+  ABSL_CHECK_EQ(free_bytes_.load(std::memory_order_acquire) +
                sizeof(GrpcMemoryAllocatorImpl),
            taken_bytes_.load(std::memory_order_relaxed));
   memory_quota_->Return(taken_bytes_.load(std::memory_order_relaxed));
@@ -274,7 +274,7 @@ void GrpcMemoryAllocatorImpl::Shutdown() {
       reclamation_handles[kNumReclamationPasses];
   {
     MutexLock lock(&reclaimer_mu_);
-    CHECK(!shutdown_);
+    ABSL_CHECK(!shutdown_);
     shutdown_ = true;
     memory_quota = memory_quota_;
     for (size_t i = 0; i < kNumReclamationPasses; i++) {
@@ -286,8 +286,8 @@ void GrpcMemoryAllocatorImpl::Shutdown() {
 size_t GrpcMemoryAllocatorImpl::Reserve(MemoryRequest request) {
   // Validate request - performed here so we don't bloat the generated code with
   // inlined asserts.
-  CHECK(request.min() <= request.max());
-  CHECK(request.max() <= MemoryRequest::max_allowed_size());
+  ABSL_CHECK(request.min() <= request.max());
+  ABSL_CHECK(request.max() <= MemoryRequest::max_allowed_size());
   size_t old_free = free_bytes_.load(std::memory_order_relaxed);

   while (true) {
@@ -365,7 +365,7 @@ void GrpcMemoryAllocatorImpl::MaybeDonateBack() {
                                           std::memory_order_acquire)) {
       GRPC_TRACE_LOG(resource_quota, INFO)
           << "[" << this << "] Early return " << ret << " bytes";
-      CHECK(taken_bytes_.fetch_sub(ret, std::memory_order_relaxed) >= ret);
+      ABSL_CHECK(taken_bytes_.fetch_sub(ret, std::memory_order_relaxed) >= ret);
       memory_quota_->Return(ret);
       return;
     }
@@ -460,7 +460,7 @@ void BasicMemoryQuota::Start() {
         if (GRPC_TRACE_FLAG_ENABLED(resource_quota)) {
           double free = std::max(intptr_t{0}, self->free_bytes_.load());
           size_t quota_size = self->quota_size_.load();
-          LOG(INFO) << "RQ: " << self->name_ << " perform " << std::get<0>(arg)
+          ABSL_LOG(INFO) << "RQ: " << self->name_ << " perform " << std::get<0>(arg)
                     << " reclamation. Available free bytes: " << free
                     << ", total quota_size: " << quota_size;
         }
@@ -485,7 +485,7 @@ void BasicMemoryQuota::Start() {
   reclaimer_activity_ =
       MakeActivity(std::move(reclamation_loop), ExecCtxWakeupScheduler(),
                    [](absl::Status status) {
-                     CHECK(status.code() == absl::StatusCode::kCancelled);
+                     ABSL_CHECK(status.code() == absl::StatusCode::kCancelled);
                    });
 }

@@ -505,7 +505,7 @@ void BasicMemoryQuota::SetSize(size_t new_size) {
 void BasicMemoryQuota::Take(GrpcMemoryAllocatorImpl* allocator, size_t amount) {
   // If there's a request for nothing, then do nothing!
   if (amount == 0) return;
-  DCHECK(amount <= std::numeric_limits<intptr_t>::max());
+  ABSL_DCHECK(amount <= std::numeric_limits<intptr_t>::max());
   // Grab memory from the quota.
   auto prior = free_bytes_.fetch_sub(amount, std::memory_order_acq_rel);
   // If we push into overcommit, awake the reclaimer.
@@ -542,7 +542,7 @@ void BasicMemoryQuota::FinishReclamation(uint64_t token, Waker waker) {
     if (GRPC_TRACE_FLAG_ENABLED(resource_quota)) {
       double free = std::max(intptr_t{0}, free_bytes_.load());
       size_t quota_size = quota_size_.load();
-      LOG(INFO) << "RQ: " << name_
+      ABSL_LOG(INFO) << "RQ: " << name_
                 << " reclamation complete. Available free bytes: " << free
                 << ", total quota_size: " << quota_size;
     }
diff --git a/third_party/grpc/source/src/core/lib/resource_quota/memory_quota.h b/third_party/grpc/source/src/core/lib/resource_quota/memory_quota.h
index 0a786c01cf499..69b0b3b9be479 100644
--- a/third_party/grpc/source/src/core/lib/resource_quota/memory_quota.h
+++ b/third_party/grpc/source/src/core/lib/resource_quota/memory_quota.h
@@ -32,8 +32,8 @@

 #include "absl/base/thread_annotations.h"
 #include "absl/container/flat_hash_set.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/string_view.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/lib/experiments/experiments.h"
@@ -135,7 +135,7 @@ class ReclaimerQueue {
     explicit Handle(F reclaimer, std::shared_ptr<State> state)
         : sweep_(new SweepFn<F>(std::move(reclaimer), std::move(state))) {}
     ~Handle() override {
-      DCHECK_EQ(sweep_.load(std::memory_order_relaxed), nullptr);
+      ABSL_DCHECK_EQ(sweep_.load(std::memory_order_relaxed), nullptr);
     }

     Handle(const Handle&) = delete;
@@ -435,7 +435,7 @@ class GrpcMemoryAllocatorImpl final : public EventEngineMemoryAllocatorImpl {
   template <typename F>
   void PostReclaimer(ReclamationPass pass, F fn) {
     MutexLock lock(&reclaimer_mu_);
-    CHECK(!shutdown_);
+    ABSL_CHECK(!shutdown_);
     InsertReclaimer(static_cast<size_t>(pass), std::move(fn));
   }

diff --git a/third_party/grpc/source/src/core/lib/resource_quota/thread_quota.cc b/third_party/grpc/source/src/core/lib/resource_quota/thread_quota.cc
index 381375427e2ad..9ac627b8bf8eb 100644
--- a/third_party/grpc/source/src/core/lib/resource_quota/thread_quota.cc
+++ b/third_party/grpc/source/src/core/lib/resource_quota/thread_quota.cc
@@ -16,7 +16,7 @@

 #include <grpc/support/port_platform.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 namespace grpc_core {

@@ -38,7 +38,7 @@ bool ThreadQuota::Reserve(size_t num_threads) {

 void ThreadQuota::Release(size_t num_threads) {
   MutexLock lock(&mu_);
-  CHECK(num_threads <= allocated_);
+  ABSL_CHECK(num_threads <= allocated_);
   allocated_ -= num_threads;
 }

diff --git a/third_party/grpc/source/src/core/lib/security/authorization/audit_logging.cc b/third_party/grpc/source/src/core/lib/security/authorization/audit_logging.cc
index 4a6b8b97b25e1..6f4bec9284325 100644
--- a/third_party/grpc/source/src/core/lib/security/authorization/audit_logging.cc
+++ b/third_party/grpc/source/src/core/lib/security/authorization/audit_logging.cc
@@ -26,7 +26,7 @@
 #include <memory>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_format.h"
@@ -44,15 +44,15 @@ AuditLoggerRegistry* AuditLoggerRegistry::registry = new AuditLoggerRegistry();
 AuditLoggerRegistry::AuditLoggerRegistry() {
   auto factory = std::make_unique<StdoutAuditLoggerFactory>();
   absl::string_view name = factory->name();
-  CHECK(logger_factories_map_.emplace(name, std::move(factory)).second);
+  ABSL_CHECK(logger_factories_map_.emplace(name, std::move(factory)).second);
 }

 void AuditLoggerRegistry::RegisterFactory(
     std::unique_ptr<AuditLoggerFactory> factory) {
-  CHECK(factory != nullptr);
+  ABSL_CHECK(factory != nullptr);
   MutexLock lock(mu);
   absl::string_view name = factory->name();
-  CHECK(
+  ABSL_CHECK(
       registry->logger_factories_map_.emplace(name, std::move(factory)).second);
 }

@@ -77,7 +77,7 @@ std::unique_ptr<AuditLogger> AuditLoggerRegistry::CreateAuditLogger(
     std::unique_ptr<AuditLoggerFactory::Config> config) {
   MutexLock lock(mu);
   auto it = registry->logger_factories_map_.find(config->name());
-  CHECK(it != registry->logger_factories_map_.end());
+  ABSL_CHECK(it != registry->logger_factories_map_.end());
   return it->second->CreateAuditLogger(std::move(config));
 }

diff --git a/third_party/grpc/source/src/core/lib/security/authorization/cel_authorization_engine.cc b/third_party/grpc/source/src/core/lib/security/authorization/cel_authorization_engine.cc
index c81887b5f4f4e..d582d99ac3686 100644
--- a/third_party/grpc/source/src/core/lib/security/authorization/cel_authorization_engine.cc
+++ b/third_party/grpc/source/src/core/lib/security/authorization/cel_authorization_engine.cc
@@ -21,7 +21,7 @@
 #include <optional>
 #include <utility>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/string_view.h"
 #include "absl/types/span.h"
 #include "upb/base/string_view.h"
@@ -49,13 +49,13 @@ std::unique_ptr<CelAuthorizationEngine>
 CelAuthorizationEngine::CreateCelAuthorizationEngine(
     const std::vector<envoy_config_rbac_v3_RBAC*>& rbac_policies) {
   if (rbac_policies.empty() || rbac_policies.size() > 2) {
-    LOG(ERROR) << "Invalid rbac policies vector. Must contain either one or "
+    ABSL_LOG(ERROR) << "Invalid rbac policies vector. Must contain either one or "
                   "two rbac policies.";
     return nullptr;
   } else if (rbac_policies.size() == 2 &&
              (envoy_config_rbac_v3_RBAC_action(rbac_policies[0]) != kDeny ||
               envoy_config_rbac_v3_RBAC_action(rbac_policies[1]) != kAllow)) {
-    LOG(ERROR) << "Invalid rbac policies vector. Must contain one deny policy "
+    ABSL_LOG(ERROR) << "Invalid rbac policies vector. Must contain one deny policy "
                   "and one allow policy, in that order.";
     return nullptr;
   } else {
@@ -172,7 +172,7 @@ std::unique_ptr<mock_cel::Activation> CelAuthorizationEngine::CreateActivation(
             mock_cel::CelValue::CreateStringView(cert_server_name));
       }
     } else {
-      LOG(ERROR) << "Error: Authorization engine does not support evaluating "
+      ABSL_LOG(ERROR) << "Error: Authorization engine does not support evaluating "
                     "attribute "
                  << elem;
     }
diff --git a/third_party/grpc/source/src/core/lib/security/authorization/evaluate_args.cc b/third_party/grpc/source/src/core/lib/security/authorization/evaluate_args.cc
index 9e7cb8cc6a924..96d84ce129935 100644
--- a/third_party/grpc/source/src/core/lib/security/authorization/evaluate_args.cc
+++ b/third_party/grpc/source/src/core/lib/security/authorization/evaluate_args.cc
@@ -18,7 +18,7 @@
 #include <grpc/support/port_platform.h>
 #include <string.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/match.h"
@@ -39,22 +39,22 @@ EvaluateArgs::PerChannelArgs::Address ParseEndpointUri(
   EvaluateArgs::PerChannelArgs::Address address;
   absl::StatusOr<URI> uri = URI::Parse(uri_text);
   if (!uri.ok()) {
-    VLOG(2) << "Failed to parse uri.";
+    ABSL_VLOG(2) << "Failed to parse uri.";
     return address;
   }
   absl::string_view host_view;
   absl::string_view port_view;
   if (!SplitHostPort(uri->path(), &host_view, &port_view)) {
-    VLOG(2) << "Failed to split " << uri->path() << " into host and port.";
+    ABSL_VLOG(2) << "Failed to split " << uri->path() << " into host and port.";
     return address;
   }
   if (!absl::SimpleAtoi(port_view, &address.port)) {
-    VLOG(2) << "Port " << port_view << " is out of range or null.";
+    ABSL_VLOG(2) << "Port " << port_view << " is out of range or null.";
   }
   address.address_str = std::string(host_view);
   auto resolved_address = StringToSockaddr(uri->path());
   if (!resolved_address.ok()) {
-    VLOG(2) << "Address \"" << uri->path()
+    ABSL_VLOG(2) << "Address \"" << uri->path()
             << "\" is not IPv4/IPv6. Error: " << resolved_address.status();
     memset(&address.address, 0, sizeof(address.address));
   } else {
diff --git a/third_party/grpc/source/src/core/lib/security/authorization/grpc_authorization_engine.cc b/third_party/grpc/source/src/core/lib/security/authorization/grpc_authorization_engine.cc
index a2b38af3d399b..c36d46e091456 100644
--- a/third_party/grpc/source/src/core/lib/security/authorization/grpc_authorization_engine.cc
+++ b/third_party/grpc/source/src/core/lib/security/authorization/grpc_authorization_engine.cc
@@ -20,7 +20,7 @@
 #include <map>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/security/authorization/audit_logging.h"
 #include "src/core/lib/security/authorization/authorization_engine.h"

@@ -58,7 +58,7 @@ GrpcAuthorizationEngine::GrpcAuthorizationEngine(Rbac policy)
   for (auto& logger_config : policy.logger_configs) {
     auto logger =
         AuditLoggerRegistry::CreateAuditLogger(std::move(logger_config));
-    CHECK(logger != nullptr);
+    ABSL_CHECK(logger != nullptr);
     audit_loggers_.push_back(std::move(logger));
   }
 }
diff --git a/third_party/grpc/source/src/core/lib/security/authorization/grpc_authorization_policy_provider.cc b/third_party/grpc/source/src/core/lib/security/authorization/grpc_authorization_policy_provider.cc
index 6b7a1ccec9f1c..edab3011b58cb 100644
--- a/third_party/grpc/source/src/core/lib/security/authorization/grpc_authorization_policy_provider.cc
+++ b/third_party/grpc/source/src/core/lib/security/authorization/grpc_authorization_policy_provider.cc
@@ -25,8 +25,8 @@
 #include <optional>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/lib/iomgr/error.h"
 #include "src/core/lib/security/authorization/grpc_authorization_engine.h"
@@ -79,8 +79,8 @@ gpr_timespec TimeoutSecondsToDeadline(int64_t seconds) {
 absl::StatusOr<RefCountedPtr<grpc_authorization_policy_provider>>
 FileWatcherAuthorizationPolicyProvider::Create(
     absl::string_view authz_policy_path, unsigned int refresh_interval_sec) {
-  CHECK(!authz_policy_path.empty());
-  CHECK_GT(refresh_interval_sec, 0u);
+  ABSL_CHECK(!authz_policy_path.empty());
+  ABSL_CHECK_GT(refresh_interval_sec, 0u);
   absl::Status status;
   auto provider = MakeRefCounted<FileWatcherAuthorizationPolicyProvider>(
       authz_policy_path, refresh_interval_sec, &status);
@@ -102,7 +102,7 @@ FileWatcherAuthorizationPolicyProvider::FileWatcherAuthorizationPolicyProvider(
   auto thread_lambda = [](void* arg) {
     WeakRefCountedPtr<FileWatcherAuthorizationPolicyProvider> provider(
         static_cast<FileWatcherAuthorizationPolicyProvider*>(arg));
-    CHECK(provider != nullptr);
+    ABSL_CHECK(provider != nullptr);
     while (true) {
       void* value = gpr_event_wait(
           &provider->shutdown_event_,
@@ -112,7 +112,7 @@ FileWatcherAuthorizationPolicyProvider::FileWatcherAuthorizationPolicyProvider(
       }
       absl::Status status = provider->ForceUpdate();
       if (GRPC_TRACE_FLAG_ENABLED(grpc_authz_api) && !status.ok()) {
-        LOG(ERROR) << "authorization policy reload status. code="
+        ABSL_LOG(ERROR) << "authorization policy reload status. code="
                    << static_cast<int>(status.code())
                    << " error_details=" << status.message();
       }
@@ -187,7 +187,7 @@ grpc_authorization_policy_provider*
 grpc_authorization_policy_provider_static_data_create(
     const char* authz_policy, grpc_status_code* code,
     const char** error_details) {
-  CHECK_NE(authz_policy, nullptr);
+  ABSL_CHECK_NE(authz_policy, nullptr);
   auto provider_or =
       grpc_core::StaticDataAuthorizationPolicyProvider::Create(authz_policy);
   if (!provider_or.ok()) {
@@ -203,7 +203,7 @@ grpc_authorization_policy_provider*
 grpc_authorization_policy_provider_file_watcher_create(
     const char* authz_policy_path, unsigned int refresh_interval_sec,
     grpc_status_code* code, const char** error_details) {
-  CHECK_NE(authz_policy_path, nullptr);
+  ABSL_CHECK_NE(authz_policy_path, nullptr);
   auto provider_or = grpc_core::FileWatcherAuthorizationPolicyProvider::Create(
       authz_policy_path, refresh_interval_sec);
   if (!provider_or.ok()) {
diff --git a/third_party/grpc/source/src/core/lib/security/authorization/grpc_server_authz_filter.cc b/third_party/grpc/source/src/core/lib/security/authorization/grpc_server_authz_filter.cc
index 6548d807fae24..67b1401cbba8a 100644
--- a/third_party/grpc/source/src/core/lib/security/authorization/grpc_server_authz_filter.cc
+++ b/third_party/grpc/source/src/core/lib/security/authorization/grpc_server_authz_filter.cc
@@ -21,7 +21,7 @@
 #include <string>
 #include <utility>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_join.h"
 #include "src/core/lib/channel/channel_stack.h"
diff --git a/third_party/grpc/source/src/core/lib/security/authorization/matchers.cc b/third_party/grpc/source/src/core/lib/security/authorization/matchers.cc
index c113514f2334b..31f07264ce055 100644
--- a/third_party/grpc/source/src/core/lib/security/authorization/matchers.cc
+++ b/third_party/grpc/source/src/core/lib/security/authorization/matchers.cc
@@ -20,7 +20,7 @@

 #include <string>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/string_view.h"
@@ -155,7 +155,7 @@ IpAuthorizationMatcher::IpAuthorizationMatcher(Type type, Rbac::CidrRange range)
   auto address =
       StringToSockaddr(range.address_prefix, 0);  // Port does not matter here.
   if (!address.ok()) {
-    VLOG(2) << "CidrRange address \"" << range.address_prefix
+    ABSL_VLOG(2) << "CidrRange address \"" << range.address_prefix
             << "\" is not IPv4/IPv6. Error: " << address.status();
     memset(&subnet_address_, 0, sizeof(subnet_address_));
     return;
diff --git a/third_party/grpc/source/src/core/lib/security/authorization/rbac_translator.cc b/third_party/grpc/source/src/core/lib/security/authorization/rbac_translator.cc
index 21e6358e5f405..8805d5123b373 100644
--- a/third_party/grpc/source/src/core/lib/security/authorization/rbac_translator.cc
+++ b/third_party/grpc/source/src/core/lib/security/authorization/rbac_translator.cc
@@ -26,7 +26,7 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/match.h"
@@ -419,7 +419,7 @@ ParseAuditLogger(const Json& json, size_t pos) {
 }

 absl::Status ParseAuditLoggingOptions(const Json& json, RbacPolicies* rbacs) {
-  CHECK_NE(rbacs, nullptr);
+  ABSL_CHECK_NE(rbacs, nullptr);
   for (auto it = json.object().begin(); it != json.object().end(); ++it) {
     if (it->first == "audit_condition") {
       if (it->second.type() != Json::Type::kString) {
@@ -473,7 +473,7 @@ absl::Status ParseAuditLoggingOptions(const Json& json, RbacPolicies* rbacs) {
             // Parse again since it returns unique_ptr, but result should be ok
             // this time.
             auto result = ParseAuditLogger(loggers.at(i), i);
-            CHECK(result.ok());
+            ABSL_CHECK(result.ok());
             rbacs->deny_policy->logger_configs.push_back(
                 std::move(result.value()));
           }
diff --git a/third_party/grpc/source/src/core/lib/security/authorization/stdout_logger.cc b/third_party/grpc/source/src/core/lib/security/authorization/stdout_logger.cc
index f2fc5eaa6a623..3d2bcd42a6c33 100644
--- a/third_party/grpc/source/src/core/lib/security/authorization/stdout_logger.cc
+++ b/third_party/grpc/source/src/core/lib/security/authorization/stdout_logger.cc
@@ -22,7 +22,7 @@
 #include <memory>
 #include <string>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_format.h"
 #include "absl/strings/string_view.h"
@@ -65,8 +65,8 @@ StdoutAuditLoggerFactory::ParseAuditLoggerConfig(const Json&) {
 std::unique_ptr<AuditLogger> StdoutAuditLoggerFactory::CreateAuditLogger(
     std::unique_ptr<AuditLoggerFactory::Config> config) {
   // Sanity check.
-  CHECK(config != nullptr);
-  CHECK(config->name() == name());
+  ABSL_CHECK(config != nullptr);
+  ABSL_CHECK(config->name() == name());
   return std::make_unique<StdoutAuditLogger>();
 }

diff --git a/third_party/grpc/source/src/core/lib/security/certificate_provider/certificate_provider_registry.cc b/third_party/grpc/source/src/core/lib/security/certificate_provider/certificate_provider_registry.cc
index 40b9a6a90c9c1..dc25f6f17f2b4 100644
--- a/third_party/grpc/source/src/core/lib/security/certificate_provider/certificate_provider_registry.cc
+++ b/third_party/grpc/source/src/core/lib/security/certificate_provider/certificate_provider_registry.cc
@@ -23,16 +23,16 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"

 namespace grpc_core {

 void CertificateProviderRegistry::Builder::RegisterCertificateProviderFactory(
     std::unique_ptr<CertificateProviderFactory> factory) {
   absl::string_view name = factory->name();
-  VLOG(2) << "registering certificate provider factory for \"" << name << "\"";
-  CHECK(factories_.emplace(name, std::move(factory)).second);
+  ABSL_VLOG(2) << "registering certificate provider factory for \"" << name << "\"";
+  ABSL_CHECK(factories_.emplace(name, std::move(factory)).second);
 }

 CertificateProviderRegistry CertificateProviderRegistry::Builder::Build() {
diff --git a/third_party/grpc/source/src/core/lib/security/context/security_context.cc b/third_party/grpc/source/src/core/lib/security/context/security_context.cc
index 46fe754b72824..cabbfd125dfad 100644
--- a/third_party/grpc/source/src/core/lib/security/context/security_context.cc
+++ b/third_party/grpc/source/src/core/lib/security/context/security_context.cc
@@ -27,8 +27,8 @@

 #include <algorithm>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/channel/channel_args.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
@@ -46,7 +46,7 @@ grpc_call_error grpc_call_set_credentials(grpc_call* call,
   GRPC_TRACE_LOG(api, INFO) << "grpc_call_set_credentials(call=" << call
                             << ", creds=" << creds << ")";
   if (!grpc_call_is_client(call)) {
-    LOG(ERROR) << "Method is client-side only.";
+    ABSL_LOG(ERROR) << "Method is client-side only.";
     return GRPC_CALL_ERROR_NOT_ON_SERVER;
   }
   auto* arena = grpc_call_get_arena(call);
@@ -154,7 +154,7 @@ int grpc_auth_context_set_peer_identity_property_name(grpc_auth_context* ctx,
       << "grpc_auth_context_set_peer_identity_property_name(ctx=" << ctx
       << ", name=" << name << ")";
   if (prop == nullptr) {
-    LOG(ERROR) << "Property name " << (name != nullptr ? name : "NULL")
+    ABSL_LOG(ERROR) << "Property name " << (name != nullptr ? name : "NULL")
                << " not found in auth context.";
     return 0;
   }
@@ -194,7 +194,7 @@ const grpc_auth_property* grpc_auth_property_iterator_next(
     while (it->index < it->ctx->properties().count) {
       const grpc_auth_property* prop =
           &it->ctx->properties().array[it->index++];
-      CHECK_NE(prop->name, nullptr);
+      ABSL_CHECK_NE(prop->name, nullptr);
       if (strcmp(it->name, prop->name) == 0) {
         return prop;
       }
@@ -312,7 +312,7 @@ grpc_arg grpc_auth_context_to_arg(grpc_auth_context* c) {
 grpc_auth_context* grpc_auth_context_from_arg(const grpc_arg* arg) {
   if (strcmp(arg->key, GRPC_AUTH_CONTEXT_ARG) != 0) return nullptr;
   if (arg->type != GRPC_ARG_POINTER) {
-    LOG(ERROR) << "Invalid type " << arg->type << " for arg "
+    ABSL_LOG(ERROR) << "Invalid type " << arg->type << " for arg "
                << GRPC_AUTH_CONTEXT_ARG;
     return nullptr;
   }
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/alts/check_gcp_environment.cc b/third_party/grpc/source/src/core/lib/security/credentials/alts/check_gcp_environment.cc
index 37628d18321ae..b89db66dfe7a9 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/alts/check_gcp_environment.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/alts/check_gcp_environment.cc
@@ -24,7 +24,7 @@
 #include <stdio.h>
 #include <string.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"

 const size_t kBiosDataBufferSize = 256;

@@ -56,7 +56,7 @@ namespace internal {
 char* read_bios_file(const char* bios_file) {
   FILE* fp = fopen(bios_file, "r");
   if (!fp) {
-    VLOG(2) << "BIOS data file does not exist or cannot be opened.";
+    ABSL_VLOG(2) << "BIOS data file does not exist or cannot be opened.";
     return nullptr;
   }
   char buf[kBiosDataBufferSize + 1];
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/alts/check_gcp_environment_no_op.cc b/third_party/grpc/source/src/core/lib/security/credentials/alts/check_gcp_environment_no_op.cc
index bf64fe60a36ae..583d1f4067cbc 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/alts/check_gcp_environment_no_op.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/alts/check_gcp_environment_no_op.cc
@@ -20,12 +20,12 @@

 #if !defined(GPR_LINUX) && !defined(GPR_WINDOWS)

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/security/credentials/alts/check_gcp_environment.h"
 #include "src/core/util/crash.h"

 bool grpc_alts_is_running_on_gcp() {
-  VLOG(2) << "ALTS: Platforms other than Linux and Windows are not supported";
+  ABSL_VLOG(2) << "ALTS: Platforms other than Linux and Windows are not supported";
   return false;
 }

diff --git a/third_party/grpc/source/src/core/lib/security/credentials/alts/grpc_alts_credentials_client_options.cc b/third_party/grpc/source/src/core/lib/security/credentials/alts/grpc_alts_credentials_client_options.cc
index 37a1856713a62..e801ae1987cdf 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/alts/grpc_alts_credentials_client_options.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/alts/grpc_alts_credentials_client_options.cc
@@ -21,7 +21,7 @@
 #include <grpc/support/port_platform.h>
 #include <grpc/support/string_util.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/security/credentials/alts/grpc_alts_credentials_options.h"
 #include "src/core/tsi/alts/handshaker/transport_security_common_api.h"

@@ -44,7 +44,7 @@ static target_service_account* target_service_account_create(
 void grpc_alts_credentials_client_options_add_target_service_account(
     grpc_alts_credentials_options* options, const char* service_account) {
   if (options == nullptr || service_account == nullptr) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "Invalid nullptr arguments to "
            "grpc_alts_credentials_client_options_add_target_service_account()";
     return;
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/alts/grpc_alts_credentials_options.cc b/third_party/grpc/source/src/core/lib/security/credentials/alts/grpc_alts_credentials_options.cc
index a52dfe9617395..2d19d93602600 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/alts/grpc_alts_credentials_options.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/alts/grpc_alts_credentials_options.cc
@@ -21,7 +21,7 @@
 #include <grpc/support/alloc.h>
 #include <grpc/support/port_platform.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"

 grpc_alts_credentials_options* grpc_alts_credentials_options_copy(
     const grpc_alts_credentials_options* options) {
@@ -30,7 +30,7 @@ grpc_alts_credentials_options* grpc_alts_credentials_options_copy(
     return options->vtable->copy(options);
   }
   // An error occurred.
-  LOG(ERROR) << "Invalid arguments to grpc_alts_credentials_options_copy()";
+  ABSL_LOG(ERROR) << "Invalid arguments to grpc_alts_credentials_options_copy()";
   return nullptr;
 }

diff --git a/third_party/grpc/source/src/core/lib/security/credentials/call_creds_util.cc b/third_party/grpc/source/src/core/lib/security/credentials/call_creds_util.cc
index e97ba305f17d4..54be4273852fb 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/call_creds_util.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/call_creds_util.cc
@@ -20,8 +20,8 @@
 #include <grpc/support/string_util.h>
 #include <string.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
 #include "src/core/lib/security/context/security_context.h"
@@ -41,13 +41,13 @@ struct ServiceUrlAndMethod {
 ServiceUrlAndMethod MakeServiceUrlAndMethod(
     const ClientMetadataHandle& initial_metadata,
     const grpc_call_credentials::GetRequestMetadataArgs* args) {
-  DCHECK(initial_metadata->get_pointer(HttpPathMetadata()) != nullptr);
+  ABSL_DCHECK(initial_metadata->get_pointer(HttpPathMetadata()) != nullptr);
   auto service =
       initial_metadata->get_pointer(HttpPathMetadata())->as_string_view();
   auto last_slash = service.find_last_of('/');
   absl::string_view method_name;
   if (last_slash == absl::string_view::npos) {
-    LOG(ERROR) << "No '/' found in fully qualified method name";
+    ABSL_LOG(ERROR) << "No '/' found in fully qualified method name";
     service = "";
     method_name = "";
   } else if (last_slash == 0) {
@@ -56,7 +56,7 @@ ServiceUrlAndMethod MakeServiceUrlAndMethod(
     method_name = service.substr(last_slash + 1);
     service = service.substr(0, last_slash);
   }
-  DCHECK(initial_metadata->get_pointer(HttpAuthorityMetadata()) != nullptr);
+  ABSL_DCHECK(initial_metadata->get_pointer(HttpAuthorityMetadata()) != nullptr);
   auto host_and_port =
       initial_metadata->get_pointer(HttpAuthorityMetadata())->as_string_view();
   absl::string_view url_scheme = args->security_connector->url_scheme();
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/composite/composite_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/composite/composite_credentials.cc
index 81b6463421fa4..d10f4a1c0addd 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/composite/composite_credentials.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/composite/composite_credentials.cc
@@ -24,7 +24,7 @@
 #include <memory>
 #include <vector>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_join.h"
 #include "src/core/lib/debug/trace.h"
@@ -127,9 +127,9 @@ grpc_call_credentials* grpc_composite_call_credentials_create(
   GRPC_TRACE_LOG(api, INFO)
       << "grpc_composite_call_credentials_create(creds1=" << creds1
       << ", creds2=" << creds2 << ", reserved=" << reserved << ")";
-  CHECK_EQ(reserved, nullptr);
-  CHECK_NE(creds1, nullptr);
-  CHECK_NE(creds2, nullptr);
+  ABSL_CHECK_EQ(reserved, nullptr);
+  ABSL_CHECK_NE(creds1, nullptr);
+  ABSL_CHECK_NE(creds2, nullptr);

   return composite_call_credentials_create(creds1->Ref(), creds2->Ref())
       .release();
@@ -141,8 +141,8 @@ grpc_core::RefCountedPtr<grpc_channel_security_connector>
 grpc_composite_channel_credentials::create_security_connector(
     grpc_core::RefCountedPtr<grpc_call_credentials> call_creds,
     const char* target, grpc_core::ChannelArgs* args) {
-  CHECK(inner_creds_ != nullptr);
-  CHECK(call_creds_ != nullptr);
+  ABSL_CHECK(inner_creds_ != nullptr);
+  ABSL_CHECK(call_creds_ != nullptr);
   // If we are passed a call_creds, create a call composite to pass it
   // downstream.
   if (call_creds != nullptr) {
@@ -157,7 +157,7 @@ grpc_composite_channel_credentials::create_security_connector(
 grpc_channel_credentials* grpc_composite_channel_credentials_create(
     grpc_channel_credentials* channel_creds, grpc_call_credentials* call_creds,
     void* reserved) {
-  CHECK(channel_creds != nullptr && call_creds != nullptr &&
+  ABSL_CHECK(channel_creds != nullptr && call_creds != nullptr &&
         reserved == nullptr);
   GRPC_TRACE_LOG(api, INFO)
       << "grpc_composite_channel_credentials_create(channel_creds="
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/credentials.cc
index 69a0180b93c18..4154cdceee102 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/credentials.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/credentials.cc
@@ -22,8 +22,8 @@
 #include <stdint.h>
 #include <string.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/channel/channel_args.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
@@ -73,7 +73,7 @@ grpc_channel_credentials* grpc_channel_credentials_from_arg(
     const grpc_arg* arg) {
   if (strcmp(arg->key, GRPC_ARG_CHANNEL_CREDENTIALS) != 0) return nullptr;
   if (arg->type != GRPC_ARG_POINTER) {
-    LOG(ERROR) << "Invalid type " << arg->type << " for arg "
+    ABSL_LOG(ERROR) << "Invalid type " << arg->type << " for arg "
                << GRPC_ARG_CHANNEL_CREDENTIALS;
     return nullptr;
   }
@@ -112,7 +112,7 @@ void grpc_server_credentials::set_auth_metadata_processor(

 void grpc_server_credentials_set_auth_metadata_processor(
     grpc_server_credentials* creds, grpc_auth_metadata_processor processor) {
-  DCHECK_NE(creds, nullptr);
+  ABSL_DCHECK_NE(creds, nullptr);
   creds->set_auth_metadata_processor(processor);
 }

@@ -140,7 +140,7 @@ grpc_arg grpc_server_credentials_to_arg(grpc_server_credentials* c) {
 grpc_server_credentials* grpc_server_credentials_from_arg(const grpc_arg* arg) {
   if (strcmp(arg->key, GRPC_SERVER_CREDENTIALS_ARG) != 0) return nullptr;
   if (arg->type != GRPC_ARG_POINTER) {
-    LOG(ERROR) << "Invalid type " << arg->type << " for arg "
+    ABSL_LOG(ERROR) << "Invalid type " << arg->type << " for arg "
                << GRPC_SERVER_CREDENTIALS_ARG;
     return nullptr;
   }
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/credentials.h b/third_party/grpc/source/src/core/lib/security/credentials/credentials.h
index 2daef3c6b0088..b08d81f3752ce 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/credentials.h
+++ b/third_party/grpc/source/src/core/lib/security/credentials/credentials.h
@@ -30,7 +30,7 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/string_view.h"
 #include "src/core/lib/channel/channel_args.h"
@@ -136,7 +136,7 @@ struct grpc_channel_credentials
   // two different `grpc_channel_credentials` objects are used but they compare
   // as equal (assuming other channel args match).
   int cmp(const grpc_channel_credentials* other) const {
-    CHECK_NE(other, nullptr);
+    ABSL_CHECK_NE(other, nullptr);
     int r = type().Compare(other->type());
     if (r != 0) return r;
     return cmp_impl(other);
@@ -217,7 +217,7 @@ struct grpc_call_credentials
   // If this method returns 0, it means that gRPC can treat the two call
   // credentials as effectively the same..
   int cmp(const grpc_call_credentials* other) const {
-    CHECK_NE(other, nullptr);
+    ABSL_CHECK_NE(other, nullptr);
     int r = type().Compare(other->type());
     if (r != 0) return r;
     return cmp_impl(other);
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/external/aws_external_account_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/external/aws_external_account_credentials.cc
index e14088496a62a..3a2bb78d9094f 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/external/aws_external_account_credentials.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/external/aws_external_account_credentials.cc
@@ -28,7 +28,7 @@
 #include <optional>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -423,8 +423,8 @@ void AwsExternalAccountCredentials::AwsFetchBody::BuildSubjectToken() {
 void AwsExternalAccountCredentials::AwsFetchBody::AddMetadataRequestHeaders(
     grpc_http_request* request) {
   if (!imdsv2_session_token_.empty()) {
-    CHECK_EQ(request->hdr_count, 0u);
-    CHECK_EQ(request->hdrs, nullptr);
+    ABSL_CHECK_EQ(request->hdr_count, 0u);
+    ABSL_CHECK_EQ(request->hdrs, nullptr);
     grpc_http_header* headers =
         static_cast<grpc_http_header*>(gpr_malloc(sizeof(grpc_http_header)));
     headers[0].key = gpr_strdup("x-aws-ec2-metadata-token");
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/external/external_account_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/external/external_account_credentials.cc
index f05cd63f9e674..8889707658173 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/external/external_account_credentials.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/external/external_account_credentials.cc
@@ -29,8 +29,8 @@
 #include <memory>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/escaping.h"
@@ -392,7 +392,7 @@ void ExternalAccountCredentials::ExternalFetchRequest::FinishTokenFetch(
     absl::StatusOr<std::string> response_body) {
   absl::StatusOr<RefCountedPtr<Token>> result;
   if (!response_body.ok()) {
-    LOG(ERROR) << "Fetch external account credentials access token: "
+    ABSL_LOG(ERROR) << "Fetch external account credentials access token: "
                << response_body.status();
     result = absl::Status(response_body.status().code(),
                           absl::StrCat("error fetching oauth2 token: ",
@@ -627,7 +627,7 @@ grpc_call_credentials* grpc_external_account_credentials_create(
     const char* json_string, const char* scopes_string) {
   auto json = grpc_core::JsonParse(json_string);
   if (!json.ok()) {
-    LOG(ERROR) << "External account credentials creation failed. Error: "
+    ABSL_LOG(ERROR) << "External account credentials creation failed. Error: "
                << json.status();
     return nullptr;
   }
@@ -635,7 +635,7 @@ grpc_call_credentials* grpc_external_account_credentials_create(
   auto creds =
       grpc_core::ExternalAccountCredentials::Create(*json, std::move(scopes));
   if (!creds.ok()) {
-    LOG(ERROR) << "External account credentials creation failed. Error: "
+    ABSL_LOG(ERROR) << "External account credentials creation failed. Error: "
                << grpc_core::StatusToString(creds.status());
     return nullptr;
   }
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/external/url_external_account_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/external/url_external_account_credentials.cc
index 502700a4d64d2..689efe1a6ddc5 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/external/url_external_account_credentials.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/external/url_external_account_credentials.cc
@@ -27,7 +27,7 @@
 #include <memory>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/gcp_service_account_identity/gcp_service_account_identity_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/gcp_service_account_identity/gcp_service_account_identity_credentials.cc
index 31d00e7bfd39f..595436c453f1c 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/gcp_service_account_identity/gcp_service_account_identity_credentials.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/gcp_service_account_identity/gcp_service_account_identity_credentials.cc
@@ -182,7 +182,7 @@ GcpServiceAccountIdentityCallCredentials::StartHttpRequest(
       "http", "metadata.google.internal.",
       "/computeMetadata/v1/instance/service-accounts/default/identity",
       {{"audience", audience_}}, /*fragment=*/"");
-  CHECK_OK(uri);  // params are hardcoded
+  ABSL_CHECK_OK(uri);  // params are hardcoded
   auto http_request =
       HttpRequest::Get(std::move(*uri), /*args=*/nullptr, pollent, &request,
                        deadline, on_complete, response,
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/google_default/credentials_generic.cc b/third_party/grpc/source/src/core/lib/security/credentials/google_default/credentials_generic.cc
index 771f9c128acf0..6a40ca908cd65 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/google_default/credentials_generic.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/google_default/credentials_generic.cc
@@ -21,7 +21,7 @@
 #include <optional>
 #include <string>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/lib/security/credentials/credentials.h"
 #include "src/core/lib/security/credentials/google_default/google_default_credentials.h"
@@ -30,7 +30,7 @@
 std::string grpc_get_well_known_google_credentials_file_path_impl(void) {
   auto base = grpc_core::GetEnv(GRPC_GOOGLE_CREDENTIALS_PATH_ENV_VAR);
   if (!base.has_value()) {
-    LOG(ERROR) << "Could not get " << GRPC_GOOGLE_CREDENTIALS_PATH_ENV_VAR
+    ABSL_LOG(ERROR) << "Could not get " << GRPC_GOOGLE_CREDENTIALS_PATH_ENV_VAR
                << " environment variable.";
     return "";
   }
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/google_default/google_default_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/google_default/google_default_credentials.cc
index 8c4dfed149616..8b4db2ac9775a 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/google_default/google_default_credentials.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/google_default/google_default_credentials.cc
@@ -32,8 +32,8 @@
 #include <optional>
 #include <string>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/match.h"
 #include "absl/strings/str_cat.h"
@@ -135,7 +135,7 @@ grpc_google_default_channel_credentials::create_security_connector(
                         is_xds_non_cfe_cluster;
   // Return failure if ALTS is selected but not running on GCE.
   if (use_alts && alts_creds_ == nullptr) {
-    LOG(ERROR) << "ALTS is selected, but not running on GCE.";
+    ABSL_LOG(ERROR) << "ALTS is selected, but not running on GCE.";
     return nullptr;
   }
   grpc_core::RefCountedPtr<grpc_channel_security_connector> sc =
@@ -213,7 +213,7 @@ static int is_metadata_server_reachable() {
   auto uri =
       grpc_core::URI::Create("http", GRPC_COMPUTE_ENGINE_DETECTION_HOST, "/",
                              {} /* query params */, "" /* fragment */);
-  CHECK(uri.ok());  // params are hardcoded
+  ABSL_CHECK(uri.ok());  // params are hardcoded
   auto http_request = grpc_core::HttpRequest::Get(
       std::move(*uri), nullptr /* channel args */, &detector.pollent, &request,
       grpc_core::Timestamp::Now() + max_detection_delay,
@@ -378,7 +378,7 @@ grpc_channel_credentials* grpc_google_default_credentials_create(
     // Create google default credentials.
     grpc_channel_credentials* ssl_creds =
         grpc_ssl_credentials_create(nullptr, nullptr, nullptr, nullptr);
-    CHECK_NE(ssl_creds, nullptr);
+    ABSL_CHECK_NE(ssl_creds, nullptr);
     grpc_alts_credentials_options* options =
         grpc_alts_credentials_client_options_create();
     grpc_channel_credentials* alts_creds =
@@ -390,9 +390,9 @@ grpc_channel_credentials* grpc_google_default_credentials_create(
             grpc_core::RefCountedPtr<grpc_channel_credentials>(ssl_creds));
     result = grpc_composite_channel_credentials_create(
         creds.get(), call_creds.get(), nullptr);
-    CHECK_NE(result, nullptr);
+    ABSL_CHECK_NE(result, nullptr);
   } else {
-    LOG(ERROR) << "Could not create google default credentials: "
+    ABSL_LOG(ERROR) << "Could not create google default credentials: "
                << grpc_core::StatusToString(error);
   }
   return result;
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/iam/iam_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/iam/iam_credentials.cc
index 3d1acd4a037fa..03e2eb20e6152 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/iam/iam_credentials.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/iam/iam_credentials.cc
@@ -24,7 +24,7 @@
 #include <memory>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_format.h"
 #include "absl/strings/string_view.h"
 #include "src/core/lib/debug/trace.h"
@@ -69,9 +69,9 @@ grpc_call_credentials* grpc_google_iam_credentials_create(
   GRPC_TRACE_LOG(api, INFO) << "grpc_iam_credentials_create(token=" << token
                             << ", authority_selector=" << authority_selector
                             << ", reserved=" << reserved << ")";
-  CHECK_EQ(reserved, nullptr);
-  CHECK_NE(token, nullptr);
-  CHECK_NE(authority_selector, nullptr);
+  ABSL_CHECK_EQ(reserved, nullptr);
+  ABSL_CHECK_NE(token, nullptr);
+  ABSL_CHECK_NE(authority_selector, nullptr);
   return grpc_core::MakeRefCounted<grpc_google_iam_credentials>(
              token, authority_selector)
       .release();
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/jwt/json_token.cc b/third_party/grpc/source/src/core/lib/security/credentials/jwt/json_token.cc
index eac638a1283c9..5295693f670bb 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/jwt/json_token.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/jwt/json_token.cc
@@ -35,8 +35,8 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/escaping.h"
@@ -83,7 +83,7 @@ grpc_auth_json_key grpc_auth_json_key_create_from_json(const Json& json) {
   memset(&result, 0, sizeof(grpc_auth_json_key));
   result.type = GRPC_AUTH_JSON_TYPE_INVALID;
   if (json.type() == Json::Type::kNull) {
-    LOG(ERROR) << "Invalid json.";
+    ABSL_LOG(ERROR) << "Invalid json.";
     goto end;
   }

@@ -111,7 +111,7 @@ grpc_auth_json_key grpc_auth_json_key_create_from_json(const Json& json) {
   bio = BIO_new(BIO_s_mem());
   success = BIO_puts(bio, prop_value);
   if ((success < 0) || (static_cast<size_t>(success) != strlen(prop_value))) {
-    LOG(ERROR) << "Could not write into openssl BIO.";
+    ABSL_LOG(ERROR) << "Could not write into openssl BIO.";
     goto end;
   }
 #if OPENSSL_VERSION_NUMBER < 0x30000000L
@@ -121,7 +121,7 @@ grpc_auth_json_key grpc_auth_json_key_create_from_json(const Json& json) {
   result.private_key = PEM_read_bio_PrivateKey(bio, nullptr, nullptr, nullptr);
 #endif
   if (result.private_key == nullptr) {
-    LOG(ERROR) << "Could not deserialize private key.";
+    ABSL_LOG(ERROR) << "Could not deserialize private key.";
     goto end;
   }
   success = 1;
@@ -137,7 +137,7 @@ grpc_auth_json_key grpc_auth_json_key_create_from_string(
   Json json;
   auto json_or = grpc_core::JsonParse(json_string);
   if (!json_or.ok()) {
-    LOG(ERROR) << "JSON key parsing error: " << json_or.status();
+    ABSL_LOG(ERROR) << "JSON key parsing error: " << json_or.status();
   } else {
     json = std::move(*json_or);
   }
@@ -187,7 +187,7 @@ static char* encoded_jwt_claim(const grpc_auth_json_key* json_key,
   gpr_timespec now = gpr_now(GPR_CLOCK_REALTIME);
   gpr_timespec expiration = gpr_time_add(now, token_lifetime);
   if (gpr_time_cmp(token_lifetime, grpc_max_auth_token_lifetime()) > 0) {
-    VLOG(2) << "Cropping token lifetime to maximum allowed value.";
+    ABSL_VLOG(2) << "Cropping token lifetime to maximum allowed value.";
     expiration = gpr_time_add(now, grpc_max_auth_token_lifetime());
   }

@@ -221,8 +221,8 @@ static char* dot_concat_and_free_strings(char* str1, char* str2) {
   *(current++) = '.';
   memcpy(current, str2, str2_len);
   current += str2_len;
-  CHECK(current >= result);
-  CHECK((uintptr_t)(current - result) == result_len);
+  ABSL_CHECK(current >= result);
+  ABSL_CHECK((uintptr_t)(current - result) == result_len);
   *current = '\0';
   gpr_free(str1);
   gpr_free(str2);
@@ -233,7 +233,7 @@ const EVP_MD* openssl_digest_from_algorithm(const char* algorithm) {
   if (strcmp(algorithm, GRPC_JWT_RSA_SHA256_ALGORITHM) == 0) {
     return EVP_sha256();
   } else {
-    LOG(ERROR) << "Unknown algorithm " << algorithm;
+    ABSL_LOG(ERROR) << "Unknown algorithm " << algorithm;
     return nullptr;
   }
 }
@@ -252,7 +252,7 @@ char* compute_and_encode_signature(const grpc_auth_json_key* json_key,
   if (md == nullptr) return nullptr;
   md_ctx = EVP_MD_CTX_create();
   if (md_ctx == nullptr) {
-    LOG(ERROR) << "Could not create MD_CTX";
+    ABSL_LOG(ERROR) << "Could not create MD_CTX";
     goto end;
   }
 #if OPENSSL_VERSION_NUMBER < 0x30000000L
@@ -262,20 +262,20 @@ char* compute_and_encode_signature(const grpc_auth_json_key* json_key,
   if (EVP_DigestSignInit(md_ctx, nullptr, md, nullptr, json_key->private_key) !=
       1) {
 #endif
-    LOG(ERROR) << "DigestInit failed.";
+    ABSL_LOG(ERROR) << "DigestInit failed.";
     goto end;
   }
   if (EVP_DigestSignUpdate(md_ctx, to_sign, strlen(to_sign)) != 1) {
-    LOG(ERROR) << "DigestUpdate failed.";
+    ABSL_LOG(ERROR) << "DigestUpdate failed.";
     goto end;
   }
   if (EVP_DigestSignFinal(md_ctx, nullptr, &sig_len) != 1) {
-    LOG(ERROR) << "DigestFinal (get signature length) failed.";
+    ABSL_LOG(ERROR) << "DigestFinal (get signature length) failed.";
     goto end;
   }
   sig = static_cast<unsigned char*>(gpr_malloc(sig_len));
   if (EVP_DigestSignFinal(md_ctx, sig, &sig_len) != 1) {
-    LOG(ERROR) << "DigestFinal (signature compute) failed.";
+    ABSL_LOG(ERROR) << "DigestFinal (signature compute) failed.";
     goto end;
   }
   result =
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/jwt/jwt_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/jwt/jwt_credentials.cc
index 7047365e9059e..08be171465495 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/jwt/jwt_credentials.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/jwt/jwt_credentials.cc
@@ -30,8 +30,8 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/lib/debug/trace.h"
@@ -113,7 +113,7 @@ grpc_service_account_jwt_access_credentials::
     : key_(key) {
   gpr_timespec max_token_lifetime = grpc_max_auth_token_lifetime();
   if (gpr_time_cmp(token_lifetime, max_token_lifetime) > 0) {
-    VLOG(2) << "Cropping token lifetime to maximum allowed value ("
+    ABSL_VLOG(2) << "Cropping token lifetime to maximum allowed value ("
             << max_token_lifetime.tv_sec << " secs).";
     token_lifetime = grpc_max_auth_token_lifetime();
   }
@@ -130,7 +130,7 @@ grpc_core::RefCountedPtr<grpc_call_credentials>
 grpc_service_account_jwt_access_credentials_create_from_auth_json_key(
     grpc_auth_json_key key, gpr_timespec token_lifetime) {
   if (!grpc_auth_json_key_is_valid(&key)) {
-    LOG(ERROR) << "Invalid input for jwt credentials creation";
+    ABSL_LOG(ERROR) << "Invalid input for jwt credentials creation";
     return nullptr;
   }
   return grpc_core::MakeRefCounted<grpc_service_account_jwt_access_credentials>(
@@ -153,7 +153,7 @@ grpc_call_credentials* grpc_service_account_jwt_access_credentials_create(
     const char* json_key, gpr_timespec token_lifetime, void* reserved) {
   if (GRPC_TRACE_FLAG_ENABLED(api)) {
     char* clean_json = redact_private_key(json_key);
-    VLOG(2) << "grpc_service_account_jwt_access_credentials_create("
+    ABSL_VLOG(2) << "grpc_service_account_jwt_access_credentials_create("
             << "json_key=" << clean_json
             << ", token_lifetime=gpr_timespec { tv_sec: "
             << token_lifetime.tv_sec << ", tv_nsec: " << token_lifetime.tv_nsec
@@ -161,7 +161,7 @@ grpc_call_credentials* grpc_service_account_jwt_access_credentials_create(
             << " }, reserved=" << reserved << ")";
     gpr_free(clean_json);
   }
-  CHECK_EQ(reserved, nullptr);
+  ABSL_CHECK_EQ(reserved, nullptr);
   grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;
   grpc_core::ExecCtx exec_ctx;
   return grpc_service_account_jwt_access_credentials_create_from_auth_json_key(
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/jwt/jwt_verifier.cc b/third_party/grpc/source/src/core/lib/security/credentials/jwt/jwt_verifier.cc
index 845a179b89001..f778b2a679732 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/jwt/jwt_verifier.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/jwt/jwt_verifier.cc
@@ -45,8 +45,8 @@
 #include <grpc/support/string_util.h>
 #include <grpc/support/time.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/escaping.h"
@@ -111,12 +111,12 @@ static const EVP_MD* evp_md_from_alg(const char* alg) {
 static Json parse_json_part_from_jwt(const char* str, size_t len) {
   std::string string;
   if (!absl::WebSafeBase64Unescape(absl::string_view(str, len), &string)) {
-    LOG(ERROR) << "Invalid base64.";
+    ABSL_LOG(ERROR) << "Invalid base64.";
     return Json();  // JSON null
   }
   auto json = grpc_core::JsonParse(string);
   if (!json.ok()) {
-    LOG(ERROR) << "JSON parse error: " << json.status();
+    ABSL_LOG(ERROR) << "JSON parse error: " << json.status();
     return Json();  // JSON null
   }
   return std::move(*json);
@@ -124,7 +124,7 @@ static Json parse_json_part_from_jwt(const char* str, size_t len) {

 static const char* validate_string_field(const Json& json, const char* key) {
   if (json.type() != Json::Type::kString) {
-    LOG(ERROR) << "Invalid " << key << " field";
+    ABSL_LOG(ERROR) << "Invalid " << key << " field";
     return nullptr;
   }
   return json.string().c_str();
@@ -133,7 +133,7 @@ static const char* validate_string_field(const Json& json, const char* key) {
 static gpr_timespec validate_time_field(const Json& json, const char* key) {
   gpr_timespec result = gpr_time_0(GPR_CLOCK_REALTIME);
   if (json.type() != Json::Type::kNumber) {
-    LOG(ERROR) << "Invalid " << key << " field";
+    ABSL_LOG(ERROR) << "Invalid " << key << " field";
     return result;
   }
   result.tv_sec = strtol(json.string().c_str(), nullptr, 10);
@@ -159,13 +159,13 @@ static jose_header* jose_header_from_json(Json json) {
   Json::Object::const_iterator it;
   jose_header* h = grpc_core::Zalloc<jose_header>();
   if (json.type() != Json::Type::kObject) {
-    LOG(ERROR) << "JSON value is not an object";
+    ABSL_LOG(ERROR) << "JSON value is not an object";
     goto error;
   }
   // Check alg field.
   it = json.object().find("alg");
   if (it == json.object().end()) {
-    LOG(ERROR) << "Missing alg field.";
+    ABSL_LOG(ERROR) << "Missing alg field.";
     goto error;
   }
   // We only support RSA-1.5 signatures for now.
@@ -176,7 +176,7 @@ static jose_header* jose_header_from_json(Json json) {
   if (it->second.type() != Json::Type::kString ||
       strncmp(alg_value, "RS", 2) != 0 ||
       evp_md_from_alg(alg_value) == nullptr) {
-    LOG(ERROR) << "Invalid alg field";
+    ABSL_LOG(ERROR) << "Invalid alg field";
     goto error;
   }
   h->alg = alg_value;
@@ -310,18 +310,18 @@ grpc_jwt_verifier_status grpc_jwt_claims_check(const grpc_jwt_claims* claims,
   gpr_timespec skewed_now;
   int audience_ok;

-  CHECK_NE(claims, nullptr);
+  ABSL_CHECK_NE(claims, nullptr);

   skewed_now =
       gpr_time_add(gpr_now(GPR_CLOCK_REALTIME), grpc_jwt_verifier_clock_skew);
   if (gpr_time_cmp(skewed_now, claims->nbf) < 0) {
-    LOG(ERROR) << "JWT is not valid yet.";
+    ABSL_LOG(ERROR) << "JWT is not valid yet.";
     return GRPC_JWT_VERIFIER_TIME_CONSTRAINT_FAILURE;
   }
   skewed_now =
       gpr_time_sub(gpr_now(GPR_CLOCK_REALTIME), grpc_jwt_verifier_clock_skew);
   if (gpr_time_cmp(skewed_now, claims->exp) > 0) {
-    LOG(ERROR) << "JWT is expired.";
+    ABSL_LOG(ERROR) << "JWT is expired.";
     return GRPC_JWT_VERIFIER_TIME_CONSTRAINT_FAILURE;
   }

@@ -330,7 +330,7 @@ grpc_jwt_verifier_status grpc_jwt_claims_check(const grpc_jwt_claims* claims,
   // issued.
   if (grpc_jwt_issuer_email_domain(claims->iss) != nullptr &&
       claims->sub != nullptr && strcmp(claims->iss, claims->sub) != 0) {
-    LOG(ERROR) << "Email issuer (" << claims->iss
+    ABSL_LOG(ERROR) << "Email issuer (" << claims->iss
                << ") cannot assert another subject (" << claims->sub
                << ") than itself.";
     return GRPC_JWT_VERIFIER_BAD_SUBJECT;
@@ -342,7 +342,7 @@ grpc_jwt_verifier_status grpc_jwt_claims_check(const grpc_jwt_claims* claims,
     audience_ok = claims->aud != nullptr && strcmp(audience, claims->aud) == 0;
   }
   if (!audience_ok) {
-    LOG(ERROR) << "Audience mismatch: expected "
+    ABSL_LOG(ERROR) << "Audience mismatch: expected "
                << (audience == nullptr ? "NULL" : audience) << " and found "
                << (claims->aud == nullptr ? "NULL" : claims->aud);
     return GRPC_JWT_VERIFIER_BAD_AUDIENCE;
@@ -426,17 +426,17 @@ struct grpc_jwt_verifier {

 static Json json_from_http(const grpc_http_response* response) {
   if (response == nullptr) {
-    LOG(ERROR) << "HTTP response is NULL.";
+    ABSL_LOG(ERROR) << "HTTP response is NULL.";
     return Json();  // JSON null
   }
   if (response->status != 200) {
-    LOG(ERROR) << "Call to http server failed with error " << response->status;
+    ABSL_LOG(ERROR) << "Call to http server failed with error " << response->status;
     return Json();  // JSON null
   }
   auto json = grpc_core::JsonParse(
       absl::string_view(response->body, response->body_length));
   if (!json.ok()) {
-    LOG(ERROR) << "Invalid JSON found in response.";
+    ABSL_LOG(ERROR) << "Invalid JSON found in response.";
     return Json();  // JSON null
   }
   return std::move(*json);
@@ -455,16 +455,16 @@ static EVP_PKEY* extract_pkey_from_x509(const char* x509_str) {
   EVP_PKEY* result = nullptr;
   BIO* bio = BIO_new(BIO_s_mem());
   size_t len = strlen(x509_str);
-  CHECK_LT(len, static_cast<size_t>(INT_MAX));
+  ABSL_CHECK_LT(len, static_cast<size_t>(INT_MAX));
   BIO_write(bio, x509_str, static_cast<int>(len));
   x509 = PEM_read_bio_X509(bio, nullptr, nullptr, nullptr);
   if (x509 == nullptr) {
-    LOG(ERROR) << "Unable to parse x509 cert.";
+    ABSL_LOG(ERROR) << "Unable to parse x509 cert.";
     goto end;
   }
   result = X509_get_pubkey(x509);
   if (result == nullptr) {
-    LOG(ERROR) << "Cannot find public key in X509 cert.";
+    ABSL_LOG(ERROR) << "Cannot find public key in X509 cert.";
   }

 end:
@@ -477,7 +477,7 @@ static BIGNUM* bignum_from_base64(const char* b64) {
   if (b64 == nullptr) return nullptr;
   std::string string;
   if (!absl::WebSafeBase64Unescape(b64, &string)) {
-    LOG(ERROR) << "Invalid base64 for big num.";
+    ABSL_LOG(ERROR) << "Invalid base64 for big num.";
     return nullptr;
   }
   return BN_bin2bn(reinterpret_cast<const uint8_t*>(string.data()),
@@ -526,36 +526,36 @@ static EVP_PKEY* pkey_from_jwk(const Json& json, const char* kty) {
   BIGNUM* tmp_e = nullptr;
   Json::Object::const_iterator it;

-  CHECK(json.type() == Json::Type::kObject);
-  CHECK_NE(kty, nullptr);
+  ABSL_CHECK(json.type() == Json::Type::kObject);
+  ABSL_CHECK_NE(kty, nullptr);
   if (strcmp(kty, "RSA") != 0) {
-    LOG(ERROR) << "Unsupported key type " << kty;
+    ABSL_LOG(ERROR) << "Unsupported key type " << kty;
     goto end;
   }
 #if OPENSSL_VERSION_NUMBER < 0x30000000L
   rsa = RSA_new();
   if (rsa == nullptr) {
-    LOG(ERROR) << "Could not create rsa key.";
+    ABSL_LOG(ERROR) << "Could not create rsa key.";
     goto end;
   }
 #endif
   it = json.object().find("n");
   if (it == json.object().end()) {
-    LOG(ERROR) << "Missing RSA public key field.";
+    ABSL_LOG(ERROR) << "Missing RSA public key field.";
     goto end;
   }
   tmp_n = bignum_from_base64(validate_string_field(it->second, "n"));
   if (tmp_n == nullptr) goto end;
   it = json.object().find("e");
   if (it == json.object().end()) {
-    LOG(ERROR) << "Missing RSA public key field.";
+    ABSL_LOG(ERROR) << "Missing RSA public key field.";
     goto end;
   }
   tmp_e = bignum_from_base64(validate_string_field(it->second, "e"));
   if (tmp_e == nullptr) goto end;
 #if OPENSSL_VERSION_NUMBER < 0x30000000L
   if (!RSA_set0_key(rsa, tmp_n, tmp_e, nullptr)) {
-    LOG(ERROR) << "Cannot set RSA key from inputs.";
+    ABSL_LOG(ERROR) << "Cannot set RSA key from inputs.";
     goto end;
   }
   // RSA_set0_key takes ownership on success.
@@ -568,21 +568,21 @@ static EVP_PKEY* pkey_from_jwk(const Json& json, const char* kty) {
   if (!OSSL_PARAM_BLD_push_BN(bld, "n", tmp_n) ||
       !OSSL_PARAM_BLD_push_BN(bld, "e", tmp_e) ||
       (params = OSSL_PARAM_BLD_to_param(bld)) == NULL) {
-    LOG(ERROR) << "Could not create OSSL_PARAM";
+    ABSL_LOG(ERROR) << "Could not create OSSL_PARAM";
     goto end;
   }

   ctx = EVP_PKEY_CTX_new_from_name(nullptr, "RSA", nullptr);
   if (ctx == nullptr) {
-    LOG(ERROR) << "Could not create rsa key.";
+    ABSL_LOG(ERROR) << "Could not create rsa key.";
     goto end;
   }
   if (EVP_PKEY_fromdata_init(ctx) <= 0) {
-    LOG(ERROR) << "Could not create rsa key.";
+    ABSL_LOG(ERROR) << "Could not create rsa key.";
     goto end;
   }
   if (EVP_PKEY_fromdata(ctx, &result, EVP_PKEY_KEYPAIR, params) <= 0) {
-    LOG(ERROR) << "Cannot set RSA key from inputs.";
+    ABSL_LOG(ERROR) << "Cannot set RSA key from inputs.";
     goto end;
   }
 #endif
@@ -613,7 +613,7 @@ static EVP_PKEY* find_verification_key(const Json& json, const char* header_alg,
     return extract_pkey_from_x509(cur->string().c_str());
   }
   if (jwt_keys->type() != Json::Type::kArray) {
-    LOG(ERROR) << "Unexpected value type of keys property in jwks key set.";
+    ABSL_LOG(ERROR) << "Unexpected value type of keys property in jwks key set.";
     return nullptr;
   }
   // Key format is specified in:
@@ -640,7 +640,7 @@ static EVP_PKEY* find_verification_key(const Json& json, const char* header_alg,
       return pkey_from_jwk(jkey, kty);
     }
   }
-  LOG(ERROR) << "Could not find matching key in key set for kid=" << header_kid
+  ABSL_LOG(ERROR) << "Could not find matching key in key set for kid=" << header_kid
              << " and alg=" << header_alg;
   return nullptr;
 }
@@ -652,23 +652,23 @@ static int verify_jwt_signature(EVP_PKEY* key, const char* alg,
   const EVP_MD* md = evp_md_from_alg(alg);
   int result = 0;

-  CHECK_NE(md, nullptr);  // Checked before.
+  ABSL_CHECK_NE(md, nullptr);  // Checked before.
   if (md_ctx == nullptr) {
-    LOG(ERROR) << "Could not create EVP_MD_CTX.";
+    ABSL_LOG(ERROR) << "Could not create EVP_MD_CTX.";
     goto end;
   }
   if (EVP_DigestVerifyInit(md_ctx, nullptr, md, nullptr, key) != 1) {
-    LOG(ERROR) << "EVP_DigestVerifyInit failed.";
+    ABSL_LOG(ERROR) << "EVP_DigestVerifyInit failed.";
     goto end;
   }
   if (EVP_DigestVerifyUpdate(md_ctx, GRPC_SLICE_START_PTR(signed_data),
                              GRPC_SLICE_LENGTH(signed_data)) != 1) {
-    LOG(ERROR) << "EVP_DigestVerifyUpdate failed.";
+    ABSL_LOG(ERROR) << "EVP_DigestVerifyUpdate failed.";
     goto end;
   }
   if (EVP_DigestVerifyFinal(md_ctx, GRPC_SLICE_START_PTR(signature),
                             GRPC_SLICE_LENGTH(signature)) != 1) {
-    LOG(ERROR) << "JWT signature verification failed.";
+    ABSL_LOG(ERROR) << "JWT signature verification failed.";

     goto end;
   }
@@ -693,7 +693,7 @@ static void on_keys_retrieved(void* user_data, grpc_error_handle /*error*/) {
   verification_key =
       find_verification_key(json, ctx->header->alg, ctx->header->kid);
   if (verification_key == nullptr) {
-    LOG(ERROR) << "Could not find verification key with kid "
+    ABSL_LOG(ERROR) << "Could not find verification key with kid "
                << ctx->header->kid;
     status = GRPC_JWT_VERIFIER_KEY_RETRIEVAL_ERROR;
     goto end;
@@ -735,13 +735,13 @@ static void on_openid_config_retrieved(void* user_data,
   if (json.type() == Json::Type::kNull) goto error;
   cur = find_property_by_name(json, "jwks_uri");
   if (cur == nullptr) {
-    LOG(ERROR) << "Could not find jwks_uri in openid config.";
+    ABSL_LOG(ERROR) << "Could not find jwks_uri in openid config.";
     goto error;
   }
   jwks_uri = validate_string_field(*cur, "jwks_uri");
   if (jwks_uri == nullptr) goto error;
   if (strstr(jwks_uri, "https://") != jwks_uri) {
-    LOG(ERROR) << "Invalid non https jwks_uri: " << jwks_uri;
+    ABSL_LOG(ERROR) << "Invalid non https jwks_uri: " << jwks_uri;
     goto error;
   }
   jwks_uri += 8;
@@ -791,7 +791,7 @@ static email_key_mapping* verifier_get_mapping(grpc_jwt_verifier* v,
 static void verifier_put_mapping(grpc_jwt_verifier* v, const char* email_domain,
                                  const char* key_url_prefix) {
   email_key_mapping* mapping = verifier_get_mapping(v, email_domain);
-  CHECK(v->num_mappings < v->allocated_mappings);
+  ABSL_CHECK(v->num_mappings < v->allocated_mappings);
   if (mapping != nullptr) {
     gpr_free(mapping->key_url_prefix);
     mapping->key_url_prefix = gpr_strdup(key_url_prefix);
@@ -800,7 +800,7 @@ static void verifier_put_mapping(grpc_jwt_verifier* v, const char* email_domain,
   v->mappings[v->num_mappings].email_domain = gpr_strdup(email_domain);
   v->mappings[v->num_mappings].key_url_prefix = gpr_strdup(key_url_prefix);
   v->num_mappings++;
-  CHECK(v->num_mappings <= v->allocated_mappings);
+  ABSL_CHECK(v->num_mappings <= v->allocated_mappings);
 }

 // Very non-sophisticated way to detect an email address. Should be good
@@ -812,7 +812,7 @@ const char* grpc_jwt_issuer_email_domain(const char* issuer) {
   if (*email_domain == '\0') return nullptr;
   const char* dot = strrchr(email_domain, '.');
   if (dot == nullptr || dot == email_domain) return email_domain;
-  CHECK(dot > email_domain);
+  ABSL_CHECK(dot > email_domain);
   // There may be a subdomain, we just want the domain.
   dot = static_cast<const char*>(
       gpr_memrchr(email_domain, '.', static_cast<size_t>(dot - email_domain)));
@@ -833,14 +833,14 @@ static void retrieve_key_and_verify(verifier_cb_ctx* ctx) {
   char* path;
   absl::StatusOr<grpc_core::URI> uri;

-  CHECK(ctx != nullptr && ctx->header != nullptr && ctx->claims != nullptr);
+  ABSL_CHECK(ctx != nullptr && ctx->header != nullptr && ctx->claims != nullptr);
   iss = ctx->claims->iss;
   if (ctx->header->kid == nullptr) {
-    LOG(ERROR) << "Missing kid in jose header.";
+    ABSL_LOG(ERROR) << "Missing kid in jose header.";
     goto error;
   }
   if (iss == nullptr) {
-    LOG(ERROR) << "Missing iss in claims.";
+    ABSL_LOG(ERROR) << "Missing iss in claims.";
     goto error;
   }

@@ -852,10 +852,10 @@ static void retrieve_key_and_verify(verifier_cb_ctx* ctx) {
   email_domain = grpc_jwt_issuer_email_domain(iss);
   if (email_domain != nullptr) {
     email_key_mapping* mapping;
-    CHECK_NE(ctx->verifier, nullptr);
+    ABSL_CHECK_NE(ctx->verifier, nullptr);
     mapping = verifier_get_mapping(ctx->verifier, email_domain);
     if (mapping == nullptr) {
-      LOG(ERROR) << "Missing mapping for issuer email.";
+      ABSL_LOG(ERROR) << "Missing mapping for issuer email.";
       goto error;
     }
     host = gpr_strdup(mapping->key_url_prefix);
@@ -919,7 +919,7 @@ void grpc_jwt_verifier_verify(grpc_jwt_verifier* verifier,
   Json json;
   std::string signature_str;

-  CHECK(verifier != nullptr && jwt != nullptr && audience != nullptr &&
+  ABSL_CHECK(verifier != nullptr && jwt != nullptr && audience != nullptr &&
         cb != nullptr);
   dot = strchr(cur, '.');
   if (dot == nullptr) goto error;
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/oauth2/oauth2_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/oauth2/oauth2_credentials.cc
index 7414b25cdd58d..8bc3906d97343 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/oauth2/oauth2_credentials.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/oauth2/oauth2_credentials.cc
@@ -35,8 +35,8 @@
 #include <memory>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/numbers.h"
 #include "absl/strings/str_cat.h"
@@ -83,7 +83,7 @@ grpc_auth_refresh_token grpc_auth_refresh_token_create_from_json(
   memset(&result, 0, sizeof(grpc_auth_refresh_token));
   result.type = GRPC_AUTH_JSON_TYPE_INVALID;
   if (json.type() != Json::Type::kObject) {
-    LOG(ERROR) << "Invalid json.";
+    ABSL_LOG(ERROR) << "Invalid json.";
     goto end;
   }

@@ -114,7 +114,7 @@ grpc_auth_refresh_token grpc_auth_refresh_token_create_from_string(
   Json json;
   auto json_or = grpc_core::JsonParse(json_string);
   if (!json_or.ok()) {
-    LOG(ERROR) << "JSON parsing failed: " << json_or.status();
+    ABSL_LOG(ERROR) << "JSON parsing failed: " << json_or.status();
   } else {
     json = std::move(*json_or);
   }
@@ -148,34 +148,34 @@ grpc_oauth2_token_fetcher_credentials_parse_server_response_body(
     grpc_core::Duration* token_lifetime) {
   auto json = grpc_core::JsonParse(body);
   if (!json.ok()) {
-    LOG(ERROR) << "Could not parse JSON from " << body << ": " << json.status();
+    ABSL_LOG(ERROR) << "Could not parse JSON from " << body << ": " << json.status();
     return GRPC_CREDENTIALS_ERROR;
   }
   if (json->type() != Json::Type::kObject) {
-    LOG(ERROR) << "Response should be a JSON object";
+    ABSL_LOG(ERROR) << "Response should be a JSON object";
     return GRPC_CREDENTIALS_ERROR;
   }
   auto it = json->object().find("access_token");
   if (it == json->object().end() || it->second.type() != Json::Type::kString) {
-    LOG(ERROR) << "Missing or invalid access_token in JSON.";
+    ABSL_LOG(ERROR) << "Missing or invalid access_token in JSON.";
     return GRPC_CREDENTIALS_ERROR;
   }
   absl::string_view access_token = it->second.string();
   it = json->object().find("token_type");
   if (it == json->object().end() || it->second.type() != Json::Type::kString) {
-    LOG(ERROR) << "Missing or invalid token_type in JSON.";
+    ABSL_LOG(ERROR) << "Missing or invalid token_type in JSON.";
     return GRPC_CREDENTIALS_ERROR;
   }
   absl::string_view token_type = it->second.string();
   it = json->object().find("expires_in");
   if (it == json->object().end() || it->second.type() != Json::Type::kNumber) {
-    LOG(ERROR) << "Missing or invalid expires_in in JSON.";
+    ABSL_LOG(ERROR) << "Missing or invalid expires_in in JSON.";
     return GRPC_CREDENTIALS_ERROR;
   }
   absl::string_view expires_in = it->second.string();
   long seconds;
   if (!absl::SimpleAtoi(expires_in, &seconds)) {
-    LOG(ERROR) << "Invalid expires_in in JSON.";
+    ABSL_LOG(ERROR) << "Invalid expires_in in JSON.";
     return GRPC_CREDENTIALS_ERROR;
   }
   *token_lifetime = grpc_core::Duration::Seconds(seconds);
@@ -191,12 +191,12 @@ grpc_oauth2_token_fetcher_credentials_parse_server_response(
     grpc_core::Duration* token_lifetime) {
   *token_value = std::nullopt;
   if (response == nullptr) {
-    LOG(ERROR) << "Received NULL response.";
+    ABSL_LOG(ERROR) << "Received NULL response.";
     return GRPC_CREDENTIALS_ERROR;
   }
   absl::string_view body(response->body, response->body_length);
   if (response->status != 200) {
-    LOG(ERROR) << "Call to http server ended with error " << response->status
+    ABSL_LOG(ERROR) << "Call to http server ended with error " << response->status
                << " [" << body << "]";
     return GRPC_CREDENTIALS_ERROR;
   }
@@ -316,7 +316,7 @@ class grpc_compute_engine_token_fetcher_credentials
     auto uri = grpc_core::URI::Create("http", GRPC_COMPUTE_ENGINE_METADATA_HOST,
                                       GRPC_COMPUTE_ENGINE_METADATA_TOKEN_PATH,
                                       {} /* query params */, "" /* fragment */);
-    CHECK(uri.ok());  // params are hardcoded
+    ABSL_CHECK(uri.ok());  // params are hardcoded
     auto http_request = grpc_core::HttpRequest::Get(
         std::move(*uri), /*args=*/nullptr, pollent, &request, deadline,
         on_complete, response,
@@ -333,7 +333,7 @@ grpc_call_credentials* grpc_google_compute_engine_credentials_create(
     void* reserved) {
   GRPC_TRACE_LOG(api, INFO)
       << "grpc_compute_engine_credentials_create(reserved=" << reserved << ")";
-  CHECK_EQ(reserved, nullptr);
+  ABSL_CHECK_EQ(reserved, nullptr);
   return grpc_core::MakeRefCounted<
              grpc_compute_engine_token_fetcher_credentials>()
       .release();
@@ -374,7 +374,7 @@ grpc_google_refresh_token_credentials::StartHttpRequest(
   auto uri = grpc_core::URI::Create("https", GRPC_GOOGLE_OAUTH2_SERVICE_HOST,
                                     GRPC_GOOGLE_OAUTH2_SERVICE_TOKEN_PATH,
                                     {} /* query params */, "" /* fragment */);
-  CHECK(uri.ok());  // params are hardcoded
+  ABSL_CHECK(uri.ok());  // params are hardcoded
   auto http_request = grpc_core::HttpRequest::Post(
       std::move(*uri), /*args=*/nullptr, pollent, &request, deadline,
       on_complete, response, grpc_core::CreateHttpRequestSSLCredentials());
@@ -386,7 +386,7 @@ grpc_core::RefCountedPtr<grpc_call_credentials>
 grpc_refresh_token_credentials_create_from_auth_refresh_token(
     grpc_auth_refresh_token refresh_token) {
   if (!grpc_auth_refresh_token_is_valid(&refresh_token)) {
-    LOG(ERROR) << "Invalid input for refresh token credentials creation";
+    ABSL_LOG(ERROR) << "Invalid input for refresh token credentials creation";
     return nullptr;
   }
   return grpc_core::MakeRefCounted<grpc_google_refresh_token_credentials>(
@@ -423,7 +423,7 @@ grpc_call_credentials* grpc_google_refresh_token_credentials_create(
       << "grpc_refresh_token_credentials_create(json_refresh_token="
       << create_loggable_refresh_token(&token) << ", reserved=" << reserved
       << ")";
-  CHECK_EQ(reserved, nullptr);
+  ABSL_CHECK_EQ(reserved, nullptr);
   return grpc_refresh_token_credentials_create_from_auth_refresh_token(token)
       .release();
 }
@@ -446,7 +446,7 @@ grpc_error_handle LoadTokenFile(const char* path, grpc_slice* token) {
   auto slice = LoadFile(path, /*add_null_terminator=*/true);
   if (!slice.ok()) return slice.status();
   if (slice->empty()) {
-    LOG(ERROR) << "Token file " << path << " is empty";
+    ABSL_LOG(ERROR) << "Token file " << path << " is empty";
     return GRPC_ERROR_CREATE("Token file is empty.");
   }
   *token = slice->TakeCSlice();
@@ -601,11 +601,11 @@ absl::StatusOr<URI> ValidateStsCredentialsOptions(

 grpc_call_credentials* grpc_sts_credentials_create(
     const grpc_sts_credentials_options* options, void* reserved) {
-  CHECK_EQ(reserved, nullptr);
+  ABSL_CHECK_EQ(reserved, nullptr);
   absl::StatusOr<grpc_core::URI> sts_url =
       grpc_core::ValidateStsCredentialsOptions(options);
   if (!sts_url.ok()) {
-    LOG(ERROR) << "STS Credentials creation failed. Error: "
+    ABSL_LOG(ERROR) << "STS Credentials creation failed. Error: "
                << sts_url.status();
     return nullptr;
   }
@@ -647,7 +647,7 @@ grpc_call_credentials* grpc_access_token_credentials_create(
   GRPC_TRACE_LOG(api, INFO) << "grpc_access_token_credentials_create(access_"
                                "token=<redacted>, reserved="
                             << reserved << ")";
-  CHECK_EQ(reserved, nullptr);
+  ABSL_CHECK_EQ(reserved, nullptr);
   return grpc_core::MakeRefCounted<grpc_access_token_credentials>(access_token)
       .release();
 }
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/plugin/plugin_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/plugin/plugin_credentials.cc
index 1e0bae22f94f9..53d68ea02cdc5 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/plugin/plugin_credentials.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/plugin/plugin_credentials.cc
@@ -24,8 +24,8 @@
 #include <atomic>
 #include <memory>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
@@ -79,7 +79,7 @@ grpc_plugin_credentials::PendingRequest::ProcessPluginResult(
                  !GRPC_LOG_IF_ERROR(
                      "validate_metadata_from_plugin",
                      grpc_validate_header_nonbin_value_is_legal(md[i].value))) {
-        LOG(ERROR) << "Plugin added invalid metadata value.";
+        ABSL_LOG(ERROR) << "Plugin added invalid metadata value.";
         seen_illegal_header = true;
         break;
       }
@@ -197,6 +197,6 @@ grpc_call_credentials* grpc_metadata_credentials_create_from_plugin(
   GRPC_TRACE_LOG(api, INFO)
       << "grpc_metadata_credentials_create_from_plugin(reserved=" << reserved
       << ")";
-  CHECK_EQ(reserved, nullptr);
+  ABSL_CHECK_EQ(reserved, nullptr);
   return new grpc_plugin_credentials(plugin, min_security_level);
 }
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/ssl/ssl_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/ssl/ssl_credentials.cc
index 7747f4a5476be..3952644786b13 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/ssl/ssl_credentials.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/ssl/ssl_credentials.cc
@@ -28,8 +28,8 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/channel/channel_args.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/lib/security/security_connector/ssl_utils.h"
@@ -51,7 +51,7 @@ grpc_ssl_credentials::grpc_ssl_credentials(
     const char* pem_root_certs =
         grpc_core::DefaultSslRootStore::GetPemRootCerts();
     if (pem_root_certs == nullptr) {
-      LOG(ERROR) << "Could not get default pem root certs.";
+      ABSL_LOG(ERROR) << "Could not get default pem root certs.";
     } else {
       char* default_roots = gpr_strdup(pem_root_certs);
       config_.pem_root_certs = default_roots;
@@ -82,7 +82,7 @@ grpc_ssl_credentials::create_security_connector(
     grpc_core::RefCountedPtr<grpc_call_credentials> call_creds,
     const char* target, grpc_core::ChannelArgs* args) {
   if (config_.pem_root_certs == nullptr) {
-    LOG(ERROR) << "No root certs in config. Client-side security connector "
+    ABSL_LOG(ERROR) << "No root certs in config. Client-side security connector "
                   "must have root certs.";
     return nullptr;
   }
@@ -107,7 +107,7 @@ grpc_ssl_credentials::create_security_connector(
         &config_, config_.pem_root_certs, root_store_, session_cache,
         &factory_with_cache);
     if (status != GRPC_SECURITY_OK) {
-      LOG(ERROR) << "InitializeClientHandshakerFactory returned bad status.";
+      ABSL_LOG(ERROR) << "InitializeClientHandshakerFactory returned bad status.";
       return nullptr;
     }
     security_connector = grpc_ssl_channel_security_connector_create(
@@ -144,8 +144,8 @@ void grpc_ssl_credentials::build_config(
     const grpc_ssl_verify_peer_options* verify_options) {
   config_.pem_root_certs = gpr_strdup(pem_root_certs);
   if (pem_key_cert_pair != nullptr) {
-    CHECK_NE(pem_key_cert_pair->private_key, nullptr);
-    CHECK_NE(pem_key_cert_pair->cert_chain, nullptr);
+    ABSL_CHECK_NE(pem_key_cert_pair->private_key, nullptr);
+    ABSL_CHECK_NE(pem_key_cert_pair->cert_chain, nullptr);
     config_.pem_key_cert_pair = static_cast<tsi_ssl_pem_key_cert_pair*>(
         gpr_zalloc(sizeof(tsi_ssl_pem_key_cert_pair)));
     config_.pem_key_cert_pair->cert_chain =
@@ -190,7 +190,7 @@ grpc_security_status grpc_ssl_credentials::InitializeClientHandshakerFactory(
                            config->pem_key_cert_pair->cert_chain != nullptr;
   tsi_ssl_client_handshaker_options options;
   if (pem_root_certs == nullptr) {
-    LOG(ERROR) << "Handshaker factory creation failed. pem_root_certs cannot "
+    ABSL_LOG(ERROR) << "Handshaker factory creation failed. pem_root_certs cannot "
                   "be nullptr";
     return GRPC_SECURITY_ERROR;
   }
@@ -210,7 +210,7 @@ grpc_security_status grpc_ssl_credentials::InitializeClientHandshakerFactory(
                                                             handshaker_factory);
   gpr_free(options.alpn_protocols);
   if (result != TSI_OK) {
-    LOG(ERROR) << "Handshaker factory creation failed with "
+    ABSL_LOG(ERROR) << "Handshaker factory creation failed with "
                << tsi_result_to_string(result);
     return GRPC_SECURITY_ERROR;
   }
@@ -227,7 +227,7 @@ grpc_channel_credentials* grpc_ssl_credentials_create(
       << ", pem_key_cert_pair=" << pem_key_cert_pair
       << ", verify_options=" << verify_options << ", reserved=" << reserved
       << ")";
-  CHECK_EQ(reserved, nullptr);
+  ABSL_CHECK_EQ(reserved, nullptr);

   return new grpc_ssl_credentials(
       pem_root_certs, pem_key_cert_pair,
@@ -242,7 +242,7 @@ grpc_channel_credentials* grpc_ssl_credentials_create_ex(
       << ", pem_key_cert_pair=" << pem_key_cert_pair
       << ", verify_options=" << verify_options << ", reserved=" << reserved
       << ")";
-  CHECK_EQ(reserved, nullptr);
+  ABSL_CHECK_EQ(reserved, nullptr);

   return new grpc_ssl_credentials(pem_root_certs, pem_key_cert_pair,
                                   verify_options);
@@ -292,13 +292,13 @@ tsi_ssl_pem_key_cert_pair* grpc_convert_grpc_to_tsi_cert_pairs(
     size_t num_key_cert_pairs) {
   tsi_ssl_pem_key_cert_pair* tsi_pairs = nullptr;
   if (num_key_cert_pairs > 0) {
-    CHECK_NE(pem_key_cert_pairs, nullptr);
+    ABSL_CHECK_NE(pem_key_cert_pairs, nullptr);
     tsi_pairs = static_cast<tsi_ssl_pem_key_cert_pair*>(
         gpr_zalloc(num_key_cert_pairs * sizeof(tsi_ssl_pem_key_cert_pair)));
   }
   for (size_t i = 0; i < num_key_cert_pairs; i++) {
-    CHECK_NE(pem_key_cert_pairs[i].private_key, nullptr);
-    CHECK_NE(pem_key_cert_pairs[i].cert_chain, nullptr);
+    ABSL_CHECK_NE(pem_key_cert_pairs[i].private_key, nullptr);
+    ABSL_CHECK_NE(pem_key_cert_pairs[i].cert_chain, nullptr);
     tsi_pairs[i].cert_chain = gpr_strdup(pem_key_cert_pairs[i].cert_chain);
     tsi_pairs[i].private_key = gpr_strdup(pem_key_cert_pairs[i].private_key);
   }
@@ -335,14 +335,14 @@ grpc_ssl_server_certificate_config* grpc_ssl_server_certificate_config_create(
           gpr_zalloc(sizeof(grpc_ssl_server_certificate_config)));
   config->pem_root_certs = gpr_strdup(pem_root_certs);
   if (num_key_cert_pairs > 0) {
-    CHECK_NE(pem_key_cert_pairs, nullptr);
+    ABSL_CHECK_NE(pem_key_cert_pairs, nullptr);
     config->pem_key_cert_pairs = static_cast<grpc_ssl_pem_key_cert_pair*>(
         gpr_zalloc(num_key_cert_pairs * sizeof(grpc_ssl_pem_key_cert_pair)));
   }
   config->num_key_cert_pairs = num_key_cert_pairs;
   for (size_t i = 0; i < num_key_cert_pairs; i++) {
-    CHECK_NE(pem_key_cert_pairs[i].private_key, nullptr);
-    CHECK_NE(pem_key_cert_pairs[i].cert_chain, nullptr);
+    ABSL_CHECK_NE(pem_key_cert_pairs[i].private_key, nullptr);
+    ABSL_CHECK_NE(pem_key_cert_pairs[i].cert_chain, nullptr);
     config->pem_key_cert_pairs[i].cert_chain =
         gpr_strdup(pem_key_cert_pairs[i].cert_chain);
     config->pem_key_cert_pairs[i].private_key =
@@ -369,7 +369,7 @@ grpc_ssl_server_credentials_create_options_using_config(
     grpc_ssl_server_certificate_config* config) {
   grpc_ssl_server_credentials_options* options = nullptr;
   if (config == nullptr) {
-    LOG(ERROR) << "Certificate config must not be NULL.";
+    ABSL_LOG(ERROR) << "Certificate config must not be NULL.";
     goto done;
   }
   options = static_cast<grpc_ssl_server_credentials_options*>(
@@ -385,7 +385,7 @@ grpc_ssl_server_credentials_create_options_using_config_fetcher(
     grpc_ssl_client_certificate_request_type client_certificate_request,
     grpc_ssl_server_certificate_config_callback cb, void* user_data) {
   if (cb == nullptr) {
-    LOG(ERROR) << "Invalid certificate config callback parameter.";
+    ABSL_LOG(ERROR) << "Invalid certificate config callback parameter.";
     return nullptr;
   }

@@ -426,7 +426,7 @@ grpc_server_credentials* grpc_ssl_server_credentials_create_ex(
       << ", num_key_cert_pairs=" << (unsigned long)num_key_cert_pairs
       << ", client_certificate_request=" << client_certificate_request
       << ", reserved=" << reserved << ")";
-  CHECK_EQ(reserved, nullptr);
+  ABSL_CHECK_EQ(reserved, nullptr);

   grpc_ssl_server_certificate_config* cert_config =
       grpc_ssl_server_certificate_config_create(
@@ -443,18 +443,18 @@ grpc_server_credentials* grpc_ssl_server_credentials_create_with_options(
   grpc_server_credentials* retval = nullptr;

   if (options == nullptr) {
-    LOG(ERROR) << "Invalid options trying to create SSL server credentials.";
+    ABSL_LOG(ERROR) << "Invalid options trying to create SSL server credentials.";
     goto done;
   }

   if (options->certificate_config == nullptr &&
       options->certificate_config_fetcher == nullptr) {
-    LOG(ERROR) << "SSL server credentials options must specify either "
+    ABSL_LOG(ERROR) << "SSL server credentials options must specify either "
                   "certificate config or fetcher.";
     goto done;
   } else if (options->certificate_config_fetcher != nullptr &&
              options->certificate_config_fetcher->cb == nullptr) {
-    LOG(ERROR) << "Certificate config fetcher callback must not be NULL.";
+    ABSL_LOG(ERROR) << "Certificate config fetcher callback must not be NULL.";
     goto done;
   }

diff --git a/third_party/grpc/source/src/core/lib/security/credentials/ssl/ssl_credentials.h b/third_party/grpc/source/src/core/lib/security/credentials/ssl/ssl_credentials.h
index d0f947a537c2a..f6a5ba8f5c4a0 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/ssl/ssl_credentials.h
+++ b/third_party/grpc/source/src/core/lib/security/credentials/ssl/ssl_credentials.h
@@ -25,7 +25,7 @@
 #include <grpc/support/port_platform.h>
 #include <stddef.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/channel/channel_args.h"
 #include "src/core/lib/security/credentials/credentials.h"
 #include "src/core/lib/security/security_connector/security_connector.h"
@@ -115,7 +115,7 @@ class grpc_ssl_server_credentials final : public grpc_server_credentials {

   grpc_ssl_certificate_config_reload_status FetchCertConfig(
       grpc_ssl_server_certificate_config** config) {
-    DCHECK(has_cert_config_fetcher());
+    ABSL_DCHECK(has_cert_config_fetcher());
     return certificate_config_fetcher_.cb(certificate_config_fetcher_.user_data,
                                           config);
   }
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_distributor.cc b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_distributor.cc
index 2b3cc4c36a84e..9b0a11610177a 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_distributor.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_distributor.cc
@@ -20,23 +20,23 @@
 #include <grpc/grpc_security.h>
 #include <grpc/support/port_platform.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"

 void grpc_tls_certificate_distributor::SetKeyMaterials(
     const std::string& cert_name, std::optional<std::string> pem_root_certs,
     std::optional<grpc_core::PemKeyCertPairList> pem_key_cert_pairs) {
-  CHECK(pem_root_certs.has_value() || pem_key_cert_pairs.has_value());
+  ABSL_CHECK(pem_root_certs.has_value() || pem_key_cert_pairs.has_value());
   grpc_core::MutexLock lock(&mu_);
   auto& cert_info = certificate_info_map_[cert_name];
   if (pem_root_certs.has_value()) {
     // Successful credential updates will clear any pre-existing error.
     cert_info.SetRootError(absl::OkStatus());
     for (auto* watcher_ptr : cert_info.root_cert_watchers) {
-      CHECK_NE(watcher_ptr, nullptr);
+      ABSL_CHECK_NE(watcher_ptr, nullptr);
       const auto watcher_it = watchers_.find(watcher_ptr);
-      CHECK(watcher_it != watchers_.end());
-      CHECK(watcher_it->second.root_cert_name.has_value());
+      ABSL_CHECK(watcher_it != watchers_.end());
+      ABSL_CHECK(watcher_it->second.root_cert_name.has_value());
       std::optional<grpc_core::PemKeyCertPairList> pem_key_cert_pairs_to_report;
       if (pem_key_cert_pairs.has_value() &&
           watcher_it->second.identity_cert_name == cert_name) {
@@ -57,10 +57,10 @@ void grpc_tls_certificate_distributor::SetKeyMaterials(
     // Successful credential updates will clear any pre-existing error.
     cert_info.SetIdentityError(absl::OkStatus());
     for (const auto watcher_ptr : cert_info.identity_cert_watchers) {
-      CHECK_NE(watcher_ptr, nullptr);
+      ABSL_CHECK_NE(watcher_ptr, nullptr);
       const auto watcher_it = watchers_.find(watcher_ptr);
-      CHECK(watcher_it != watchers_.end());
-      CHECK(watcher_it->second.identity_cert_name.has_value());
+      ABSL_CHECK(watcher_it != watchers_.end());
+      ABSL_CHECK(watcher_it->second.identity_cert_name.has_value());
       std::optional<absl::string_view> pem_root_certs_to_report;
       if (pem_root_certs.has_value() &&
           watcher_it->second.root_cert_name == cert_name) {
@@ -101,14 +101,14 @@ void grpc_tls_certificate_distributor::SetErrorForCert(
     const std::string& cert_name,
     std::optional<grpc_error_handle> root_cert_error,
     std::optional<grpc_error_handle> identity_cert_error) {
-  CHECK(root_cert_error.has_value() || identity_cert_error.has_value());
+  ABSL_CHECK(root_cert_error.has_value() || identity_cert_error.has_value());
   grpc_core::MutexLock lock(&mu_);
   CertificateInfo& cert_info = certificate_info_map_[cert_name];
   if (root_cert_error.has_value()) {
     for (auto* watcher_ptr : cert_info.root_cert_watchers) {
-      CHECK_NE(watcher_ptr, nullptr);
+      ABSL_CHECK_NE(watcher_ptr, nullptr);
       const auto watcher_it = watchers_.find(watcher_ptr);
-      CHECK(watcher_it != watchers_.end());
+      ABSL_CHECK(watcher_it != watchers_.end());
       // identity_cert_error_to_report is the error of the identity cert this
       // watcher is watching, if there is any.
       grpc_error_handle identity_cert_error_to_report;
@@ -126,9 +126,9 @@ void grpc_tls_certificate_distributor::SetErrorForCert(
   }
   if (identity_cert_error.has_value()) {
     for (auto* watcher_ptr : cert_info.identity_cert_watchers) {
-      CHECK_NE(watcher_ptr, nullptr);
+      ABSL_CHECK_NE(watcher_ptr, nullptr);
       const auto watcher_it = watchers_.find(watcher_ptr);
-      CHECK(watcher_it != watchers_.end());
+      ABSL_CHECK(watcher_it != watchers_.end());
       // root_cert_error_to_report is the error of the root cert this watcher is
       // watching, if there is any.
       grpc_error_handle root_cert_error_to_report;
@@ -149,11 +149,11 @@ void grpc_tls_certificate_distributor::SetErrorForCert(
 };

 void grpc_tls_certificate_distributor::SetError(grpc_error_handle error) {
-  CHECK(!error.ok());
+  ABSL_CHECK(!error.ok());
   grpc_core::MutexLock lock(&mu_);
   for (const auto& watcher : watchers_) {
     const auto watcher_ptr = watcher.first;
-    CHECK_NE(watcher_ptr, nullptr);
+    ABSL_CHECK_NE(watcher_ptr, nullptr);
     const auto& watcher_info = watcher.second;
     watcher_ptr->OnError(
         watcher_info.root_cert_name.has_value() ? error : absl::OkStatus(),
@@ -174,16 +174,16 @@ void grpc_tls_certificate_distributor::WatchTlsCertificates(
   bool already_watching_identity_for_root_cert = false;
   bool start_watching_identity_cert = false;
   bool already_watching_root_for_identity_cert = false;
-  CHECK(root_cert_name.has_value() || identity_cert_name.has_value());
+  ABSL_CHECK(root_cert_name.has_value() || identity_cert_name.has_value());
   TlsCertificatesWatcherInterface* watcher_ptr = watcher.get();
-  CHECK_NE(watcher_ptr, nullptr);
+  ABSL_CHECK_NE(watcher_ptr, nullptr);
   // Update watchers_ and certificate_info_map_.
   {
     grpc_core::MutexLock lock(&mu_);
     const auto watcher_it = watchers_.find(watcher_ptr);
     // The caller needs to cancel the watcher first if it wants to re-register
     // the watcher.
-    CHECK(watcher_it == watchers_.end());
+    ABSL_CHECK(watcher_it == watchers_.end());
     watchers_[watcher_ptr] = {std::move(watcher), root_cert_name,
                               identity_cert_name};
     std::optional<absl::string_view> updated_root_certs;
@@ -269,7 +269,7 @@ void grpc_tls_certificate_distributor::CancelTlsCertificatesWatch(
     watchers_.erase(it);
     if (root_cert_name.has_value()) {
       auto it = certificate_info_map_.find(*root_cert_name);
-      CHECK(it != certificate_info_map_.end());
+      ABSL_CHECK(it != certificate_info_map_.end());
       CertificateInfo& cert_info = it->second;
       cert_info.root_cert_watchers.erase(watcher);
       stop_watching_root_cert = cert_info.root_cert_watchers.empty();
@@ -281,7 +281,7 @@ void grpc_tls_certificate_distributor::CancelTlsCertificatesWatch(
     }
     if (identity_cert_name.has_value()) {
       auto it = certificate_info_map_.find(*identity_cert_name);
-      CHECK(it != certificate_info_map_.end());
+      ABSL_CHECK(it != certificate_info_map_.end());
       CertificateInfo& cert_info = it->second;
       cert_info.identity_cert_watchers.erase(watcher);
       stop_watching_identity_cert = cert_info.identity_cert_watchers.empty();
@@ -325,13 +325,13 @@ grpc_tls_identity_pairs* grpc_tls_identity_pairs_create() {
 void grpc_tls_identity_pairs_add_pair(grpc_tls_identity_pairs* pairs,
                                       const char* private_key,
                                       const char* cert_chain) {
-  CHECK_NE(pairs, nullptr);
-  CHECK_NE(private_key, nullptr);
-  CHECK_NE(cert_chain, nullptr);
+  ABSL_CHECK_NE(pairs, nullptr);
+  ABSL_CHECK_NE(private_key, nullptr);
+  ABSL_CHECK_NE(cert_chain, nullptr);
   pairs->pem_key_cert_pairs.emplace_back(private_key, cert_chain);
 }

 void grpc_tls_identity_pairs_destroy(grpc_tls_identity_pairs* pairs) {
-  CHECK_NE(pairs, nullptr);
+  ABSL_CHECK_NE(pairs, nullptr);
   delete pairs;
 }
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.cc b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.cc
index 5bde40009fdb0..2d030092db1bc 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.cc
@@ -27,8 +27,8 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/string_view.h"
 #include "src/core/lib/debug/trace.h"
@@ -184,21 +184,21 @@ FileWatcherCertificateProvider::FileWatcherCertificateProvider(
       refresh_interval_sec_(refresh_interval_sec),
       distributor_(MakeRefCounted<grpc_tls_certificate_distributor>()) {
   if (refresh_interval_sec_ < kMinimumFileWatcherRefreshIntervalSeconds) {
-    VLOG(2) << "FileWatcherCertificateProvider refresh_interval_sec_ set to "
+    ABSL_VLOG(2) << "FileWatcherCertificateProvider refresh_interval_sec_ set to "
                "value less than minimum. Overriding configured value to "
                "minimum.";
     refresh_interval_sec_ = kMinimumFileWatcherRefreshIntervalSeconds;
   }
   // Private key and identity cert files must be both set or both unset.
-  CHECK(private_key_path_.empty() == identity_certificate_path_.empty());
+  ABSL_CHECK(private_key_path_.empty() == identity_certificate_path_.empty());
   // Must be watching either root or identity certs.
-  CHECK(!private_key_path_.empty() || !root_cert_path_.empty());
+  ABSL_CHECK(!private_key_path_.empty() || !root_cert_path_.empty());
   gpr_event_init(&shutdown_event_);
   ForceUpdate();
   auto thread_lambda = [](void* arg) {
     FileWatcherCertificateProvider* provider =
         static_cast<FileWatcherCertificateProvider*>(arg);
-    CHECK_NE(provider, nullptr);
+    ABSL_CHECK_NE(provider, nullptr);
     while (true) {
       void* value = gpr_event_wait(
           &provider->shutdown_event_,
@@ -361,7 +361,7 @@ FileWatcherCertificateProvider::ReadRootCertificatesFromFile(
   auto root_slice =
       LoadFile(root_cert_full_path, /*add_null_terminator=*/false);
   if (!root_slice.ok()) {
-    LOG(ERROR) << "Reading file " << root_cert_full_path
+    ABSL_LOG(ERROR) << "Reading file " << root_cert_full_path
                << " failed: " << root_slice.status();
     return std::nullopt;
   }
@@ -392,28 +392,28 @@ FileWatcherCertificateProvider::ReadIdentityKeyCertPairFromFiles(
     time_t identity_key_ts_before =
         GetModificationTime(private_key_path.c_str());
     if (identity_key_ts_before == 0) {
-      LOG(ERROR) << "Failed to get the file's modification time of "
+      ABSL_LOG(ERROR) << "Failed to get the file's modification time of "
                  << private_key_path << ". Start retrying...";
       continue;
     }
     time_t identity_cert_ts_before =
         GetModificationTime(identity_certificate_path.c_str());
     if (identity_cert_ts_before == 0) {
-      LOG(ERROR) << "Failed to get the file's modification time of "
+      ABSL_LOG(ERROR) << "Failed to get the file's modification time of "
                  << identity_certificate_path << ". Start retrying...";
       continue;
     }
     // Read the identity files.
     auto key_slice = LoadFile(private_key_path, /*add_null_terminator=*/false);
     if (!key_slice.ok()) {
-      LOG(ERROR) << "Reading file " << private_key_path
+      ABSL_LOG(ERROR) << "Reading file " << private_key_path
                  << " failed: " << key_slice.status() << ". Start retrying...";
       continue;
     }
     auto cert_slice =
         LoadFile(identity_certificate_path, /*add_null_terminator=*/false);
     if (!cert_slice.ok()) {
-      LOG(ERROR) << "Reading file " << identity_certificate_path
+      ABSL_LOG(ERROR) << "Reading file " << identity_certificate_path
                  << " failed: " << cert_slice.status() << ". Start retrying...";
       continue;
     }
@@ -425,21 +425,21 @@ FileWatcherCertificateProvider::ReadIdentityKeyCertPairFromFiles(
     time_t identity_key_ts_after =
         GetModificationTime(private_key_path.c_str());
     if (identity_key_ts_before != identity_key_ts_after) {
-      LOG(ERROR) << "Last modified time before and after reading "
+      ABSL_LOG(ERROR) << "Last modified time before and after reading "
                  << private_key_path << " is not the same. Start retrying...";
       continue;
     }
     time_t identity_cert_ts_after =
         GetModificationTime(identity_certificate_path.c_str());
     if (identity_cert_ts_before != identity_cert_ts_after) {
-      LOG(ERROR) << "Last modified time before and after reading "
+      ABSL_LOG(ERROR) << "Last modified time before and after reading "
                  << identity_certificate_path
                  << " is not the same. Start retrying...";
       continue;
     }
     return identity_pairs;
   }
-  LOG(ERROR) << "All retry attempts failed. Will try again after the next "
+  ABSL_LOG(ERROR) << "All retry attempts failed. Will try again after the next "
                 "interval.";
   return std::nullopt;
 }
@@ -455,7 +455,7 @@ int64_t FileWatcherCertificateProvider::TestOnlyGetRefreshIntervalSecond()

 grpc_tls_certificate_provider* grpc_tls_certificate_provider_static_data_create(
     const char* root_certificate, grpc_tls_identity_pairs* pem_key_cert_pairs) {
-  CHECK(root_certificate != nullptr || pem_key_cert_pairs != nullptr);
+  ABSL_CHECK(root_certificate != nullptr || pem_key_cert_pairs != nullptr);
   grpc_core::ExecCtx exec_ctx;
   grpc_core::PemKeyCertPairList identity_pairs_core;
   if (pem_key_cert_pairs != nullptr) {
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.h b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.h
index f002013aefd66..893de19722783 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.h
+++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.h
@@ -27,7 +27,7 @@
 #include <string>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/string_view.h"
 #include "src/core/lib/security/credentials/tls/grpc_tls_certificate_distributor.h"
@@ -63,7 +63,7 @@ struct grpc_tls_certificate_provider
   // be reused when two different `grpc_tls_certificate_provider` objects are
   // used but they compare as equal (assuming other channel args match).
   int Compare(const grpc_tls_certificate_provider* other) const {
-    CHECK_NE(other, nullptr);
+    ABSL_CHECK_NE(other, nullptr);
     int r = type().Compare(other->type());
     if (r != 0) return r;
     return CompareImpl(other);
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_verifier.cc b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_verifier.cc
index 47447ed536c26..465796faacc12 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_verifier.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_verifier.cc
@@ -24,7 +24,7 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/string_view.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
@@ -108,7 +108,7 @@ UniqueTypeName NoOpCertificateVerifier::type() const {
 bool HostNameCertificateVerifier::Verify(
     grpc_tls_custom_verification_check_request* request,
     std::function<void(absl::Status)>, absl::Status* sync_status) {
-  CHECK_NE(request, nullptr);
+  ABSL_CHECK_NE(request, nullptr);
   // Extract the target name, and remove its port.
   const char* target_name = request->target_name;
   if (target_name == nullptr) {
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_verifier.h b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_verifier.h
index 3b80d9bc852c2..237d01ae8de26 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_verifier.h
+++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_certificate_verifier.h
@@ -26,7 +26,7 @@
 #include <map>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "src/core/util/ref_counted.h"
 #include "src/core/util/sync.h"
@@ -57,7 +57,7 @@ struct grpc_tls_certificate_verifier
   // If this method returns 0, it means that gRPC can treat the two certificate
   // verifiers as effectively the same.
   int Compare(const grpc_tls_certificate_verifier* other) const {
-    CHECK_NE(other, nullptr);
+    ABSL_CHECK_NE(other, nullptr);
     int r = type().Compare(other->type());
     if (r != 0) return r;
     return CompareImpl(other);
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_credentials_options.cc b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_credentials_options.cc
index 69f73476cae38..6170af24b3a30 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_credentials_options.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_credentials_options.cc
@@ -23,8 +23,8 @@

 #include <memory>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
 #include "src/core/tsi/ssl_transport_security.h"
@@ -39,7 +39,7 @@ grpc_tls_credentials_options* grpc_tls_credentials_options_create() {

 grpc_tls_credentials_options* grpc_tls_credentials_options_copy(
     grpc_tls_credentials_options* options) {
-  CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
   return new grpc_tls_credentials_options(*options);
 }

@@ -51,21 +51,21 @@ void grpc_tls_credentials_options_destroy(
 void grpc_tls_credentials_options_set_cert_request_type(
     grpc_tls_credentials_options* options,
     grpc_ssl_client_certificate_request_type type) {
-  CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
   options->set_cert_request_type(type);
 }

 void grpc_tls_credentials_options_set_verify_server_cert(
     grpc_tls_credentials_options* options, int verify_server_cert) {
-  CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
   options->set_verify_server_cert(verify_server_cert);
 }

 void grpc_tls_credentials_options_set_certificate_provider(
     grpc_tls_credentials_options* options,
     grpc_tls_certificate_provider* provider) {
-  CHECK_NE(options, nullptr);
-  CHECK_NE(provider, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(provider, nullptr);
   grpc_core::ExecCtx exec_ctx;
   options->set_certificate_provider(
       provider->Ref(DEBUG_LOCATION, "set_certificate_provider"));
@@ -73,45 +73,45 @@ void grpc_tls_credentials_options_set_certificate_provider(

 void grpc_tls_credentials_options_watch_root_certs(
     grpc_tls_credentials_options* options) {
-  CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
   options->set_watch_root_cert(true);
 }

 void grpc_tls_credentials_options_set_root_cert_name(
     grpc_tls_credentials_options* options, const char* root_cert_name) {
-  CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
   options->set_root_cert_name(root_cert_name);
 }

 void grpc_tls_credentials_options_watch_identity_key_cert_pairs(
     grpc_tls_credentials_options* options) {
-  CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
   options->set_watch_identity_pair(true);
 }

 void grpc_tls_credentials_options_set_identity_cert_name(
     grpc_tls_credentials_options* options, const char* identity_cert_name) {
-  CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
   options->set_identity_cert_name(identity_cert_name);
 }

 void grpc_tls_credentials_options_set_certificate_verifier(
     grpc_tls_credentials_options* options,
     grpc_tls_certificate_verifier* verifier) {
-  CHECK_NE(options, nullptr);
-  CHECK_NE(verifier, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(verifier, nullptr);
   options->set_certificate_verifier(verifier->Ref());
 }

 void grpc_tls_credentials_options_set_crl_directory(
     grpc_tls_credentials_options* options, const char* crl_directory) {
-  CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
   options->set_crl_directory(crl_directory);
 }

 void grpc_tls_credentials_options_set_check_call_host(
     grpc_tls_credentials_options* options, int check_call_host) {
-  CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
   options->set_check_call_host(check_call_host);
 }

@@ -126,9 +126,9 @@ void grpc_tls_credentials_options_set_tls_session_key_log_file_path(
   // Tls session key logging is assumed to be enabled if the specified log
   // file is non-empty.
   if (path != nullptr) {
-    VLOG(2) << "Enabling TLS session key logging with keys stored at: " << path;
+    ABSL_VLOG(2) << "Enabling TLS session key logging with keys stored at: " << path;
   } else {
-    VLOG(2) << "Disabling TLS session key logging";
+    ABSL_VLOG(2) << "Disabling TLS session key logging";
   }
   options->set_tls_session_key_log_file_path(path != nullptr ? path : "");
 }
@@ -144,18 +144,18 @@ void grpc_tls_credentials_options_set_send_client_ca_list(
 void grpc_tls_credentials_options_set_crl_provider(
     grpc_tls_credentials_options* options,
     std::shared_ptr<grpc_core::experimental::CrlProvider> provider) {
-  CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
   options->set_crl_provider(provider);
 }

 void grpc_tls_credentials_options_set_min_tls_version(
     grpc_tls_credentials_options* options, grpc_tls_version min_tls_version) {
-  CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
   options->set_min_tls_version(min_tls_version);
 }

 void grpc_tls_credentials_options_set_max_tls_version(
     grpc_tls_credentials_options* options, grpc_tls_version max_tls_version) {
-  CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
   options->set_max_tls_version(max_tls_version);
 }
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc
index 72a113cd5922e..4fec5db6fbd5a 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc
@@ -34,7 +34,7 @@
 #include <openssl/x509.h>

 #include "absl/container/flat_hash_map.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -127,7 +127,7 @@ absl::StatusOr<std::shared_ptr<CrlProvider>> CreateStaticCrlProvider(
     }
     bool inserted = crl_map.emplace((*crl)->Issuer(), std::move(*crl)).second;
     if (!inserted) {
-      LOG(ERROR) << "StaticCrlProvider received multiple CRLs with the same "
+      ABSL_LOG(ERROR) << "StaticCrlProvider received multiple CRLs with the same "
                     "issuer. The first one in the span will be used.";
     }
   }
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/tls_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/tls/tls_credentials.cc
index fe543c574b28a..ffb6d16072360 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/tls_credentials.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/tls_credentials.cc
@@ -28,7 +28,7 @@
 #include <string>
 #include <utility>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/channel/channel_args.h"
 #include "src/core/lib/security/credentials/tls/grpc_tls_certificate_verifier.h"
 #include "src/core/lib/security/credentials/tls/grpc_tls_credentials_options.h"
@@ -41,27 +41,27 @@ namespace {
 bool CredentialOptionSanityCheck(grpc_tls_credentials_options* options,
                                  bool is_client) {
   if (options == nullptr) {
-    LOG(ERROR) << "TLS credentials options is nullptr.";
+    ABSL_LOG(ERROR) << "TLS credentials options is nullptr.";
     return false;
   }
   // In this case, there will be non-retriable handshake errors.
   if (options->min_tls_version() > options->max_tls_version()) {
-    LOG(ERROR) << "TLS min version must not be higher than max version.";
+    ABSL_LOG(ERROR) << "TLS min version must not be higher than max version.";
     grpc_tls_credentials_options_destroy(options);
     return false;
   }
   if (options->max_tls_version() > grpc_tls_version::TLS1_3) {
-    LOG(ERROR) << "TLS max version must not be higher than v1.3.";
+    ABSL_LOG(ERROR) << "TLS max version must not be higher than v1.3.";
     grpc_tls_credentials_options_destroy(options);
     return false;
   }
   if (options->min_tls_version() < grpc_tls_version::TLS1_2) {
-    LOG(ERROR) << "TLS min version must not be lower than v1.2.";
+    ABSL_LOG(ERROR) << "TLS min version must not be lower than v1.2.";
     grpc_tls_credentials_options_destroy(options);
     return false;
   }
   if (!options->crl_directory().empty() && options->crl_provider() != nullptr) {
-    LOG(ERROR) << "Setting crl_directory and crl_provider not supported. Using "
+    ABSL_LOG(ERROR) << "Setting crl_directory and crl_provider not supported. Using "
                   "the crl_provider.";
     // TODO(gtcooke94) - Maybe return false here. Right now object lifetime of
     // this options struct is leaky if false is returned and represents a more
@@ -71,11 +71,11 @@ bool CredentialOptionSanityCheck(grpc_tls_credentials_options* options,
   // indicate callers are doing something wrong with the API.
   if (is_client && options->cert_request_type() !=
                        GRPC_SSL_DONT_REQUEST_CLIENT_CERTIFICATE) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "Client's credentials options should not set cert_request_type.";
   }
   if (!is_client && !options->verify_server_cert()) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "Server's credentials options should not set verify_server_cert.";
   }
   // In the following conditions, there could be severe security issues.
@@ -83,7 +83,7 @@ bool CredentialOptionSanityCheck(grpc_tls_credentials_options* options,
     // If no verifier is specified on the client side, use the hostname verifier
     // as default. Users who want to bypass all the verifier check should
     // implement an external verifier instead.
-    VLOG(2) << "No verifier specified on the client side. Using default "
+    ABSL_VLOG(2) << "No verifier specified on the client side. Using default "
                "hostname verifier";
     options->set_certificate_verifier(
         grpc_core::MakeRefCounted<grpc_core::HostNameCertificateVerifier>());
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/tls/tls_utils.cc b/third_party/grpc/source/src/core/lib/security/credentials/tls/tls_utils.cc
index 296839a8aea6b..4f109221c6061 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/tls/tls_utils.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/tls/tls_utils.cc
@@ -23,7 +23,7 @@

 #include <algorithm>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/ascii.h"
 #include "absl/strings/match.h"
 #include "absl/strings/str_cat.h"
@@ -98,11 +98,11 @@ absl::string_view GetAuthPropertyValue(grpc_auth_context* context,
       grpc_auth_context_find_properties_by_name(context, property_name);
   const grpc_auth_property* prop = grpc_auth_property_iterator_next(&it);
   if (prop == nullptr) {
-    VLOG(2) << "No value found for " << property_name << " property.";
+    ABSL_VLOG(2) << "No value found for " << property_name << " property.";
     return "";
   }
   if (grpc_auth_property_iterator_next(&it) != nullptr) {
-    VLOG(2) << "Multiple values found for " << property_name << " property.";
+    ABSL_VLOG(2) << "Multiple values found for " << property_name << " property.";
     return "";
   }
   return absl::string_view(prop->value, prop->value_length);
@@ -119,7 +119,7 @@ std::vector<absl::string_view> GetAuthPropertyArray(grpc_auth_context* context,
     prop = grpc_auth_property_iterator_next(&it);
   }
   if (values.empty()) {
-    VLOG(2) << "No value found for " << property_name << " property.";
+    ABSL_VLOG(2) << "No value found for " << property_name << " property.";
   }
   return values;
 }
diff --git a/third_party/grpc/source/src/core/lib/security/credentials/xds/xds_credentials.cc b/third_party/grpc/source/src/core/lib/security/credentials/xds/xds_credentials.cc
index 402a41c733d54..e3e1153545a38 100644
--- a/third_party/grpc/source/src/core/lib/security/credentials/xds/xds_credentials.cc
+++ b/third_party/grpc/source/src/core/lib/security/credentials/xds/xds_credentials.cc
@@ -24,7 +24,7 @@

 #include <optional>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/channel/channel_args.h"
 #include "src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.h"
 #include "src/core/lib/security/credentials/tls/grpc_tls_credentials_options.h"
@@ -79,7 +79,7 @@ XdsCertificateVerifier::XdsCertificateVerifier(
 bool XdsCertificateVerifier::Verify(
     grpc_tls_custom_verification_check_request* request,
     std::function<void(absl::Status)>, absl::Status* sync_status) {
-  CHECK_NE(request, nullptr);
+  ABSL_CHECK_NE(request, nullptr);
   if (!XdsVerifySubjectAlternativeNames(
           request->peer_info.san_names.uri_names,
           request->peer_info.san_names.uri_names_size,
@@ -169,7 +169,7 @@ XdsCredentials::create_security_connector(
                                                         target_name, args);
     }
   }
-  CHECK(fallback_credentials_ != nullptr);
+  ABSL_CHECK(fallback_credentials_ != nullptr);
   return fallback_credentials_->create_security_connector(std::move(call_creds),
                                                           target_name, args);
 }
@@ -220,12 +220,12 @@ UniqueTypeName XdsServerCredentials::Type() {

 grpc_channel_credentials* grpc_xds_credentials_create(
     grpc_channel_credentials* fallback_credentials) {
-  CHECK_NE(fallback_credentials, nullptr);
+  ABSL_CHECK_NE(fallback_credentials, nullptr);
   return new grpc_core::XdsCredentials(fallback_credentials->Ref());
 }

 grpc_server_credentials* grpc_xds_server_credentials_create(
     grpc_server_credentials* fallback_credentials) {
-  CHECK_NE(fallback_credentials, nullptr);
+  ABSL_CHECK_NE(fallback_credentials, nullptr);
   return new grpc_core::XdsServerCredentials(fallback_credentials->Ref());
 }
diff --git a/third_party/grpc/source/src/core/lib/security/security_connector/alts/alts_security_connector.cc b/third_party/grpc/source/src/core/lib/security/security_connector/alts/alts_security_connector.cc
index bc9d14e38b5ec..5496aaa3c10af 100644
--- a/third_party/grpc/source/src/core/lib/security/security_connector/alts/alts_security_connector.cc
+++ b/third_party/grpc/source/src/core/lib/security/security_connector/alts/alts_security_connector.cc
@@ -31,8 +31,8 @@
 #include <optional>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/string_view.h"
 #include "src/core/handshaker/handshaker.h"
@@ -102,7 +102,7 @@ class grpc_alts_channel_security_connector final
         static_cast<const grpc_alts_credentials*>(channel_creds());
     const size_t user_specified_max_frame_size =
         std::max(0, args.GetInt(GRPC_ARG_TSI_MAX_FRAME_SIZE).value_or(0));
-    CHECK(alts_tsi_handshaker_create(creds->options(), target_name_,
+    ABSL_CHECK(alts_tsi_handshaker_create(creds->options(), target_name_,
                                      creds->handshaker_service_url(), true,
                                      interested_parties, &handshaker,
                                      user_specified_max_frame_size) == TSI_OK);
@@ -155,7 +155,7 @@ class grpc_alts_server_security_connector final
         static_cast<const grpc_alts_server_credentials*>(server_creds());
     size_t user_specified_max_frame_size =
         std::max(0, args.GetInt(GRPC_ARG_TSI_MAX_FRAME_SIZE).value_or(0));
-    CHECK(alts_tsi_handshaker_create(creds->options(), nullptr,
+    ABSL_CHECK(alts_tsi_handshaker_create(creds->options(), nullptr,
                                      creds->handshaker_service_url(), false,
                                      interested_parties, &handshaker,
                                      user_specified_max_frame_size) == TSI_OK);
@@ -185,7 +185,7 @@ namespace internal {
 RefCountedPtr<grpc_auth_context> grpc_alts_auth_context_from_tsi_peer(
     const tsi_peer* peer) {
   if (peer == nullptr) {
-    LOG(ERROR) << "Invalid arguments to grpc_alts_auth_context_from_tsi_peer()";
+    ABSL_LOG(ERROR) << "Invalid arguments to grpc_alts_auth_context_from_tsi_peer()";
     return nullptr;
   }
   // Validate certificate type.
@@ -194,21 +194,21 @@ RefCountedPtr<grpc_auth_context> grpc_alts_auth_context_from_tsi_peer(
   if (cert_type_prop == nullptr ||
       strncmp(cert_type_prop->value.data, TSI_ALTS_CERTIFICATE_TYPE,
               cert_type_prop->value.length) != 0) {
-    LOG(ERROR) << "Invalid or missing certificate type property.";
+    ABSL_LOG(ERROR) << "Invalid or missing certificate type property.";
     return nullptr;
   }
   // Check if security level exists.
   const tsi_peer_property* security_level_prop =
       tsi_peer_get_property_by_name(peer, TSI_SECURITY_LEVEL_PEER_PROPERTY);
   if (security_level_prop == nullptr) {
-    LOG(ERROR) << "Missing security level property.";
+    ABSL_LOG(ERROR) << "Missing security level property.";
     return nullptr;
   }
   // Validate RPC protocol versions.
   const tsi_peer_property* rpc_versions_prop =
       tsi_peer_get_property_by_name(peer, TSI_ALTS_RPC_VERSIONS);
   if (rpc_versions_prop == nullptr) {
-    LOG(ERROR) << "Missing rpc protocol versions property.";
+    ABSL_LOG(ERROR) << "Missing rpc protocol versions property.";
     return nullptr;
   }
   grpc_gcp_rpc_protocol_versions local_versions, peer_versions;
@@ -219,21 +219,21 @@ RefCountedPtr<grpc_auth_context> grpc_alts_auth_context_from_tsi_peer(
       grpc_gcp_rpc_protocol_versions_decode(slice, &peer_versions);
   CSliceUnref(slice);
   if (!decode_result) {
-    LOG(ERROR) << "Invalid peer rpc protocol versions.";
+    ABSL_LOG(ERROR) << "Invalid peer rpc protocol versions.";
     return nullptr;
   }
   // TODO(unknown): Pass highest common rpc protocol version to grpc caller.
   bool check_result = grpc_gcp_rpc_protocol_versions_check(
       &local_versions, &peer_versions, nullptr);
   if (!check_result) {
-    LOG(ERROR) << "Mismatch of local and peer rpc protocol versions.";
+    ABSL_LOG(ERROR) << "Mismatch of local and peer rpc protocol versions.";
     return nullptr;
   }
   // Validate ALTS Context.
   const tsi_peer_property* alts_context_prop =
       tsi_peer_get_property_by_name(peer, TSI_ALTS_CONTEXT);
   if (alts_context_prop == nullptr) {
-    LOG(ERROR) << "Missing alts context property.";
+    ABSL_LOG(ERROR) << "Missing alts context property.";
     return nullptr;
   }
   // Create auth context.
@@ -249,7 +249,7 @@ RefCountedPtr<grpc_auth_context> grpc_alts_auth_context_from_tsi_peer(
       grpc_auth_context_add_property(
           ctx.get(), TSI_ALTS_SERVICE_ACCOUNT_PEER_PROPERTY,
           tsi_prop->value.data, tsi_prop->value.length);
-      CHECK(grpc_auth_context_set_peer_identity_property_name(
+      ABSL_CHECK(grpc_auth_context_set_peer_identity_property_name(
                 ctx.get(), TSI_ALTS_SERVICE_ACCOUNT_PEER_PROPERTY) == 1);
     }
     // Add alts context to auth context.
@@ -266,7 +266,7 @@ RefCountedPtr<grpc_auth_context> grpc_alts_auth_context_from_tsi_peer(
     }
   }
   if (!grpc_auth_context_peer_is_authenticated(ctx.get())) {
-    LOG(ERROR) << "Invalid unauthenticated peer.";
+    ABSL_LOG(ERROR) << "Invalid unauthenticated peer.";
     ctx.reset(DEBUG_LOCATION, "test");
     return nullptr;
   }
@@ -282,7 +282,7 @@ grpc_alts_channel_security_connector_create(
     grpc_core::RefCountedPtr<grpc_call_credentials> request_metadata_creds,
     const char* target_name) {
   if (channel_creds == nullptr || target_name == nullptr) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "Invalid arguments to grpc_alts_channel_security_connector_create()";
     return nullptr;
   }
@@ -294,7 +294,7 @@ grpc_core::RefCountedPtr<grpc_server_security_connector>
 grpc_alts_server_security_connector_create(
     grpc_core::RefCountedPtr<grpc_server_credentials> server_creds) {
   if (server_creds == nullptr) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "Invalid arguments to grpc_alts_server_security_connector_create()";
     return nullptr;
   }
diff --git a/third_party/grpc/source/src/core/lib/security/security_connector/fake/fake_security_connector.cc b/third_party/grpc/source/src/core/lib/security/security_connector/fake/fake_security_connector.cc
index 66051e2401872..05141197b6bf3 100644
--- a/third_party/grpc/source/src/core/lib/security/security_connector/fake/fake_security_connector.cc
+++ b/third_party/grpc/source/src/core/lib/security/security_connector/fake/fake_security_connector.cc
@@ -30,8 +30,8 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
@@ -140,7 +140,7 @@ class grpc_fake_channel_security_connector final

  private:
   bool fake_check_target(const char* target, const char* set_str) const {
-    CHECK_NE(target, nullptr);
+    ABSL_CHECK_NE(target, nullptr);
     char** set = nullptr;
     size_t set_size = 0;
     gpr_string_split(set_str, ",", &set, &set_size);
@@ -163,20 +163,20 @@ class grpc_fake_channel_security_connector final
     gpr_string_split(expected_targets_->c_str(), ";", &lbs_and_backends,
                      &lbs_and_backends_size);
     if (lbs_and_backends_size > 2 || lbs_and_backends_size == 0) {
-      LOG(ERROR) << "Invalid expected targets arg value: '"
+      ABSL_LOG(ERROR) << "Invalid expected targets arg value: '"
                  << expected_targets_->c_str() << "'";
       goto done;
     }
     if (is_lb_channel_) {
       if (lbs_and_backends_size != 2) {
-        LOG(ERROR) << "Invalid expected targets arg value: '"
+        ABSL_LOG(ERROR) << "Invalid expected targets arg value: '"
                    << expected_targets_->c_str()
                    << "'. Expectations for LB channels must be of the form "
                       "'be1,be2,be3,...;lb1,lb2,...";
         goto done;
       }
       if (!fake_check_target(target_, lbs_and_backends[1])) {
-        LOG(ERROR) << "LB target '" << target_
+        ABSL_LOG(ERROR) << "LB target '" << target_
                    << "' not found in expected set '" << lbs_and_backends[1]
                    << "'";
         goto done;
@@ -184,7 +184,7 @@ class grpc_fake_channel_security_connector final
       success = true;
     } else {
       if (!fake_check_target(target_, lbs_and_backends[0])) {
-        LOG(ERROR) << "Backend target '" << target_
+        ABSL_LOG(ERROR) << "Backend target '" << target_
                    << "' not found in expected set '" << lbs_and_backends[0]
                    << "'";
         goto done;
diff --git a/third_party/grpc/source/src/core/lib/security/security_connector/insecure/insecure_security_connector.cc b/third_party/grpc/source/src/core/lib/security/security_connector/insecure/insecure_security_connector.cc
index da250fea5988a..7af11057cce4a 100644
--- a/third_party/grpc/source/src/core/lib/security/security_connector/insecure/insecure_security_connector.cc
+++ b/third_party/grpc/source/src/core/lib/security/security_connector/insecure/insecure_security_connector.cc
@@ -22,7 +22,7 @@
 #include <grpc/support/port_platform.h>
 #include <string.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/handshaker/security/security_handshaker.h"
 #include "src/core/lib/channel/channel_args.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
@@ -69,7 +69,7 @@ void InsecureChannelSecurityConnector::add_handshakers(
     HandshakeManager* handshake_manager) {
   tsi_handshaker* handshaker = nullptr;
   // Re-use local_tsi_handshaker_create as a minimalist handshaker.
-  CHECK(tsi_local_handshaker_create(&handshaker) == TSI_OK);
+  ABSL_CHECK(tsi_local_handshaker_create(&handshaker) == TSI_OK);
   handshake_manager->Add(SecurityHandshakerCreate(handshaker, this, args));
 }

@@ -96,7 +96,7 @@ void InsecureServerSecurityConnector::add_handshakers(
     HandshakeManager* handshake_manager) {
   tsi_handshaker* handshaker = nullptr;
   // Re-use local_tsi_handshaker_create as a minimalist handshaker.
-  CHECK(tsi_local_handshaker_create(&handshaker) == TSI_OK);
+  ABSL_CHECK(tsi_local_handshaker_create(&handshaker) == TSI_OK);
   handshake_manager->Add(SecurityHandshakerCreate(handshaker, this, args));
 }

diff --git a/third_party/grpc/source/src/core/lib/security/security_connector/load_system_roots_supported.cc b/third_party/grpc/source/src/core/lib/security/security_connector/load_system_roots_supported.cc
index c1cf3ab2a2ebf..36b57fee15dad 100644
--- a/third_party/grpc/source/src/core/lib/security/security_connector/load_system_roots_supported.cc
+++ b/third_party/grpc/source/src/core/lib/security/security_connector/load_system_roots_supported.cc
@@ -33,7 +33,7 @@
 #include <sys/stat.h>
 #include <unistd.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/config/config_vars.h"
 #include "src/core/lib/iomgr/error.h"
 #include "src/core/lib/security/security_connector/load_system_roots.h"
@@ -78,7 +78,7 @@ void GetAbsoluteFilePath(const char* valid_file_dir,
     int path_len = snprintf(path_buffer, MAXPATHLEN, "%s/%s", valid_file_dir,
                             file_entry_name);
     if (path_len == 0) {
-      LOG(ERROR) << "failed to get absolute path for file: " << file_entry_name;
+      ABSL_LOG(ERROR) << "failed to get absolute path for file: " << file_entry_name;
     }
   }
 }
@@ -108,7 +108,7 @@ grpc_slice CreateRootCertsBundle(const char* certs_directory) {
     if (stat_return == -1 || !S_ISREG(dir_entry_stat.st_mode)) {
       // no subdirectories.
       if (stat_return == -1) {
-        LOG(ERROR) << "failed to get status for file: " << file_data.path;
+        ABSL_LOG(ERROR) << "failed to get status for file: " << file_data.path;
       }
       continue;
     }
@@ -129,7 +129,7 @@ grpc_slice CreateRootCertsBundle(const char* certs_directory) {
       if (read_ret != -1) {
         bytes_read += read_ret;
       } else {
-        LOG(ERROR) << "failed to read file: " << roots_filenames[i].path;
+        ABSL_LOG(ERROR) << "failed to read file: " << roots_filenames[i].path;
       }
     }
   }
diff --git a/third_party/grpc/source/src/core/lib/security/security_connector/local/local_security_connector.cc b/third_party/grpc/source/src/core/lib/security/security_connector/local/local_security_connector.cc
index 657bcaf47d9da..86d192844cfab 100644
--- a/third_party/grpc/source/src/core/lib/security/security_connector/local/local_security_connector.cc
+++ b/third_party/grpc/source/src/core/lib/security/security_connector/local/local_security_connector.cc
@@ -29,8 +29,8 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/match.h"
@@ -77,12 +77,12 @@ grpc_core::RefCountedPtr<grpc_auth_context> local_auth_context_create(
   grpc_auth_context_add_cstring_property(
       ctx.get(), GRPC_TRANSPORT_SECURITY_TYPE_PROPERTY_NAME,
       GRPC_LOCAL_TRANSPORT_SECURITY_TYPE);
-  CHECK(grpc_auth_context_set_peer_identity_property_name(
+  ABSL_CHECK(grpc_auth_context_set_peer_identity_property_name(
             ctx.get(), GRPC_TRANSPORT_SECURITY_TYPE_PROPERTY_NAME) == 1);
-  CHECK_EQ(peer->property_count, 1u);
+  ABSL_CHECK_EQ(peer->property_count, 1u);
   const tsi_peer_property* prop = &peer->properties[0];
-  CHECK_NE(prop, nullptr);
-  CHECK_EQ(strcmp(prop->name, TSI_SECURITY_LEVEL_PEER_PROPERTY), 0);
+  ABSL_CHECK_NE(prop, nullptr);
+  ABSL_CHECK_EQ(strcmp(prop->name, TSI_SECURITY_LEVEL_PEER_PROPERTY), 0);
   grpc_auth_context_add_property(ctx.get(),
                                  GRPC_TRANSPORT_SECURITY_LEVEL_PROPERTY_NAME,
                                  prop->value.data, prop->value.length);
@@ -98,7 +98,7 @@ void local_check_peer(tsi_peer peer, grpc_endpoint* ep,
   absl::string_view local_addr = grpc_endpoint_get_local_address(ep);
   absl::StatusOr<grpc_core::URI> uri = grpc_core::URI::Parse(local_addr);
   if (!uri.ok() || !grpc_parse_uri(*uri, &resolved_addr)) {
-    LOG(ERROR) << "Could not parse endpoint address: " << local_addr;
+    ABSL_LOG(ERROR) << "Could not parse endpoint address: " << local_addr;
   } else {
     grpc_resolved_address addr_normalized;
     grpc_resolved_address* addr =
@@ -186,7 +186,7 @@ class grpc_local_channel_security_connector final
       grpc_pollset_set* /*interested_parties*/,
       grpc_core::HandshakeManager* handshake_manager) override {
     tsi_handshaker* handshaker = nullptr;
-    CHECK(tsi_local_handshaker_create(&handshaker) == TSI_OK);
+    ABSL_CHECK(tsi_local_handshaker_create(&handshaker) == TSI_OK);
     handshake_manager->Add(
         grpc_core::SecurityHandshakerCreate(handshaker, this, args));
   }
@@ -241,7 +241,7 @@ class grpc_local_server_security_connector final
       grpc_pollset_set* /*interested_parties*/,
       grpc_core::HandshakeManager* handshake_manager) override {
     tsi_handshaker* handshaker = nullptr;
-    CHECK(tsi_local_handshaker_create(&handshaker) == TSI_OK);
+    ABSL_CHECK(tsi_local_handshaker_create(&handshaker) == TSI_OK);
     handshake_manager->Add(
         grpc_core::SecurityHandshakerCreate(handshaker, this, args));
   }
@@ -272,7 +272,7 @@ grpc_local_channel_security_connector_create(
     grpc_core::RefCountedPtr<grpc_call_credentials> request_metadata_creds,
     const grpc_core::ChannelArgs& args, const char* target_name) {
   if (channel_creds == nullptr || target_name == nullptr) {
-    LOG(ERROR) << "Invalid arguments to "
+    ABSL_LOG(ERROR) << "Invalid arguments to "
                   "grpc_local_channel_security_connector_create()";
     return nullptr;
   }
@@ -285,7 +285,7 @@ grpc_local_channel_security_connector_create(
   if (creds->connect_type() == UDS &&
       !absl::StartsWith(server_uri_str, GRPC_UDS_URI_PATTERN) &&
       !absl::StartsWith(server_uri_str, GRPC_ABSTRACT_UDS_URI_PATTERN)) {
-    LOG(ERROR) << "Invalid UDS target name to "
+    ABSL_LOG(ERROR) << "Invalid UDS target name to "
                   "grpc_local_channel_security_connector_create()";
     return nullptr;
   }
@@ -297,7 +297,7 @@ grpc_core::RefCountedPtr<grpc_server_security_connector>
 grpc_local_server_security_connector_create(
     grpc_core::RefCountedPtr<grpc_server_credentials> server_creds) {
   if (server_creds == nullptr) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "Invalid arguments to grpc_local_server_security_connector_create()";
     return nullptr;
   }
diff --git a/third_party/grpc/source/src/core/lib/security/security_connector/security_connector.cc b/third_party/grpc/source/src/core/lib/security/security_connector/security_connector.cc
index 481175c76e08d..167701bc77b1c 100644
--- a/third_party/grpc/source/src/core/lib/security/security_connector/security_connector.cc
+++ b/third_party/grpc/source/src/core/lib/security/security_connector/security_connector.cc
@@ -23,8 +23,8 @@

 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/channel/channel_args.h"
 #include "src/core/lib/security/credentials/credentials.h"
 #include "src/core/util/debug_location.h"
@@ -42,8 +42,8 @@ int grpc_channel_security_connector::channel_security_connector_cmp(
     const grpc_channel_security_connector* other) const {
   const grpc_channel_security_connector* other_sc =
       static_cast<const grpc_channel_security_connector*>(other);
-  CHECK_NE(channel_creds(), nullptr);
-  CHECK_NE(other_sc->channel_creds(), nullptr);
+  ABSL_CHECK_NE(channel_creds(), nullptr);
+  ABSL_CHECK_NE(other_sc->channel_creds(), nullptr);
   int c = channel_creds()->cmp(other_sc->channel_creds());
   if (c != 0) return c;
   return grpc_core::QsortCompare(request_metadata_creds(),
@@ -64,8 +64,8 @@ int grpc_server_security_connector::server_security_connector_cmp(
     const grpc_server_security_connector* other) const {
   const grpc_server_security_connector* other_sc =
       static_cast<const grpc_server_security_connector*>(other);
-  CHECK_NE(server_creds(), nullptr);
-  CHECK_NE(other_sc->server_creds(), nullptr);
+  ABSL_CHECK_NE(server_creds(), nullptr);
+  ABSL_CHECK_NE(other_sc->server_creds(), nullptr);
   return grpc_core::QsortCompare(server_creds(), other_sc->server_creds());
 }

@@ -103,7 +103,7 @@ grpc_arg grpc_security_connector_to_arg(grpc_security_connector* sc) {
 grpc_security_connector* grpc_security_connector_from_arg(const grpc_arg* arg) {
   if (strcmp(arg->key, GRPC_ARG_SECURITY_CONNECTOR) != 0) return nullptr;
   if (arg->type != GRPC_ARG_POINTER) {
-    LOG(ERROR) << "Invalid type " << arg->type << " for arg "
+    ABSL_LOG(ERROR) << "Invalid type " << arg->type << " for arg "
                << GRPC_ARG_SECURITY_CONNECTOR;
     return nullptr;
   }
diff --git a/third_party/grpc/source/src/core/lib/security/security_connector/ssl/ssl_security_connector.cc b/third_party/grpc/source/src/core/lib/security/security_connector/ssl/ssl_security_connector.cc
index 0c8dc6043f865..eb59cc5f22764 100644
--- a/third_party/grpc/source/src/core/lib/security/security_connector/ssl/ssl_security_connector.cc
+++ b/third_party/grpc/source/src/core/lib/security/security_connector/ssl/ssl_security_connector.cc
@@ -26,8 +26,8 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
@@ -110,7 +110,7 @@ class grpc_ssl_channel_security_connector final
         /*network_bio_buf_size=*/0,
         /*ssl_bio_buf_size=*/0, &tsi_hs);
     if (result != TSI_OK) {
-      LOG(ERROR) << "Handshaker creation failed with error "
+      ABSL_LOG(ERROR) << "Handshaker creation failed with error "
                  << tsi_result_to_string(result);
       return;
     }
@@ -202,7 +202,7 @@ class grpc_ssl_server_security_connector
     if (has_cert_config_fetcher()) {
       // Load initial credentials from certificate_config_fetcher:
       if (!try_fetch_ssl_server_credentials()) {
-        LOG(ERROR) << "Failed loading SSL server credentials from fetcher.";
+        ABSL_LOG(ERROR) << "Failed loading SSL server credentials from fetcher.";
         return GRPC_SECURITY_ERROR;
       }
     } else {
@@ -233,7 +233,7 @@ class grpc_ssl_server_security_connector
               &options, &server_handshaker_factory_);
       gpr_free(alpn_protocol_strings);
       if (result != TSI_OK) {
-        LOG(ERROR) << "Handshaker factory creation failed with "
+        ABSL_LOG(ERROR) << "Handshaker factory creation failed with "
                    << tsi_result_to_string(result);
         return GRPC_SECURITY_ERROR;
       }
@@ -251,7 +251,7 @@ class grpc_ssl_server_security_connector
         server_handshaker_factory_, /*network_bio_buf_size=*/0,
         /*ssl_bio_buf_size=*/0, &tsi_hs);
     if (result != TSI_OK) {
-      LOG(ERROR) << "Handshaker creation failed with error "
+      ABSL_LOG(ERROR) << "Handshaker creation failed with error "
                  << tsi_result_to_string(result);
       return;
     }
@@ -296,7 +296,7 @@ class grpc_ssl_server_security_connector
       status = try_replace_server_handshaker_factory(certificate_config);
     } else {
       // Log error, continue using previously-loaded credentials.
-      LOG(ERROR) << "Failed fetching new server credentials, continuing to "
+      ABSL_LOG(ERROR) << "Failed fetching new server credentials, continuing to "
                     "use previously-loaded credentials.";
       status = false;
     }
@@ -314,12 +314,12 @@ class grpc_ssl_server_security_connector
   bool try_replace_server_handshaker_factory(
       const grpc_ssl_server_certificate_config* config) {
     if (config == nullptr) {
-      LOG(ERROR)
+      ABSL_LOG(ERROR)
           << "Server certificate config callback returned invalid (NULL) "
              "config.";
       return false;
     }
-    VLOG(2) << "Using new server certificate config (" << config << ").";
+    ABSL_VLOG(2) << "Using new server certificate config (" << config << ").";

     size_t num_alpn_protocols = 0;
     const char** alpn_protocol_strings =
@@ -327,7 +327,7 @@ class grpc_ssl_server_security_connector
     tsi_ssl_server_handshaker_factory* new_handshaker_factory = nullptr;
     const grpc_ssl_server_credentials* server_creds =
         static_cast<const grpc_ssl_server_credentials*>(this->server_creds());
-    DCHECK_NE(config->pem_root_certs, nullptr);
+    ABSL_DCHECK_NE(config->pem_root_certs, nullptr);
     tsi_ssl_server_handshaker_options options;
     options.pem_key_cert_pairs = grpc_convert_grpc_to_tsi_cert_pairs(
         config->pem_key_cert_pairs, config->num_key_cert_pairs);
@@ -347,7 +347,7 @@ class grpc_ssl_server_security_connector
     gpr_free(alpn_protocol_strings);

     if (result != TSI_OK) {
-      LOG(ERROR) << "Handshaker factory creation failed with "
+      ABSL_LOG(ERROR) << "Handshaker factory creation failed with "
                  << tsi_result_to_string(result);
       return false;
     }
@@ -376,7 +376,7 @@ grpc_ssl_channel_security_connector_create(
     const char* overridden_target_name,
     tsi_ssl_client_handshaker_factory* client_factory) {
   if (config == nullptr || target_name == nullptr) {
-    LOG(ERROR) << "An ssl channel needs a config and a target name.";
+    ABSL_LOG(ERROR) << "An ssl channel needs a config and a target name.";
     return nullptr;
   }

@@ -391,7 +391,7 @@ grpc_ssl_channel_security_connector_create(
 grpc_core::RefCountedPtr<grpc_server_security_connector>
 grpc_ssl_server_security_connector_create(
     grpc_core::RefCountedPtr<grpc_server_credentials> server_credentials) {
-  CHECK(server_credentials != nullptr);
+  ABSL_CHECK(server_credentials != nullptr);
   grpc_core::RefCountedPtr<grpc_ssl_server_security_connector> c =
       grpc_core::MakeRefCounted<grpc_ssl_server_security_connector>(
           std::move(server_credentials));
diff --git a/third_party/grpc/source/src/core/lib/security/security_connector/ssl_utils.cc b/third_party/grpc/source/src/core/lib/security/security_connector/ssl_utils.cc
index 09962b3eec910..07eeeef1de207 100644
--- a/third_party/grpc/source/src/core/lib/security/security_connector/ssl_utils.cc
+++ b/third_party/grpc/source/src/core/lib/security/security_connector/ssl_utils.cc
@@ -33,8 +33,8 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/match.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_split.h"
@@ -121,7 +121,7 @@ tsi_tls_version grpc_get_tsi_tls_version(grpc_tls_version tls_version) {
     case grpc_tls_version::TLS1_3:
       return tsi_tls_version::TSI_TLS1_3;
     default:
-      LOG(INFO) << "Falling back to TLS 1.2.";
+      ABSL_LOG(INFO) << "Falling back to TLS 1.2.";
       return tsi_tls_version::TSI_TLS1_2;
   }
 }
@@ -178,7 +178,7 @@ absl::Status SslCheckCallHost(absl::string_view host,
     status = GRPC_SECURITY_OK;
   }
   if (status != GRPC_SECURITY_OK) {
-    LOG(ERROR) << "call host does not match SSL server name";
+    ABSL_LOG(ERROR) << "call host does not match SSL server name";
     grpc_shallow_peer_destruct(&peer);
     return absl::UnauthenticatedError(
         "call host does not match SSL server name");
@@ -190,7 +190,7 @@ absl::Status SslCheckCallHost(absl::string_view host,
 }  // namespace grpc_core

 const char** grpc_fill_alpn_protocol_strings(size_t* num_alpn_protocols) {
-  CHECK_NE(num_alpn_protocols, nullptr);
+  ABSL_CHECK_NE(num_alpn_protocols, nullptr);
   *num_alpn_protocols = grpc_chttp2_num_alpn_versions();
   const char** alpn_protocol_strings = static_cast<const char**>(
       gpr_malloc(sizeof(const char*) * (*num_alpn_protocols)));
@@ -253,7 +253,7 @@ grpc_core::RefCountedPtr<grpc_auth_context> grpc_ssl_peer_to_auth_context(
   const char* peer_identity_property_name = nullptr;

   // The caller has checked the certificate type property.
-  CHECK_GE(peer->property_count, 1u);
+  ABSL_CHECK_GE(peer->property_count, 1u);
   grpc_core::RefCountedPtr<grpc_auth_context> ctx =
       grpc_core::MakeRefCounted<grpc_auth_context>(nullptr);
   grpc_auth_context_add_cstring_property(
@@ -320,14 +320,14 @@ grpc_core::RefCountedPtr<grpc_auth_context> grpc_ssl_peer_to_auth_context(
     }
   }
   if (peer_identity_property_name != nullptr) {
-    CHECK(grpc_auth_context_set_peer_identity_property_name(
+    ABSL_CHECK(grpc_auth_context_set_peer_identity_property_name(
               ctx.get(), peer_identity_property_name) == 1);
   }
   // A valid SPIFFE certificate can only have exact one URI SAN field.
   if (has_spiffe_id) {
     if (uri_count == 1) {
-      CHECK_GT(spiffe_length, 0u);
-      CHECK_NE(spiffe_data, nullptr);
+      ABSL_CHECK_GT(spiffe_length, 0u);
+      ABSL_CHECK_NE(spiffe_data, nullptr);
       grpc_auth_context_add_property(ctx.get(),
                                      GRPC_PEER_SPIFFE_ID_PROPERTY_NAME,
                                      spiffe_data, spiffe_length);
@@ -425,7 +425,7 @@ grpc_security_status grpc_ssl_tsi_client_handshaker_factory_init(
     // Use default root certificates.
     root_certs = grpc_core::DefaultSslRootStore::GetPemRootCerts();
     if (root_certs == nullptr) {
-      LOG(ERROR) << "Could not get default pem root certs.";
+      ABSL_LOG(ERROR) << "Could not get default pem root certs.";
       return GRPC_SECURITY_ERROR;
     }
     root_store = grpc_core::DefaultSslRootStore::GetRootStore();
@@ -458,7 +458,7 @@ grpc_security_status grpc_ssl_tsi_client_handshaker_factory_init(
                                                             handshaker_factory);
   gpr_free(options.alpn_protocols);
   if (result != TSI_OK) {
-    LOG(ERROR) << "Handshaker factory creation failed with "
+    ABSL_LOG(ERROR) << "Handshaker factory creation failed with "
                << tsi_result_to_string(result);
     return GRPC_SECURITY_ERROR;
   }
@@ -497,7 +497,7 @@ grpc_security_status grpc_ssl_tsi_server_handshaker_factory_init(
                                                             handshaker_factory);
   gpr_free(alpn_protocol_strings);
   if (result != TSI_OK) {
-    LOG(ERROR) << "Handshaker factory creation failed with "
+    ABSL_LOG(ERROR) << "Handshaker factory creation failed with "
                << tsi_result_to_string(result);
     return GRPC_SECURITY_ERROR;
   }
@@ -575,7 +575,7 @@ grpc_slice DefaultSslRootStore::ComputePemRootCerts() {
     auto slice =
         LoadFile(default_root_certs_path, /*add_null_terminator=*/true);
     if (!slice.ok()) {
-      LOG(ERROR) << "error loading file " << default_root_certs_path << ": "
+      ABSL_LOG(ERROR) << "error loading file " << default_root_certs_path << ": "
                  << slice.status();
     } else {
       result = std::move(*slice);
@@ -587,7 +587,7 @@ grpc_slice DefaultSslRootStore::ComputePemRootCerts() {
     char* pem_root_certs = nullptr;
     ovrd_res = ssl_roots_override_cb(&pem_root_certs);
     if (ovrd_res == GRPC_SSL_ROOTS_OVERRIDE_OK) {
-      CHECK_NE(pem_root_certs, nullptr);
+      ABSL_CHECK_NE(pem_root_certs, nullptr);
       result = Slice::FromCopiedBuffer(
           pem_root_certs,
           strlen(pem_root_certs) + 1);  // nullptr terminator.
@@ -602,7 +602,7 @@ grpc_slice DefaultSslRootStore::ComputePemRootCerts() {
   if (result.empty() && ovrd_res != GRPC_SSL_ROOTS_OVERRIDE_FAIL_PERMANENTLY) {
     auto slice = LoadFile(installed_roots_path, /*add_null_terminator=*/true);
     if (!slice.ok()) {
-      LOG(ERROR) << "error loading file " << installed_roots_path << ": "
+      ABSL_LOG(ERROR) << "error loading file " << installed_roots_path << ": "
                  << slice.status();
     } else {
       result = std::move(*slice);
diff --git a/third_party/grpc/source/src/core/lib/security/security_connector/tls/tls_security_connector.cc b/third_party/grpc/source/src/core/lib/security/security_connector/tls/tls_security_connector.cc
index 40fc246a72dc4..3a9a810d4c063 100644
--- a/third_party/grpc/source/src/core/lib/security/security_connector/tls/tls_security_connector.cc
+++ b/third_party/grpc/source/src/core/lib/security/security_connector/tls/tls_security_connector.cc
@@ -30,8 +30,8 @@
 #include <vector>

 #include "absl/functional/bind_front.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
 #include "src/core/handshaker/security/security_handshaker.h"
@@ -62,7 +62,7 @@ char* CopyCoreString(char* src, size_t length) {
 void PendingVerifierRequestInit(
     const char* target_name, tsi_peer peer,
     grpc_tls_custom_verification_check_request* request) {
-  CHECK_NE(request, nullptr);
+  ABSL_CHECK_NE(request, nullptr);
   // The verifier holds a ref to the security connector, so it's fine to
   // directly point this to the name cached in the security connector.
   request->target_name = target_name;
@@ -174,7 +174,7 @@ void PendingVerifierRequestInit(

 void PendingVerifierRequestDestroy(
     grpc_tls_custom_verification_check_request* request) {
-  CHECK_NE(request, nullptr);
+  ABSL_CHECK_NE(request, nullptr);
   if (request->peer_info.common_name != nullptr) {
     gpr_free(const_cast<char*>(request->peer_info.common_name));
   }
@@ -218,13 +218,13 @@ tsi_ssl_pem_key_cert_pair* ConvertToTsiPemKeyCertPair(
   tsi_ssl_pem_key_cert_pair* tsi_pairs = nullptr;
   size_t num_key_cert_pairs = cert_pair_list.size();
   if (num_key_cert_pairs > 0) {
-    CHECK_NE(cert_pair_list.data(), nullptr);
+    ABSL_CHECK_NE(cert_pair_list.data(), nullptr);
     tsi_pairs = static_cast<tsi_ssl_pem_key_cert_pair*>(
         gpr_zalloc(num_key_cert_pairs * sizeof(tsi_ssl_pem_key_cert_pair)));
   }
   for (size_t i = 0; i < num_key_cert_pairs; i++) {
-    CHECK(!cert_pair_list[i].private_key().empty());
-    CHECK(!cert_pair_list[i].cert_chain().empty());
+    ABSL_CHECK(!cert_pair_list[i].private_key().empty());
+    ABSL_CHECK(!cert_pair_list[i].cert_chain().empty());
     tsi_pairs[i].cert_chain =
         gpr_strdup(cert_pair_list[i].cert_chain().c_str());
     tsi_pairs[i].private_key =
@@ -244,17 +244,17 @@ TlsChannelSecurityConnector::CreateTlsChannelSecurityConnector(
     const char* target_name, const char* overridden_target_name,
     tsi_ssl_session_cache* ssl_session_cache) {
   if (channel_creds == nullptr) {
-    LOG(ERROR) << "channel_creds is nullptr in "
+    ABSL_LOG(ERROR) << "channel_creds is nullptr in "
                   "TlsChannelSecurityConnectorCreate()";
     return nullptr;
   }
   if (options == nullptr) {
-    LOG(ERROR) << "options is nullptr in "
+    ABSL_LOG(ERROR) << "options is nullptr in "
                   "TlsChannelSecurityConnectorCreate()";
     return nullptr;
   }
   if (target_name == nullptr) {
-    LOG(ERROR) << "target_name is nullptr in "
+    ABSL_LOG(ERROR) << "target_name is nullptr in "
                   "TlsChannelSecurityConnectorCreate()";
     return nullptr;
   }
@@ -349,7 +349,7 @@ void TlsChannelSecurityConnector::add_handshakers(
         /*network_bio_buf_size=*/0,
         /*ssl_bio_buf_size=*/0, &tsi_hs);
     if (result != TSI_OK) {
-      LOG(ERROR) << "Handshaker creation failed with error "
+      ABSL_LOG(ERROR) << "Handshaker creation failed with error "
                  << tsi_result_to_string(result);
     }
   }
@@ -372,7 +372,7 @@ void TlsChannelSecurityConnector::check_peer(
   }
   *auth_context =
       grpc_ssl_peer_to_auth_context(&peer, GRPC_TLS_TRANSPORT_SECURITY_TYPE);
-  CHECK_NE(options_->certificate_verifier(), nullptr);
+  ABSL_CHECK_NE(options_->certificate_verifier(), nullptr);
   auto* pending_request = new ChannelPendingVerifierRequest(
       RefAsSubclass<TlsChannelSecurityConnector>(), on_peer_checked, peer,
       target_name);
@@ -395,7 +395,7 @@ void TlsChannelSecurityConnector::cancel_check_peer(
       if (it != pending_verifier_requests_.end()) {
         pending_verifier_request = it->second->request();
       } else {
-        VLOG(2) << "TlsChannelSecurityConnector::cancel_check_peer: no "
+        ABSL_VLOG(2) << "TlsChannelSecurityConnector::cancel_check_peer: no "
                    "corresponding pending request found";
       }
     }
@@ -430,7 +430,7 @@ ArenaPromise<absl::Status> TlsChannelSecurityConnector::CheckCallHost(
 void TlsChannelSecurityConnector::TlsChannelCertificateWatcher::
     OnCertificatesChanged(std::optional<absl::string_view> root_certs,
                           std::optional<PemKeyCertPairList> key_cert_pairs) {
-  CHECK_NE(security_connector_, nullptr);
+  ABSL_CHECK_NE(security_connector_, nullptr);
   MutexLock lock(&security_connector_->mu_);
   if (root_certs.has_value()) {
     security_connector_->pem_root_certs_ = root_certs;
@@ -446,7 +446,7 @@ void TlsChannelSecurityConnector::TlsChannelCertificateWatcher::
   if (root_ready && identity_ready) {
     if (security_connector_->UpdateHandshakerFactoryLocked() !=
         GRPC_SECURITY_OK) {
-      LOG(ERROR) << "Update handshaker factory failed.";
+      ABSL_LOG(ERROR) << "Update handshaker factory failed.";
     }
   }
 }
@@ -456,11 +456,11 @@ void TlsChannelSecurityConnector::TlsChannelCertificateWatcher::
 void TlsChannelSecurityConnector::TlsChannelCertificateWatcher::OnError(
     grpc_error_handle root_cert_error, grpc_error_handle identity_cert_error) {
   if (!root_cert_error.ok()) {
-    LOG(ERROR) << "TlsChannelCertificateWatcher getting root_cert_error: "
+    ABSL_LOG(ERROR) << "TlsChannelCertificateWatcher getting root_cert_error: "
                << StatusToString(root_cert_error);
   }
   if (!identity_cert_error.ok()) {
-    LOG(ERROR) << "TlsChannelCertificateWatcher getting identity_cert_error: "
+    ABSL_LOG(ERROR) << "TlsChannelCertificateWatcher getting identity_cert_error: "
                << StatusToString(identity_cert_error);
   }
 }
@@ -557,12 +557,12 @@ TlsServerSecurityConnector::CreateTlsServerSecurityConnector(
     RefCountedPtr<grpc_server_credentials> server_creds,
     RefCountedPtr<grpc_tls_credentials_options> options) {
   if (server_creds == nullptr) {
-    LOG(ERROR) << "server_creds is nullptr in "
+    ABSL_LOG(ERROR) << "server_creds is nullptr in "
                   "TlsServerSecurityConnectorCreate()";
     return nullptr;
   }
   if (options == nullptr) {
-    LOG(ERROR) << "options is nullptr in "
+    ABSL_LOG(ERROR) << "options is nullptr in "
                   "TlsServerSecurityConnectorCreate()";
     return nullptr;
   }
@@ -623,7 +623,7 @@ void TlsServerSecurityConnector::add_handshakers(
         server_handshaker_factory_, /*network_bio_buf_size=*/0,
         /*ssl_bio_buf_size=*/0, &tsi_hs);
     if (result != TSI_OK) {
-      LOG(ERROR) << "Handshaker creation failed with error "
+      ABSL_LOG(ERROR) << "Handshaker creation failed with error "
                  << tsi_result_to_string(result);
     }
   }
@@ -669,7 +669,7 @@ void TlsServerSecurityConnector::cancel_check_peer(
       if (it != pending_verifier_requests_.end()) {
         pending_verifier_request = it->second->request();
       } else {
-        LOG(INFO) << "TlsServerSecurityConnector::cancel_check_peer: no "
+        ABSL_LOG(INFO) << "TlsServerSecurityConnector::cancel_check_peer: no "
                      "corresponding pending request found";
       }
     }
@@ -690,7 +690,7 @@ int TlsServerSecurityConnector::cmp(
 void TlsServerSecurityConnector::TlsServerCertificateWatcher::
     OnCertificatesChanged(std::optional<absl::string_view> root_certs,
                           std::optional<PemKeyCertPairList> key_cert_pairs) {
-  CHECK_NE(security_connector_, nullptr);
+  ABSL_CHECK_NE(security_connector_, nullptr);
   MutexLock lock(&security_connector_->mu_);
   if (root_certs.has_value()) {
     security_connector_->pem_root_certs_ = root_certs;
@@ -710,7 +710,7 @@ void TlsServerSecurityConnector::TlsServerCertificateWatcher::
       (!root_being_watched && identity_being_watched && identity_has_value)) {
     if (security_connector_->UpdateHandshakerFactoryLocked() !=
         GRPC_SECURITY_OK) {
-      LOG(ERROR) << "Update handshaker factory failed.";
+      ABSL_LOG(ERROR) << "Update handshaker factory failed.";
     }
   }
 }
@@ -720,11 +720,11 @@ void TlsServerSecurityConnector::TlsServerCertificateWatcher::
 void TlsServerSecurityConnector::TlsServerCertificateWatcher::OnError(
     grpc_error_handle root_cert_error, grpc_error_handle identity_cert_error) {
   if (!root_cert_error.ok()) {
-    LOG(ERROR) << "TlsServerCertificateWatcher getting root_cert_error: "
+    ABSL_LOG(ERROR) << "TlsServerCertificateWatcher getting root_cert_error: "
                << StatusToString(root_cert_error);
   }
   if (!identity_cert_error.ok()) {
-    LOG(ERROR) << "TlsServerCertificateWatcher getting identity_cert_error: "
+    ABSL_LOG(ERROR) << "TlsServerCertificateWatcher getting identity_cert_error: "
                << StatusToString(identity_cert_error);
   }
 }
@@ -787,8 +787,8 @@ TlsServerSecurityConnector::UpdateHandshakerFactoryLocked() {
     tsi_ssl_server_handshaker_factory_unref(server_handshaker_factory_);
   }
   // The identity certs on the server side shouldn't be empty.
-  CHECK(pem_key_cert_pair_list_.has_value());
-  CHECK(!(*pem_key_cert_pair_list_).empty());
+  ABSL_CHECK(pem_key_cert_pair_list_.has_value());
+  ABSL_CHECK(!(*pem_key_cert_pair_list_).empty());
   std::string pem_root_certs;
   if (pem_root_certs_.has_value()) {
     // TODO(ZhenLian): update the underlying TSI layer to use C++ types like
diff --git a/third_party/grpc/source/src/core/lib/security/transport/server_auth_filter.cc b/third_party/grpc/source/src/core/lib/security/transport/server_auth_filter.cc
index ebd3ee467c8cd..c0c08c7044808 100644
--- a/third_party/grpc/source/src/core/lib/security/transport/server_auth_filter.cc
+++ b/third_party/grpc/source/src/core/lib/security/transport/server_auth_filter.cc
@@ -30,8 +30,8 @@
 #include <memory>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "src/core/lib/channel/channel_args.h"
@@ -151,7 +151,7 @@ void ServerAuthFilter::RunApplicationCode::OnMdProcessingDone(

   // TODO(ZhenLian): Implement support for response_md.
   if (response_md != nullptr && num_response_md > 0) {
-    LOG(ERROR) << "response_md in auth metadata processing not supported for "
+    ABSL_LOG(ERROR) << "response_md in auth metadata processing not supported for "
                   "now. Ignoring...";
   }

@@ -199,7 +199,7 @@ ServerAuthFilter::ServerAuthFilter(
 absl::StatusOr<std::unique_ptr<ServerAuthFilter>> ServerAuthFilter::Create(
     const ChannelArgs& args, ChannelFilter::Args) {
   auto auth_context = args.GetObjectRef<grpc_auth_context>();
-  CHECK(auth_context != nullptr);
+  ABSL_CHECK(auth_context != nullptr);
   auto creds = args.GetObjectRef<grpc_server_credentials>();
   return std::make_unique<ServerAuthFilter>(std::move(creds),
                                             std::move(auth_context));
diff --git a/third_party/grpc/source/src/core/lib/slice/percent_encoding.cc b/third_party/grpc/source/src/core/lib/slice/percent_encoding.cc
index 88af7e0a20fde..ba74e24c4607d 100644
--- a/third_party/grpc/source/src/core/lib/slice/percent_encoding.cc
+++ b/third_party/grpc/source/src/core/lib/slice/percent_encoding.cc
@@ -24,7 +24,7 @@
 #include <cstdint>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/util/bitset.h"

 namespace grpc_core {
@@ -99,7 +99,7 @@ Slice PercentEncodeSlice(Slice slice, PercentEncodingType type) {
       *q++ = hex[c & 15];
     }
   }
-  CHECK(q == out.end());
+  ABSL_CHECK(q == out.end());
   return Slice(std::move(out));
 }

diff --git a/third_party/grpc/source/src/core/lib/slice/slice.cc b/third_party/grpc/source/src/core/lib/slice/slice.cc
index 52af6a4e28875..237fb6f422b41 100644
--- a/third_party/grpc/source/src/core/lib/slice/slice.cc
+++ b/third_party/grpc/source/src/core/lib/slice/slice.cc
@@ -25,7 +25,7 @@

 #include <new>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/slice/slice_internal.h"
 #include "src/core/lib/slice/slice_refcount.h"
 #include "src/core/util/memory.h"
@@ -243,11 +243,11 @@ static grpc_slice sub_no_ref(const grpc_slice& source, size_t begin,
                              size_t end) {
   grpc_slice subset;

-  CHECK(end >= begin);
+  ABSL_CHECK(end >= begin);

   if (source.refcount != nullptr) {
     // Enforce preconditions
-    CHECK(source.data.refcounted.length >= end);
+    ABSL_CHECK(source.data.refcounted.length >= end);

     // Build the result
     subset.refcount = source.refcount;
@@ -256,7 +256,7 @@ static grpc_slice sub_no_ref(const grpc_slice& source, size_t begin,
     subset.data.refcounted.length = end - begin;
   } else {
     // Enforce preconditions
-    CHECK(source.data.inlined.length >= end);
+    ABSL_CHECK(source.data.inlined.length >= end);
     subset.refcount = nullptr;
     subset.data.inlined.length = static_cast<uint8_t>(end - begin);
     memcpy(subset.data.inlined.bytes, source.data.inlined.bytes + begin,
@@ -295,7 +295,7 @@ grpc_slice grpc_slice_split_tail_maybe_ref_impl(grpc_slice* source,

   if (source->refcount == nullptr) {
     // inlined data, copy it out
-    CHECK(source->data.inlined.length >= split);
+    ABSL_CHECK(source->data.inlined.length >= split);
     tail.refcount = nullptr;
     tail.data.inlined.length =
         static_cast<uint8_t>(source->data.inlined.length - split);
@@ -310,7 +310,7 @@ grpc_slice grpc_slice_split_tail_maybe_ref_impl(grpc_slice* source,
     source->data.refcounted.length = split;
   } else {
     size_t tail_length = source->data.refcounted.length - split;
-    CHECK(source->data.refcounted.length >= split);
+    ABSL_CHECK(source->data.refcounted.length >= split);
     if (allow_inline && tail_length < sizeof(tail.data.inlined.bytes) &&
         ref_whom != GRPC_SLICE_REF_TAIL) {
       // Copy out the bytes - it'll be cheaper than refcounting
@@ -370,7 +370,7 @@ grpc_slice grpc_slice_split_head_impl(grpc_slice* source, size_t split) {
   grpc_slice head;

   if (source->refcount == nullptr) {
-    CHECK(source->data.inlined.length >= split);
+    ABSL_CHECK(source->data.inlined.length >= split);

     head.refcount = nullptr;
     head.data.inlined.length = static_cast<uint8_t>(split);
@@ -380,7 +380,7 @@ grpc_slice grpc_slice_split_head_impl(grpc_slice* source, size_t split) {
     memmove(source->data.inlined.bytes, source->data.inlined.bytes + split,
             source->data.inlined.length);
   } else if (allow_inline && split < sizeof(head.data.inlined.bytes)) {
-    CHECK(source->data.refcounted.length >= split);
+    ABSL_CHECK(source->data.refcounted.length >= split);

     head.refcount = nullptr;
     head.data.inlined.length = static_cast<uint8_t>(split);
@@ -388,7 +388,7 @@ grpc_slice grpc_slice_split_head_impl(grpc_slice* source, size_t split) {
     source->data.refcounted.bytes += split;
     source->data.refcounted.length -= split;
   } else {
-    CHECK(source->data.refcounted.length >= split);
+    ABSL_CHECK(source->data.refcounted.length >= split);

     // Build the result
     head.refcount = source->refcount;
diff --git a/third_party/grpc/source/src/core/lib/slice/slice.h b/third_party/grpc/source/src/core/lib/slice/slice.h
index 6a84345d8382c..2ac37a686a6b4 100644
--- a/third_party/grpc/source/src/core/lib/slice/slice.h
+++ b/third_party/grpc/source/src/core/lib/slice/slice.h
@@ -25,7 +25,7 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/string_view.h"
 #include "src/core/lib/slice/slice_internal.h"
 #include "src/core/lib/slice/slice_refcount.h"
@@ -241,7 +241,7 @@ class StaticSlice : public slice_detail::BaseSlice,
   StaticSlice() = default;
   explicit StaticSlice(const grpc_slice& slice)
       : slice_detail::BaseSlice(slice) {
-    DCHECK(slice.refcount == grpc_slice_refcount::NoopRefcount());
+    ABSL_DCHECK(slice.refcount == grpc_slice_refcount::NoopRefcount());
   }

   StaticSlice(const StaticSlice& other)
@@ -265,7 +265,7 @@ class GPR_MSVC_EMPTY_BASE_CLASS_WORKAROUND MutableSlice
   MutableSlice() = default;
   explicit MutableSlice(const grpc_slice& slice)
       : slice_detail::BaseSlice(slice) {
-    DCHECK(slice.refcount == nullptr || slice.refcount->IsUnique());
+    ABSL_DCHECK(slice.refcount == nullptr || slice.refcount->IsUnique());
   }
   ~MutableSlice() { CSliceUnref(c_slice()); }

diff --git a/third_party/grpc/source/src/core/lib/slice/slice_buffer.cc b/third_party/grpc/source/src/core/lib/slice/slice_buffer.cc
index 9b6b3a3f69b39..3edba3437a5af 100644
--- a/third_party/grpc/source/src/core/lib/slice/slice_buffer.cc
+++ b/third_party/grpc/source/src/core/lib/slice/slice_buffer.cc
@@ -26,7 +26,7 @@

 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/slice/slice_internal.h"

 namespace grpc_core {
@@ -79,7 +79,7 @@ Slice SliceBuffer::JoinIntoSlice() const {
            GRPC_SLICE_LENGTH(slice_buffer_.slices[i]));
     ofs += GRPC_SLICE_LENGTH(slice_buffer_.slices[i]);
   }
-  CHECK(ofs == slice_buffer_.length);
+  ABSL_CHECK(ofs == slice_buffer_.length);
   return Slice(slice);
 }

@@ -329,7 +329,7 @@ static void slice_buffer_move_first_maybe_ref(grpc_slice_buffer* src, size_t n,
     return;
   }

-  CHECK(src->length >= n);
+  ABSL_CHECK(src->length >= n);
   if (src->length == n) {
     grpc_slice_buffer_move_into(src, dst);
     return;
@@ -357,7 +357,7 @@ static void slice_buffer_move_first_maybe_ref(grpc_slice_buffer* src, size_t n,
             src, grpc_slice_split_tail_maybe_ref_no_inline(
                      &slice, n, GRPC_SLICE_REF_BOTH));
       }
-      CHECK(GRPC_SLICE_LENGTH(slice) == n);
+      ABSL_CHECK(GRPC_SLICE_LENGTH(slice) == n);
       grpc_slice_buffer_add(dst, slice);
       break;
     } else {  // n < slice_len
@@ -370,14 +370,14 @@ static void slice_buffer_move_first_maybe_ref(grpc_slice_buffer* src, size_t n,
             src, grpc_slice_split_tail_maybe_ref_no_inline(
                      &slice, n, GRPC_SLICE_REF_TAIL));
       }
-      CHECK(GRPC_SLICE_LENGTH(slice) == n);
+      ABSL_CHECK(GRPC_SLICE_LENGTH(slice) == n);
       grpc_slice_buffer_add_indexed(dst, slice);
       break;
     }
   }
-  CHECK(dst->length == output_len);
-  CHECK(src->length == new_input_len);
-  CHECK_GT(src->count, 0u);
+  ABSL_CHECK(dst->length == output_len);
+  ABSL_CHECK(src->length == new_input_len);
+  ABSL_CHECK_GT(src->count, 0u);
 }

 void grpc_slice_buffer_move_first_no_inline(grpc_slice_buffer* src, size_t n,
@@ -398,7 +398,7 @@ void grpc_slice_buffer_move_first_no_ref(grpc_slice_buffer* src, size_t n,
 void grpc_slice_buffer_move_first_into_buffer(grpc_slice_buffer* src, size_t n,
                                               void* dst) {
   char* dstp = static_cast<char*>(dst);
-  CHECK(src->length >= n);
+  ABSL_CHECK(src->length >= n);

   while (n > 0) {
     grpc_slice slice = grpc_slice_buffer_take_first(src);
@@ -424,7 +424,7 @@ void grpc_slice_buffer_move_first_into_buffer(grpc_slice_buffer* src, size_t n,
 void grpc_slice_buffer_copy_first_into_buffer(const grpc_slice_buffer* src,
                                               size_t n, void* dst) {
   uint8_t* dstp = static_cast<uint8_t*>(dst);
-  CHECK(src->length >= n);
+  ABSL_CHECK(src->length >= n);

   for (size_t i = 0; i < src->count; i++) {
     grpc_slice slice = src->slices[i];
@@ -442,7 +442,7 @@ template <bool allow_inline>
 void grpc_slice_buffer_trim_end_impl(grpc_slice_buffer* sb, size_t n,
                                      grpc_slice_buffer* garbage) {
   if (n == 0) return;
-  CHECK(n <= sb->length);
+  ABSL_CHECK(n <= sb->length);
   sb->length -= n;
   for (;;) {
     size_t idx = sb->count - 1;
@@ -493,7 +493,7 @@ void grpc_slice_buffer_trim_end(grpc_slice_buffer* sb, size_t n,

 grpc_slice grpc_slice_buffer_take_first(grpc_slice_buffer* sb) {
   grpc_slice slice;
-  CHECK_GT(sb->count, 0u);
+  ABSL_CHECK_GT(sb->count, 0u);
   slice = sb->slices[0];
   sb->slices++;
   sb->count--;
@@ -503,7 +503,7 @@ grpc_slice grpc_slice_buffer_take_first(grpc_slice_buffer* sb) {
 }

 void grpc_slice_buffer_remove_first(grpc_slice_buffer* sb) {
-  DCHECK_GT(sb->count, 0u);
+  ABSL_DCHECK_GT(sb->count, 0u);
   sb->length -= GRPC_SLICE_LENGTH(sb->slices[0]);
   grpc_core::CSliceUnref(sb->slices[0]);
   sb->slices++;
diff --git a/third_party/grpc/source/src/core/lib/slice/slice_internal.h b/third_party/grpc/source/src/core/lib/slice/slice_internal.h
index 9c05f6fdacdeb..98e37186e96c8 100644
--- a/third_party/grpc/source/src/core/lib/slice/slice_internal.h
+++ b/third_party/grpc/source/src/core/lib/slice/slice_internal.h
@@ -27,14 +27,14 @@
 #include <string>

 #include "absl/hash/hash.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/string_view.h"
 #include "src/core/util/memory.h"

 // Returns a pointer to the first slice in the slice buffer without giving
 // ownership to or a reference count on that slice.
 inline grpc_slice* grpc_slice_buffer_peek_first(grpc_slice_buffer* sb) {
-  DCHECK_GT(sb->count, 0u);
+  ABSL_DCHECK_GT(sb->count, 0u);
   return &sb->slices[0];
 }

diff --git a/third_party/grpc/source/src/core/lib/surface/byte_buffer_reader.cc b/third_party/grpc/source/src/core/lib/surface/byte_buffer_reader.cc
index 52bf3795c905e..4d90ec97b248e 100644
--- a/third_party/grpc/source/src/core/lib/surface/byte_buffer_reader.cc
+++ b/third_party/grpc/source/src/core/lib/surface/byte_buffer_reader.cc
@@ -24,7 +24,7 @@
 #include <stdint.h>
 #include <string.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
 #include "src/core/lib/slice/slice.h"

@@ -92,7 +92,7 @@ grpc_slice grpc_byte_buffer_reader_readall(grpc_byte_buffer_reader* reader) {
     memcpy(&(outbuf[bytes_read]), GRPC_SLICE_START_PTR(in_slice), slice_length);
     bytes_read += slice_length;
     grpc_core::CSliceUnref(in_slice);
-    CHECK(bytes_read <= input_size);
+    ABSL_CHECK(bytes_read <= input_size);
   }

   return out_slice;
diff --git a/third_party/grpc/source/src/core/lib/surface/call.cc b/third_party/grpc/source/src/core/lib/surface/call.cc
index 95f42cf41f877..745756f7b0ae6 100644
--- a/third_party/grpc/source/src/core/lib/surface/call.cc
+++ b/third_party/grpc/source/src/core/lib/surface/call.cc
@@ -48,8 +48,8 @@
 #include <vector>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
@@ -119,8 +119,8 @@ Call::Call(bool is_client, Timestamp send_deadline, RefCountedPtr<Arena> arena)
     : arena_(std::move(arena)),
       send_deadline_(send_deadline),
       is_client_(is_client) {
-  DCHECK_NE(arena_.get(), nullptr);
-  DCHECK_NE(arena_->GetContext<grpc_event_engine::experimental::EventEngine>(),
+  ABSL_DCHECK_NE(arena_.get(), nullptr);
+  ABSL_DCHECK_NE(arena_->GetContext<grpc_event_engine::experimental::EventEngine>(),
             nullptr);
   arena_->SetContext<Call>(this);
 }
@@ -148,8 +148,8 @@ absl::Status Call::InitParent(Call* parent, uint32_t propagation_mask) {
   child_ = arena()->New<ChildCall>(parent);

   parent->InternalRef("child");
-  CHECK(is_client_);
-  CHECK(!parent->is_client_);
+  ABSL_CHECK(is_client_);
+  ABSL_CHECK(!parent->is_client_);

   if (propagation_mask & GRPC_PROPAGATE_DEADLINE) {
     send_deadline_ = std::min(send_deadline_, parent->send_deadline_);
@@ -303,7 +303,7 @@ void Call::ProcessIncomingInitialMetadata(grpc_metadata_batch& md) {
     HandleCompressionAlgorithmDisabled(compression_algorithm);
   }
   // GRPC_COMPRESS_NONE is always set.
-  DCHECK(encodings_accepted_by_peer_.IsSet(GRPC_COMPRESS_NONE));
+  ABSL_DCHECK(encodings_accepted_by_peer_.IsSet(GRPC_COMPRESS_NONE));
   if (GPR_UNLIKELY(!encodings_accepted_by_peer_.IsSet(compression_algorithm))) {
     if (GRPC_TRACE_FLAG_ENABLED(compression)) {
       HandleCompressionAlgorithmNotAccepted(compression_algorithm);
@@ -315,7 +315,7 @@ void Call::HandleCompressionAlgorithmNotAccepted(
     grpc_compression_algorithm compression_algorithm) {
   const char* algo_name = nullptr;
   grpc_compression_algorithm_name(compression_algorithm, &algo_name);
-  LOG(ERROR) << "Compression algorithm ('" << algo_name
+  ABSL_LOG(ERROR) << "Compression algorithm ('" << algo_name
              << "') not present in the accepted encodings ("
              << encodings_accepted_by_peer_.ToString() << ")";
 }
@@ -326,7 +326,7 @@ void Call::HandleCompressionAlgorithmDisabled(
   grpc_compression_algorithm_name(compression_algorithm, &algo_name);
   std::string error_msg =
       absl::StrFormat("Compression algorithm '%s' is disabled.", algo_name);
-  LOG(ERROR) << error_msg;
+  ABSL_LOG(ERROR) << error_msg;
   CancelWithError(grpc_error_set_int(absl::UnimplementedError(error_msg),
                                      StatusIntProperty::kRpcStatus,
                                      GRPC_STATUS_UNIMPLEMENTED));
@@ -410,7 +410,7 @@ char* grpc_call_get_peer(grpc_call* call) {
 grpc_call_error grpc_call_cancel(grpc_call* call, void* reserved) {
   GRPC_TRACE_LOG(api, INFO)
       << "grpc_call_cancel(call=" << call << ", reserved=" << reserved << ")";
-  CHECK_EQ(reserved, nullptr);
+  ABSL_CHECK_EQ(reserved, nullptr);
   if (call == nullptr) {
     return GRPC_CALL_ERROR;
   }
@@ -427,7 +427,7 @@ grpc_call_error grpc_call_cancel_with_status(grpc_call* c,
   GRPC_TRACE_LOG(api, INFO)
       << "grpc_call_cancel_with_status(c=" << c << ", status=" << (int)status
       << ", description=" << description << ", reserved=" << reserved << ")";
-  CHECK_EQ(reserved, nullptr);
+  ABSL_CHECK_EQ(reserved, nullptr);
   if (c == nullptr) {
     return GRPC_CALL_ERROR;
   }
diff --git a/third_party/grpc/source/src/core/lib/surface/call.h b/third_party/grpc/source/src/core/lib/surface/call.h
index bc7220ac60918..280443aa01d40 100644
--- a/third_party/grpc/source/src/core/lib/surface/call.h
+++ b/third_party/grpc/source/src/core/lib/surface/call.h
@@ -30,7 +30,7 @@

 #include "absl/functional/any_invocable.h"
 #include "absl/functional/function_ref.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/string_view.h"
 #include "src/core/lib/channel/channel_fwd.h"
 #include "src/core/lib/channel/channel_stack.h"
diff --git a/third_party/grpc/source/src/core/lib/surface/call_log_batch.cc b/third_party/grpc/source/src/core/lib/surface/call_log_batch.cc
index 2162ac2831b1a..1aa82121b0120 100644
--- a/third_party/grpc/source/src/core/lib/surface/call_log_batch.cc
+++ b/third_party/grpc/source/src/core/lib/surface/call_log_batch.cc
@@ -106,7 +106,7 @@ static std::string grpc_op_string(const grpc_op* op) {
 void grpc_call_log_batch(const char* file, int line, const grpc_op* ops,
                          size_t nops) {
   for (size_t i = 0; i < nops; i++) {
-    LOG(INFO).AtLocation(file, line)
+    ABSL_LOG(INFO).AtLocation(file, line)
         << "ops[" << i << "]: " << grpc_op_string(&ops[i]);
   }
 }
diff --git a/third_party/grpc/source/src/core/lib/surface/call_utils.cc b/third_party/grpc/source/src/core/lib/surface/call_utils.cc
index bb67b1b4f559d..b070e7c8ba5a3 100644
--- a/third_party/grpc/source/src/core/lib/surface/call_utils.cc
+++ b/third_party/grpc/source/src/core/lib/surface/call_utils.cc
@@ -40,8 +40,8 @@
 #include <type_traits>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
@@ -86,7 +86,7 @@ void CToMetadata(grpc_metadata* metadata, size_t count,
     if (key == "content-length") continue;
     b->Append(key, Slice(CSliceRef(md->value)),
               [md](absl::string_view error, const Slice& value) {
-                VLOG(2) << "Append error: key=" << StringViewFromSlice(md->key)
+                ABSL_VLOG(2) << "Append error: key=" << StringViewFromSlice(md->key)
                         << " error=" << error
                         << " value=" << value.as_string_view();
               });
@@ -215,7 +215,7 @@ bool ValidateMetadata(size_t count, grpc_metadata* metadata) {
 void EndOpImmediately(grpc_completion_queue* cq, void* notify_tag,
                       bool is_notify_tag_closure) {
   if (!is_notify_tag_closure) {
-    CHECK(grpc_cq_begin_op(cq, notify_tag));
+    ABSL_CHECK(grpc_cq_begin_op(cq, notify_tag));
     grpc_cq_end_op(
         cq, notify_tag, absl::OkStatus(),
         [](void*, grpc_cq_completion* completion) { gpr_free(completion); },
diff --git a/third_party/grpc/source/src/core/lib/surface/call_utils.h b/third_party/grpc/source/src/core/lib/surface/call_utils.h
index 1f92267b1fe74..362b6b1ba9a0f 100644
--- a/third_party/grpc/source/src/core/lib/surface/call_utils.h
+++ b/third_party/grpc/source/src/core/lib/surface/call_utils.h
@@ -40,7 +40,7 @@
 #include <type_traits>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
@@ -428,7 +428,7 @@ class MessageReceiver {

   template <typename Puller>
   auto MakeBatchOp(const grpc_op& op, Puller* puller) {
-    CHECK_EQ(recv_message_, nullptr);
+    ABSL_CHECK_EQ(recv_message_, nullptr);
     recv_message_ = op.data.recv_message.recv_message;
     return [this, puller]() mutable {
       return Map(puller->PullMessage(),
diff --git a/third_party/grpc/source/src/core/lib/surface/channel.cc b/third_party/grpc/source/src/core/lib/surface/channel.cc
index bc2b62c134016..db90c7604b3d2 100644
--- a/third_party/grpc/source/src/core/lib/surface/channel.cc
+++ b/third_party/grpc/source/src/core/lib/surface/channel.cc
@@ -22,7 +22,7 @@
 #include <grpc/support/alloc.h>
 #include <grpc/support/port_platform.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/channelz/channel_trace.h"
 #include "src/core/channelz/channelz.h"
 #include "src/core/lib/channel/channel_args.h"
@@ -103,7 +103,7 @@ grpc_call* grpc_channel_create_call(grpc_channel* channel,
                                     grpc_completion_queue* completion_queue,
                                     grpc_slice method, const grpc_slice* host,
                                     gpr_timespec deadline, void* reserved) {
-  CHECK(!reserved);
+  ABSL_CHECK(!reserved);
   grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;
   grpc_core::ExecCtx exec_ctx;
   return grpc_core::Channel::FromC(channel)->CreateCall(
@@ -121,7 +121,7 @@ void* grpc_channel_register_call(grpc_channel* channel, const char* method,
   GRPC_TRACE_LOG(api, INFO) << "grpc_channel_register_call(channel=" << channel
                             << ", method=" << method << ", host=" << host
                             << ", reserved=" << reserved << ")";
-  CHECK(!reserved);
+  ABSL_CHECK(!reserved);
   grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;
   grpc_core::ExecCtx exec_ctx;
   return grpc_core::Channel::FromC(channel)->RegisterCall(method, host);
@@ -216,6 +216,6 @@ void grpc_channel_ping(grpc_channel* channel, grpc_completion_queue* cq,
   GRPC_TRACE_LOG(api, INFO)
       << "grpc_channel_ping(channel=" << channel << ", cq=" << cq
       << ", tag=" << tag << ", reserved=" << reserved << ")";
-  CHECK_EQ(reserved, nullptr);
+  ABSL_CHECK_EQ(reserved, nullptr);
   grpc_core::Channel::FromC(channel)->Ping(cq, tag);
 }
diff --git a/third_party/grpc/source/src/core/lib/surface/channel_create.cc b/third_party/grpc/source/src/core/lib/surface/channel_create.cc
index e14b3aa3683c1..242950cc51bf9 100644
--- a/third_party/grpc/source/src/core/lib/surface/channel_create.cc
+++ b/third_party/grpc/source/src/core/lib/surface/channel_create.cc
@@ -20,7 +20,7 @@
 #include <grpc/impl/channel_arg_names.h>
 #include <grpc/support/port_platform.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/channelz/channelz.h"
 #include "src/core/client_channel/client_channel.h"
 #include "src/core/client_channel/direct_channel.h"
@@ -120,6 +120,6 @@ grpc_channel* grpc_lame_client_channel_create(const char* target,
   auto channel =
       grpc_core::ChannelCreate(target == nullptr ? "" : target, std::move(args),
                                GRPC_CLIENT_LAME_CHANNEL, nullptr);
-  CHECK(channel.ok());
+  ABSL_CHECK(channel.ok());
   return channel->release()->c_ptr();
 }
diff --git a/third_party/grpc/source/src/core/lib/surface/channel_init.cc b/third_party/grpc/source/src/core/lib/surface/channel_init.cc
index d458888bcd8d6..f41078174f0a2 100644
--- a/third_party/grpc/source/src/core/lib/surface/channel_init.cc
+++ b/third_party/grpc/source/src/core/lib/surface/channel_init.cc
@@ -29,8 +29,8 @@
 #include <string>
 #include <type_traits>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_join.h"
 #include "absl/strings/string_view.h"
@@ -152,7 +152,7 @@ class ChannelInit::DependencyTracker {

   FilterRegistration* Next() {
     if (ready_dependencies_.empty()) {
-      CHECK_EQ(nodes_taken_, nodes_.size()) << "Unresolvable graph of channel "
+      ABSL_CHECK_EQ(nodes_taken_, nodes_.size()) << "Unresolvable graph of channel "
                                                "filters:\n"
                                             << GraphString();
       return nullptr;
@@ -164,13 +164,13 @@ class ChannelInit::DependencyTracker {
       // Constraint: if we use ordering other than default, then we must have an
       // unambiguous pick. If there is ambiguity, we must fix it by adding
       // explicit ordering constraints.
-      CHECK_NE(next.node->ordering(),
+      ABSL_CHECK_NE(next.node->ordering(),
                ready_dependencies_.top().node->ordering())
           << "Ambiguous ordering between " << next.node->name() << " and "
           << ready_dependencies_.top().node->name();
     }
     for (Node* dependent : next.node->dependents) {
-      CHECK_GT(dependent->waiting_dependencies, 0u);
+      ABSL_CHECK_GT(dependent->waiting_dependencies, 0u);
       --dependent->waiting_dependencies;
       if (dependent->waiting_dependencies == 0) {
         ready_dependencies_.emplace(dependent);
@@ -195,7 +195,7 @@ class ChannelInit::DependencyTracker {

   absl::Span<const UniqueTypeName> DependenciesFor(UniqueTypeName name) const {
     auto it = nodes_.find(name);
-    CHECK(it != nodes_.end()) << "Filter " << name.name() << " not found";
+    ABSL_CHECK(it != nodes_.end()) << "Filter " << name.name() << " not found";
     return it->second.all_dependencies;
   }

@@ -246,10 +246,10 @@ ChannelInit::StackConfig ChannelInit::BuildStackConfig(
   std::vector<Filter> terminal_filters;
   for (const auto& registration : registrations) {
     if (registration->terminal_) {
-      CHECK(registration->after_.empty());
-      CHECK(registration->before_.empty());
-      CHECK(!registration->before_all_);
-      CHECK_EQ(registration->ordering_, Ordering::kDefault);
+      ABSL_CHECK(registration->after_.empty());
+      ABSL_CHECK(registration->before_.empty());
+      ABSL_CHECK(!registration->before_all_);
+      ABSL_CHECK_EQ(registration->ordering_, Ordering::kDefault);
       terminal_filters.emplace_back(
           registration->name_, registration->filter_, nullptr,
           std::move(registration->predicates_), registration->version_,
@@ -308,7 +308,7 @@ ChannelInit::StackConfig ChannelInit::BuildStackConfig(
   // Right now it forces too many tests to know about channel initialization,
   // either by supplying a valid configuration or by including an opt-out flag.
   if (terminal_filters.empty() && type != GRPC_CLIENT_DYNAMIC) {
-    LOG(ERROR) << "No terminal filters registered for channel stack type "
+    ABSL_LOG(ERROR) << "No terminal filters registered for channel stack type "
                << grpc_channel_stack_type_string(type)
                << "; this is common for unit tests messing with "
                   "CoreConfiguration, but will result in a "
@@ -333,7 +333,7 @@ void ChannelInit::PrintChannelStackTrace(
   MutexLock lock(m);
   // List the channel stack type (since we'll be repeatedly printing graphs in
   // this loop).
-  LOG(INFO) << "ORDERED CHANNEL STACK " << grpc_channel_stack_type_string(type)
+  ABSL_LOG(INFO) << "ORDERED CHANNEL STACK " << grpc_channel_stack_type_string(type)
             << ":";
   // First build up a map of filter -> file:line: strings, because it helps
   // the readability of this log to get later fields aligned vertically.
@@ -392,7 +392,7 @@ void ChannelInit::PrintChannelStackTrace(
       after_str =
           std::string(max_filter_name_len - filter.name.name().length(), ' ');
     }
-    LOG(INFO) << "  " << loc_strs[filter.name] << filter.name << after_str
+    ABSL_LOG(INFO) << "  " << loc_strs[filter.name] << filter.name << after_str
               << " [" << filter.ordering << "/" << filter.version << "]";
   }
   // Finally list out the terminal filters and where they were registered
@@ -403,7 +403,7 @@ void ChannelInit::PrintChannelStackTrace(
         std::string(max_filter_name_len + 1 - terminal.name.name().length(),
                     ' '),
         "[terminal]");
-    LOG(INFO) << filter_str;
+    ABSL_LOG(INFO) << filter_str;
   }
 }

@@ -458,7 +458,7 @@ bool ChannelInit::CreateStack(ChannelStackBuilder* builder) const {
                         "\n");
       }
     }
-    LOG(ERROR) << error;
+    ABSL_LOG(ERROR) << error;
     return false;
   }
   for (const auto& post_processor : stack_config.post_processors) {
diff --git a/third_party/grpc/source/src/core/lib/surface/channel_init.h b/third_party/grpc/source/src/core/lib/surface/channel_init.h
index 88ca3d347ddb9..fa4e92c00e65d 100644
--- a/third_party/grpc/source/src/core/lib/surface/channel_init.h
+++ b/third_party/grpc/source/src/core/lib/surface/channel_init.h
@@ -29,7 +29,7 @@
 #include <vector>

 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/channel/channel_args.h"
 #include "src/core/lib/channel/channel_fwd.h"
 #include "src/core/lib/channel/channel_stack_builder.h"
@@ -246,26 +246,26 @@ class ChannelInit {
     // stack.
     FilterRegistration& ExcludeFromMinimalStack();
     FilterRegistration& SkipV3() {
-      CHECK_EQ(version_, Version::kAny);
+      ABSL_CHECK_EQ(version_, Version::kAny);
       version_ = Version::kV2;
       return *this;
     }
     FilterRegistration& SkipV2() {
-      CHECK_EQ(version_, Version::kAny);
+      ABSL_CHECK_EQ(version_, Version::kAny);
       version_ = Version::kV3;
       return *this;
     }
     // Request this filter be placed as high as possible in the stack (given
     // before/after constraints).
     FilterRegistration& FloatToTop() {
-      CHECK_EQ(ordering_, Ordering::kDefault);
+      ABSL_CHECK_EQ(ordering_, Ordering::kDefault);
       ordering_ = Ordering::kTop;
       return *this;
     }
     // Request this filter be placed as low as possible in the stack (given
     // before/after constraints).
     FilterRegistration& SinkToBottom() {
-      CHECK_EQ(ordering_, Ordering::kDefault);
+      ABSL_CHECK_EQ(ordering_, Ordering::kDefault);
       ordering_ = Ordering::kBottom;
       return *this;
     }
@@ -301,7 +301,7 @@ class ChannelInit {
     FilterRegistration& RegisterFilter(
         grpc_channel_stack_type type, const grpc_channel_filter* filter,
         SourceLocation registration_source = {}) {
-      CHECK(filter != nullptr);
+      ABSL_CHECK(filter != nullptr);
       return RegisterFilter(type, NameFromChannelFilter(filter), filter,
                             nullptr, registration_source);
     }
@@ -331,7 +331,7 @@ class ChannelInit {
                                PostProcessorSlot slot,
                                PostProcessor post_processor) {
       auto& slot_value = post_processors_[type][static_cast<int>(slot)];
-      CHECK(slot_value == nullptr);
+      ABSL_CHECK(slot_value == nullptr);
       slot_value = std::move(post_processor);
     }

diff --git a/third_party/grpc/source/src/core/lib/surface/client_call.cc b/third_party/grpc/source/src/core/lib/surface/client_call.cc
index 7eca227afd71b..4dfdd8f3aa0e8 100644
--- a/third_party/grpc/source/src/core/lib/surface/client_call.cc
+++ b/third_party/grpc/source/src/core/lib/surface/client_call.cc
@@ -39,7 +39,7 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/strings/string_view.h"
 #include "src/core/lib/event_engine/event_engine_context.h"
@@ -376,7 +376,7 @@ void ClientCall::CommitBatch(const grpc_op* ops, size_t nops, void* notify_tag,
             [this, out_status, out_status_details, out_error_string,
              out_trailing_metadata]() {
               auto* status = cancel_status_.Get();
-              CHECK_NE(status, nullptr);
+              ABSL_CHECK_NE(status, nullptr);
               *out_status = static_cast<grpc_status_code>(status->code());
               *out_status_details =
                   Slice::FromCopiedString(status->message()).TakeCSlice();
@@ -443,8 +443,8 @@ grpc_call* MakeClientCall(grpc_call* parent_call, uint32_t propagation_mask,
                           grpc_compression_options compression_options,
                           RefCountedPtr<Arena> arena,
                           RefCountedPtr<UnstartedCallDestination> destination) {
-  DCHECK_NE(arena.get(), nullptr);
-  DCHECK_NE(arena->GetContext<grpc_event_engine::experimental::EventEngine>(),
+  ABSL_DCHECK_NE(arena.get(), nullptr);
+  ABSL_DCHECK_NE(arena->GetContext<grpc_event_engine::experimental::EventEngine>(),
             nullptr);
   return arena
       ->New<ClientCall>(parent_call, propagation_mask, cq, std::move(path),
diff --git a/third_party/grpc/source/src/core/lib/surface/completion_queue.cc b/third_party/grpc/source/src/core/lib/surface/completion_queue.cc
index e4996964e8aa7..5ec044cfe3948 100644
--- a/third_party/grpc/source/src/core/lib/surface/completion_queue.cc
+++ b/third_party/grpc/source/src/core/lib/surface/completion_queue.cc
@@ -33,8 +33,8 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_format.h"
 #include "absl/strings/str_join.h"
@@ -173,7 +173,7 @@ grpc_error_handle non_polling_poller_kick(

 void non_polling_poller_shutdown(grpc_pollset* pollset, grpc_closure* closure) {
   non_polling_poller* p = reinterpret_cast<non_polling_poller*>(pollset);
-  CHECK_NE(closure, nullptr);
+  ABSL_CHECK_NE(closure, nullptr);
   p->shutdown = closure;
   if (p->root == nullptr) {
     grpc_core::ExecCtx::Run(DEBUG_LOCATION, closure, absl::OkStatus());
@@ -251,10 +251,10 @@ class CqEventQueue {

 struct cq_next_data {
   ~cq_next_data() {
-    CHECK_EQ(queue.num_items(), 0);
+    ABSL_CHECK_EQ(queue.num_items(), 0);
 #ifndef NDEBUG
     if (pending_events.load(std::memory_order_acquire) != 0) {
-      LOG(ERROR) << "Destroying CQ without draining it fully.";
+      ABSL_LOG(ERROR) << "Destroying CQ without draining it fully.";
     }
 #endif
   }
@@ -281,10 +281,10 @@ struct cq_pluck_data {
   }

   ~cq_pluck_data() {
-    CHECK(completed_head.next == reinterpret_cast<uintptr_t>(&completed_head));
+    ABSL_CHECK(completed_head.next == reinterpret_cast<uintptr_t>(&completed_head));
 #ifndef NDEBUG
     if (pending_events.load(std::memory_order_acquire) != 0) {
-      LOG(ERROR) << "Destroying CQ without draining it fully.";
+      ABSL_LOG(ERROR) << "Destroying CQ without draining it fully.";
     }
 #endif
   }
@@ -323,7 +323,7 @@ struct cq_callback_data {
   ~cq_callback_data() {
 #ifndef NDEBUG
     if (pending_events.load(std::memory_order_acquire) != 0) {
-      LOG(ERROR) << "Destroying CQ without draining it fully.";
+      ABSL_LOG(ERROR) << "Destroying CQ without draining it fully.";
     }
 #endif
   }
@@ -444,7 +444,7 @@ static const cq_vtable g_cq_vtable[] = {
     if (GRPC_TRACE_FLAG_ENABLED(api) &&               \
         (GRPC_TRACE_FLAG_ENABLED(queue_pluck) ||      \
          (event)->type != GRPC_QUEUE_TIMEOUT)) {      \
-      LOG(INFO) << "RETURN_EVENT[" << (cq)            \
+      ABSL_LOG(INFO) << "RETURN_EVENT[" << (cq)            \
                 << "]: " << grpc_event_string(event); \
     }                                                 \
   } while (0)
@@ -650,7 +650,7 @@ static void cq_check_tag(grpc_completion_queue* cq, void* tag, bool lock_cq) {
     gpr_mu_unlock(cq->mu);
   }

-  CHECK(found);
+  ABSL_CHECK(found);
 }
 #else
 static void cq_check_tag(grpc_completion_queue* /*cq*/, void* /*tag*/,
@@ -703,7 +703,7 @@ static void cq_end_op_for_next(
         << ", error=" << errmsg.c_str() << ", done=" << done
         << ", done_arg=" << done_arg << ", storage=" << storage << ")";
     if (GRPC_TRACE_FLAG_ENABLED(op_failure) && !error.ok()) {
-      LOG(INFO) << "Operation failed: tag=" << tag << ", error=" << errmsg;
+      ABSL_LOG(INFO) << "Operation failed: tag=" << tag << ", error=" << errmsg;
     }
   }
   cq_next_data* cqd = static_cast<cq_next_data*> DATA_FROM_CQ(cq);
@@ -736,7 +736,7 @@ static void cq_end_op_for_next(
         gpr_mu_unlock(cq->mu);

         if (!kick_error.ok()) {
-          LOG(ERROR) << "Kick failed: "
+          ABSL_LOG(ERROR) << "Kick failed: "
                      << grpc_core::StatusToString(kick_error);
         }
       }
@@ -776,7 +776,7 @@ static void cq_end_op_for_pluck(
         << ", error=" << errmsg.c_str() << ", done=" << done
         << ", done_arg=" << done_arg << ", storage=" << storage << ")";
     if (GRPC_TRACE_FLAG_ENABLED(op_failure) && !error.ok()) {
-      LOG(ERROR) << "Operation failed: tag=" << tag << ", error=" << errmsg;
+      ABSL_LOG(ERROR) << "Operation failed: tag=" << tag << ", error=" << errmsg;
     }
   }

@@ -811,7 +811,7 @@ static void cq_end_op_for_pluck(
         cq->poller_vtable->kick(POLLSET_FROM_CQ(cq), pluck_worker);
     gpr_mu_unlock(cq->mu);
     if (!kick_error.ok()) {
-      LOG(ERROR) << "Kick failed: " << kick_error;
+      ABSL_LOG(ERROR) << "Kick failed: " << kick_error;
     }
   }
 }
@@ -836,7 +836,7 @@ static void cq_end_op_for_callback(
         << ", error=" << errmsg.c_str() << ", done=" << done
         << ", done_arg=" << done_arg << ", storage=" << storage << ")";
     if (GRPC_TRACE_FLAG_ENABLED(op_failure) && !error.ok()) {
-      LOG(ERROR) << "Operation failed: tag=" << tag << ", error=" << errmsg;
+      ABSL_LOG(ERROR) << "Operation failed: tag=" << tag << ", error=" << errmsg;
     }
   }

@@ -906,7 +906,7 @@ class ExecCtxNext : public grpc_core::ExecCtx {
         static_cast<cq_is_finished_arg*>(check_ready_to_finish_arg_);
     grpc_completion_queue* cq = a->cq;
     cq_next_data* cqd = static_cast<cq_next_data*> DATA_FROM_CQ(cq);
-    CHECK_EQ(a->stolen_completion, nullptr);
+    ABSL_CHECK_EQ(a->stolen_completion, nullptr);

     intptr_t current_last_seen_things_queued_ever =
         cqd->things_queued_ever.load(std::memory_order_relaxed);
@@ -943,7 +943,7 @@ static void dump_pending_tags(grpc_completion_queue* cq) {
     parts.push_back(absl::StrFormat(" %p", cq->outstanding_tags[i]));
   }
   gpr_mu_unlock(cq->mu);
-  VLOG(2) << absl::StrJoin(parts, "");
+  ABSL_VLOG(2) << absl::StrJoin(parts, "");
 }
 #else
 static void dump_pending_tags(grpc_completion_queue* /*cq*/) {}
@@ -960,7 +960,7 @@ static grpc_event cq_next(grpc_completion_queue* cq, gpr_timespec deadline,
       << ", tv_nsec: " << deadline.tv_nsec
       << ", clock_type: " << (int)deadline.clock_type
       << " }, reserved=" << reserved << ")";
-  CHECK(!reserved);
+  ABSL_CHECK(!reserved);

   dump_pending_tags(cq);

@@ -1042,7 +1042,7 @@ static grpc_event cq_next(grpc_completion_queue* cq, gpr_timespec deadline,
     gpr_mu_unlock(cq->mu);

     if (!err.ok()) {
-      LOG(ERROR) << "Completion queue next failed: "
+      ABSL_LOG(ERROR) << "Completion queue next failed: "
                  << grpc_core::StatusToString(err);
       if (err == absl::CancelledError()) {
         ret.type = GRPC_QUEUE_SHUTDOWN;
@@ -1066,7 +1066,7 @@ static grpc_event cq_next(grpc_completion_queue* cq, gpr_timespec deadline,
   GRPC_SURFACE_TRACE_RETURNED_EVENT(cq, &ret);
   GRPC_CQ_INTERNAL_UNREF(cq, "next");

-  CHECK_EQ(is_finished_arg.stolen_completion, nullptr);
+  ABSL_CHECK_EQ(is_finished_arg.stolen_completion, nullptr);

   return ret;
 }
@@ -1080,8 +1080,8 @@ static grpc_event cq_next(grpc_completion_queue* cq, gpr_timespec deadline,
 static void cq_finish_shutdown_next(grpc_completion_queue* cq) {
   cq_next_data* cqd = static_cast<cq_next_data*> DATA_FROM_CQ(cq);

-  CHECK(cqd->shutdown_called);
-  CHECK_EQ(cqd->pending_events.load(std::memory_order_relaxed), 0);
+  ABSL_CHECK(cqd->shutdown_called);
+  ABSL_CHECK_EQ(cqd->pending_events.load(std::memory_order_relaxed), 0);

   cq->poller_vtable->shutdown(POLLSET_FROM_CQ(cq), &cq->pollset_shutdown_done);
 }
@@ -1155,7 +1155,7 @@ class ExecCtxPluck : public grpc_core::ExecCtx {
     grpc_completion_queue* cq = a->cq;
     cq_pluck_data* cqd = static_cast<cq_pluck_data*> DATA_FROM_CQ(cq);

-    CHECK_EQ(a->stolen_completion, nullptr);
+    ABSL_CHECK_EQ(a->stolen_completion, nullptr);
     gpr_atm current_last_seen_things_queued_ever =
         cqd->things_queued_ever.load(std::memory_order_relaxed);
     if (current_last_seen_things_queued_ever !=
@@ -1203,7 +1203,7 @@ static grpc_event cq_pluck(grpc_completion_queue* cq, void* tag,
         << ", clock_type: " << (int)deadline.clock_type
         << " }, reserved=" << reserved << ")";
   }
-  CHECK(!reserved);
+  ABSL_CHECK(!reserved);

   dump_pending_tags(cq);

@@ -1254,7 +1254,7 @@ static grpc_event cq_pluck(grpc_completion_queue* cq, void* tag,
       break;
     }
     if (!add_plucker(cq, tag, &worker)) {
-      VLOG(2) << "Too many outstanding grpc_completion_queue_pluck calls: "
+      ABSL_VLOG(2) << "Too many outstanding grpc_completion_queue_pluck calls: "
                  "maximum is "
               << GRPC_MAX_COMPLETION_QUEUE_PLUCKERS;
       gpr_mu_unlock(cq->mu);
@@ -1279,7 +1279,7 @@ static grpc_event cq_pluck(grpc_completion_queue* cq, void* tag,
     if (!err.ok()) {
       del_plucker(cq, tag, &worker);
       gpr_mu_unlock(cq->mu);
-      LOG(ERROR) << "Completion queue pluck failed: "
+      ABSL_LOG(ERROR) << "Completion queue pluck failed: "
                  << grpc_core::StatusToString(err);
       ret.type = GRPC_QUEUE_TIMEOUT;
       ret.success = 0;
@@ -1293,7 +1293,7 @@ done:
   GRPC_SURFACE_TRACE_RETURNED_EVENT(cq, &ret);
   GRPC_CQ_INTERNAL_UNREF(cq, "pluck");

-  CHECK_EQ(is_finished_arg.stolen_completion, nullptr);
+  ABSL_CHECK_EQ(is_finished_arg.stolen_completion, nullptr);

   return ret;
 }
@@ -1306,8 +1306,8 @@ grpc_event grpc_completion_queue_pluck(grpc_completion_queue* cq, void* tag,
 static void cq_finish_shutdown_pluck(grpc_completion_queue* cq) {
   cq_pluck_data* cqd = static_cast<cq_pluck_data*> DATA_FROM_CQ(cq);

-  CHECK(cqd->shutdown_called);
-  CHECK(!cqd->shutdown.load(std::memory_order_relaxed));
+  ABSL_CHECK(cqd->shutdown_called);
+  ABSL_CHECK(!cqd->shutdown.load(std::memory_order_relaxed));
   cqd->shutdown.store(true, std::memory_order_relaxed);

   cq->poller_vtable->shutdown(POLLSET_FROM_CQ(cq), &cq->pollset_shutdown_done);
@@ -1343,7 +1343,7 @@ static void cq_finish_shutdown_callback(grpc_completion_queue* cq) {
   cq_callback_data* cqd = static_cast<cq_callback_data*> DATA_FROM_CQ(cq);
   auto* callback = cqd->shutdown_callback;

-  CHECK(cqd->shutdown_called);
+  ABSL_CHECK(cqd->shutdown_called);

   cq->poller_vtable->shutdown(POLLSET_FROM_CQ(cq), &cq->pollset_shutdown_done);

diff --git a/third_party/grpc/source/src/core/lib/surface/completion_queue_factory.cc b/third_party/grpc/source/src/core/lib/surface/completion_queue_factory.cc
index c88360772aa76..0fe229ed6e3b3 100644
--- a/third_party/grpc/source/src/core/lib/surface/completion_queue_factory.cc
+++ b/third_party/grpc/source/src/core/lib/surface/completion_queue_factory.cc
@@ -21,7 +21,7 @@
 #include <grpc/grpc.h>
 #include <grpc/support/port_platform.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
 #include "src/core/lib/surface/completion_queue.h"

@@ -47,7 +47,7 @@ static const grpc_completion_queue_factory g_default_cq_factory = {

 const grpc_completion_queue_factory* grpc_completion_queue_factory_lookup(
     const grpc_completion_queue_attributes* attributes) {
-  CHECK(attributes->version >= 1 &&
+  ABSL_CHECK(attributes->version >= 1 &&
         attributes->version <= GRPC_CQ_CURRENT_VERSION);

   // The default factory can handle version 1 of the attributes structure. We
@@ -61,7 +61,7 @@ const grpc_completion_queue_factory* grpc_completion_queue_factory_lookup(

 grpc_completion_queue* grpc_completion_queue_create_for_next(void* reserved) {
   grpc_core::ExecCtx exec_ctx;
-  CHECK(!reserved);
+  ABSL_CHECK(!reserved);
   grpc_completion_queue_attributes attr = {1, GRPC_CQ_NEXT,
                                            GRPC_CQ_DEFAULT_POLLING, nullptr};
   return g_default_cq_factory.vtable->create(&g_default_cq_factory, &attr);
@@ -69,7 +69,7 @@ grpc_completion_queue* grpc_completion_queue_create_for_next(void* reserved) {

 grpc_completion_queue* grpc_completion_queue_create_for_pluck(void* reserved) {
   grpc_core::ExecCtx exec_ctx;
-  CHECK(!reserved);
+  ABSL_CHECK(!reserved);
   grpc_completion_queue_attributes attr = {1, GRPC_CQ_PLUCK,
                                            GRPC_CQ_DEFAULT_POLLING, nullptr};
   return g_default_cq_factory.vtable->create(&g_default_cq_factory, &attr);
@@ -78,7 +78,7 @@ grpc_completion_queue* grpc_completion_queue_create_for_pluck(void* reserved) {
 grpc_completion_queue* grpc_completion_queue_create_for_callback(
     grpc_completion_queue_functor* shutdown_callback, void* reserved) {
   grpc_core::ExecCtx exec_ctx;
-  CHECK(!reserved);
+  ABSL_CHECK(!reserved);
   grpc_completion_queue_attributes attr = {
       2, GRPC_CQ_CALLBACK, GRPC_CQ_DEFAULT_POLLING, shutdown_callback};
   return g_default_cq_factory.vtable->create(&g_default_cq_factory, &attr);
@@ -88,6 +88,6 @@ grpc_completion_queue* grpc_completion_queue_create(
     const grpc_completion_queue_factory* factory,
     const grpc_completion_queue_attributes* attr, void* reserved) {
   grpc_core::ExecCtx exec_ctx;
-  CHECK(!reserved);
+  ABSL_CHECK(!reserved);
   return factory->vtable->create(factory, attr);
 }
diff --git a/third_party/grpc/source/src/core/lib/surface/filter_stack_call.cc b/third_party/grpc/source/src/core/lib/surface/filter_stack_call.cc
index 12106ad81f762..26893fc096c8f 100644
--- a/third_party/grpc/source/src/core/lib/surface/filter_stack_call.cc
+++ b/third_party/grpc/source/src/core/lib/surface/filter_stack_call.cc
@@ -37,8 +37,8 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
@@ -109,8 +109,8 @@ grpc_error_handle FilterStackCall::Create(grpc_call_create_args* args,
   arena->SetContext<grpc_event_engine::experimental::EventEngine>(
       args->channel->event_engine());
   call = new (arena->Alloc(call_alloc_size)) FilterStackCall(arena, *args);
-  DCHECK(FromC(call->c_ptr()) == call);
-  DCHECK(FromCallStack(call->call_stack()) == call);
+  ABSL_DCHECK(FromC(call->c_ptr()) == call);
+  ABSL_DCHECK(FromCallStack(call->call_stack()) == call);
   *out_call = call->c_ptr();
   grpc_slice path = grpc_empty_slice();
   ScopedContext ctx(call);
@@ -181,7 +181,7 @@ grpc_error_handle FilterStackCall::Create(grpc_call_create_args* args,
     call->CancelWithError(error);
   }
   if (args->cq != nullptr) {
-    CHECK(args->pollset_set_alternative == nullptr)
+    ABSL_CHECK(args->pollset_set_alternative == nullptr)
         << "Only one of 'cq' and 'pollset_set_alternative' should be "
            "non-nullptr.";
     GRPC_CQ_INTERNAL_REF(args->cq, "bind");
@@ -220,7 +220,7 @@ grpc_error_handle FilterStackCall::Create(grpc_call_create_args* args,
 }

 void FilterStackCall::SetCompletionQueue(grpc_completion_queue* cq) {
-  CHECK(cq);
+  ABSL_CHECK(cq);

   if (grpc_polling_entity_pollset_set(&pollent_) != nullptr) {
     Crash("A pollset_set is already registered for this call.");
@@ -270,7 +270,7 @@ void FilterStackCall::ExternalUnref() {

   MaybeUnpublishFromParent();

-  CHECK(!destroy_called_);
+  ABSL_CHECK(!destroy_called_);
   destroy_called_ = true;
   bool cancel = gpr_atm_acq_load(&received_final_op_atm_) == 0;
   if (cancel) {
@@ -413,7 +413,7 @@ bool FilterStackCall::PrepareApplicationMetadata(size_t count,
     }
     batch->Append(StringViewFromSlice(md->key), Slice(CSliceRef(md->value)),
                   [md](absl::string_view error, const Slice& value) {
-                    VLOG(2)
+                    ABSL_VLOG(2)
                         << "Append error: key=" << StringViewFromSlice(md->key)
                         << " error=" << error
                         << " value=" << value.as_string_view();
@@ -472,7 +472,7 @@ void FilterStackCall::RecvTrailingFilter(grpc_metadata_batch* b,
     } else if (!is_client()) {
       SetFinalStatus(absl::OkStatus());
     } else {
-      VLOG(2) << "Received trailing metadata with no error and no status";
+      ABSL_VLOG(2) << "Received trailing metadata with no error and no status";
       SetFinalStatus(grpc_error_set_int(GRPC_ERROR_CREATE("No status received"),
                                         StatusIntProperty::kRpcStatus,
                                         GRPC_STATUS_UNKNOWN));
@@ -672,7 +672,7 @@ void FilterStackCall::BatchControl::ReceivingInitialMetadataReady(
   while (true) {
     gpr_atm rsr_bctlp = gpr_atm_acq_load(&call->recv_state_);
     // Should only receive initial metadata once
-    CHECK_NE(rsr_bctlp, 1);
+    ABSL_CHECK_NE(rsr_bctlp, 1);
     if (rsr_bctlp == 0) {
       // We haven't seen initial metadata and messages before, thus initial
       // metadata is received first.
@@ -746,7 +746,7 @@ grpc_call_error FilterStackCall::StartBatch(const grpc_op* ops, size_t nops,
   if (!is_client() &&
       (seen_ops & (1u << GRPC_OP_SEND_STATUS_FROM_SERVER)) != 0 &&
       (seen_ops & (1u << GRPC_OP_RECV_MESSAGE)) != 0) {
-    LOG(ERROR) << "******************* SEND_STATUS WITH RECV_MESSAGE "
+    ABSL_LOG(ERROR) << "******************* SEND_STATUS WITH RECV_MESSAGE "
                   "*******************";
     return GRPC_CALL_ERROR;
   }
@@ -1080,7 +1080,7 @@ grpc_call_error FilterStackCall::StartBatch(const grpc_op* ops, size_t nops,

   InternalRef("completion");
   if (!is_notify_tag_closure) {
-    CHECK(grpc_cq_begin_op(cq_, notify_tag));
+    ABSL_CHECK(grpc_cq_begin_op(cq_, notify_tag));
   }
   bctl->set_pending_ops(pending_ops);

diff --git a/third_party/grpc/source/src/core/lib/surface/filter_stack_call.h b/third_party/grpc/source/src/core/lib/surface/filter_stack_call.h
index d6cecb0050250..a5f4570a93055 100644
--- a/third_party/grpc/source/src/core/lib/surface/filter_stack_call.h
+++ b/third_party/grpc/source/src/core/lib/surface/filter_stack_call.h
@@ -38,7 +38,7 @@
 #include <string>
 #include <vector>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_join.h"
 #include "absl/strings/string_view.h"
@@ -110,7 +110,7 @@ class FilterStackCall final : public Call {

   bool is_trailers_only() const override {
     bool result = is_trailers_only_;
-    DCHECK(!result || recv_initial_metadata_.TransportSize() == 0);
+    ABSL_DCHECK(!result || recv_initial_metadata_.TransportSize() == 0);
     return result;
   }

@@ -219,7 +219,7 @@ class FilterStackCall final : public Call {
           << "BATCH:" << this << " COMPLETE:" << PendingOpString(mask)
           << " REMAINING:" << PendingOpString(r & ~mask)
           << " (tag:" << completion_data_.notify_tag.tag << ")";
-      CHECK_NE((r & mask), 0);
+      ABSL_CHECK_NE((r & mask), 0);
       return r == mask;
     }

diff --git a/third_party/grpc/source/src/core/lib/surface/init.cc b/third_party/grpc/source/src/core/lib/surface/init.cc
index 9f3bd74786b69..2b85dd92c5417 100644
--- a/third_party/grpc/source/src/core/lib/surface/init.cc
+++ b/third_party/grpc/source/src/core/lib/surface/init.cc
@@ -28,7 +28,7 @@
 #include <grpc/support/time.h>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/time/clock.h"
 #include "absl/time/time.h"
 #include "src/core/client_channel/backup_poller.h"
@@ -128,7 +128,7 @@ void grpc_init(void) {
       address_sorting_init();
       auto status = AresInit();
       if (!status.ok()) {
-        VLOG(2) << "AresInit failed: " << status.message();
+        ABSL_VLOG(2) << "AresInit failed: " << status.message();
       } else {
         // TODO(yijiem): remove this once we remove the iomgr dns system.
         grpc_resolver_dns_ares_reset_dns_resolver();
@@ -169,7 +169,7 @@ void grpc_shutdown_from_cleanup_thread(void* /*ignored*/) {
     return;
   }
   grpc_shutdown_internal_locked();
-  VLOG(2) << "grpc_shutdown from cleanup thread done";
+  ABSL_VLOG(2) << "grpc_shutdown from cleanup thread done";
 }

 void grpc_shutdown(void) {
@@ -187,14 +187,14 @@ void grpc_shutdown(void) {
              0) &&
         grpc_core::ExecCtx::Get() == nullptr) {
       // just run clean-up when this is called on non-executor thread.
-      VLOG(2) << "grpc_shutdown starts clean-up now";
+      ABSL_VLOG(2) << "grpc_shutdown starts clean-up now";
       g_shutting_down = true;
       grpc_shutdown_internal_locked();
-      VLOG(2) << "grpc_shutdown done";
+      ABSL_VLOG(2) << "grpc_shutdown done";
     } else {
       // spawn a detached thread to do the actual clean up in case we are
       // currently in an executor thread.
-      VLOG(2) << "grpc_shutdown spawns clean-up thread";
+      ABSL_VLOG(2) << "grpc_shutdown spawns clean-up thread";
       g_initializations++;
       g_shutting_down = true;
       grpc_core::Thread cleanup_thread(
@@ -238,7 +238,7 @@ bool grpc_wait_for_shutdown_with_timeout(absl::Duration timeout) {
   grpc_core::MutexLock lock(g_init_mu);
   while (g_initializations != 0) {
     if (g_shutting_down_cv->WaitWithDeadline(g_init_mu, deadline)) {
-      LOG(ERROR) << "grpc_wait_for_shutdown_with_timeout() timed out.";
+      ABSL_LOG(ERROR) << "grpc_wait_for_shutdown_with_timeout() timed out.";
       return false;
     }
   }
diff --git a/third_party/grpc/source/src/core/lib/surface/legacy_channel.cc b/third_party/grpc/source/src/core/lib/surface/legacy_channel.cc
index 2d915523b4a0b..d4fea97df2893 100644
--- a/third_party/grpc/source/src/core/lib/surface/legacy_channel.cc
+++ b/third_party/grpc/source/src/core/lib/surface/legacy_channel.cc
@@ -27,8 +27,8 @@
 #include <optional>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "src/core/channelz/channelz.h"
 #include "src/core/client_channel/client_channel_filter.h"
@@ -86,7 +86,7 @@ absl::StatusOr<RefCountedPtr<Channel>> LegacyChannel::Create(
   absl::StatusOr<RefCountedPtr<grpc_channel_stack>> r = builder.Build();
   if (!r.ok()) {
     auto status = r.status();
-    LOG(ERROR) << "channel stack builder failed: " << status;
+    ABSL_LOG(ERROR) << "channel stack builder failed: " << status;
     return status;
   }
   if (channel_stack_type == GRPC_SERVER_CHANNEL) {
@@ -186,8 +186,8 @@ grpc_call* LegacyChannel::CreateCall(grpc_call* parent_call,
                                      Slice path, std::optional<Slice> authority,
                                      Timestamp deadline,
                                      bool registered_method) {
-  CHECK(is_client_);
-  CHECK(!(cq != nullptr && pollset_set_alternative != nullptr));
+  ABSL_CHECK(is_client_);
+  ABSL_CHECK(!(cq != nullptr && pollset_set_alternative != nullptr));
   grpc_call_create_args args;
   args.channel = RefAsSubclass<LegacyChannel>();
   args.server = nullptr;
@@ -211,7 +211,7 @@ grpc_connectivity_state LegacyChannel::CheckConnectivityState(
   ClientChannelFilter* client_channel = GetClientChannelFilter();
   if (GPR_UNLIKELY(client_channel == nullptr)) {
     if (IsLame()) return GRPC_CHANNEL_TRANSIENT_FAILURE;
-    LOG(ERROR) << "grpc_channel_check_connectivity_state called on something "
+    ABSL_LOG(ERROR) << "grpc_channel_check_connectivity_state called on something "
                   "that is not a client channel";
     return GRPC_CHANNEL_SHUTDOWN;
   }
@@ -232,7 +232,7 @@ class LegacyChannel::StateWatcher final : public DualRefCounted<StateWatcher> {
         cq_(cq),
         tag_(tag),
         state_(last_observed_state) {
-    CHECK(grpc_cq_begin_op(cq, tag));
+    ABSL_CHECK(grpc_cq_begin_op(cq, tag));
     GRPC_CLOSURE_INIT(&on_complete_, WatchComplete, this, nullptr);
     ClientChannelFilter* client_channel = channel_->GetClientChannelFilter();
     if (client_channel == nullptr) {
@@ -362,14 +362,14 @@ void LegacyChannel::AddConnectivityWatcher(
     grpc_connectivity_state initial_state,
     OrphanablePtr<AsyncConnectivityStateWatcherInterface> watcher) {
   auto* client_channel = GetClientChannelFilter();
-  CHECK_NE(client_channel, nullptr);
+  ABSL_CHECK_NE(client_channel, nullptr);
   client_channel->AddConnectivityWatcher(initial_state, std::move(watcher));
 }

 void LegacyChannel::RemoveConnectivityWatcher(
     AsyncConnectivityStateWatcherInterface* watcher) {
   auto* client_channel = GetClientChannelFilter();
-  CHECK_NE(client_channel, nullptr);
+  ABSL_CHECK_NE(client_channel, nullptr);
   client_channel->RemoveConnectivityWatcher(watcher);
 }

@@ -413,7 +413,7 @@ void LegacyChannel::Ping(grpc_completion_queue* cq, void* tag) {
   grpc_transport_op* op = grpc_make_transport_op(nullptr);
   op->send_ping.on_ack = &pr->closure;
   op->bind_pollset = grpc_cq_pollset(cq);
-  CHECK(grpc_cq_begin_op(cq, tag));
+  ABSL_CHECK(grpc_cq_begin_op(cq, tag));
   grpc_channel_element* top_elem =
       grpc_channel_stack_element(channel_stack_.get(), 0);
   top_elem->filter->start_transport_op(top_elem, op);
diff --git a/third_party/grpc/source/src/core/lib/surface/server_call.cc b/third_party/grpc/source/src/core/lib/surface/server_call.cc
index 73212e84f8f58..b5e71eb9d8d4a 100644
--- a/third_party/grpc/source/src/core/lib/surface/server_call.cc
+++ b/third_party/grpc/source/src/core/lib/surface/server_call.cc
@@ -37,7 +37,7 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/string_view.h"
 #include "src/core/lib/promise/all_ok.h"
 #include "src/core/lib/promise/map.h"
@@ -169,12 +169,12 @@ void ServerCall::CommitBatch(const grpc_op* ops, size_t nops, void* notify_tag,
       // after passing it in, which shouldn't be a supported API.
       metadata->Set(GrpcMessageMetadata(), Slice(grpc_slice_copy(*details)));
     }
-    CHECK(metadata != nullptr);
+    ABSL_CHECK(metadata != nullptr);
     bool wait_for_initial_metadata_scheduled =
         sent_server_initial_metadata_batch_.load(std::memory_order_relaxed);
     return [this, metadata = std::move(metadata),
             wait_for_initial_metadata_scheduled]() mutable {
-      CHECK(metadata != nullptr);
+      ABSL_CHECK(metadata != nullptr);
       // If there was a send initial metadata batch sent prior to this one, then
       // make sure it's been scheduled first - otherwise we may accidentally
       // treat this as trailers only.
@@ -184,7 +184,7 @@ void ServerCall::CommitBatch(const grpc_op* ops, size_t nops, void* notify_tag,
               [this]() { return server_initial_metadata_scheduled_.Wait(); },
               []() { return Empty{}; }),
           [this, metadata = std::move(metadata)]() mutable -> Poll<Success> {
-            CHECK(metadata != nullptr);
+            ABSL_CHECK(metadata != nullptr);
             call_handler_.PushServerTrailingMetadata(std::move(metadata));
             return Success{};
           });
diff --git a/third_party/grpc/source/src/core/lib/surface/server_call.h b/third_party/grpc/source/src/core/lib/surface/server_call.h
index f4bbc1e6a791f..f148bb93485ec 100644
--- a/third_party/grpc/source/src/core/lib/surface/server_call.h
+++ b/third_party/grpc/source/src/core/lib/surface/server_call.h
@@ -39,7 +39,7 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_format.h"
 #include "absl/strings/string_view.h"
diff --git a/third_party/grpc/source/src/core/lib/surface/validate_metadata.h b/third_party/grpc/source/src/core/lib/surface/validate_metadata.h
index f4630ea2d48db..a745a2d5ecf1a 100644
--- a/third_party/grpc/source/src/core/lib/surface/validate_metadata.h
+++ b/third_party/grpc/source/src/core/lib/surface/validate_metadata.h
@@ -25,7 +25,7 @@

 #include <cstring>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/string_view.h"
 #include "src/core/lib/iomgr/error.h"

@@ -56,7 +56,7 @@ inline int grpc_key_is_binary_header(const uint8_t* buf, size_t length) {
   return 0 == memcmp(buf + length - 4, "-bin", 4);
 }
 inline int grpc_is_refcounted_slice_binary_header(const grpc_slice& slice) {
-  DCHECK_NE(slice.refcount, nullptr);
+  ABSL_DCHECK_NE(slice.refcount, nullptr);
   return grpc_key_is_binary_header(slice.data.refcounted.bytes,
                                    slice.data.refcounted.length);
 }
diff --git a/third_party/grpc/source/src/core/lib/transport/bdp_estimator.cc b/third_party/grpc/source/src/core/lib/transport/bdp_estimator.cc
index 61b779d62c970..9a435971100d8 100644
--- a/third_party/grpc/source/src/core/lib/transport/bdp_estimator.cc
+++ b/third_party/grpc/source/src/core/lib/transport/bdp_estimator.cc
@@ -24,8 +24,8 @@

 #include <algorithm>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"

 namespace grpc_core {

@@ -50,7 +50,7 @@ Timestamp BdpEstimator::CompletePing() {
       << "bdp[" << name_ << "]:complete acc=" << accumulator_
       << " est=" << estimate_ << " dt=" << dt << " bw=" << bw / 125000.0
       << "Mbs bw_est=" << bw_est_ / 125000.0 << "Mbs";
-  CHECK(ping_state_ == PingState::STARTED);
+  ABSL_CHECK(ping_state_ == PingState::STARTED);
   if (accumulator_ > 2 * estimate_ / 3 && bw > bw_est_) {
     estimate_ = std::max(accumulator_, estimate_ * 2);
     bw_est_ = bw;
diff --git a/third_party/grpc/source/src/core/lib/transport/bdp_estimator.h b/third_party/grpc/source/src/core/lib/transport/bdp_estimator.h
index c5879d939c3ef..c63c1c6fe075a 100644
--- a/third_party/grpc/source/src/core/lib/transport/bdp_estimator.h
+++ b/third_party/grpc/source/src/core/lib/transport/bdp_estimator.h
@@ -25,8 +25,8 @@

 #include <string>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/string_view.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/util/time.h"
@@ -50,7 +50,7 @@ class BdpEstimator {
     GRPC_TRACE_LOG(bdp_estimator, INFO)
         << "bdp[" << name_ << "]:sched acc=" << accumulator_
         << " est=" << estimate_;
-    CHECK(ping_state_ == PingState::UNSCHEDULED);
+    ABSL_CHECK(ping_state_ == PingState::UNSCHEDULED);
     ping_state_ = PingState::SCHEDULED;
     accumulator_ = 0;
   }
@@ -62,7 +62,7 @@ class BdpEstimator {
     GRPC_TRACE_LOG(bdp_estimator, INFO)
         << "bdp[" << name_ << "]:start acc=" << accumulator_
         << " est=" << estimate_;
-    CHECK(ping_state_ == PingState::SCHEDULED);
+    ABSL_CHECK(ping_state_ == PingState::SCHEDULED);
     ping_state_ = PingState::STARTED;
     ping_start_time_ = gpr_now(GPR_CLOCK_MONOTONIC);
   }
diff --git a/third_party/grpc/source/src/core/lib/transport/call_destination.h b/third_party/grpc/source/src/core/lib/transport/call_destination.h
index 5caf299d3872b..6a1736f281f12 100644
--- a/third_party/grpc/source/src/core/lib/transport/call_destination.h
+++ b/third_party/grpc/source/src/core/lib/transport/call_destination.h
@@ -38,7 +38,7 @@ class UnstartedCallDestination
   // and started.
   // Must be called from the party owned by the call, eg the following must
   // hold:
-  // CHECK(GetContext<Activity>() == unstarted_call_handler.party());
+  // ABSL_CHECK(GetContext<Activity>() == unstarted_call_handler.party());
   virtual void StartCall(UnstartedCallHandler unstarted_call_handler) = 0;
 };

diff --git a/third_party/grpc/source/src/core/lib/transport/call_filters.cc b/third_party/grpc/source/src/core/lib/transport/call_filters.cc
index b023144a60988..1eeceaea5d69e 100644
--- a/third_party/grpc/source/src/core/lib/transport/call_filters.cc
+++ b/third_party/grpc/source/src/core/lib/transport/call_filters.cc
@@ -16,8 +16,8 @@

 #include <grpc/support/port_platform.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/transport/metadata.h"
 #include "src/core/util/crash.h"

@@ -30,7 +30,7 @@ char CallFilters::g_empty_call_data_;
 // CallFilters

 void CallFilters::Start() {
-  CHECK_EQ(call_data_, nullptr);
+  ABSL_CHECK_EQ(call_data_, nullptr);
   size_t call_data_alignment = 1;
   for (const auto& stack : stacks_) {
     call_data_alignment =
@@ -83,11 +83,11 @@ void CallFilters::CancelDueToFailedPipeOperation(SourceLocation but_where) {
 }

 void CallFilters::PushServerTrailingMetadata(ServerMetadataHandle md) {
-  CHECK(md != nullptr);
+  ABSL_CHECK(md != nullptr);
   GRPC_TRACE_LOG(call, INFO)
       << GetContext<Activity>()->DebugTag() << " PushServerTrailingMetadata["
       << this << "]: " << md->DebugString() << " into " << DebugString();
-  CHECK(md != nullptr);
+  ABSL_CHECK(md != nullptr);
   if (call_state_.PushServerTrailingMetadata(
           md->get(GrpcCallWasCancelled()).value_or(false))) {
     push_server_trailing_metadata_ = std::move(md);
diff --git a/third_party/grpc/source/src/core/lib/transport/call_filters.h b/third_party/grpc/source/src/core/lib/transport/call_filters.h
index 733382e86e15e..461ede0cd918e 100644
--- a/third_party/grpc/source/src/core/lib/transport/call_filters.h
+++ b/third_party/grpc/source/src/core/lib/transport/call_filters.h
@@ -23,7 +23,7 @@
 #include <ostream>
 #include <type_traits>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/promise/for_each.h"
 #include "src/core/lib/promise/if.h"
 #include "src/core/lib/promise/latch.h"
@@ -146,9 +146,9 @@ class NextMessage {
   NextMessage() = default;
   explicit NextMessage(Failure) : message_(error()), call_state_(nullptr) {}
   NextMessage(MessageHandle message, CallState* call_state) {
-    DCHECK_NE(call_state, nullptr);
-    DCHECK_NE(message.get(), nullptr);
-    DCHECK(message.get_deleter().has_freelist());
+    ABSL_DCHECK_NE(call_state, nullptr);
+    ABSL_DCHECK_NE(message.get(), nullptr);
+    ABSL_DCHECK(message.get_deleter().has_freelist());
     message_ = message.release();
     call_state_ = call_state;
   }
@@ -171,31 +171,31 @@ class NextMessage {
   }

   bool ok() const {
-    DCHECK_NE(message_, taken());
+    ABSL_DCHECK_NE(message_, taken());
     return message_ != error();
   }
   bool has_value() const {
-    DCHECK_NE(message_, taken());
-    DCHECK(ok());
+    ABSL_DCHECK_NE(message_, taken());
+    ABSL_DCHECK(ok());
     return message_ != end_of_stream();
   }
   StatusFlag status() const { return StatusFlag(ok()); }
   Message& value() {
-    DCHECK_NE(message_, taken());
-    DCHECK(ok());
-    DCHECK(has_value());
+    ABSL_DCHECK_NE(message_, taken());
+    ABSL_DCHECK(ok());
+    ABSL_DCHECK(has_value());
     return *message_;
   }
   MessageHandle TakeValue() {
-    DCHECK_NE(message_, taken());
-    DCHECK(ok());
-    DCHECK(has_value());
+    ABSL_DCHECK_NE(message_, taken());
+    ABSL_DCHECK(ok());
+    ABSL_DCHECK(has_value());
     return MessageHandle(std::exchange(message_, taken()),
                          Arena::PooledDeleter());
   }
   bool progressed() const { return call_state_ == nullptr; }
   void Progress() {
-    DCHECK(!progressed());
+    ABSL_DCHECK(!progressed());
     (call_state_->*on_progress)();
     call_state_ = nullptr;
   }
@@ -264,7 +264,7 @@ template <typename T>
 struct ResultOr {
   ResultOr(T ok, ServerMetadataHandle error)
       : ok(std::move(ok)), error(std::move(error)) {
-    CHECK((this->ok == nullptr) ^ (this->error == nullptr));
+    ABSL_CHECK((this->ok == nullptr) ^ (this->error == nullptr));
   }
   T ok;
   ServerMetadataHandle error;
@@ -1177,13 +1177,13 @@ struct StackData {

   template <typename FilterType>
   void AddFinalizer(FilterType*, size_t, const NoInterceptor* p) {
-    DCHECK(p == &FilterType::Call::OnFinalize);
+    ABSL_DCHECK(p == &FilterType::Call::OnFinalize);
   }

   template <typename FilterType>
   void AddFinalizer(FilterType* channel_data, size_t call_offset,
                     void (FilterType::Call::*p)(const grpc_call_final_info*)) {
-    DCHECK(p == &FilterType::Call::OnFinalize);
+    ABSL_DCHECK(p == &FilterType::Call::OnFinalize);
     finalizers.push_back(Finalizer{
         channel_data,
         call_offset,
@@ -1198,7 +1198,7 @@ struct StackData {
   void AddFinalizer(FilterType* channel_data, size_t call_offset,
                     void (FilterType::Call::*p)(const grpc_call_final_info*,
                                                 FilterType*)) {
-    DCHECK(p == &FilterType::Call::OnFinalize);
+    ABSL_DCHECK(p == &FilterType::Call::OnFinalize);
     finalizers.push_back(Finalizer{
         channel_data,
         call_offset,
@@ -1228,11 +1228,11 @@ class OperationExecutor {
   OperationExecutor(OperationExecutor&& other) noexcept
       : ops_(other.ops_), end_ops_(other.end_ops_) {
     // Movable iff we're not running.
-    DCHECK_EQ(other.promise_data_, nullptr);
+    ABSL_DCHECK_EQ(other.promise_data_, nullptr);
   }
   OperationExecutor& operator=(OperationExecutor&& other) noexcept {
-    DCHECK_EQ(other.promise_data_, nullptr);
-    DCHECK_EQ(promise_data_, nullptr);
+    ABSL_DCHECK_EQ(other.promise_data_, nullptr);
+    ABSL_DCHECK_EQ(promise_data_, nullptr);
     ops_ = other.ops_;
     end_ops_ = other.end_ops_;
     return *this;
@@ -1285,7 +1285,7 @@ OperationExecutor<T>::Start(const Layout<T>* layout, T input, void* call_data) {
   if (layout->promise_size == 0) {
     // No call state ==> instantaneously ready
     auto r = InitStep(std::move(input), call_data);
-    CHECK(r.ready());
+    ABSL_CHECK(r.ready());
     return r;
   }
   promise_data_ =
@@ -1296,7 +1296,7 @@ OperationExecutor<T>::Start(const Layout<T>* layout, T input, void* call_data) {
 template <typename T>
 GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline Poll<ResultOr<T>>
 OperationExecutor<T>::InitStep(T input, void* call_data) {
-  CHECK(input != nullptr);
+  ABSL_CHECK(input != nullptr);
   while (true) {
     if (ops_ == end_ops_) {
       return ResultOr<T>{std::move(input), nullptr};
@@ -1317,7 +1317,7 @@ OperationExecutor<T>::InitStep(T input, void* call_data) {
 template <typename T>
 GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline Poll<ResultOr<T>>
 OperationExecutor<T>::Step(void* call_data) {
-  DCHECK_NE(promise_data_, nullptr);
+  ABSL_DCHECK_NE(promise_data_, nullptr);
   auto p = ContinueStep(call_data);
   if (p.ready()) {
     gpr_free_aligned(promise_data_);
@@ -1412,7 +1412,7 @@ struct FailureStatusCastImpl<filters_detail::NextMessage<on_progress>,
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION static filters_detail::NextMessage<
       on_progress>
   Cast(StatusFlag flag) {
-    DCHECK_EQ(flag, Failure{});
+    ABSL_DCHECK_EQ(flag, Failure{});
     return filters_detail::NextMessage<on_progress>(Failure{});
   }
 };
@@ -1432,12 +1432,12 @@ struct TrySeqTraitsWithSfinae<filters_detail::NextMessage<on_progress>> {
     return value.ok();
   }
   static const char* ErrorString(const WrappedType& status) {
-    DCHECK(!status.ok());
+    ABSL_DCHECK(!status.ok());
     return "failed";
   }
   template <typename R>
   static R ReturnValue(WrappedType&& status) {
-    DCHECK(!status.ok());
+    ABSL_DCHECK(!status.ok());
     return WrappedType(Failure{});
   }
   template <typename F, typename Elem>
@@ -1581,13 +1581,13 @@ class CallFilters {
         : stack_current_(stack_begin),
           stack_end_(stack_end),
           filters_(filters) {
-      DCHECK_NE((filters_->*input_location).get(), nullptr);
+      ABSL_DCHECK_NE((filters_->*input_location).get(), nullptr);
     }

     Poll<ValueOrFailure<Output>> operator()() {
       if ((filters_->*input_location) != nullptr) {
         if (stack_current_ == stack_end_) {
-          DCHECK_NE((filters_->*input_location).get(), nullptr);
+          ABSL_DCHECK_NE((filters_->*input_location).get(), nullptr);
           (filters_->call_state_.*on_done)();
           return Output(std::move(filters_->*input_location));
         }
@@ -1638,13 +1638,13 @@ class CallFilters {
         : stack_current_(stack_begin),
           stack_end_(stack_end),
           filters_(filters) {
-      DCHECK_NE((filters_->*input_location).get(), nullptr);
+      ABSL_DCHECK_NE((filters_->*input_location).get(), nullptr);
     }

     Poll<NextMsg> operator()() {
       if ((filters_->*input_location) != nullptr) {
         if (stack_current_ == stack_end_) {
-          DCHECK_NE((filters_->*input_location).get(), nullptr);
+          ABSL_DCHECK_NE((filters_->*input_location).get(), nullptr);
           return NextMsg(std::move(filters_->*input_location),
                          &filters_->call_state_);
         }
@@ -1732,8 +1732,8 @@ class CallFilters {
   // Returns a promise that resolves to a StatusFlag indicating success
   GRPC_MUST_USE_RESULT auto PushClientToServerMessage(MessageHandle message) {
     call_state_.BeginPushClientToServerMessage();
-    DCHECK_NE(message.get(), nullptr);
-    DCHECK_EQ(push_client_to_server_message_.get(), nullptr);
+    ABSL_DCHECK_NE(message.get(), nullptr);
+    ABSL_DCHECK_EQ(push_client_to_server_message_.get(), nullptr);
     push_client_to_server_message_ = std::move(message);
     return [this]() { return call_state_.PollPushClientToServerMessage(); };
   }
diff --git a/third_party/grpc/source/src/core/lib/transport/call_spine.cc b/third_party/grpc/source/src/core/lib/transport/call_spine.cc
index 17d4b02c47b91..b726822e25a9c 100644
--- a/third_party/grpc/source/src/core/lib/transport/call_spine.cc
+++ b/third_party/grpc/source/src/core/lib/transport/call_spine.cc
@@ -79,8 +79,8 @@ void ForwardCall(CallHandler call_handler, CallInitiator call_initiator,

 CallInitiatorAndHandler MakeCallPair(
     ClientMetadataHandle client_initial_metadata, RefCountedPtr<Arena> arena) {
-  DCHECK_NE(arena.get(), nullptr);
-  DCHECK_NE(arena->GetContext<grpc_event_engine::experimental::EventEngine>(),
+  ABSL_DCHECK_NE(arena.get(), nullptr);
+  ABSL_DCHECK_NE(arena->GetContext<grpc_event_engine::experimental::EventEngine>(),
             nullptr);
   auto spine =
       CallSpine::Create(std::move(client_initial_metadata), std::move(arena));
diff --git a/third_party/grpc/source/src/core/lib/transport/call_spine.h b/third_party/grpc/source/src/core/lib/transport/call_spine.h
index 084550a24fcf0..7eb8d050eb679 100644
--- a/third_party/grpc/source/src/core/lib/transport/call_spine.h
+++ b/third_party/grpc/source/src/core/lib/transport/call_spine.h
@@ -17,7 +17,7 @@

 #include <grpc/support/port_platform.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/promise/detail/status.h"
 #include "src/core/lib/promise/if.h"
 #include "src/core/lib/promise/latch.h"
@@ -131,7 +131,7 @@ class CallSpine final : public Party {
   // The resulting (returned) promise will resolve to Empty.
   template <typename Promise>
   auto CancelIfFails(Promise promise) {
-    DCHECK(GetContext<Activity>() == this);
+    ABSL_DCHECK(GetContext<Activity>() == this);
     using P = promise_detail::PromiseLike<Promise>;
     using ResultType = typename P::Result;
     return Map(std::move(promise), [this](ResultType r) {
@@ -352,14 +352,14 @@ class CallInitiator {
   }

   void Cancel(absl::Status error) {
-    CHECK(!error.ok());
+    ABSL_CHECK(!error.ok());
     auto status = ServerMetadataFromStatus(error);
     status->Set(GrpcCallWasCancelled(), true);
     spine_->PushServerTrailingMetadata(std::move(status));
   }

   void SpawnCancel(absl::Status error) {
-    CHECK(!error.ok());
+    ABSL_CHECK(!error.ok());
     auto status = ServerMetadataFromStatus(error);
     status->Set(GrpcCallWasCancelled(), true);
     spine_->SpawnPushServerTrailingMetadata(std::move(status));
@@ -491,7 +491,7 @@ class CallHandler {
   }

   void AddChildCall(const CallInitiator& initiator) {
-    CHECK(initiator.spine_ != nullptr);
+    ABSL_CHECK(initiator.spine_ != nullptr);
     spine_->AddChildCall(initiator.spine_);
   }

diff --git a/third_party/grpc/source/src/core/lib/transport/call_state.h b/third_party/grpc/source/src/core/lib/transport/call_state.h
index ba4f5f94d59e3..7f7e30d68ad87 100644
--- a/third_party/grpc/source/src/core/lib/transport/call_state.h
+++ b/third_party/grpc/source/src/core/lib/transport/call_state.h
@@ -354,7 +354,7 @@ GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline void CallState::Start() {
     case ServerToClientPullState::kIdle:
     case ServerToClientPullState::kReading:
     case ServerToClientPullState::kProcessingServerToClientMessage:
-      LOG(FATAL) << "Start called twice; "
+      ABSL_LOG(FATAL) << "Start called twice; "
                  << GRPC_DUMP_ARGS(server_to_client_pull_state_);
     case ServerToClientPullState::kTerminated:
       break;
@@ -374,11 +374,11 @@ CallState::BeginPushClientToServerMessage() {
       break;
     case ClientToServerPushState::kPushedMessage:
     case ClientToServerPushState::kPushedMessageAndHalfClosed:
-      LOG(FATAL) << "PushClientToServerMessage called twice concurrently;"
+      ABSL_LOG(FATAL) << "PushClientToServerMessage called twice concurrently;"
                  << GRPC_DUMP_ARGS(client_to_server_push_state_);
       break;
     case ClientToServerPushState::kPushedHalfClose:
-      LOG(FATAL) << "PushClientToServerMessage called after half-close; "
+      ABSL_LOG(FATAL) << "PushClientToServerMessage called after half-close; "
                  << GRPC_DUMP_ARGS(client_to_server_push_state_);
       break;
     case ClientToServerPushState::kFinished:
@@ -420,7 +420,7 @@ CallState::ClientToServerHalfClose() {
       break;
     case ClientToServerPushState::kPushedHalfClose:
     case ClientToServerPushState::kPushedMessageAndHalfClosed:
-      LOG(FATAL) << "ClientToServerHalfClose called twice;"
+      ABSL_LOG(FATAL) << "ClientToServerHalfClose called twice;"
                  << GRPC_DUMP_ARGS(client_to_server_push_state_);
       break;
     case ClientToServerPushState::kFinished:
@@ -442,7 +442,7 @@ CallState::BeginPullClientInitialMetadata() {
     case ClientToServerPullState::kIdle:
     case ClientToServerPullState::kReading:
     case ClientToServerPullState::kProcessingClientToServerMessage:
-      LOG(FATAL) << "BeginPullClientInitialMetadata called twice; "
+      ABSL_LOG(FATAL) << "BeginPullClientInitialMetadata called twice; "
                  << GRPC_DUMP_ARGS(client_to_server_pull_state_);
       break;
     case ClientToServerPullState::kTerminated:
@@ -457,7 +457,7 @@ CallState::FinishPullClientInitialMetadata() {
       << GRPC_DUMP_ARGS(this, client_to_server_pull_state_);
   switch (client_to_server_pull_state_) {
     case ClientToServerPullState::kBegin:
-      LOG(FATAL) << "FinishPullClientInitialMetadata called before Begin; "
+      ABSL_LOG(FATAL) << "FinishPullClientInitialMetadata called before Begin; "
                  << GRPC_DUMP_ARGS(client_to_server_pull_state_);
       break;
     case ClientToServerPullState::kProcessingClientInitialMetadata:
@@ -467,7 +467,7 @@ CallState::FinishPullClientInitialMetadata() {
     case ClientToServerPullState::kIdle:
     case ClientToServerPullState::kReading:
     case ClientToServerPullState::kProcessingClientToServerMessage:
-      LOG(FATAL) << "Out of order FinishPullClientInitialMetadata"
+      ABSL_LOG(FATAL) << "Out of order FinishPullClientInitialMetadata"
                  << GRPC_DUMP_ARGS(client_to_server_pull_state_);
       break;
     case ClientToServerPullState::kTerminated:
@@ -492,14 +492,14 @@ CallState::PollPullClientToServerMessageAvailable() {
     case ClientToServerPullState::kReading:
       break;
     case ClientToServerPullState::kProcessingClientToServerMessage:
-      LOG(FATAL) << "PollPullClientToServerMessageAvailable called while "
+      ABSL_LOG(FATAL) << "PollPullClientToServerMessageAvailable called while "
                     "processing a message; "
                  << GRPC_DUMP_ARGS(client_to_server_pull_state_);
       break;
     case ClientToServerPullState::kTerminated:
       return Failure{};
   }
-  DCHECK_EQ(client_to_server_pull_state_, ClientToServerPullState::kReading);
+  ABSL_DCHECK_EQ(client_to_server_pull_state_, ClientToServerPullState::kReading);
   switch (client_to_server_push_state_) {
     case ClientToServerPushState::kIdle:
       return client_to_server_push_waiter_.pending();
@@ -545,17 +545,17 @@ CallState::FinishPullClientToServerMessage() {
   switch (client_to_server_pull_state_) {
     case ClientToServerPullState::kBegin:
     case ClientToServerPullState::kProcessingClientInitialMetadata:
-      LOG(FATAL) << "FinishPullClientToServerMessage called before Begin; "
+      ABSL_LOG(FATAL) << "FinishPullClientToServerMessage called before Begin; "
                  << GRPC_DUMP_ARGS(client_to_server_pull_state_,
                                    client_to_server_push_state_);
       break;
     case ClientToServerPullState::kIdle:
-      LOG(FATAL) << "FinishPullClientToServerMessage called twice; "
+      ABSL_LOG(FATAL) << "FinishPullClientToServerMessage called twice; "
                  << GRPC_DUMP_ARGS(client_to_server_pull_state_,
                                    client_to_server_push_state_);
       break;
     case ClientToServerPullState::kReading:
-      LOG(FATAL) << "FinishPullClientToServerMessage called before "
+      ABSL_LOG(FATAL) << "FinishPullClientToServerMessage called before "
                     "PollPullClientToServerMessageAvailable; "
                  << GRPC_DUMP_ARGS(client_to_server_pull_state_,
                                    client_to_server_push_state_);
@@ -574,7 +574,7 @@ CallState::FinishPullClientToServerMessage() {
       break;
     case ClientToServerPushState::kIdle:
     case ClientToServerPushState::kPushedHalfClose:
-      LOG(FATAL) << "FinishPullClientToServerMessage called without a message; "
+      ABSL_LOG(FATAL) << "FinishPullClientToServerMessage called without a message; "
                  << GRPC_DUMP_ARGS(client_to_server_pull_state_,
                                    client_to_server_push_state_);
       break;
@@ -611,7 +611,7 @@ CallState::PushServerInitialMetadata() {
     case ServerToClientPushState::kTrailersOnly:
     case ServerToClientPushState::kIdle:
     case ServerToClientPushState::kPushedMessage:
-      LOG(FATAL) << "PushServerInitialMetadata called twice; "
+      ABSL_LOG(FATAL) << "PushServerInitialMetadata called twice; "
                  << GRPC_DUMP_ARGS(server_to_client_push_state_);
       break;
     case ServerToClientPushState::kFinished:
@@ -638,7 +638,7 @@ CallState::BeginPushServerToClientMessage() {
     case ServerToClientPushState::kPushedServerInitialMetadataAndPushedMessage:
     case ServerToClientPushState::kPushedMessageWithoutInitialMetadata:
     case ServerToClientPushState::kPushedMessage:
-      LOG(FATAL) << "BeginPushServerToClientMessage called twice concurrently; "
+      ABSL_LOG(FATAL) << "BeginPushServerToClientMessage called twice concurrently; "
                  << GRPC_DUMP_ARGS(server_to_client_push_state_);
       break;
     case ServerToClientPushState::kTrailersOnly:
@@ -661,7 +661,7 @@ CallState::PollPushServerToClientMessage() {
   switch (server_to_client_push_state_) {
     case ServerToClientPushState::kStart:
     case ServerToClientPushState::kPushedServerInitialMetadata:
-      LOG(FATAL) << "PollPushServerToClientMessage called before "
+      ABSL_LOG(FATAL) << "PollPushServerToClientMessage called before "
                  << "PushServerInitialMetadata; "
                  << GRPC_DUMP_ARGS(server_to_client_push_state_);
     case ServerToClientPushState::kTrailersOnly:
@@ -763,13 +763,13 @@ CallState::PollPullServerInitialMetadataAvailable() {
     case ServerToClientPullState::kIdle:
     case ServerToClientPullState::kReading:
     case ServerToClientPullState::kProcessingServerToClientMessage:
-      LOG(FATAL) << "PollPullServerInitialMetadataAvailable called twice; "
+      ABSL_LOG(FATAL) << "PollPullServerInitialMetadataAvailable called twice; "
                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
                                    server_to_client_push_state_);
     case ServerToClientPullState::kTerminated:
       return false;
   }
-  DCHECK(server_to_client_pull_state_ == ServerToClientPullState::kStarted ||
+  ABSL_DCHECK(server_to_client_pull_state_ == ServerToClientPullState::kStarted ||
          server_to_client_pull_state_ ==
              ServerToClientPullState::kStartedReading)
       << server_to_client_pull_state_;
@@ -787,7 +787,7 @@ CallState::PollPullServerInitialMetadataAvailable() {
       return true;
     case ServerToClientPushState::kIdle:
     case ServerToClientPushState::kPushedMessage:
-      LOG(FATAL)
+      ABSL_LOG(FATAL)
           << "PollPullServerInitialMetadataAvailable after metadata processed; "
           << GRPC_DUMP_ARGS(server_to_client_pull_state_,
                             server_to_client_push_state_);
@@ -809,10 +809,10 @@ CallState::FinishPullServerInitialMetadata() {
   switch (server_to_client_pull_state_) {
     case ServerToClientPullState::kUnstarted:
     case ServerToClientPullState::kUnstartedReading:
-      LOG(FATAL) << "FinishPullServerInitialMetadata called before Start";
+      ABSL_LOG(FATAL) << "FinishPullServerInitialMetadata called before Start";
     case ServerToClientPullState::kStarted:
     case ServerToClientPullState::kStartedReading:
-      CHECK_EQ(server_to_client_push_state_,
+      ABSL_CHECK_EQ(server_to_client_push_state_,
                ServerToClientPushState::kTrailersOnly);
       return;
     case ServerToClientPullState::kProcessingServerInitialMetadata:
@@ -826,19 +826,19 @@ CallState::FinishPullServerInitialMetadata() {
     case ServerToClientPullState::kIdle:
     case ServerToClientPullState::kReading:
     case ServerToClientPullState::kProcessingServerToClientMessage:
-      LOG(FATAL) << "Out of order FinishPullServerInitialMetadata; "
+      ABSL_LOG(FATAL) << "Out of order FinishPullServerInitialMetadata; "
                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
                                    server_to_client_push_state_);
     case ServerToClientPullState::kTerminated:
       return;
   }
-  DCHECK(server_to_client_pull_state_ == ServerToClientPullState::kIdle ||
+  ABSL_DCHECK(server_to_client_pull_state_ == ServerToClientPullState::kIdle ||
          server_to_client_pull_state_ == ServerToClientPullState::kReading)
       << server_to_client_pull_state_;
   switch (server_to_client_push_state_) {
     case ServerToClientPushState::kStart:
     case ServerToClientPushState::kPushedMessageWithoutInitialMetadata:
-      LOG(FATAL) << "FinishPullServerInitialMetadata called before initial "
+      ABSL_LOG(FATAL) << "FinishPullServerInitialMetadata called before initial "
                     "metadata consumed; "
                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
                                    server_to_client_push_state_);
@@ -854,7 +854,7 @@ CallState::FinishPullServerInitialMetadata() {
     case ServerToClientPushState::kPushedMessage:
     case ServerToClientPushState::kTrailersOnly:
     case ServerToClientPushState::kFinished:
-      LOG(FATAL) << "FinishPullServerInitialMetadata called twice; "
+      ABSL_LOG(FATAL) << "FinishPullServerInitialMetadata called twice; "
                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
                                    server_to_client_push_state_);
   }
@@ -894,14 +894,14 @@ CallState::PollPullServerToClientMessageAvailable() {
     case ServerToClientPullState::kReading:
       break;
     case ServerToClientPullState::kProcessingServerToClientMessage:
-      LOG(FATAL) << "PollPullServerToClientMessageAvailable called while "
+      ABSL_LOG(FATAL) << "PollPullServerToClientMessageAvailable called while "
                     "processing a message; "
                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
                                    server_to_client_push_state_);
     case ServerToClientPullState::kTerminated:
       return Failure{};
   }
-  DCHECK_EQ(server_to_client_pull_state_, ServerToClientPullState::kReading);
+  ABSL_DCHECK_EQ(server_to_client_pull_state_, ServerToClientPullState::kReading);
   switch (server_to_client_push_state_) {
     case ServerToClientPushState::kStart:
     case ServerToClientPushState::kPushedMessageWithoutInitialMetadata:
@@ -916,7 +916,7 @@ CallState::PollPullServerToClientMessageAvailable() {
       server_trailing_metadata_waiter_.pending();
       return server_to_client_push_waiter_.pending();
     case ServerToClientPushState::kTrailersOnly:
-      DCHECK_NE(server_trailing_metadata_state_,
+      ABSL_DCHECK_NE(server_trailing_metadata_state_,
                 ServerTrailingMetadataState::kNotPushed);
       return false;
     case ServerToClientPushState::kPushedMessage:
@@ -968,16 +968,16 @@ CallState::FinishPullServerToClientMessage() {
     case ServerToClientPullState::kStartedReading:
     case ServerToClientPullState::kProcessingServerInitialMetadata:
     case ServerToClientPullState::kProcessingServerInitialMetadataReading:
-      LOG(FATAL) << "FinishPullServerToClientMessage called before metadata "
+      ABSL_LOG(FATAL) << "FinishPullServerToClientMessage called before metadata "
                     "available; "
                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
                                    server_to_client_push_state_);
     case ServerToClientPullState::kIdle:
-      LOG(FATAL) << "FinishPullServerToClientMessage called twice; "
+      ABSL_LOG(FATAL) << "FinishPullServerToClientMessage called twice; "
                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
                                    server_to_client_push_state_);
     case ServerToClientPullState::kReading:
-      LOG(FATAL) << "FinishPullServerToClientMessage called before "
+      ABSL_LOG(FATAL) << "FinishPullServerToClientMessage called before "
                  << "PollPullServerToClientMessageAvailable; "
                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
                                    server_to_client_push_state_);
@@ -993,12 +993,12 @@ CallState::FinishPullServerToClientMessage() {
     case ServerToClientPushState::kPushedServerInitialMetadataAndPushedMessage:
     case ServerToClientPushState::kPushedServerInitialMetadata:
     case ServerToClientPushState::kStart:
-      LOG(FATAL) << "FinishPullServerToClientMessage called before initial "
+      ABSL_LOG(FATAL) << "FinishPullServerToClientMessage called before initial "
                     "metadata consumed; "
                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
                                    server_to_client_push_state_);
     case ServerToClientPushState::kTrailersOnly:
-      LOG(FATAL) << "FinishPullServerToClientMessage called after "
+      ABSL_LOG(FATAL) << "FinishPullServerToClientMessage called after "
                     "PushServerTrailingMetadata; "
                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
                                    server_to_client_push_state_);
@@ -1007,7 +1007,7 @@ CallState::FinishPullServerToClientMessage() {
       server_to_client_push_waiter_.Wake();
       break;
     case ServerToClientPushState::kIdle:
-      LOG(FATAL) << "FinishPullServerToClientMessage called without a message; "
+      ABSL_LOG(FATAL) << "FinishPullServerToClientMessage called without a message; "
                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
                                    server_to_client_push_state_);
     case ServerToClientPushState::kFinished:
@@ -1075,7 +1075,7 @@ CallState::PollServerTrailingMetadataAvailable() {
     case ServerTrailingMetadataState::kNotPushed:
     case ServerTrailingMetadataState::kPulled:
     case ServerTrailingMetadataState::kPulledCancel:
-      LOG(FATAL) << "PollServerTrailingMetadataAvailable completed twice; "
+      ABSL_LOG(FATAL) << "PollServerTrailingMetadataAvailable completed twice; "
                  << GRPC_DUMP_ARGS(server_to_client_pull_state_,
                                    server_trailing_metadata_state_);
   }
diff --git a/third_party/grpc/source/src/core/lib/transport/connectivity_state.cc b/third_party/grpc/source/src/core/lib/transport/connectivity_state.cc
index 2a9e86c9e3db9..9425e9b39d1f6 100644
--- a/third_party/grpc/source/src/core/lib/transport/connectivity_state.cc
+++ b/third_party/grpc/source/src/core/lib/transport/connectivity_state.cc
@@ -20,7 +20,7 @@

 #include <grpc/support/port_platform.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/iomgr/closure.h"
 #include "src/core/lib/iomgr/error.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
diff --git a/third_party/grpc/source/src/core/lib/transport/interception_chain.h b/third_party/grpc/source/src/core/lib/transport/interception_chain.h
index fc6ea72e28236..431790987c86c 100644
--- a/third_party/grpc/source/src/core/lib/transport/interception_chain.h
+++ b/third_party/grpc/source/src/core/lib/transport/interception_chain.h
@@ -211,7 +211,7 @@ class InterceptionChainBuilder final {
   }

   void Fail(absl::Status status) {
-    CHECK(!status.ok()) << status;
+    ABSL_CHECK(!status.ok()) << status;
     if (status_.ok()) status_ = std::move(status);
   }

diff --git a/third_party/grpc/source/src/core/lib/transport/metadata_batch.h b/third_party/grpc/source/src/core/lib/transport/metadata_batch.h
index 2bd5f3d62d851..fd64c1e80c4e4 100644
--- a/third_party/grpc/source/src/core/lib/transport/metadata_batch.h
+++ b/third_party/grpc/source/src/core/lib/transport/metadata_batch.h
@@ -32,7 +32,7 @@

 #include "absl/container/inlined_vector.h"
 #include "absl/functional/function_ref.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/meta/type_traits.h"
 #include "absl/strings/numbers.h"
 #include "absl/strings/string_view.h"
@@ -107,7 +107,7 @@ struct TeMetadata {
                                   MetadataParseErrorFn on_error);
   static ValueType MementoToValue(MementoType te) { return te; }
   static StaticSlice Encode(ValueType x) {
-    CHECK(x == kTrailers);
+    ABSL_CHECK(x == kTrailers);
     return StaticSlice::FromStaticString("trailers");
   }
   static const char* DisplayValue(ValueType te);
@@ -213,7 +213,7 @@ struct CompressionAlgorithmBasedMetadata {
                                   MetadataParseErrorFn on_error);
   static ValueType MementoToValue(MementoType x) { return x; }
   static Slice Encode(ValueType x) {
-    CHECK(x != GRPC_COMPRESS_ALGORITHMS_COUNT);
+    ABSL_CHECK(x != GRPC_COMPRESS_ALGORITHMS_COUNT);
     return Slice::FromStaticString(CompressionAlgorithmAsString(x));
   }
   static const char* DisplayValue(ValueType x) {
diff --git a/third_party/grpc/source/src/core/lib/transport/promise_endpoint.cc b/third_party/grpc/source/src/core/lib/transport/promise_endpoint.cc
index 656297624de8f..6cc5e34086f26 100644
--- a/third_party/grpc/source/src/core/lib/transport/promise_endpoint.cc
+++ b/third_party/grpc/source/src/core/lib/transport/promise_endpoint.cc
@@ -25,7 +25,7 @@
 #include <optional>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "src/core/lib/slice/slice_buffer.h"
 #include "src/core/util/sync.h"
@@ -37,7 +37,7 @@ PromiseEndpoint::PromiseEndpoint(
         endpoint,
     SliceBuffer already_received)
     : endpoint_(std::move(endpoint)) {
-  CHECK_NE(endpoint_, nullptr);
+  ABSL_CHECK_NE(endpoint_, nullptr);
   read_state_->endpoint = endpoint_;
   // TODO(ladynana): Replace this with `SliceBufferCast<>` when it is
   // available.
@@ -71,7 +71,7 @@ void PromiseEndpoint::ReadState::Complete(absl::Status status,
     // Appends `pending_buffer` to `buffer`.
     pending_buffer.MoveFirstNBytesIntoSliceBuffer(pending_buffer.Length(),
                                                   buffer);
-    DCHECK(pending_buffer.Count() == 0u);
+    ABSL_DCHECK(pending_buffer.Count() == 0u);
     if (buffer.Length() < num_bytes_requested) {
       // A further read is needed.
       // Set read args with number of bytes needed as hint.
diff --git a/third_party/grpc/source/src/core/lib/transport/promise_endpoint.h b/third_party/grpc/source/src/core/lib/transport/promise_endpoint.h
index db96dfdac87c6..ab195347c70f8 100644
--- a/third_party/grpc/source/src/core/lib/transport/promise_endpoint.h
+++ b/third_party/grpc/source/src/core/lib/transport/promise_endpoint.h
@@ -31,7 +31,7 @@
 #include <utility>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "src/core/lib/event_engine/extensions/chaotic_good_extension.h"
@@ -74,7 +74,7 @@ class PromiseEndpoint {
     // Start write and assert previous write finishes.
     auto prev = write_state_->state.exchange(WriteState::kWriting,
                                              std::memory_order_relaxed);
-    CHECK(prev == WriteState::kIdle);
+    ABSL_CHECK(prev == WriteState::kIdle);
     bool completed;
     if (data.Length() == 0) {
       completed = true;
@@ -101,7 +101,7 @@ class PromiseEndpoint {
           return [write_state = write_state_]() {
             auto prev = write_state->state.exchange(WriteState::kIdle,
                                                     std::memory_order_relaxed);
-            CHECK(prev == WriteState::kWriting);
+            ABSL_CHECK(prev == WriteState::kWriting);
             return absl::OkStatus();
           };
         },
@@ -120,7 +120,7 @@ class PromiseEndpoint {
                 }
                 // State was not Written; since we're polling it must be
                 // Writing. Assert that and return Pending.
-                CHECK(expected == WriteState::kWriting);
+                ABSL_CHECK(expected == WriteState::kWriting);
                 return Pending();
               };
             })));
@@ -135,9 +135,9 @@ class PromiseEndpoint {
   auto Read(size_t num_bytes) {
     GRPC_LATENT_SEE_PARENT_SCOPE("GRPC:Read");
     // Assert previous read finishes.
-    CHECK(!read_state_->complete.load(std::memory_order_relaxed));
+    ABSL_CHECK(!read_state_->complete.load(std::memory_order_relaxed));
     // Should not have pending reads.
-    CHECK(read_state_->pending_buffer.Count() == 0u);
+    ABSL_CHECK(read_state_->pending_buffer.Count() == 0u);
     bool complete = true;
     while (read_state_->buffer.Length() < num_bytes) {
       // Set read args with hinted bytes.
@@ -157,7 +157,7 @@ class PromiseEndpoint {
         read_state_->waker = Waker();
         read_state_->pending_buffer.MoveFirstNBytesIntoSliceBuffer(
             read_state_->pending_buffer.Length(), read_state_->buffer);
-        DCHECK(read_state_->pending_buffer.Count() == 0u);
+        ABSL_DCHECK(read_state_->pending_buffer.Count() == 0u);
       } else {
         complete = false;
         break;
@@ -236,7 +236,7 @@ class PromiseEndpoint {
       // Copy everything from read_state_->buffer into a single slice and
       // replace the contents of read_state_->buffer with that slice.
       grpc_slice slice = grpc_slice_malloc_large(read_state_->buffer.Length());
-      CHECK(reinterpret_cast<uintptr_t>(GRPC_SLICE_START_PTR(slice)) % 64 == 0);
+      ABSL_CHECK(reinterpret_cast<uintptr_t>(GRPC_SLICE_START_PTR(slice)) % 64 == 0);
       size_t ofs = 0;
       for (size_t i = 0; i < read_state_->buffer.Count(); i++) {
         memcpy(
@@ -251,7 +251,7 @@ class PromiseEndpoint {
       read_state_->buffer.Clear();
       read_state_->buffer.AppendIndexed(
           grpc_event_engine::experimental::Slice(slice));
-      DCHECK(read_state_->buffer.Length() == ofs);
+      ABSL_DCHECK(read_state_->buffer.Length() == ofs);
     }
   }

@@ -312,7 +312,7 @@ class PromiseEndpoint {
       auto prev = state.exchange(kWritten, std::memory_order_release);
       // Previous state should be Writing. If we got anything else we've entered
       // the callback path twice.
-      CHECK(prev == kWriting);
+      ABSL_CHECK(prev == kWriting);
       w.Wakeup();
     }
   };
diff --git a/third_party/grpc/source/src/core/lib/transport/timeout_encoding.cc b/third_party/grpc/source/src/core/lib/transport/timeout_encoding.cc
index ec561ce0ab378..8598e81e7458a 100644
--- a/third_party/grpc/source/src/core/lib/transport/timeout_encoding.cc
+++ b/third_party/grpc/source/src/core/lib/transport/timeout_encoding.cc
@@ -24,7 +24,7 @@
 #include <limits>

 #include "absl/base/attributes.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 namespace grpc_core {

@@ -182,7 +182,7 @@ Timeout Timeout::FromMillis(int64_t millis) {
 }

 Timeout Timeout::FromSeconds(int64_t seconds) {
-  DCHECK_NE(seconds, 0);
+  ABSL_DCHECK_NE(seconds, 0);
   if (seconds < 1000) {
     if (seconds % kSecondsPerMinute != 0) {
       return Timeout(seconds, Unit::kSeconds);
@@ -202,7 +202,7 @@ Timeout Timeout::FromSeconds(int64_t seconds) {
 }

 Timeout Timeout::FromMinutes(int64_t minutes) {
-  DCHECK_NE(minutes, 0);
+  ABSL_DCHECK_NE(minutes, 0);
   if (minutes < 1000) {
     if (minutes % kMinutesPerHour != 0) {
       return Timeout(minutes, Unit::kMinutes);
@@ -222,7 +222,7 @@ Timeout Timeout::FromMinutes(int64_t minutes) {
 }

 Timeout Timeout::FromHours(int64_t hours) {
-  DCHECK_NE(hours, 0);
+  ABSL_DCHECK_NE(hours, 0);
   if (hours < kMaxHours) {
     return Timeout(hours, Unit::kHours);
   }
diff --git a/third_party/grpc/source/src/core/lib/transport/transport.h b/third_party/grpc/source/src/core/lib/transport/transport.h
index 7df662ecfa806..79715d166eb24 100644
--- a/third_party/grpc/source/src/core/lib/transport/transport.h
+++ b/third_party/grpc/source/src/core/lib/transport/transport.h
@@ -34,7 +34,7 @@
 #include <utility>

 #include "absl/functional/any_invocable.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/string_view.h"
 #include "src/core/lib/debug/trace.h"
@@ -554,7 +554,7 @@ class Transport : public InternallyRefCounted<Transport> {
   }

   void DisconnectWithError(grpc_error_handle error) {
-    CHECK(!error.ok()) << error;
+    ABSL_CHECK(!error.ok()) << error;
     grpc_transport_op* op = grpc_make_transport_op(nullptr);
     op->disconnect_with_error = error;
     PerformOp(op);
diff --git a/third_party/grpc/source/src/core/load_balancing/child_policy_handler.cc b/third_party/grpc/source/src/core/load_balancing/child_policy_handler.cc
index 3048508314931..9e693b60dcbc9 100644
--- a/third_party/grpc/source/src/core/load_balancing/child_policy_handler.cc
+++ b/third_party/grpc/source/src/core/load_balancing/child_policy_handler.cc
@@ -22,8 +22,8 @@
 #include <memory>
 #include <string>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
@@ -67,7 +67,7 @@ class ChildPolicyHandler::Helper final
     // into place.
     if (CalledByPendingChild()) {
       if (GRPC_TRACE_FLAG_ENABLED_OBJ(*(parent()->tracer_))) {
-        LOG(INFO) << "[child_policy_handler " << parent() << "] helper " << this
+        ABSL_LOG(INFO) << "[child_policy_handler " << parent() << "] helper " << this
                   << ": pending child policy " << child_
                   << " reports state=" << ConnectivityStateName(state) << " ("
                   << status << ")";
@@ -96,7 +96,7 @@ class ChildPolicyHandler::Helper final
             : parent()->child_policy_.get();
     if (child_ != latest_child_policy) return;
     if (GRPC_TRACE_FLAG_ENABLED_OBJ(*(parent()->tracer_))) {
-      LOG(INFO) << "[child_policy_handler " << parent()
+      ABSL_LOG(INFO) << "[child_policy_handler " << parent()
                 << "] requesting re-resolution";
     }
     parent()->channel_control_helper()->RequestReresolution();
@@ -113,12 +113,12 @@ class ChildPolicyHandler::Helper final

  private:
   bool CalledByPendingChild() const {
-    CHECK_NE(child_, nullptr);
+    ABSL_CHECK_NE(child_, nullptr);
     return child_ == parent()->pending_child_policy_.get();
   }

   bool CalledByCurrentChild() const {
-    CHECK_NE(child_, nullptr);
+    ABSL_CHECK_NE(child_, nullptr);
     return child_ == parent()->child_policy_.get();
   };

@@ -131,12 +131,12 @@ class ChildPolicyHandler::Helper final

 void ChildPolicyHandler::ShutdownLocked() {
   if (GRPC_TRACE_FLAG_ENABLED_OBJ(*tracer_)) {
-    LOG(INFO) << "[child_policy_handler " << this << "] shutting down";
+    ABSL_LOG(INFO) << "[child_policy_handler " << this << "] shutting down";
   }
   shutting_down_ = true;
   if (child_policy_ != nullptr) {
     if (GRPC_TRACE_FLAG_ENABLED_OBJ(*tracer_)) {
-      LOG(INFO) << "[child_policy_handler " << this
+      ABSL_LOG(INFO) << "[child_policy_handler " << this
                 << "] shutting down lb_policy " << child_policy_.get();
     }
     grpc_pollset_set_del_pollset_set(child_policy_->interested_parties(),
@@ -145,7 +145,7 @@ void ChildPolicyHandler::ShutdownLocked() {
   }
   if (pending_child_policy_ != nullptr) {
     if (GRPC_TRACE_FLAG_ENABLED_OBJ(*tracer_)) {
-      LOG(INFO) << "[child_policy_handler " << this
+      ABSL_LOG(INFO) << "[child_policy_handler " << this
                 << "] shutting down pending lb_policy "
                 << pending_child_policy_.get();
     }
@@ -222,7 +222,7 @@ absl::Status ChildPolicyHandler::UpdateLocked(UpdateArgs args) {
     // switch to the new policy, even if the new policy stays in
     // CONNECTING for a very long period of time.
     if (GRPC_TRACE_FLAG_ENABLED_OBJ(*tracer_)) {
-      LOG(INFO) << "[child_policy_handler " << this << "] creating new "
+      ABSL_LOG(INFO) << "[child_policy_handler " << this << "] creating new "
                 << (child_policy_ == nullptr ? "" : "pending ")
                 << "child policy " << args.config->name();
     }
@@ -238,10 +238,10 @@ absl::Status ChildPolicyHandler::UpdateLocked(UpdateArgs args) {
                            ? pending_child_policy_.get()
                            : child_policy_.get();
   }
-  CHECK_NE(policy_to_update, nullptr);
+  ABSL_CHECK_NE(policy_to_update, nullptr);
   // Update the policy.
   if (GRPC_TRACE_FLAG_ENABLED_OBJ(*tracer_)) {
-    LOG(INFO) << "[child_policy_handler " << this << "] updating "
+    ABSL_LOG(INFO) << "[child_policy_handler " << this << "] updating "
               << (policy_to_update == pending_child_policy_.get() ? "pending "
                                                                   : "")
               << "child policy " << policy_to_update;
@@ -279,12 +279,12 @@ OrphanablePtr<LoadBalancingPolicy> ChildPolicyHandler::CreateChildPolicy(
   OrphanablePtr<LoadBalancingPolicy> lb_policy =
       CreateLoadBalancingPolicy(child_policy_name, std::move(lb_policy_args));
   if (GPR_UNLIKELY(lb_policy == nullptr)) {
-    LOG(ERROR) << "could not create LB policy \"" << child_policy_name << "\"";
+    ABSL_LOG(ERROR) << "could not create LB policy \"" << child_policy_name << "\"";
     return nullptr;
   }
   helper->set_child(lb_policy.get());
   if (GRPC_TRACE_FLAG_ENABLED_OBJ(*tracer_)) {
-    LOG(INFO) << "[child_policy_handler " << this
+    ABSL_LOG(INFO) << "[child_policy_handler " << this
               << "] created new LB policy \"" << child_policy_name << "\" ("
               << lb_policy.get() << ")";
   }
diff --git a/third_party/grpc/source/src/core/load_balancing/endpoint_list.cc b/third_party/grpc/source/src/core/load_balancing/endpoint_list.cc
index 8dd402f9cfc5e..44289f4a93e65 100644
--- a/third_party/grpc/source/src/core/load_balancing/endpoint_list.cc
+++ b/third_party/grpc/source/src/core/load_balancing/endpoint_list.cc
@@ -26,8 +26,8 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "src/core/config/core_configuration.h"
@@ -101,7 +101,7 @@ absl::Status EndpointList::Endpoint::Init(
       CoreConfiguration::Get().lb_policy_registry().CreateLoadBalancingPolicy(
           "pick_first", std::move(lb_policy_args));
   if (GPR_UNLIKELY(endpoint_list_->tracer_ != nullptr)) {
-    LOG(INFO) << "[" << endpoint_list_->tracer_ << " "
+    ABSL_LOG(INFO) << "[" << endpoint_list_->tracer_ << " "
               << endpoint_list_->policy_.get() << "] endpoint " << this
               << ": created child policy " << child_policy_.get();
   }
@@ -116,7 +116,7 @@ absl::Status EndpointList::Endpoint::Init(
       CoreConfiguration::Get().lb_policy_registry().ParseLoadBalancingConfig(
           Json::FromArray(
               {Json::FromObject({{"pick_first", Json::FromObject({})}})}));
-  CHECK(config.ok());
+  ABSL_CHECK(config.ok());
   // Update child policy.
   LoadBalancingPolicy::UpdateArgs update_args;
   update_args.addresses = std::make_shared<SingleEndpointIterator>(addresses);
diff --git a/third_party/grpc/source/src/core/load_balancing/grpclb/grpclb.cc b/third_party/grpc/source/src/core/load_balancing/grpclb/grpclb.cc
index 0025bd07ce927..63a240565cda3 100644
--- a/third_party/grpc/source/src/core/load_balancing/grpclb/grpclb.cc
+++ b/third_party/grpc/source/src/core/load_balancing/grpclb/grpclb.cc
@@ -82,9 +82,9 @@

 #include "absl/container/inlined_vector.h"
 #include "absl/functional/function_ref.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/log/globals.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -605,14 +605,14 @@ bool IsServerValid(const GrpcLbServer& server, size_t idx, bool log) {
   if (server.drop) return false;
   if (GPR_UNLIKELY(server.port >> 16 != 0)) {
     if (log) {
-      LOG(ERROR) << "Invalid port '" << server.port << "' at index " << idx
+      ABSL_LOG(ERROR) << "Invalid port '" << server.port << "' at index " << idx
                  << " of serverlist. Ignoring.";
     }
     return false;
   }
   if (GPR_UNLIKELY(server.ip_size != 4 && server.ip_size != 16)) {
     if (log) {
-      LOG(ERROR) << "Expected IP to be 4 or 16 bytes, got " << server.ip_size
+      ABSL_LOG(ERROR) << "Expected IP to be 4 or 16 bytes, got " << server.ip_size
                  << " at index " << idx << " of serverlist. Ignoring";
     }
     return false;
@@ -871,8 +871,8 @@ GrpcLb::BalancerCallState::BalancerCallState(
     : InternallyRefCounted<BalancerCallState>(
           GRPC_TRACE_FLAG_ENABLED(glb) ? "BalancerCallState" : nullptr),
       grpclb_policy_(std::move(parent_grpclb_policy)) {
-  CHECK(grpclb_policy_ != nullptr);
-  CHECK(!grpclb_policy()->shutting_down_);
+  ABSL_CHECK(grpclb_policy_ != nullptr);
+  ABSL_CHECK(!grpclb_policy()->shutting_down_);
   // Init the LB call. Note that the LB call will progress every time there's
   // activity in grpclb_policy_->interested_parties(), which is comprised of
   // the polling entities from client_channel.
@@ -909,7 +909,7 @@ GrpcLb::BalancerCallState::BalancerCallState(
 }

 GrpcLb::BalancerCallState::~BalancerCallState() {
-  CHECK_NE(lb_call_, nullptr);
+  ABSL_CHECK_NE(lb_call_, nullptr);
   grpc_call_unref(lb_call_);
   grpc_metadata_array_destroy(&lb_initial_metadata_recv_);
   grpc_metadata_array_destroy(&lb_trailing_metadata_recv_);
@@ -919,7 +919,7 @@ GrpcLb::BalancerCallState::~BalancerCallState() {
 }

 void GrpcLb::BalancerCallState::Orphan() {
-  CHECK_NE(lb_call_, nullptr);
+  ABSL_CHECK_NE(lb_call_, nullptr);
   // If we are here because grpclb_policy wants to cancel the call,
   // lb_on_balancer_status_received_ will complete the cancellation and clean
   // up. Otherwise, we are here because grpclb_policy has to orphan a failed
@@ -936,7 +936,7 @@ void GrpcLb::BalancerCallState::Orphan() {
 }

 void GrpcLb::BalancerCallState::StartQuery() {
-  CHECK_NE(lb_call_, nullptr);
+  ABSL_CHECK_NE(lb_call_, nullptr);
   GRPC_TRACE_LOG(glb, INFO)
       << "[grpclb " << grpclb_policy_.get() << "] lb_calld=" << this
       << ": Starting LB call " << lb_call_;
@@ -953,7 +953,7 @@ void GrpcLb::BalancerCallState::StartQuery() {
   op->reserved = nullptr;
   op++;
   // Op: send request message.
-  CHECK_NE(send_message_payload_, nullptr);
+  ABSL_CHECK_NE(send_message_payload_, nullptr);
   op->op = GRPC_OP_SEND_MESSAGE;
   op->data.send_message.send_message = send_message_payload_;
   op->flags = 0;
@@ -967,7 +967,7 @@ void GrpcLb::BalancerCallState::StartQuery() {
   call_error = grpc_call_start_batch_and_execute(lb_call_, ops,
                                                  static_cast<size_t>(op - ops),
                                                  &lb_on_initial_request_sent_);
-  CHECK_EQ(call_error, GRPC_CALL_OK);
+  ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
   // Op: recv initial metadata.
   op = ops;
   op->op = GRPC_OP_RECV_INITIAL_METADATA;
@@ -990,7 +990,7 @@ void GrpcLb::BalancerCallState::StartQuery() {
   call_error = grpc_call_start_batch_and_execute(
       lb_call_, ops, static_cast<size_t>(op - ops),
       &lb_on_balancer_message_received_);
-  CHECK_EQ(call_error, GRPC_CALL_OK);
+  ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
   // Op: recv server status.
   op = ops;
   op->op = GRPC_OP_RECV_STATUS_ON_CLIENT;
@@ -1007,7 +1007,7 @@ void GrpcLb::BalancerCallState::StartQuery() {
   call_error = grpc_call_start_batch_and_execute(
       lb_call_, ops, static_cast<size_t>(op - ops),
       &lb_on_balancer_status_received_);
-  CHECK_EQ(call_error, GRPC_CALL_OK);
+  ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
 }

 void GrpcLb::BalancerCallState::ScheduleNextClientLoadReportLocked() {
@@ -1039,7 +1039,7 @@ void GrpcLb::BalancerCallState::MaybeSendClientLoadReportLocked() {

 void GrpcLb::BalancerCallState::SendClientLoadReportLocked() {
   // Construct message payload.
-  CHECK_EQ(send_message_payload_, nullptr);
+  ABSL_CHECK_EQ(send_message_payload_, nullptr);
   // Get snapshot of stats.
   int64_t num_calls_started;
   int64_t num_calls_finished;
@@ -1080,9 +1080,9 @@ void GrpcLb::BalancerCallState::SendClientLoadReportLocked() {
   grpc_call_error call_error = grpc_call_start_batch_and_execute(
       lb_call_, &op, 1, &client_load_report_done_closure_);
   if (GPR_UNLIKELY(call_error != GRPC_CALL_OK)) {
-    LOG(ERROR) << "[grpclb " << grpclb_policy_.get() << "] lb_calld=" << this
+    ABSL_LOG(ERROR) << "[grpclb " << grpclb_policy_.get() << "] lb_calld=" << this
                << " call_error=" << call_error << " sending client load report";
-    CHECK_EQ(call_error, GRPC_CALL_OK);
+    ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
   }
 }

@@ -1150,7 +1150,7 @@ void GrpcLb::BalancerCallState::OnBalancerMessageReceivedLocked() {
     if (absl::MinLogLevel() <= absl::LogSeverityAtLeast::kError) {
       char* response_slice_str =
           grpc_dump_slice(response_slice, GPR_DUMP_ASCII | GPR_DUMP_HEX);
-      LOG(ERROR) << "[grpclb " << grpclb_policy() << "] lb_calld=" << this
+      ABSL_LOG(ERROR) << "[grpclb " << grpclb_policy() << "] lb_calld=" << this
                  << ": Invalid LB response received: '" << response_slice_str
                  << "'. Ignoring.";
       gpr_free(response_slice_str);
@@ -1176,7 +1176,7 @@ void GrpcLb::BalancerCallState::OnBalancerMessageReceivedLocked() {
         break;
       }
       case response.SERVERLIST: {
-        CHECK_NE(lb_call_, nullptr);
+        ABSL_CHECK_NE(lb_call_, nullptr);
         auto serverlist_wrapper =
             MakeRefCounted<Serverlist>(std::move(response.serverlist));
         GRPC_TRACE_LOG(glb, INFO)
@@ -1222,7 +1222,7 @@ void GrpcLb::BalancerCallState::OnBalancerMessageReceivedLocked() {
           // it in favor of the xds policy.  We will implement this the
           // right way in the xds policy instead.
           if (grpclb_policy()->fallback_mode_) {
-            LOG(INFO) << "[grpclb " << grpclb_policy()
+            ABSL_LOG(INFO) << "[grpclb " << grpclb_policy()
                       << "] Received response from balancer; exiting fallback "
                          "mode";
             grpclb_policy()->fallback_mode_ = false;
@@ -1243,7 +1243,7 @@ void GrpcLb::BalancerCallState::OnBalancerMessageReceivedLocked() {
       }
       case response.FALLBACK: {
         if (!grpclb_policy()->fallback_mode_) {
-          LOG(INFO) << "[grpclb " << grpclb_policy()
+          ABSL_LOG(INFO) << "[grpclb " << grpclb_policy()
                     << "] Entering fallback mode as requested by balancer";
           if (grpclb_policy()->fallback_at_startup_checks_pending_) {
             grpclb_policy()->fallback_at_startup_checks_pending_ = false;
@@ -1274,7 +1274,7 @@ void GrpcLb::BalancerCallState::OnBalancerMessageReceivedLocked() {
     // Reuse the "OnBalancerMessageReceivedLocked" ref taken in StartQuery().
     const grpc_call_error call_error = grpc_call_start_batch_and_execute(
         lb_call_, &op, 1, &lb_on_balancer_message_received_);
-    CHECK_EQ(call_error, GRPC_CALL_OK);
+    ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
   } else {
     Unref(DEBUG_LOCATION, "on_message_received+grpclb_shutdown");
   }
@@ -1289,10 +1289,10 @@ void GrpcLb::BalancerCallState::OnBalancerStatusReceived(

 void GrpcLb::BalancerCallState::OnBalancerStatusReceivedLocked(
     grpc_error_handle error) {
-  CHECK_NE(lb_call_, nullptr);
+  ABSL_CHECK_NE(lb_call_, nullptr);
   if (GRPC_TRACE_FLAG_ENABLED(glb)) {
     char* status_details = grpc_slice_to_c_string(lb_call_status_details_);
-    LOG(INFO) << "[grpclb " << grpclb_policy() << "] lb_calld=" << this
+    ABSL_LOG(INFO) << "[grpclb " << grpclb_policy() << "] lb_calld=" << this
               << ": Status from LB server received. Status = "
               << lb_call_status_ << ", details = '" << status_details
               << "', (lb_call: " << lb_call_ << "), error '"
@@ -1308,8 +1308,8 @@ void GrpcLb::BalancerCallState::OnBalancerStatusReceivedLocked(
     // case.
     grpclb_policy()->lb_calld_.reset();
     if (grpclb_policy()->fallback_at_startup_checks_pending_) {
-      CHECK(!seen_serverlist_);
-      LOG(INFO) << "[grpclb " << grpclb_policy()
+      ABSL_CHECK(!seen_serverlist_);
+      ABSL_LOG(INFO) << "[grpclb " << grpclb_policy()
                 << "] Balancer call finished without receiving serverlist; "
                    "entering fallback mode";
       grpclb_policy()->fallback_at_startup_checks_pending_ = false;
@@ -1322,7 +1322,7 @@ void GrpcLb::BalancerCallState::OnBalancerStatusReceivedLocked(
       // This handles the fallback-after-startup case.
       grpclb_policy()->MaybeEnterFallbackModeAfterStartup();
     }
-    CHECK(!grpclb_policy()->shutting_down_);
+    ABSL_CHECK(!grpclb_policy()->shutting_down_);
     grpclb_policy()->channel_control_helper()->RequestReresolution();
     if (seen_initial_response_) {
       // If we lose connection to the LB server, reset the backoff and restart
@@ -1476,7 +1476,7 @@ void GrpcLb::ShutdownLocked() {
   if (lb_channel_ != nullptr) {
     if (parent_channelz_node_ != nullptr) {
       channelz::ChannelNode* child_channelz_node = lb_channel_->channelz_node();
-      CHECK_NE(child_channelz_node, nullptr);
+      ABSL_CHECK_NE(child_channelz_node, nullptr);
       parent_channelz_node_->RemoveChildChannel(child_channelz_node->uuid());
     }
     lb_channel_.reset();
@@ -1526,7 +1526,7 @@ absl::Status GrpcLb::UpdateLocked(UpdateArgs args) {
   GRPC_TRACE_LOG(glb, INFO) << "[grpclb " << this << "] received update";
   const bool is_initial_update = lb_channel_ == nullptr;
   config_ = args.config.TakeAsSubclass<GrpcLbConfig>();
-  CHECK(config_ != nullptr);
+  ABSL_CHECK(config_ != nullptr);
   args_ = std::move(args.args);
   // Update fallback address list.
   if (!args.addresses.ok()) {
@@ -1580,7 +1580,7 @@ absl::Status GrpcLb::UpdateBalancerChannelLocked() {
   EndpointAddressesList balancer_addresses = ExtractBalancerAddresses(args_);
   if (GRPC_TRACE_FLAG_ENABLED(glb)) {
     for (const auto& endpoint : balancer_addresses) {
-      LOG(INFO) << "[grpclb " << this
+      ABSL_LOG(INFO) << "[grpclb " << this
                 << "] balancer address: " << endpoint.ToString();
     }
   }
@@ -1600,7 +1600,7 @@ absl::Status GrpcLb::UpdateBalancerChannelLocked() {
     lb_channel_.reset(Channel::FromC(
         grpc_channel_create(uri_str.c_str(), channel_credentials.get(),
                             lb_channel_args.ToC().get())));
-    CHECK(lb_channel_ != nullptr);
+    ABSL_CHECK(lb_channel_ != nullptr);
     // Set up channelz linkage.
     channelz::ChannelNode* child_channelz_node = lb_channel_->channelz_node();
     auto parent_channelz_node = args_.GetObjectRef<channelz::ChannelNode>();
@@ -1630,10 +1630,10 @@ void GrpcLb::CancelBalancerChannelConnectivityWatchLocked() {
 //

 void GrpcLb::StartBalancerCallLocked() {
-  CHECK(lb_channel_ != nullptr);
+  ABSL_CHECK(lb_channel_ != nullptr);
   if (shutting_down_) return;
   // Init the LB call data.
-  CHECK(lb_calld_ == nullptr);
+  ABSL_CHECK(lb_calld_ == nullptr);
   lb_calld_ = MakeOrphanable<BalancerCallState>(Ref());
   GRPC_TRACE_LOG(glb, INFO)
       << "[grpclb " << this
@@ -1645,12 +1645,12 @@ void GrpcLb::StartBalancerCallLocked() {
 void GrpcLb::StartBalancerCallRetryTimerLocked() {
   Duration delay = lb_call_backoff_.NextAttemptDelay();
   if (GRPC_TRACE_FLAG_ENABLED(glb)) {
-    LOG(INFO) << "[grpclb " << this << "] Connection to LB server lost...";
+    ABSL_LOG(INFO) << "[grpclb " << this << "] Connection to LB server lost...";
     if (delay > Duration::Zero()) {
-      LOG(INFO) << "[grpclb " << this << "] ... retry_timer_active in "
+      ABSL_LOG(INFO) << "[grpclb " << this << "] ... retry_timer_active in "
                 << delay.millis() << "ms.";
     } else {
-      LOG(INFO) << "[grpclb " << this
+      ABSL_LOG(INFO) << "[grpclb " << this
                 << "] ... retry_timer_active immediately.";
     }
   }
@@ -1690,7 +1690,7 @@ void GrpcLb::MaybeEnterFallbackModeAfterStartup() {
   if (!fallback_mode_ && !fallback_at_startup_checks_pending_ &&
       (lb_calld_ == nullptr || !lb_calld_->seen_serverlist()) &&
       !child_policy_ready_) {
-    LOG(INFO) << "[grpclb " << this
+    ABSL_LOG(INFO) << "[grpclb " << this
               << "] lost contact with balancer and backends from most recent "
                  "serverlist; entering fallback mode";
     fallback_mode_ = true;
@@ -1702,7 +1702,7 @@ void GrpcLb::OnFallbackTimerLocked() {
   // If we receive a serverlist after the timer fires but before this callback
   // actually runs, don't fall back.
   if (fallback_at_startup_checks_pending_ && !shutting_down_) {
-    LOG(INFO) << "[grpclb " << this
+    ABSL_LOG(INFO) << "[grpclb " << this
               << "] No response from balancer after fallback timeout; "
                  "entering fallback mode";
     fallback_at_startup_checks_pending_ = false;
@@ -1784,7 +1784,7 @@ void GrpcLb::CreateOrUpdateChildPolicyLocked() {
   }
   update_args.args =
       CreateChildPolicyArgsLocked(is_backend_from_grpclb_load_balancer);
-  CHECK(update_args.args != ChannelArgs());
+  ABSL_CHECK(update_args.args != ChannelArgs());
   update_args.config = config_->child_policy();
   // Create child policy if needed.
   if (child_policy_ == nullptr) {
@@ -1813,7 +1813,7 @@ void GrpcLb::CacheDeletedSubchannelLocked(
 }

 void GrpcLb::StartSubchannelCacheTimerLocked() {
-  CHECK(!cached_subchannels_.empty());
+  ABSL_CHECK(!cached_subchannels_.empty());
   subchannel_cache_timer_handle_ =
       channel_control_helper()->GetEventEngine()->RunAfter(
           cached_subchannels_.begin()->first - Timestamp::Now(),
diff --git a/third_party/grpc/source/src/core/load_balancing/grpclb/load_balancer_api.cc b/third_party/grpc/source/src/core/load_balancing/grpclb/load_balancer_api.cc
index 6fd1eafd9ff64..93d219873763b 100644
--- a/third_party/grpc/source/src/core/load_balancing/grpclb/load_balancer_api.cc
+++ b/third_party/grpc/source/src/core/load_balancing/grpclb/load_balancer_api.cc
@@ -24,7 +24,7 @@

 #include <algorithm>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "google/protobuf/duration.upb.h"
 #include "google/protobuf/timestamp.upb.h"
 #include "src/core/util/memory.h"
@@ -143,7 +143,7 @@ bool ParseServerList(const grpc_lb_v1_LoadBalanceResponse& response,
       } else if (token.size <= GRPC_GRPCLB_SERVER_LOAD_BALANCE_TOKEN_MAX_SIZE) {
         memcpy(cur.load_balance_token, token.data, token.size);
       } else {
-        LOG(ERROR) << "grpc_lb_v1_LoadBalanceResponse has too long token. len="
+        ABSL_LOG(ERROR) << "grpc_lb_v1_LoadBalanceResponse has too long token. len="
                    << token.size;
       }
       cur.drop = grpc_lb_v1_Server_drop(servers[i]);
diff --git a/third_party/grpc/source/src/core/load_balancing/health_check_client.cc b/third_party/grpc/source/src/core/load_balancing/health_check_client.cc
index e1bb7b2fbe348..c78873de3edb2 100644
--- a/third_party/grpc/source/src/core/load_balancing/health_check_client.cc
+++ b/third_party/grpc/source/src/core/load_balancing/health_check_client.cc
@@ -30,8 +30,8 @@
 #include <type_traits>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -104,7 +104,7 @@ void HealthProducer::HealthChecker::OnConnectivityStateChangeLocked(
       state_ = GRPC_CHANNEL_CONNECTING;
       status_ = absl::OkStatus();
     } else {
-      CHECK(state_ == GRPC_CHANNEL_CONNECTING);
+      ABSL_CHECK(state_ == GRPC_CHANNEL_CONNECTING);
     }
     // Start the health watch stream.
     StartHealthStreamLocked();
@@ -218,7 +218,7 @@ class HealthProducer::HealthChecker::HealthStreamEventHandler final
       static const char kErrorMessage[] =
           "health checking Watch method returned UNIMPLEMENTED; "
           "disabling health checks but assuming server is healthy";
-      LOG(ERROR) << kErrorMessage;
+      ABSL_LOG(ERROR) << kErrorMessage;
       auto* channelz_node =
           health_checker_->producer_->subchannel_->channelz_node();
       if (channelz_node != nullptr) {
diff --git a/third_party/grpc/source/src/core/load_balancing/lb_policy_registry.cc b/third_party/grpc/source/src/core/load_balancing/lb_policy_registry.cc
index 20ef3a110117e..a9efe1a4bdf7d 100644
--- a/third_party/grpc/source/src/core/load_balancing/lb_policy_registry.cc
+++ b/third_party/grpc/source/src/core/load_balancing/lb_policy_registry.cc
@@ -25,8 +25,8 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
@@ -42,8 +42,8 @@ namespace grpc_core {

 void LoadBalancingPolicyRegistry::Builder::RegisterLoadBalancingPolicyFactory(
     std::unique_ptr<LoadBalancingPolicyFactory> factory) {
-  VLOG(2) << "registering LB policy factory for \"" << factory->name() << "\"";
-  CHECK(factories_.find(factory->name()) == factories_.end());
+  ABSL_VLOG(2) << "registering LB policy factory for \"" << factory->name() << "\"";
+  ABSL_CHECK(factories_.find(factory->name()) == factories_.end());
   factories_.emplace(factory->name(), std::move(factory));
 }

diff --git a/third_party/grpc/source/src/core/load_balancing/oob_backend_metric.cc b/third_party/grpc/source/src/core/load_balancing/oob_backend_metric.cc
index 4b29bd2584768..32e648e4e3df4 100644
--- a/third_party/grpc/source/src/core/load_balancing/oob_backend_metric.cc
+++ b/third_party/grpc/source/src/core/load_balancing/oob_backend_metric.cc
@@ -29,8 +29,8 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/string_view.h"
 #include "google/protobuf/duration.upb.h"
@@ -145,7 +145,7 @@ class OrcaProducer::OrcaStreamEventHandler final
     if (status == GRPC_STATUS_UNIMPLEMENTED) {
       static const char kErrorMessage[] =
           "Orca stream returned UNIMPLEMENTED; disabling";
-      LOG(ERROR) << kErrorMessage;
+      ABSL_LOG(ERROR) << kErrorMessage;
       auto* channelz_node = producer_->subchannel_->channelz_node();
       if (channelz_node != nullptr) {
         channelz_node->AddTraceEvent(
@@ -221,7 +221,7 @@ void OrcaProducer::Orphaned() {
     MutexLock lock(&mu_);
     stream_client_.reset();
   }
-  CHECK(subchannel_ != nullptr);  // Should not be called before Start().
+  ABSL_CHECK(subchannel_ != nullptr);  // Should not be called before Start().
   subchannel_->CancelConnectivityStateWatch(connectivity_watcher_);
   subchannel_->RemoveDataProducer(this);
 }
diff --git a/third_party/grpc/source/src/core/load_balancing/outlier_detection/outlier_detection.cc b/third_party/grpc/source/src/core/load_balancing/outlier_detection/outlier_detection.cc
index dd157b373e388..b57ce8cf9611d 100644
--- a/third_party/grpc/source/src/core/load_balancing/outlier_detection/outlier_detection.cc
+++ b/third_party/grpc/source/src/core/load_balancing/outlier_detection/outlier_detection.cc
@@ -35,8 +35,8 @@
 #include <vector>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/meta/type_traits.h"
 #include "absl/random/random.h"
 #include "absl/status/status.h"
@@ -328,7 +328,7 @@ class OutlierDetectionLb final : public LoadBalancingPolicy {
           --multiplier_;
         }
       } else {
-        CHECK(ejection_time_.has_value());
+        ABSL_CHECK(ejection_time_.has_value());
         auto change_time = ejection_time_.value() +
                            Duration::Milliseconds(std::min(
                                base_ejection_time_in_millis * multiplier_,
@@ -665,7 +665,7 @@ absl::Status OutlierDetectionLb::UpdateLocked(UpdateArgs args) {
             if (GRPC_TRACE_FLAG_ENABLED(outlier_detection_lb)) {
               std::string address_str = grpc_sockaddr_to_string(&address, false)
                                             .value_or("<unknown>");
-              LOG(INFO) << "[outlier_detection_lb " << this
+              ABSL_LOG(INFO) << "[outlier_detection_lb " << this
                         << "] adding address entry for " << address_str;
             }
             it2 = subchannel_state_map_
@@ -693,7 +693,7 @@ absl::Status OutlierDetectionLb::UpdateLocked(UpdateArgs args) {
         if (GRPC_TRACE_FLAG_ENABLED(outlier_detection_lb)) {
           std::string address_str =
               grpc_sockaddr_to_string(&address, false).value_or("<unknown>");
-          LOG(INFO) << "[outlier_detection_lb " << this
+          ABSL_LOG(INFO) << "[outlier_detection_lb " << this
                     << "] removing subchannel map entry " << address_str;
         }
         // Don't hold a ref to the corresponding EndpointState object,
@@ -788,7 +788,7 @@ RefCountedPtr<SubchannelInterface> OutlierDetectionLb::Helper::CreateSubchannel(
   if (GRPC_TRACE_FLAG_ENABLED(outlier_detection_lb)) {
     std::string address_str =
         grpc_sockaddr_to_string(&address, false).value_or("<unknown>");
-    LOG(INFO) << "[outlier_detection_lb " << parent()
+    ABSL_LOG(INFO) << "[outlier_detection_lb " << parent()
               << "] creating subchannel for " << address_str
               << ", subchannel state " << subchannel_state.get();
   }
@@ -1001,7 +1001,7 @@ void OutlierDetectionLb::EjectionTimer::OnTimerLocked() {
     const bool unejected = endpoint_state->MaybeUneject(
         config.base_ejection_time.millis(), config.max_ejection_time.millis());
     if (unejected && GRPC_TRACE_FLAG_ENABLED(outlier_detection_lb)) {
-      LOG(INFO) << "[outlier_detection_lb " << parent_.get()
+      ABSL_LOG(INFO) << "[outlier_detection_lb " << parent_.get()
                 << "] unejected endpoint " << address_set.ToString() << " ("
                 << endpoint_state.get() << ")";
     }
diff --git a/third_party/grpc/source/src/core/load_balancing/pick_first/pick_first.cc b/third_party/grpc/source/src/core/load_balancing/pick_first/pick_first.cc
index 8780c4911aed8..7de500482a583 100644
--- a/third_party/grpc/source/src/core/load_balancing/pick_first/pick_first.cc
+++ b/third_party/grpc/source/src/core/load_balancing/pick_first/pick_first.cc
@@ -32,8 +32,8 @@
 #include <vector>

 #include "absl/algorithm/container.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/random/random.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
@@ -428,7 +428,7 @@ PickFirst::PickFirst(Args args)

 PickFirst::~PickFirst() {
   GRPC_TRACE_LOG(pick_first, INFO) << "Destroying Pick First " << this;
-  CHECK_EQ(subchannel_list_.get(), nullptr);
+  ABSL_CHECK_EQ(subchannel_list_.get(), nullptr);
 }

 void PickFirst::ShutdownLocked() {
@@ -459,7 +459,7 @@ void PickFirst::AttemptToConnectUsingLatestUpdateArgsLocked() {
   }
   // Replace subchannel_list_.
   if (GRPC_TRACE_FLAG_ENABLED(pick_first) && subchannel_list_ != nullptr) {
-    LOG(INFO) << "[PF " << this << "] Shutting down previous subchannel list "
+    ABSL_LOG(INFO) << "[PF " << this << "] Shutting down previous subchannel list "
               << subchannel_list_.get();
   }
   subchannel_list_ = MakeOrphanable<SubchannelList>(
@@ -510,9 +510,9 @@ class AddressFamilyIterator final {
 absl::Status PickFirst::UpdateLocked(UpdateArgs args) {
   if (GRPC_TRACE_FLAG_ENABLED(pick_first)) {
     if (args.addresses.ok()) {
-      LOG(INFO) << "Pick First " << this << " received update";
+      ABSL_LOG(INFO) << "Pick First " << this << " received update";
     } else {
-      LOG(INFO) << "Pick First " << this
+      ABSL_LOG(INFO) << "Pick First " << this
                 << " received update with address error: "
                 << args.addresses.status();
     }
@@ -696,7 +696,7 @@ void PickFirst::SubchannelList::SubchannelData::SubchannelState::Select() {
   GRPC_TRACE_LOG(pick_first, INFO)
       << "Pick First " << pick_first_.get() << " selected subchannel "
       << subchannel_.get();
-  CHECK_NE(subchannel_data_, nullptr);
+  ABSL_CHECK_NE(subchannel_data_, nullptr);
   pick_first_->UnsetSelectedSubchannel();  // Cancel health watch, if any.
   pick_first_->selected_ = std::move(subchannel_data_->subchannel_state_);
   // If health checking is enabled, start the health watch, but don't
@@ -752,7 +752,7 @@ void PickFirst::SubchannelList::SubchannelData::SubchannelState::
   // If we're still part of a subchannel list trying to connect, check
   // if we're connected.
   if (subchannel_data_ != nullptr) {
-    CHECK_EQ(pick_first_->subchannel_list_.get(),
+    ABSL_CHECK_EQ(pick_first_->subchannel_list_.get(),
              subchannel_data_->subchannel_list_);
     // If the subchannel is READY, use it.
     // Otherwise, tell the subchannel list to keep trying.
@@ -764,7 +764,7 @@ void PickFirst::SubchannelList::SubchannelData::SubchannelState::
     return;
   }
   // We aren't trying to connect, so we must be the selected subchannel.
-  CHECK_EQ(pick_first_->selected_.get(), this);
+  ABSL_CHECK_EQ(pick_first_->selected_.get(), this);
   GRPC_TRACE_LOG(pick_first, INFO)
       << "Pick First " << pick_first_.get()
       << " selected subchannel connectivity changed to "
@@ -815,12 +815,12 @@ void PickFirst::SubchannelList::SubchannelData::OnConnectivityStateChange(
       << p->subchannel_list_->shutting_down_;
   if (subchannel_list_->shutting_down_) return;
   // The notification must be for a subchannel in the current list.
-  CHECK_EQ(subchannel_list_, p->subchannel_list_.get());
+  ABSL_CHECK_EQ(subchannel_list_, p->subchannel_list_.get());
   // SHUTDOWN should never happen.
-  CHECK_NE(new_state, GRPC_CHANNEL_SHUTDOWN);
+  ABSL_CHECK_NE(new_state, GRPC_CHANNEL_SHUTDOWN);
   // READY should be caught by SubchannelState, in which case it will
   // not call us in the first place.
-  CHECK_NE(new_state, GRPC_CHANNEL_READY);
+  ABSL_CHECK_NE(new_state, GRPC_CHANNEL_READY);
   // Update state.
   std::optional<grpc_connectivity_state> old_state = connectivity_state_;
   connectivity_state_ = new_state;
@@ -939,11 +939,11 @@ void PickFirst::SubchannelList::SubchannelData::OnConnectivityStateChange(
 }

 void PickFirst::SubchannelList::SubchannelData::RequestConnectionWithTimer() {
-  CHECK(connectivity_state_.has_value());
+  ABSL_CHECK(connectivity_state_.has_value());
   if (connectivity_state_ == GRPC_CHANNEL_IDLE) {
     subchannel_state_->RequestConnection();
   } else {
-    CHECK_EQ(connectivity_state_.value(), GRPC_CHANNEL_CONNECTING);
+    ABSL_CHECK_EQ(connectivity_state_.value(), GRPC_CHANNEL_CONNECTING);
   }
   // If this is not the last subchannel in the list, start the timer.
   if (index_ != subchannel_list_->size() - 1) {
@@ -999,7 +999,7 @@ PickFirst::SubchannelList::SubchannelList(RefCountedPtr<PickFirst> policy,
   if (addresses == nullptr) return;
   // Create a subchannel for each address.
   addresses->ForEach([&](const EndpointAddresses& address) {
-    CHECK_EQ(address.addresses().size(), 1u);
+    ABSL_CHECK_EQ(address.addresses().size(), 1u);
     RefCountedPtr<SubchannelInterface> subchannel =
         policy_->channel_control_helper()->CreateSubchannel(
             address.address(), address.args(), args_);
@@ -1028,7 +1028,7 @@ PickFirst::SubchannelList::~SubchannelList() {
 void PickFirst::SubchannelList::Orphan() {
   GRPC_TRACE_LOG(pick_first, INFO)
       << "[PF " << policy_.get() << "] Shutting down subchannel_list " << this;
-  CHECK(!shutting_down_);
+  ABSL_CHECK(!shutting_down_);
   shutting_down_ = true;
   // Shut down subchannels.
   subchannels_.clear();
@@ -1060,7 +1060,7 @@ void PickFirst::SubchannelList::StartConnectingNextSubchannel() {
   // large recursion that could overflow the stack.
   for (; attempting_index_ < size(); ++attempting_index_) {
     SubchannelData* sc = subchannels_[attempting_index_].get();
-    CHECK(sc->connectivity_state().has_value());
+    ABSL_CHECK(sc->connectivity_state().has_value());
     if (sc->connectivity_state() != GRPC_CHANNEL_TRANSIENT_FAILURE) {
       // Found a subchannel not in TRANSIENT_FAILURE, so trigger a
       // connection attempt.
@@ -1381,8 +1381,8 @@ OldPickFirst::OldPickFirst(Args args)

 OldPickFirst::~OldPickFirst() {
   GRPC_TRACE_LOG(pick_first, INFO) << "Destroying Pick First " << this;
-  CHECK(subchannel_list_ == nullptr);
-  CHECK(latest_pending_subchannel_list_ == nullptr);
+  ABSL_CHECK(subchannel_list_ == nullptr);
+  ABSL_CHECK(latest_pending_subchannel_list_ == nullptr);
 }

 void OldPickFirst::ShutdownLocked() {
@@ -1418,7 +1418,7 @@ void OldPickFirst::AttemptToConnectUsingLatestUpdateArgsLocked() {
   // Replace latest_pending_subchannel_list_.
   if (GRPC_TRACE_FLAG_ENABLED(pick_first) &&
       latest_pending_subchannel_list_ != nullptr) {
-    LOG(INFO) << "[PF " << this
+    ABSL_LOG(INFO) << "[PF " << this
               << "] Shutting down previous pending subchannel list "
               << latest_pending_subchannel_list_.get();
   }
@@ -1439,7 +1439,7 @@ void OldPickFirst::AttemptToConnectUsingLatestUpdateArgsLocked() {
   if (latest_pending_subchannel_list_->size() == 0 || selected_ == nullptr) {
     UnsetSelectedSubchannel();
     if (GRPC_TRACE_FLAG_ENABLED(pick_first) && subchannel_list_ != nullptr) {
-      LOG(INFO) << "[PF " << this << "] Shutting down previous subchannel list "
+      ABSL_LOG(INFO) << "[PF " << this << "] Shutting down previous subchannel list "
                 << subchannel_list_.get();
     }
     subchannel_list_ = std::move(latest_pending_subchannel_list_);
@@ -1449,9 +1449,9 @@ void OldPickFirst::AttemptToConnectUsingLatestUpdateArgsLocked() {
 absl::Status OldPickFirst::UpdateLocked(UpdateArgs args) {
   if (GRPC_TRACE_FLAG_ENABLED(pick_first)) {
     if (args.addresses.ok()) {
-      LOG(INFO) << "Pick First " << this << " received update";
+      ABSL_LOG(INFO) << "Pick First " << this << " received update";
     } else {
-      LOG(INFO) << "Pick First " << this
+      ABSL_LOG(INFO) << "Pick First " << this
                 << " received update with address error: "
                 << args.addresses.status();
     }
@@ -1643,15 +1643,15 @@ void OldPickFirst::SubchannelList::SubchannelData::OnConnectivityStateChange(
                             ->GetStatsPluginGroup();
   // The notification must be for a subchannel in either the current or
   // latest pending subchannel lists.
-  CHECK(subchannel_list_ == p->subchannel_list_.get() ||
+  ABSL_CHECK(subchannel_list_ == p->subchannel_list_.get() ||
         subchannel_list_ == p->latest_pending_subchannel_list_.get());
-  CHECK(new_state != GRPC_CHANNEL_SHUTDOWN);
+  ABSL_CHECK(new_state != GRPC_CHANNEL_SHUTDOWN);
   std::optional<grpc_connectivity_state> old_state = connectivity_state_;
   connectivity_state_ = new_state;
   connectivity_status_ = std::move(status);
   // Handle updates for the currently selected subchannel.
   if (p->selected_ == this) {
-    CHECK(subchannel_list_ == p->subchannel_list_.get());
+    ABSL_CHECK(subchannel_list_ == p->subchannel_list_.get());
     GRPC_TRACE_LOG(pick_first, INFO)
         << "Pick First " << p << " selected subchannel connectivity changed to "
         << ConnectivityStateName(new_state);
@@ -1819,11 +1819,11 @@ void OldPickFirst::SubchannelList::SubchannelData::OnConnectivityStateChange(

 void OldPickFirst::SubchannelList::SubchannelData::
     RequestConnectionWithTimer() {
-  CHECK(connectivity_state_.has_value());
+  ABSL_CHECK(connectivity_state_.has_value());
   if (connectivity_state_ == GRPC_CHANNEL_IDLE) {
     subchannel_->RequestConnection();
   } else {
-    CHECK(connectivity_state_ == GRPC_CHANNEL_CONNECTING);
+    ABSL_CHECK(connectivity_state_ == GRPC_CHANNEL_CONNECTING);
   }
   // If this is not the last subchannel in the list, start the timer.
   if (index_ != subchannel_list_->size() - 1) {
@@ -1875,7 +1875,7 @@ void OldPickFirst::SubchannelList::SubchannelData::
   //    for a subchannel in p->latest_pending_subchannel_list_.  The
   //    goal here is to find a subchannel from the update that we can
   //    select in place of the current one.
-  CHECK(subchannel_list_ == p->subchannel_list_.get() ||
+  ABSL_CHECK(subchannel_list_ == p->subchannel_list_.get() ||
         subchannel_list_ == p->latest_pending_subchannel_list_.get());
   // Case 2.  Promote p->latest_pending_subchannel_list_ to p->subchannel_list_.
   if (subchannel_list_ == p->latest_pending_subchannel_list_.get()) {
@@ -1937,7 +1937,7 @@ OldPickFirst::SubchannelList::SubchannelList(
   if (addresses == nullptr) return;
   // Create a subchannel for each address.
   addresses->ForEach([&](const EndpointAddresses& address) {
-    CHECK_EQ(address.addresses().size(), 1u);
+    ABSL_CHECK_EQ(address.addresses().size(), 1u);
     RefCountedPtr<SubchannelInterface> subchannel =
         policy_->channel_control_helper()->CreateSubchannel(
             address.address(), address.args(), args_);
@@ -1965,7 +1965,7 @@ OldPickFirst::SubchannelList::~SubchannelList() {
 void OldPickFirst::SubchannelList::Orphan() {
   GRPC_TRACE_LOG(pick_first, INFO)
       << "[PF " << policy_.get() << "] Shutting down subchannel_list " << this;
-  CHECK(!shutting_down_);
+  ABSL_CHECK(!shutting_down_);
   shutting_down_ = true;
   for (auto& sd : subchannels_) {
     sd.ShutdownLocked();
@@ -1997,7 +1997,7 @@ void OldPickFirst::SubchannelList::StartConnectingNextSubchannel() {
   // large recursion that could overflow the stack.
   for (; attempting_index_ < size(); ++attempting_index_) {
     SubchannelData* sc = &subchannels_[attempting_index_];
-    CHECK(sc->connectivity_state().has_value());
+    ABSL_CHECK(sc->connectivity_state().has_value());
     if (sc->connectivity_state() != GRPC_CHANNEL_TRANSIENT_FAILURE) {
       // Found a subchannel not in TRANSIENT_FAILURE, so trigger a
       // connection attempt.
diff --git a/third_party/grpc/source/src/core/load_balancing/priority/priority.cc b/third_party/grpc/source/src/core/load_balancing/priority/priority.cc
index 0f8a501ff0497..cf1a71d96dcf7 100644
--- a/third_party/grpc/source/src/core/load_balancing/priority/priority.cc
+++ b/third_party/grpc/source/src/core/load_balancing/priority/priority.cc
@@ -30,8 +30,8 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -401,7 +401,7 @@ void PriorityLb::ChoosePriorityLocked() {
           RefAsSubclass<PriorityLb>(DEBUG_LOCATION, "ChildPriority"),
           child_name);
       auto child_config = config_->children().find(child_name);
-      DCHECK(child_config != config_->children().end());
+      ABSL_DCHECK(child_config != config_->children().end());
       // If the child policy returns a non-OK status, request re-resolution.
       // Note that this will initially cause fixed backoff delay in the
       // resolver instead of exponential delay.  However, once the
@@ -451,7 +451,7 @@ void PriorityLb::ChoosePriorityLocked() {
         << "[priority_lb " << this << "] trying priority " << priority
         << ", child " << child_name;
     auto& child = children_[child_name];
-    CHECK(child != nullptr);
+    ABSL_CHECK(child != nullptr);
     if (child->connectivity_state() == GRPC_CHANNEL_CONNECTING) {
       SetCurrentPriorityLocked(priority, /*deactivate_lower_priorities=*/false,
                                "CONNECTING (pass 2)");
@@ -480,7 +480,7 @@ void PriorityLb::SetCurrentPriorityLocked(int32_t priority,
     }
   }
   auto& child = children_[config_->priorities()[priority]];
-  CHECK(child != nullptr);
+  ABSL_CHECK(child != nullptr);
   channel_control_helper()->UpdateState(child->connectivity_state(),
                                         child->connectivity_status(),
                                         child->GetPicker());
diff --git a/third_party/grpc/source/src/core/load_balancing/ring_hash/ring_hash.cc b/third_party/grpc/source/src/core/load_balancing/ring_hash/ring_hash.cc
index fb6691b83e647..37592957c4edd 100644
--- a/third_party/grpc/source/src/core/load_balancing/ring_hash/ring_hash.cc
+++ b/third_party/grpc/source/src/core/load_balancing/ring_hash/ring_hash.cc
@@ -34,8 +34,8 @@

 #include "absl/base/attributes.h"
 #include "absl/container/inlined_vector.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/random/random.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
@@ -597,7 +597,7 @@ void RingHash::RingHashEndpoint::RequestConnectionLocked() {
 }

 void RingHash::RingHashEndpoint::CreateChildPolicy() {
-  CHECK(child_policy_ == nullptr);
+  ABSL_CHECK(child_policy_ == nullptr);
   LoadBalancingPolicy::Args lb_policy_args;
   lb_policy_args.work_serializer = ring_hash_->work_serializer();
   lb_policy_args.args =
@@ -611,7 +611,7 @@ void RingHash::RingHashEndpoint::CreateChildPolicy() {
           "pick_first", std::move(lb_policy_args));
   if (GRPC_TRACE_FLAG_ENABLED(ring_hash_lb)) {
     const EndpointAddresses& endpoint = ring_hash_->endpoints_[index_];
-    LOG(INFO) << "[RH " << ring_hash_.get() << "] endpoint " << this
+    ABSL_LOG(INFO) << "[RH " << ring_hash_.get() << "] endpoint " << this
               << " (index " << index_ << " of " << ring_hash_->endpoints_.size()
               << ", " << endpoint.ToString() << "): created child policy "
               << child_policy_.get();
@@ -639,7 +639,7 @@ absl::Status RingHash::RingHashEndpoint::UpdateChildPolicyLocked() {
       CoreConfiguration::Get().lb_policy_registry().ParseLoadBalancingConfig(
           Json::FromArray(
               {Json::FromObject({{"pick_first", Json::FromObject({})}})}));
-  CHECK(config.ok());
+  ABSL_CHECK(config.ok());
   // Update child policy.
   LoadBalancingPolicy::UpdateArgs update_args;
   update_args.addresses =
@@ -901,7 +901,7 @@ void RingHash::UpdateAggregatedConnectivityStateLocked(
     for (size_t i = 0; i < endpoints_.size(); ++i) {
       auto it =
           endpoint_map_.find(EndpointAddressSet(endpoints_[i].addresses()));
-      CHECK(it != endpoint_map_.end());
+      ABSL_CHECK(it != endpoint_map_.end());
       auto& endpoint = it->second;
       if (endpoint->connectivity_state() == GRPC_CHANNEL_CONNECTING) {
         first_idle_index = endpoints_.size();
@@ -915,7 +915,7 @@ void RingHash::UpdateAggregatedConnectivityStateLocked(
     if (first_idle_index != endpoints_.size()) {
       auto it = endpoint_map_.find(
           EndpointAddressSet(endpoints_[first_idle_index].addresses()));
-      CHECK(it != endpoint_map_.end());
+      ABSL_CHECK(it != endpoint_map_.end());
       auto& endpoint = it->second;
       GRPC_TRACE_LOG(ring_hash_lb, INFO)
           << "[RH " << this
diff --git a/third_party/grpc/source/src/core/load_balancing/rls/rls.cc b/third_party/grpc/source/src/core/load_balancing/rls/rls.cc
index 19e976e768d9d..515c9d05f4890 100644
--- a/third_party/grpc/source/src/core/load_balancing/rls/rls.cc
+++ b/third_party/grpc/source/src/core/load_balancing/rls/rls.cc
@@ -53,8 +53,8 @@

 #include "absl/base/thread_annotations.h"
 #include "absl/hash/hash.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/random/random.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
@@ -796,7 +796,7 @@ void RlsLb::ChildPolicyWrapper::StartUpdate(
   auto child_policy_config = InsertOrUpdateChildPolicyField(
       lb_policy_->config_->child_policy_config_target_field_name(), target_,
       lb_policy_->config_->child_policy_config(), &errors);
-  CHECK(child_policy_config.has_value());
+  ABSL_CHECK(child_policy_config.has_value());
   GRPC_TRACE_LOG(rls_lb, INFO)
       << "[rlslb " << lb_policy_.get() << "] ChildPolicyWrapper=" << this
       << " [" << target_
@@ -873,7 +873,7 @@ void RlsLb::ChildPolicyWrapper::ChildPolicyHelper::UpdateState(
       return;
     }
     wrapper_->connectivity_state_ = state;
-    DCHECK(picker != nullptr);
+    ABSL_DCHECK(picker != nullptr);
     if (picker != nullptr) {
       // We want to unref the picker after we release the lock.
       wrapper_->picker_.swap(picker);
@@ -897,7 +897,7 @@ std::map<std::string, std::string> BuildKeyMap(
   if (it == key_builder_map.end()) {
     // Didn't find exact match, try method wildcard.
     last_slash_pos = path.rfind('/');
-    DCHECK(last_slash_pos != path.npos);
+    ABSL_DCHECK(last_slash_pos != path.npos);
     if (GPR_UNLIKELY(last_slash_pos == path.npos)) return {};
     std::string service(path.substr(0, last_slash_pos + 1));
     it = key_builder_map.find(service);
@@ -929,7 +929,7 @@ std::map<std::string, std::string> BuildKeyMap(
   if (!key_builder->service_key.empty()) {
     if (last_slash_pos == path.npos) {
       last_slash_pos = path.rfind('/');
-      DCHECK(last_slash_pos != path.npos);
+      ABSL_DCHECK(last_slash_pos != path.npos);
       if (GPR_UNLIKELY(last_slash_pos == path.npos)) return {};
     }
     key_map[key_builder->service_key] =
@@ -939,7 +939,7 @@ std::map<std::string, std::string> BuildKeyMap(
   if (!key_builder->method_key.empty()) {
     if (last_slash_pos == path.npos) {
       last_slash_pos = path.rfind('/');
-      DCHECK(last_slash_pos != path.npos);
+      ABSL_DCHECK(last_slash_pos != path.npos);
       if (GPR_UNLIKELY(last_slash_pos == path.npos)) return {};
     }
     key_map[key_builder->method_key] =
@@ -1125,7 +1125,7 @@ void RlsLb::Cache::Entry::Orphan() {
   is_shutdown_ = true;
   lb_policy_->cache_.lru_list_.erase(lru_iterator_);
   lru_iterator_ = lb_policy_->cache_.lru_list_.end();  // Just in case.
-  CHECK(child_policy_wrappers_.empty());
+  ABSL_CHECK(child_policy_wrappers_.empty());
   backoff_state_.reset();
   if (backoff_timer_ != nullptr) {
     backoff_timer_.reset();
@@ -1136,7 +1136,7 @@ void RlsLb::Cache::Entry::Orphan() {

 size_t RlsLb::Cache::Entry::Size() const {
   // lru_iterator_ is not valid once we're shut down.
-  CHECK(!is_shutdown_);
+  ABSL_CHECK(!is_shutdown_);
   return lb_policy_->cache_.EntrySizeForKey(*lru_iterator_);
 }

@@ -1428,7 +1428,7 @@ void RlsLb::Cache::MaybeShrinkSize(
     auto lru_it = lru_list_.begin();
     if (GPR_UNLIKELY(lru_it == lru_list_.end())) break;
     auto map_it = map_.find(*lru_it);
-    CHECK(map_it != map_.end());
+    ABSL_CHECK(map_it != map_.end());
     auto& entry = map_it->second;
     if (!entry->CanEvict()) break;
     GRPC_TRACE_LOG(rls_lb, INFO)
@@ -1576,7 +1576,7 @@ void RlsLb::RlsChannel::Orphan() {
     // Remove channelz linkage.
     if (parent_channelz_node_ != nullptr) {
       channelz::ChannelNode* child_channelz_node = channel_->channelz_node();
-      CHECK_NE(child_channelz_node, nullptr);
+      ABSL_CHECK_NE(child_channelz_node, nullptr);
       parent_channelz_node_->RemoveChildChannel(child_channelz_node->uuid());
     }
     // Stop connectivity watch.
@@ -1612,7 +1612,7 @@ void RlsLb::RlsChannel::ReportResponseLocked(bool response_succeeded) {
 }

 void RlsLb::RlsChannel::ResetBackoff() {
-  DCHECK(channel_ != nullptr);
+  ABSL_DCHECK(channel_ != nullptr);
   channel_->ResetConnectionBackoff();
 }

@@ -1645,7 +1645,7 @@ RlsLb::RlsRequest::RlsRequest(
       absl::OkStatus());
 }

-RlsLb::RlsRequest::~RlsRequest() { CHECK_EQ(call_, nullptr); }
+RlsLb::RlsRequest::~RlsRequest() { ABSL_CHECK_EQ(call_, nullptr); }

 void RlsLb::RlsRequest::Orphan() {
   if (call_ != nullptr) {
@@ -1705,7 +1705,7 @@ void RlsLb::RlsRequest::StartCallLocked() {
   Ref(DEBUG_LOCATION, "OnRlsCallComplete").release();
   auto call_error = grpc_call_start_batch_and_execute(
       call_, ops, static_cast<size_t>(op - ops), &call_complete_cb_);
-  CHECK_EQ(call_error, GRPC_CALL_OK);
+  ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
 }

 void RlsLb::RlsRequest::OnRlsCallComplete(void* arg, grpc_error_handle error) {
@@ -1719,7 +1719,7 @@ void RlsLb::RlsRequest::OnRlsCallComplete(void* arg, grpc_error_handle error) {
 void RlsLb::RlsRequest::OnRlsCallCompleteLocked(grpc_error_handle error) {
   if (GRPC_TRACE_FLAG_ENABLED(rls_lb)) {
     std::string status_message(StringViewFromSlice(status_details_recv_));
-    LOG(INFO) << "[rlslb " << lb_policy_.get() << "] rls_request=" << this
+    ABSL_LOG(INFO) << "[rlslb " << lb_policy_.get() << "] rls_request=" << this
               << " " << key_.ToString() << ", error=" << StatusToString(error)
               << ", status={" << status_recv_ << ", " << status_message << "}"
               << " RLS call response received";
@@ -1896,7 +1896,7 @@ absl::Status RlsLb::UpdateLocked(UpdateArgs args) {
   if (GRPC_TRACE_FLAG_ENABLED(rls_lb) &&
       (old_config == nullptr ||
        old_config->child_policy_config() != config_->child_policy_config())) {
-    LOG(INFO) << "[rlslb " << this << "] updated child policy config: "
+    ABSL_LOG(INFO) << "[rlslb " << this << "] updated child policy config: "
               << JsonDump(config_->child_policy_config());
   }
   // Swap out addresses.
diff --git a/third_party/grpc/source/src/core/load_balancing/round_robin/round_robin.cc b/third_party/grpc/source/src/core/load_balancing/round_robin/round_robin.cc
index 2a6577f4934ca..97148b9959dce 100644
--- a/third_party/grpc/source/src/core/load_balancing/round_robin/round_robin.cc
+++ b/third_party/grpc/source/src/core/load_balancing/round_robin/round_robin.cc
@@ -27,8 +27,8 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/meta/type_traits.h"
 #include "absl/random/random.h"
 #include "absl/status/status.h"
@@ -209,8 +209,8 @@ RoundRobin::RoundRobin(Args args) : LoadBalancingPolicy(std::move(args)) {
 RoundRobin::~RoundRobin() {
   GRPC_TRACE_LOG(round_robin, INFO)
       << "[RR " << this << "] Destroying Round Robin policy";
-  CHECK(endpoint_list_ == nullptr);
-  CHECK(latest_pending_endpoint_list_ == nullptr);
+  ABSL_CHECK(endpoint_list_ == nullptr);
+  ABSL_CHECK(latest_pending_endpoint_list_ == nullptr);
 }

 void RoundRobin::ShutdownLocked() {
@@ -243,7 +243,7 @@ absl::Status RoundRobin::UpdateLocked(UpdateArgs args) {
   // Create new child list, replacing the previous pending list, if any.
   if (GRPC_TRACE_FLAG_ENABLED(round_robin) &&
       latest_pending_endpoint_list_ != nullptr) {
-    LOG(INFO) << "[RR " << this << "] replacing previous pending child list "
+    ABSL_LOG(INFO) << "[RR " << this << "] replacing previous pending child list "
               << latest_pending_endpoint_list_.get();
   }
   std::vector<std::string> errors;
@@ -254,7 +254,7 @@ absl::Status RoundRobin::UpdateLocked(UpdateArgs args) {
   // endpoint_list_ and report TRANSIENT_FAILURE.
   if (latest_pending_endpoint_list_->size() == 0) {
     if (GRPC_TRACE_FLAG_ENABLED(round_robin) && endpoint_list_ != nullptr) {
-      LOG(INFO) << "[RR " << this << "] replacing previous child list "
+      ABSL_LOG(INFO) << "[RR " << this << "] replacing previous child list "
                 << endpoint_list_.get();
     }
     endpoint_list_ = std::move(latest_pending_endpoint_list_);
@@ -316,20 +316,20 @@ void RoundRobin::RoundRobinEndpointList::UpdateStateCountersLocked(
   // We treat IDLE the same as CONNECTING, since it will immediately
   // transition into that state anyway.
   if (old_state.has_value()) {
-    CHECK(*old_state != GRPC_CHANNEL_SHUTDOWN);
+    ABSL_CHECK(*old_state != GRPC_CHANNEL_SHUTDOWN);
     if (*old_state == GRPC_CHANNEL_READY) {
-      CHECK_GT(num_ready_, 0u);
+      ABSL_CHECK_GT(num_ready_, 0u);
       --num_ready_;
     } else if (*old_state == GRPC_CHANNEL_CONNECTING ||
                *old_state == GRPC_CHANNEL_IDLE) {
-      CHECK_GT(num_connecting_, 0u);
+      ABSL_CHECK_GT(num_connecting_, 0u);
       --num_connecting_;
     } else if (*old_state == GRPC_CHANNEL_TRANSIENT_FAILURE) {
-      CHECK_GT(num_transient_failure_, 0u);
+      ABSL_CHECK_GT(num_transient_failure_, 0u);
       --num_transient_failure_;
     }
   }
-  CHECK(new_state != GRPC_CHANNEL_SHUTDOWN);
+  ABSL_CHECK(new_state != GRPC_CHANNEL_SHUTDOWN);
   if (new_state == GRPC_CHANNEL_READY) {
     ++num_ready_;
   } else if (new_state == GRPC_CHANNEL_CONNECTING ||
@@ -356,7 +356,7 @@ void RoundRobin::RoundRobinEndpointList::
        (num_ready_ > 0 && AllEndpointsSeenInitialState()) ||
        num_transient_failure_ == size())) {
     if (GRPC_TRACE_FLAG_ENABLED(round_robin)) {
-      LOG(INFO) << "[RR " << round_robin << "] swapping out child list "
+      ABSL_LOG(INFO) << "[RR " << round_robin << "] swapping out child list "
                 << round_robin->endpoint_list_.get() << " ("
                 << round_robin->endpoint_list_->CountersString()
                 << ") in favor of " << this << " (" << CountersString() << ")";
@@ -381,7 +381,7 @@ void RoundRobin::RoundRobinEndpointList::
         pickers.push_back(endpoint->picker());
       }
     }
-    CHECK(!pickers.empty());
+    ABSL_CHECK(!pickers.empty());
     round_robin->channel_control_helper()->UpdateState(
         GRPC_CHANNEL_READY, absl::OkStatus(),
         MakeRefCounted<Picker>(round_robin, std::move(pickers)));
diff --git a/third_party/grpc/source/src/core/load_balancing/weighted_round_robin/static_stride_scheduler.cc b/third_party/grpc/source/src/core/load_balancing/weighted_round_robin/static_stride_scheduler.cc
index 61240f0fd4d5f..12d166ef041a3 100644
--- a/third_party/grpc/source/src/core/load_balancing/weighted_round_robin/static_stride_scheduler.cc
+++ b/third_party/grpc/source/src/core/load_balancing/weighted_round_robin/static_stride_scheduler.cc
@@ -25,7 +25,7 @@
 #include <vector>

 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 namespace grpc_core {

@@ -146,7 +146,7 @@ std::optional<StaticStrideScheduler> StaticStrideScheduler::Make(
     }
   }

-  CHECK(weights.size() == float_weights.size());
+  ABSL_CHECK(weights.size() == float_weights.size());
   return StaticStrideScheduler{std::move(weights),
                                std::move(next_sequence_func)};
 }
@@ -156,7 +156,7 @@ StaticStrideScheduler::StaticStrideScheduler(
     absl::AnyInvocable<uint32_t()> next_sequence_func)
     : next_sequence_func_(std::move(next_sequence_func)),
       weights_(std::move(weights)) {
-  CHECK(next_sequence_func_ != nullptr);
+  ABSL_CHECK(next_sequence_func_ != nullptr);
 }

 size_t StaticStrideScheduler::Pick() const {
diff --git a/third_party/grpc/source/src/core/load_balancing/weighted_round_robin/weighted_round_robin.cc b/third_party/grpc/source/src/core/load_balancing/weighted_round_robin/weighted_round_robin.cc
index 2ef90411a6aad..06522256a6556 100644
--- a/third_party/grpc/source/src/core/load_balancing/weighted_round_robin/weighted_round_robin.cc
+++ b/third_party/grpc/source/src/core/load_balancing/weighted_round_robin/weighted_round_robin.cc
@@ -33,8 +33,8 @@
 #include <vector>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/meta/type_traits.h"
 #include "absl/random/random.h"
 #include "absl/status/status.h"
@@ -574,7 +574,7 @@ void WeightedRoundRobin::Picker::Orphaned() {

 WeightedRoundRobin::PickResult WeightedRoundRobin::Picker::Pick(PickArgs args) {
   size_t index = PickIndex();
-  CHECK(index < endpoints_.size());
+  ABSL_CHECK(index < endpoints_.size());
   auto& endpoint_info = endpoints_[index];
   GRPC_TRACE_LOG(weighted_round_robin_lb, INFO)
       << "[WRR " << wrr_.get() << " picker " << this << "] returning index "
@@ -699,8 +699,8 @@ WeightedRoundRobin::WeightedRoundRobin(Args args)
 WeightedRoundRobin::~WeightedRoundRobin() {
   GRPC_TRACE_LOG(weighted_round_robin_lb, INFO)
       << "[WRR " << this << "] Destroying Round Robin policy";
-  CHECK(endpoint_list_ == nullptr);
-  CHECK(latest_pending_endpoint_list_ == nullptr);
+  ABSL_CHECK(endpoint_list_ == nullptr);
+  ABSL_CHECK(latest_pending_endpoint_list_ == nullptr);
 }

 void WeightedRoundRobin::ShutdownLocked() {
@@ -760,7 +760,7 @@ absl::Status WeightedRoundRobin::UpdateLocked(UpdateArgs args) {
   // Create new endpoint list, replacing the previous pending list, if any.
   if (GRPC_TRACE_FLAG_ENABLED(weighted_round_robin_lb) &&
       latest_pending_endpoint_list_ != nullptr) {
-    LOG(INFO) << "[WRR " << this
+    ABSL_LOG(INFO) << "[WRR " << this
               << "] replacing previous pending endpoint list "
               << latest_pending_endpoint_list_.get();
   }
@@ -773,7 +773,7 @@ absl::Status WeightedRoundRobin::UpdateLocked(UpdateArgs args) {
   if (latest_pending_endpoint_list_->size() == 0) {
     if (GRPC_TRACE_FLAG_ENABLED(weighted_round_robin_lb) &&
         endpoint_list_ != nullptr) {
-      LOG(INFO) << "[WRR " << this << "] replacing previous endpoint list "
+      ABSL_LOG(INFO) << "[WRR " << this << "] replacing previous endpoint list "
                 << endpoint_list_.get();
     }
     endpoint_list_ = std::move(latest_pending_endpoint_list_);
@@ -899,20 +899,20 @@ void WeightedRoundRobin::WrrEndpointList::UpdateStateCountersLocked(
   // We treat IDLE the same as CONNECTING, since it will immediately
   // transition into that state anyway.
   if (old_state.has_value()) {
-    CHECK(*old_state != GRPC_CHANNEL_SHUTDOWN);
+    ABSL_CHECK(*old_state != GRPC_CHANNEL_SHUTDOWN);
     if (*old_state == GRPC_CHANNEL_READY) {
-      CHECK_GT(num_ready_, 0u);
+      ABSL_CHECK_GT(num_ready_, 0u);
       --num_ready_;
     } else if (*old_state == GRPC_CHANNEL_CONNECTING ||
                *old_state == GRPC_CHANNEL_IDLE) {
-      CHECK_GT(num_connecting_, 0u);
+      ABSL_CHECK_GT(num_connecting_, 0u);
       --num_connecting_;
     } else if (*old_state == GRPC_CHANNEL_TRANSIENT_FAILURE) {
-      CHECK_GT(num_transient_failure_, 0u);
+      ABSL_CHECK_GT(num_transient_failure_, 0u);
       --num_transient_failure_;
     }
   }
-  CHECK(new_state != GRPC_CHANNEL_SHUTDOWN);
+  ABSL_CHECK(new_state != GRPC_CHANNEL_SHUTDOWN);
   if (new_state == GRPC_CHANNEL_READY) {
     ++num_ready_;
   } else if (new_state == GRPC_CHANNEL_CONNECTING ||
@@ -939,7 +939,7 @@ void WeightedRoundRobin::WrrEndpointList::
        (num_ready_ > 0 && AllEndpointsSeenInitialState()) ||
        num_transient_failure_ == size())) {
     if (GRPC_TRACE_FLAG_ENABLED(weighted_round_robin_lb)) {
-      LOG(INFO) << "[WRR " << wrr << "] swapping out endpoint list "
+      ABSL_LOG(INFO) << "[WRR " << wrr << "] swapping out endpoint list "
                 << wrr->endpoint_list_.get() << " ("
                 << wrr->endpoint_list_->CountersString() << ") in favor of "
                 << this << " (" << CountersString() << ")";
diff --git a/third_party/grpc/source/src/core/load_balancing/weighted_target/weighted_target.cc b/third_party/grpc/source/src/core/load_balancing/weighted_target/weighted_target.cc
index bc83cbcd499b8..dbde69ab8fd5d 100644
--- a/third_party/grpc/source/src/core/load_balancing/weighted_target/weighted_target.cc
+++ b/third_party/grpc/source/src/core/load_balancing/weighted_target/weighted_target.cc
@@ -31,8 +31,8 @@
 #include <vector>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/meta/type_traits.h"
 #include "absl/random/random.h"
 #include "absl/status/status.h"
@@ -271,7 +271,7 @@ WeightedTargetLb::PickResult WeightedTargetLb::WeightedPicker::Pick(
     }
   }
   if (index == 0) index = start_index;
-  CHECK(pickers_[index].first > key);
+  ABSL_CHECK(pickers_[index].first > key);
   // Delegate to the child picker.
   return pickers_[index].second->Pick(args);
 }
@@ -400,7 +400,7 @@ void WeightedTargetLb::UpdateStateLocked() {
         << " weight=" << child->weight() << " picker=" << child_picker.get();
     switch (child->connectivity_state()) {
       case GRPC_CHANNEL_READY: {
-        CHECK_GT(child->weight(), 0u);
+        ABSL_CHECK_GT(child->weight(), 0u);
         ready_end += child->weight();
         ready_picker_list.emplace_back(ready_end, std::move(child_picker));
         break;
@@ -414,7 +414,7 @@ void WeightedTargetLb::UpdateStateLocked() {
         break;
       }
       case GRPC_CHANNEL_TRANSIENT_FAILURE: {
-        CHECK_GT(child->weight(), 0u);
+        ABSL_CHECK_GT(child->weight(), 0u);
         tf_end += child->weight();
         tf_picker_list.emplace_back(tf_end, std::move(child_picker));
         break;
@@ -489,7 +489,7 @@ void WeightedTargetLb::WeightedChild::DelayedRemovalTimer::Orphan() {
 }

 void WeightedTargetLb::WeightedChild::DelayedRemovalTimer::OnTimerLocked() {
-  CHECK(timer_handle_.has_value());
+  ABSL_CHECK(timer_handle_.has_value());
   timer_handle_.reset();
   weighted_child_->weighted_target_policy_->targets_.erase(
       weighted_child_->name_);
@@ -565,7 +565,7 @@ absl::Status WeightedTargetLb::WeightedChild::UpdateLocked(
   if (weighted_target_policy_->shutting_down_) return absl::OkStatus();
   // Update child weight.
   if (weight_ != config.weight && GRPC_TRACE_FLAG_ENABLED(weighted_target_lb)) {
-    LOG(INFO) << "[weighted_target_lb " << weighted_target_policy_.get()
+    ABSL_LOG(INFO) << "[weighted_target_lb " << weighted_target_policy_.get()
               << "] WeightedChild " << this << " " << name_
               << ": weight=" << config.weight;
   }
diff --git a/third_party/grpc/source/src/core/load_balancing/xds/cds.cc b/third_party/grpc/source/src/core/load_balancing/xds/cds.cc
index 8a3f2fb2727fb..32e119dc4a4b3 100644
--- a/third_party/grpc/source/src/core/load_balancing/xds/cds.cc
+++ b/third_party/grpc/source/src/core/load_balancing/xds/cds.cc
@@ -30,8 +30,8 @@
 #include <variant>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -277,13 +277,13 @@ absl::Status CdsLb::UpdateLocked(UpdateArgs args) {
       << "[cdslb " << this
       << "] received update: cluster=" << new_config->cluster()
       << " is_dynamic=" << new_config->is_dynamic();
-  CHECK(new_config != nullptr);
+  ABSL_CHECK(new_config != nullptr);
   // Cluster name should never change, because we should use a different
   // child name in xds_cluster_manager in that case.
   if (cluster_name_.empty()) {
     cluster_name_ = new_config->cluster();
   } else {
-    CHECK(cluster_name_ == new_config->cluster());
+    ABSL_CHECK(cluster_name_ == new_config->cluster());
   }
   // Start dynamic subscription if needed.
   if (new_config->is_dynamic() && subscription_ == nullptr) {
@@ -335,7 +335,7 @@ absl::Status CdsLb::UpdateLocked(UpdateArgs args) {
     ReportTransientFailure(new_cluster_config.status());
     return new_cluster_config.status();
   }
-  CHECK_NE(new_cluster_config->cluster, nullptr);
+  ABSL_CHECK_NE(new_cluster_config->cluster, nullptr);
   // Find old cluster, if any.
   const XdsConfig::ClusterConfig* old_cluster_config = nullptr;
   if (xds_config_ != nullptr) {
@@ -375,7 +375,7 @@ absl::Status CdsLb::UpdateLocked(UpdateArgs args) {
           ReportTransientFailure(aggregate_cluster_config.status());
           return aggregate_cluster_config.status();
         }
-        CHECK_NE(aggregate_cluster_config->cluster, nullptr);
+        ABSL_CHECK_NE(aggregate_cluster_config->cluster, nullptr);
         aggregate_cluster_resource = aggregate_cluster_config->cluster.get();
       }
     } else {
@@ -456,7 +456,7 @@ CdsLb::ChildNameState CdsLb::ComputeChildNames(
     const XdsConfig::ClusterConfig* old_cluster,
     const XdsConfig::ClusterConfig& new_cluster,
     const XdsConfig::ClusterConfig::EndpointConfig& endpoint_config) const {
-  CHECK(!std::holds_alternative<XdsConfig::ClusterConfig::AggregateConfig>(
+  ABSL_CHECK(!std::holds_alternative<XdsConfig::ClusterConfig::AggregateConfig>(
       new_cluster.children));
   // First, build some maps from locality to child number and the reverse
   // from old_cluster and child_name_state_.
diff --git a/third_party/grpc/source/src/core/load_balancing/xds/xds_cluster_impl.cc b/third_party/grpc/source/src/core/load_balancing/xds/xds_cluster_impl.cc
index d3bbb0ae10d0c..aad9a914cbb81 100644
--- a/third_party/grpc/source/src/core/load_balancing/xds/xds_cluster_impl.cc
+++ b/third_party/grpc/source/src/core/load_balancing/xds/xds_cluster_impl.cc
@@ -29,8 +29,8 @@
 #include <vector>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -333,7 +333,7 @@ class XdsClusterImplLb::Picker::SubchannelCallTracker final
     locality_stats_.reset(DEBUG_LOCATION, "SubchannelCallTracker");
     call_counter_.reset(DEBUG_LOCATION, "SubchannelCallTracker");
 #ifndef NDEBUG
-    DCHECK(!started_);
+    ABSL_DCHECK(!started_);
 #endif
   }

@@ -559,7 +559,7 @@ absl::Status XdsClusterImplLb::UpdateLocked(UpdateArgs args) {
   // different priority child name if that happens, which means that this
   // policy instance will get replaced instead of being updated.
   if (config_ != nullptr) {
-    CHECK(config_->cluster_name() == new_config->cluster_name());
+    ABSL_CHECK(config_->cluster_name() == new_config->cluster_name());
   }
   // Get xDS config.
   auto new_xds_config = args.args.GetObjectRef<XdsConfig>();
@@ -622,7 +622,7 @@ absl::Status XdsClusterImplLb::UpdateLocked(UpdateArgs args) {
         new_cluster_config.cluster->lrs_load_reporting_server,
         new_config->cluster_name(), new_eds_service_name);
     if (drop_stats_ == nullptr) {
-      LOG(ERROR)
+      ABSL_LOG(ERROR)
           << "[xds_cluster_impl_lb " << this
           << "] Failed to get cluster drop stats for LRS server "
           << new_cluster_config.cluster->lrs_load_reporting_server->server_uri()
@@ -822,7 +822,7 @@ RefCountedPtr<SubchannelInterface> XdsClusterImplLb::Helper::CreateSubchannel(
             GetEdsResourceName(*parent()->cluster_resource_), locality_name,
             parent()->cluster_resource_->lrs_backend_metric_propagation);
     if (locality_stats == nullptr) {
-      LOG(ERROR)
+      ABSL_LOG(ERROR)
           << "[xds_cluster_impl_lb " << parent()
           << "] Failed to get locality stats object for LRS server "
           << parent()
@@ -901,7 +901,7 @@ class XdsClusterImplLbFactory final : public LoadBalancingPolicyFactory {
     auto xds_client = args.args.GetObjectRef<GrpcXdsClient>(DEBUG_LOCATION,
                                                             "XdsClusterImplLb");
     if (xds_client == nullptr) {
-      LOG(ERROR) << "XdsClient not present in channel args -- cannot "
+      ABSL_LOG(ERROR) << "XdsClient not present in channel args -- cannot "
                     "instantiate xds_cluster_impl LB policy";
       return nullptr;
     }
diff --git a/third_party/grpc/source/src/core/load_balancing/xds/xds_cluster_manager.cc b/third_party/grpc/source/src/core/load_balancing/xds/xds_cluster_manager.cc
index c9ef2faaf9f33..4b67d3f1a4893 100644
--- a/third_party/grpc/source/src/core/load_balancing/xds/xds_cluster_manager.cc
+++ b/third_party/grpc/source/src/core/load_balancing/xds/xds_cluster_manager.cc
@@ -29,7 +29,7 @@
 #include <utility>
 #include <vector>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
diff --git a/third_party/grpc/source/src/core/load_balancing/xds/xds_override_host.cc b/third_party/grpc/source/src/core/load_balancing/xds/xds_override_host.cc
index 034899773040d..5868e6124196f 100644
--- a/third_party/grpc/source/src/core/load_balancing/xds/xds_override_host.cc
+++ b/third_party/grpc/source/src/core/load_balancing/xds/xds_override_host.cc
@@ -36,8 +36,8 @@

 #include "absl/base/thread_annotations.h"
 #include "absl/functional/function_ref.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -225,7 +225,7 @@ class XdsOverrideHostLb final : public LoadBalancingPolicy {
     // already has an owned subchannel.
     void SetOwnedSubchannel(RefCountedPtr<SubchannelWrapper> subchannel)
         ABSL_EXCLUSIVE_LOCKS_REQUIRED(&XdsOverrideHostLb::mu_) {
-      DCHECK(!HasOwnedSubchannel());
+      ABSL_DCHECK(!HasOwnedSubchannel());
       subchannel_ = std::move(subchannel);
     }

@@ -441,7 +441,7 @@ XdsOverrideHostLb::Picker::Picker(
 std::optional<LoadBalancingPolicy::PickResult>
 XdsOverrideHostLb::Picker::PickOverriddenHost(
     XdsOverrideHostAttribute* override_host_attr) const {
-  CHECK_NE(override_host_attr, nullptr);
+  ABSL_CHECK_NE(override_host_attr, nullptr);
   auto cookie_address_list = override_host_attr->cookie_address_list();
   if (cookie_address_list.empty()) return std::nullopt;
   // The cookie has an address list, so look through the addresses in order.
@@ -908,7 +908,7 @@ void XdsOverrideHostLb::CreateSubchannelForAddress(absl::string_view address) {
       << "[xds_override_host_lb " << this << "] creating owned subchannel for "
       << address;
   auto addr = StringToSockaddr(address);
-  CHECK(addr.ok());
+  ABSL_CHECK(addr.ok());
   // Note: We don't currently have any cases where per_address_args need to
   // be passed through.  If we encounter any such cases in the future, we
   // will need to change this to store those attributes from the resolver
@@ -973,7 +973,7 @@ RefCountedPtr<SubchannelInterface> XdsOverrideHostLb::Helper::CreateSubchannel(
     const ChannelArgs& args) {
   if (GRPC_TRACE_FLAG_ENABLED(xds_override_host_lb)) {
     auto key = grpc_sockaddr_to_string(&address, /*normalize=*/false);
-    LOG(INFO) << "[xds_override_host_lb " << this
+    ABSL_LOG(INFO) << "[xds_override_host_lb " << this
               << "] creating subchannel for " << key.value_or("<unknown>")
               << ", per_address_args=" << per_address_args << ", args=" << args;
   }
diff --git a/third_party/grpc/source/src/core/load_balancing/xds/xds_wrr_locality.cc b/third_party/grpc/source/src/core/load_balancing/xds/xds_wrr_locality.cc
index 25c4f95fdb55f..a0770cba7569f 100644
--- a/third_party/grpc/source/src/core/load_balancing/xds/xds_wrr_locality.cc
+++ b/third_party/grpc/source/src/core/load_balancing/xds/xds_wrr_locality.cc
@@ -25,7 +25,7 @@
 #include <string>
 #include <utility>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -171,7 +171,7 @@ absl::Status XdsWrrLocalityLb::UpdateLocked(UpdateArgs args) {
         auto [it, inserted] = locality_weights.emplace(
             locality_name->human_readable_string(), weight);
         if (!inserted && it->second != weight) {
-          LOG(ERROR) << "INTERNAL ERROR: xds_wrr_locality found different "
+          ABSL_LOG(ERROR) << "INTERNAL ERROR: xds_wrr_locality found different "
                         "weights for locality "
                      << it->first.as_string_view() << " (" << it->second
                      << " vs " << weight << "); using first value";
@@ -206,7 +206,7 @@ absl::Status XdsWrrLocalityLb::UpdateLocked(UpdateArgs args) {
   if (!child_config.ok()) {
     // This should never happen, but if it does, we basically have no
     // way to fix it, so we put the channel in TRANSIENT_FAILURE.
-    LOG(ERROR) << "[xds_wrr_locality " << this
+    ABSL_LOG(ERROR) << "[xds_wrr_locality " << this
                << "] error parsing generated child policy config -- putting "
                   "channel in TRANSIENT_FAILURE: "
                << child_config.status();
diff --git a/third_party/grpc/source/src/core/resolver/dns/c_ares/dns_resolver_ares.cc b/third_party/grpc/source/src/core/resolver/dns/c_ares/dns_resolver_ares.cc
index 17be5a11c686f..82e7052241941 100644
--- a/third_party/grpc/source/src/core/resolver/dns/c_ares/dns_resolver_ares.cc
+++ b/third_party/grpc/source/src/core/resolver/dns/c_ares/dns_resolver_ares.cc
@@ -28,7 +28,7 @@
 #include <vector>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/match.h"
@@ -352,7 +352,7 @@ class AresClientChannelDNSResolverFactory final : public ResolverFactory {

   bool IsValidUri(const URI& uri) const override {
     if (absl::StripPrefix(uri.path(), "/").empty()) {
-      LOG(ERROR) << "no server name supplied in dns URI";
+      ABSL_LOG(ERROR) << "no server name supplied in dns URI";
       return false;
     }
     return true;
diff --git a/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_ev_driver_posix.cc b/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_ev_driver_posix.cc
index 7341ffba63938..5f128a0432599 100644
--- a/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_ev_driver_posix.cc
+++ b/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_ev_driver_posix.cc
@@ -35,7 +35,7 @@
 #include <utility>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/lib/iomgr/closure.h"
 #include "src/core/lib/iomgr/error.h"
@@ -113,7 +113,7 @@ class GrpcPolledFdFactoryPosix final : public GrpcPolledFdFactory {
   GrpcPolledFd* NewGrpcPolledFdLocked(
       ares_socket_t as, grpc_pollset_set* driver_pollset_set) override {
     auto insert_result = owned_fds_.insert(as);
-    CHECK(insert_result.second);
+    ABSL_CHECK(insert_result.second);
     return new GrpcPolledFdPosix(as, driver_pollset_set);
   }

diff --git a/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_ev_driver_windows.cc b/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_ev_driver_windows.cc
index f30826bbb43dc..3c8fd7480cd23 100644
--- a/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_ev_driver_windows.cc
+++ b/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_ev_driver_windows.cc
@@ -32,7 +32,7 @@
 #include <unordered_set>

 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_format.h"
 #include "src/core/lib/address_utils/sockaddr_utils.h"
 #include "src/core/lib/iomgr/iocp_windows.h"
@@ -134,8 +134,8 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
         << "| ~GrpcPolledFdWindows shutdown_called_: " << shutdown_called_;
     CSliceUnref(read_buf_);
     CSliceUnref(write_buf_);
-    CHECK_EQ(read_closure_, nullptr);
-    CHECK_EQ(write_closure_, nullptr);
+    ABSL_CHECK_EQ(read_closure_, nullptr);
+    ABSL_CHECK_EQ(write_closure_, nullptr);
     if (!shutdown_called_) {
       // This can happen if the socket was never seen by grpc ares wrapper
       // code, i.e. if we never started I/O polling on it.
@@ -155,16 +155,16 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
   }

   void RegisterForOnReadableLocked(grpc_closure* read_closure) override {
-    CHECK_EQ(read_closure_, nullptr);
+    ABSL_CHECK_EQ(read_closure_, nullptr);
     read_closure_ = read_closure;
-    CHECK_EQ(GRPC_SLICE_LENGTH(read_buf_), 0);
+    ABSL_CHECK_EQ(GRPC_SLICE_LENGTH(read_buf_), 0);
     CSliceUnref(read_buf_);
-    CHECK(!read_buf_has_data_);
+    ABSL_CHECK(!read_buf_has_data_);
     read_buf_ = GRPC_SLICE_MALLOC(4192);
     if (connect_done_) {
       ContinueRegisterForOnReadableLocked();
     } else {
-      CHECK(pending_continue_register_for_on_readable_locked_ == false);
+      ABSL_CHECK(pending_continue_register_for_on_readable_locked_ == false);
       pending_continue_register_for_on_readable_locked_ = true;
     }
   }
@@ -174,7 +174,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
         << "(c-ares resolver) fd:|" << GetName()
         << "| ContinueRegisterForOnReadableLocked "
         << "wsa_connect_error_:" << wsa_connect_error_;
-    CHECK(connect_done_);
+    ABSL_CHECK(connect_done_);
     if (wsa_connect_error_ != 0) {
       ScheduleAndNullReadClosure(GRPC_WSA_ERROR(wsa_connect_error_, "connect"));
       return;
@@ -211,16 +211,16 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
           << "(c-ares resolver) fd:|" << GetName()
           << "| RegisterForOnWriteableLocked called";
     } else {
-      CHECK(socket_type_ == SOCK_STREAM);
+      ABSL_CHECK(socket_type_ == SOCK_STREAM);
       GRPC_TRACE_VLOG(cares_resolver, 2)
           << "(c-ares resolver) fd:|" << GetName()
           << "| RegisterForOnWriteableLocked called tcp_write_state_: "
           << tcp_write_state_ << " connect_done_: " << connect_done_;
     }
-    CHECK_EQ(write_closure_, nullptr);
+    ABSL_CHECK_EQ(write_closure_, nullptr);
     write_closure_ = write_closure;
     if (!connect_done_) {
-      CHECK(!pending_continue_register_for_on_writeable_locked_);
+      ABSL_CHECK(!pending_continue_register_for_on_writeable_locked_);
       pending_continue_register_for_on_writeable_locked_ = true;
       // Register an async OnTcpConnect callback here rather than when the
       // connect was initiated, since we are now guaranteed to hold a ref of the
@@ -236,7 +236,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
         << "(c-ares resolver) fd:|" << GetName()
         << "| ContinueRegisterForOnWriteableLocked "
         << "wsa_connect_error_:" << wsa_connect_error_;
-    CHECK(connect_done_);
+    ABSL_CHECK(connect_done_);
     if (wsa_connect_error_ != 0) {
       ScheduleAndNullWriteClosure(
           GRPC_WSA_ERROR(wsa_connect_error_, "connect"));
@@ -245,7 +245,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
     if (socket_type_ == SOCK_DGRAM) {
       ScheduleAndNullWriteClosure(absl::OkStatus());
     } else {
-      CHECK(socket_type_ == SOCK_STREAM);
+      ABSL_CHECK(socket_type_ == SOCK_STREAM);
       int wsa_error_code = 0;
       switch (tcp_write_state_) {
         case WRITE_IDLE:
@@ -271,7 +271,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
   bool IsFdStillReadableLocked() override { return read_buf_has_data_; }

   void ShutdownLocked(grpc_error_handle /* error */) override {
-    CHECK(!shutdown_called_);
+    ABSL_CHECK(!shutdown_called_);
     shutdown_called_ = true;
     on_shutdown_locked_();
     grpc_winsocket_shutdown(winsocket_);
@@ -307,7 +307,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
     // c-ares overloads this recv_from virtual socket function to receive
     // data on both UDP and TCP sockets, and from is nullptr for TCP.
     if (from != nullptr) {
-      CHECK(*from_len >= recv_from_source_addr_len_);
+      ABSL_CHECK(*from_len >= recv_from_source_addr_len_);
       memcpy(from, &recv_from_source_addr_, recv_from_source_addr_len_);
       *from_len = recv_from_source_addr_len_;
     }
@@ -378,7 +378,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
     // to write everything inline.
     GRPC_TRACE_VLOG(cares_resolver, 2)
         << "(c-ares resolver) fd:" << GetName() << " SendVUDP called";
-    CHECK_EQ(GRPC_SLICE_LENGTH(write_buf_), 0);
+    ABSL_CHECK_EQ(GRPC_SLICE_LENGTH(write_buf_), 0);
     CSliceUnref(write_buf_);
     write_buf_ = FlattenIovec(iov, iov_count);
     DWORD bytes_sent = 0;
@@ -413,7 +413,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
     switch (tcp_write_state_) {
       case WRITE_IDLE:
         tcp_write_state_ = WRITE_REQUESTED;
-        CHECK_EQ(GRPC_SLICE_LENGTH(write_buf_), 0);
+        ABSL_CHECK_EQ(GRPC_SLICE_LENGTH(write_buf_), 0);
         CSliceUnref(write_buf_);
         write_buf_ = FlattenIovec(iov, iov_count);
         wsa_error_ctx->SetWSAError(WSAEWOULDBLOCK);
@@ -429,11 +429,11 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
         // send again. If c-ares still needs to send even more data, we'll get
         // to it eventually.
         grpc_slice currently_attempted = FlattenIovec(iov, iov_count);
-        CHECK(GRPC_SLICE_LENGTH(currently_attempted) >=
+        ABSL_CHECK(GRPC_SLICE_LENGTH(currently_attempted) >=
               GRPC_SLICE_LENGTH(write_buf_));
         ares_ssize_t total_sent = 0;
         for (size_t i = 0; i < GRPC_SLICE_LENGTH(write_buf_); i++) {
-          CHECK(GRPC_SLICE_START_PTR(currently_attempted)[i] ==
+          ABSL_CHECK(GRPC_SLICE_START_PTR(currently_attempted)[i] ==
                 GRPC_SLICE_START_PTR(write_buf_)[i]);
           total_sent++;
         }
@@ -459,9 +459,9 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
         << pending_continue_register_for_on_readable_locked_
         << " pending_register_for_writeable:"
         << pending_continue_register_for_on_writeable_locked_;
-    CHECK(!connect_done_);
+    ABSL_CHECK(!connect_done_);
     connect_done_ = true;
-    CHECK_EQ(wsa_connect_error_, 0);
+    ABSL_CHECK_EQ(wsa_connect_error_, 0);
     if (!error.ok() || shutdown_called_) {
       wsa_connect_error_ = WSA_OPERATION_ABORTED;
     } else {
@@ -471,7 +471,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
           WSAGetOverlappedResult(grpc_winsocket_wrapped_socket(winsocket_),
                                  &winsocket_->write_info.overlapped,
                                  &transferred_bytes, FALSE, &flags);
-      CHECK_EQ(transferred_bytes, 0);
+      ABSL_CHECK_EQ(transferred_bytes, 0);
       if (!wsa_success) {
         wsa_connect_error_ = WSAGetLastError();
         char* msg = gpr_format_message(wsa_connect_error_);
@@ -506,8 +506,8 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
                  ares_socklen_t target_len) {
     GRPC_TRACE_VLOG(cares_resolver, 2)
         << "(c-ares resolver) fd:" << GetName() << " ConnectUDP";
-    CHECK(!connect_done_);
-    CHECK_EQ(wsa_connect_error_, 0);
+    ABSL_CHECK(!connect_done_);
+    ABSL_CHECK_EQ(wsa_connect_error_, 0);
     SOCKET s = grpc_winsocket_wrapped_socket(winsocket_);
     int out =
         WSAConnect(s, target, target_len, nullptr, nullptr, nullptr, nullptr);
@@ -651,7 +651,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
   void OnIocpWriteableLocked(grpc_error_handle error) {
     GRPC_TRACE_VLOG(cares_resolver, 2)
         << "(c-ares resolver) OnIocpWriteableInner. fd:|" << GetName() << "|";
-    CHECK(socket_type_ == SOCK_STREAM);
+    ABSL_CHECK(socket_type_ == SOCK_STREAM);
     if (error.ok()) {
       if (winsocket_->write_info.wsa_error != 0) {
         error = GRPC_WSA_ERROR(winsocket_->write_info.wsa_error,
@@ -664,7 +664,7 @@ class GrpcPolledFdWindows final : public GrpcPolledFd {
             << StatusToString(error) << "|";
       }
     }
-    CHECK(tcp_write_state_ == WRITE_PENDING);
+    ABSL_CHECK(tcp_write_state_ == WRITE_PENDING);
     if (error.ok()) {
       tcp_write_state_ = WRITE_WAITING_FOR_VERIFICATION_UPON_RETRY;
       write_buf_ = grpc_slice_sub_no_ref(
@@ -725,7 +725,7 @@ class GrpcPolledFdFactoryWindows final : public GrpcPolledFdFactory {
   GrpcPolledFd* NewGrpcPolledFdLocked(
       ares_socket_t as, grpc_pollset_set* /* driver_pollset_set */) override {
     auto it = sockets_.find(as);
-    CHECK(it != sockets_.end());
+    ABSL_CHECK(it != sockets_.end());
     return it->second;
   }

@@ -776,7 +776,7 @@ class GrpcPolledFdFactoryWindows final : public GrpcPolledFdFactory {
         << "(c-ares resolver) fd:" << polled_fd->GetName()
         << " created with params af:" << af << " type:" << type
         << " protocol:" << protocol;
-    CHECK(self->sockets_.insert({s, polled_fd}).second);
+    ABSL_CHECK(self->sockets_.insert({s, polled_fd}).second);
     return s;
   }

@@ -786,7 +786,7 @@ class GrpcPolledFdFactoryWindows final : public GrpcPolledFdFactory {
     GrpcPolledFdFactoryWindows* self =
         static_cast<GrpcPolledFdFactoryWindows*>(user_data);
     auto it = self->sockets_.find(as);
-    CHECK(it != self->sockets_.end());
+    ABSL_CHECK(it != self->sockets_.end());
     return it->second->Connect(&wsa_error_ctx, target, target_len);
   }

@@ -796,7 +796,7 @@ class GrpcPolledFdFactoryWindows final : public GrpcPolledFdFactory {
     GrpcPolledFdFactoryWindows* self =
         static_cast<GrpcPolledFdFactoryWindows*>(user_data);
     auto it = self->sockets_.find(as);
-    CHECK(it != self->sockets_.end());
+    ABSL_CHECK(it != self->sockets_.end());
     return it->second->SendV(&wsa_error_ctx, iov, iovec_count);
   }

@@ -807,7 +807,7 @@ class GrpcPolledFdFactoryWindows final : public GrpcPolledFdFactory {
     GrpcPolledFdFactoryWindows* self =
         static_cast<GrpcPolledFdFactoryWindows*>(user_data);
     auto it = self->sockets_.find(as);
-    CHECK(it != self->sockets_.end());
+    ABSL_CHECK(it != self->sockets_.end());
     return it->second->RecvFrom(&wsa_error_ctx, data, data_len, flags, from,
                                 from_len);
   }
diff --git a/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_wrapper.cc b/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_wrapper.cc
index cad4cfa1918fc..e722e6595e8a2 100644
--- a/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_wrapper.cc
+++ b/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_wrapper.cc
@@ -47,8 +47,8 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -215,7 +215,7 @@ static void grpc_ares_ev_driver_unref(grpc_ares_ev_driver* ev_driver)
     GRPC_TRACE_VLOG(cares_resolver, 2)
         << "(c-ares resolver) request:" << ev_driver->request
         << " destroy ev_driver " << ev_driver;
-    CHECK_EQ(ev_driver->fds, nullptr);
+    ABSL_CHECK_EQ(ev_driver->fds, nullptr);
     ares_destroy(ev_driver->channel);
     grpc_ares_complete_request_locked(ev_driver->request);
     delete ev_driver;
@@ -227,9 +227,9 @@ static void fd_node_destroy_locked(fd_node* fdn)
   GRPC_TRACE_VLOG(cares_resolver, 2)
       << "(c-ares resolver) request:" << fdn->ev_driver->request
       << " delete fd: " << fdn->grpc_polled_fd->GetName();
-  CHECK(!fdn->readable_registered);
-  CHECK(!fdn->writable_registered);
-  CHECK(fdn->already_shutdown);
+  ABSL_CHECK(!fdn->readable_registered);
+  ABSL_CHECK(!fdn->writable_registered);
+  ABSL_CHECK(fdn->already_shutdown);
   delete fdn->grpc_polled_fd;
   delete fdn;
 }
@@ -369,7 +369,7 @@ static void on_ares_backup_poll_alarm(void* arg, grpc_error_handle error) {
 static void on_readable(void* arg, grpc_error_handle error) {
   fd_node* fdn = static_cast<fd_node*>(arg);
   grpc_core::MutexLock lock(&fdn->ev_driver->request->mu);
-  CHECK(fdn->readable_registered);
+  ABSL_CHECK(fdn->readable_registered);
   grpc_ares_ev_driver* ev_driver = fdn->ev_driver;
   const ares_socket_t as = fdn->grpc_polled_fd->GetWrappedAresSocketLocked();
   fdn->readable_registered = false;
@@ -394,7 +394,7 @@ static void on_readable(void* arg, grpc_error_handle error) {
 static void on_writable(void* arg, grpc_error_handle error) {
   fd_node* fdn = static_cast<fd_node*>(arg);
   grpc_core::MutexLock lock(&fdn->ev_driver->request->mu);
-  CHECK(fdn->writable_registered);
+  ABSL_CHECK(fdn->writable_registered);
   grpc_ares_ev_driver* ev_driver = fdn->ev_driver;
   const ares_socket_t as = fdn->grpc_polled_fd->GetWrappedAresSocketLocked();
   fdn->writable_registered = false;
@@ -577,7 +577,7 @@ static void log_address_sorting_list(const grpc_ares_request* r,
                                      const char* input_output_str) {
   for (size_t i = 0; i < addresses.size(); i++) {
     auto addr_str = grpc_sockaddr_to_string(&addresses[i].address(), true);
-    LOG(INFO) << "(c-ares resolver) request:" << r
+    ABSL_LOG(INFO) << "(c-ares resolver) request:" << r
               << " c-ares address sorting: " << input_output_str << "[" << i
               << "]="
               << (addr_str.ok() ? addr_str->c_str()
@@ -928,13 +928,13 @@ static bool inner_resolve_as_ip_literal_locked(
     std::unique_ptr<grpc_core::EndpointAddressesList>* addrs, std::string* host,
     std::string* port, std::string* hostport) {
   if (!grpc_core::SplitHostPort(name, host, port)) {
-    LOG(ERROR) << "Failed to parse " << name
+    ABSL_LOG(ERROR) << "Failed to parse " << name
                << " to host:port while attempting to resolve as ip literal.";
     return false;
   }
   if (port->empty()) {
     if (default_port == nullptr || strlen(default_port) == 0) {
-      LOG(ERROR) << "No port or default port for " << name
+      ABSL_LOG(ERROR) << "No port or default port for " << name
                  << " while attempting to resolve as ip literal.";
       return false;
     }
@@ -946,7 +946,7 @@ static bool inner_resolve_as_ip_literal_locked(
                                false /* log errors */) ||
       grpc_parse_ipv6_hostport(hostport->c_str(), &addr,
                                false /* log errors */)) {
-    CHECK(*addrs == nullptr);
+    ABSL_CHECK(*addrs == nullptr);
     *addrs = std::make_unique<EndpointAddressesList>();
     (*addrs)->emplace_back(addr, grpc_core::ChannelArgs());
     return true;
@@ -968,7 +968,7 @@ static bool resolve_as_ip_literal_locked(
 static bool target_matches_localhost_inner(const char* name, std::string* host,
                                            std::string* port) {
   if (!grpc_core::SplitHostPort(name, host, port)) {
-    LOG(ERROR) << "Unable to split host and port for name: " << name;
+    ABSL_LOG(ERROR) << "Unable to split host and port for name: " << name;
     return false;
   }
   return gpr_stricmp(host->c_str(), "localhost") == 0;
@@ -987,20 +987,20 @@ static bool inner_maybe_resolve_localhost_manually_locked(
     std::string* port) {
   grpc_core::SplitHostPort(name, host, port);
   if (host->empty()) {
-    LOG(ERROR) << "Failed to parse " << name
+    ABSL_LOG(ERROR) << "Failed to parse " << name
                << " into host:port during manual localhost resolution check.";
     return false;
   }
   if (port->empty()) {
     if (default_port == nullptr || strlen(default_port) == 0) {
-      LOG(ERROR) << "No port or default port for " << name
+      ABSL_LOG(ERROR) << "No port or default port for " << name
                  << " during manual localhost resolution check.";
       return false;
     }
     *port = default_port;
   }
   if (gpr_stricmp(host->c_str(), "localhost") == 0) {
-    CHECK(*addrs == nullptr);
+    ABSL_CHECK(*addrs == nullptr);
     *addrs = std::make_unique<grpc_core::EndpointAddressesList>();
     uint16_t numeric_port = grpc_strhtons(port->c_str());
     grpc_resolved_address address;
@@ -1199,7 +1199,7 @@ grpc_ares_request* (*grpc_dns_lookup_txt_ares)(
     int query_timeout_ms) = grpc_dns_lookup_txt_ares_impl;

 static void grpc_cancel_ares_request_impl(grpc_ares_request* r) {
-  CHECK_NE(r, nullptr);
+  ABSL_CHECK_NE(r, nullptr);
   grpc_core::MutexLock lock(&r->mu);
   GRPC_TRACE_VLOG(cares_resolver, 2)
       << "(c-ares resolver) request:" << r
diff --git a/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_wrapper.h b/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_wrapper.h
index 272ef463ac4ab..174579b938dd5 100644
--- a/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_wrapper.h
+++ b/third_party/grpc/source/src/core/resolver/dns/c_ares/grpc_ares_wrapper.h
@@ -26,7 +26,7 @@
 #include <memory>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/lib/iomgr/closure.h"
 #include "src/core/lib/iomgr/error.h"
diff --git a/third_party/grpc/source/src/core/resolver/dns/dns_resolver_plugin.cc b/third_party/grpc/source/src/core/resolver/dns/dns_resolver_plugin.cc
index 92fff39943fcc..a40a8fb7d1fd0 100644
--- a/third_party/grpc/source/src/core/resolver/dns/dns_resolver_plugin.cc
+++ b/third_party/grpc/source/src/core/resolver/dns/dns_resolver_plugin.cc
@@ -17,7 +17,7 @@

 #include <memory>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/match.h"
 #include "src/core/config/config_vars.h"
 #include "src/core/lib/experiments/experiments.h"
@@ -31,14 +31,14 @@ namespace grpc_core {

 void RegisterDnsResolver(CoreConfiguration::Builder* builder) {
 #if GRPC_IOS_EVENT_ENGINE_CLIENT
-  VLOG(2) << "Using EventEngine dns resolver";
+  ABSL_VLOG(2) << "Using EventEngine dns resolver";
   builder->resolver_registry()->RegisterResolverFactory(
       std::make_unique<EventEngineClientChannelDNSResolverFactory>());
   return;
 #endif
 #ifndef GRPC_DO_NOT_INSTANTIATE_POSIX_POLLER
   if (IsEventEngineDnsEnabled()) {
-    VLOG(2) << "Using EventEngine dns resolver";
+    ABSL_VLOG(2) << "Using EventEngine dns resolver";
     builder->resolver_registry()->RegisterResolverFactory(
         std::make_unique<EventEngineClientChannelDNSResolverFactory>());
     return;
@@ -47,14 +47,14 @@ void RegisterDnsResolver(CoreConfiguration::Builder* builder) {
   auto resolver = ConfigVars::Get().DnsResolver();
   // ---- Ares resolver ----
   if (ShouldUseAresDnsResolver(resolver)) {
-    VLOG(2) << "Using ares dns resolver";
+    ABSL_VLOG(2) << "Using ares dns resolver";
     RegisterAresDnsResolver(builder);
     return;
   }
   // ---- Native resolver ----
   if (absl::EqualsIgnoreCase(resolver, "native") ||
       !builder->resolver_registry()->HasResolverFactory("dns")) {
-    VLOG(2) << "Using native dns resolver";
+    ABSL_VLOG(2) << "Using native dns resolver";
     RegisterNativeDnsResolver(builder);
     return;
   }
diff --git a/third_party/grpc/source/src/core/resolver/dns/event_engine/event_engine_client_channel_resolver.cc b/third_party/grpc/source/src/core/resolver/dns/event_engine/event_engine_client_channel_resolver.cc
index 69fc916be9eb8..5772f5ee5303b 100644
--- a/third_party/grpc/source/src/core/resolver/dns/event_engine/event_engine_client_channel_resolver.cc
+++ b/third_party/grpc/source/src/core/resolver/dns/event_engine/event_engine_client_channel_resolver.cc
@@ -29,8 +29,8 @@

 #include "absl/base/thread_annotations.h"
 #include "absl/cleanup/cleanup.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/match.h"
@@ -426,7 +426,7 @@ void EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::
     // Make sure field destroys before cleanup.
     ValidationErrors::ScopedField field(&errors_, "txt lookup");
     if (orphaned_) return;
-    CHECK(is_txt_inflight_);
+    ABSL_CHECK(is_txt_inflight_);
     is_txt_inflight_ = false;
     if (!service_config.ok()) {
       errors_.AddError(service_config.status().message());
@@ -560,7 +560,7 @@ std::optional<Resolver::Result> EventEngineClientChannelDNSResolver::
 bool EventEngineClientChannelDNSResolverFactory::IsValidUri(
     const URI& uri) const {
   if (absl::StripPrefix(uri.path(), "/").empty()) {
-    LOG(ERROR) << "no server name supplied in dns URI";
+    ABSL_LOG(ERROR) << "no server name supplied in dns URI";
     return false;
   }
   return true;
diff --git a/third_party/grpc/source/src/core/resolver/dns/native/dns_resolver.cc b/third_party/grpc/source/src/core/resolver/dns/native/dns_resolver.cc
index 97012d43401ad..afbbfc3f496fb 100644
--- a/third_party/grpc/source/src/core/resolver/dns/native/dns_resolver.cc
+++ b/third_party/grpc/source/src/core/resolver/dns/native/dns_resolver.cc
@@ -24,7 +24,7 @@
 #include <vector>

 #include "absl/functional/bind_front.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -141,11 +141,11 @@ class NativeClientChannelDNSResolverFactory final : public ResolverFactory {

   bool IsValidUri(const URI& uri) const override {
     if (GPR_UNLIKELY(!uri.authority().empty())) {
-      LOG(ERROR) << "authority based dns uri's not supported";
+      ABSL_LOG(ERROR) << "authority based dns uri's not supported";
       return false;
     }
     if (absl::StripPrefix(uri.path(), "/").empty()) {
-      LOG(ERROR) << "no server name supplied in dns URI";
+      ABSL_LOG(ERROR) << "no server name supplied in dns URI";
       return false;
     }
     return true;
diff --git a/third_party/grpc/source/src/core/resolver/endpoint_addresses.cc b/third_party/grpc/source/src/core/resolver/endpoint_addresses.cc
index aa5f46e3abdbc..a71e3b05c79a1 100644
--- a/third_party/grpc/source/src/core/resolver/endpoint_addresses.cc
+++ b/third_party/grpc/source/src/core/resolver/endpoint_addresses.cc
@@ -25,7 +25,7 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -45,7 +45,7 @@ EndpointAddresses::EndpointAddresses(const grpc_resolved_address& address,
 EndpointAddresses::EndpointAddresses(
     std::vector<grpc_resolved_address> addresses, const ChannelArgs& args)
     : addresses_(std::move(addresses)), args_(args) {
-  CHECK(!addresses_.empty());
+  ABSL_CHECK(!addresses_.empty());
 }

 EndpointAddresses::EndpointAddresses(const EndpointAddresses& other)
@@ -108,7 +108,7 @@ bool EndpointAddressSet::operator==(const EndpointAddressSet& other) const {
   if (addresses_.size() != other.addresses_.size()) return false;
   auto other_it = other.addresses_.begin();
   for (auto it = addresses_.begin(); it != addresses_.end(); ++it) {
-    CHECK(other_it != other.addresses_.end());
+    ABSL_CHECK(other_it != other.addresses_.end());
     if (it->len != other_it->len ||
         memcmp(it->addr, other_it->addr, it->len) != 0) {
       return false;
diff --git a/third_party/grpc/source/src/core/resolver/fake/fake_resolver.cc b/third_party/grpc/source/src/core/resolver/fake/fake_resolver.cc
index 68348d1ce09b7..c3e436ce74cba 100644
--- a/third_party/grpc/source/src/core/resolver/fake/fake_resolver.cc
+++ b/third_party/grpc/source/src/core/resolver/fake/fake_resolver.cc
@@ -25,7 +25,7 @@
 #include <type_traits>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/string_view.h"
 #include "src/core/config/core_configuration.h"
 #include "src/core/lib/channel/channel_args.h"
@@ -94,7 +94,7 @@ void FakeResolver::StartLocked() {

 void FakeResolver::RequestReresolutionLocked() {
   // Re-resolution can't happen until after we return an initial result.
-  CHECK(response_generator_ != nullptr);
+  ABSL_CHECK(response_generator_ != nullptr);
   response_generator_->ReresolutionRequested();
 }

diff --git a/third_party/grpc/source/src/core/resolver/google_c2p/google_c2p_resolver.cc b/third_party/grpc/source/src/core/resolver/google_c2p/google_c2p_resolver.cc
index 0c86c392c57d8..3b18ce028e56c 100644
--- a/third_party/grpc/source/src/core/resolver/google_c2p/google_c2p_resolver.cc
+++ b/third_party/grpc/source/src/core/resolver/google_c2p/google_c2p_resolver.cc
@@ -25,8 +25,8 @@
 #include <type_traits>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
@@ -122,7 +122,7 @@ GoogleCloud2ProdResolver::GoogleCloud2ProdResolver(ResolverArgs args)
         CoreConfiguration::Get().resolver_registry().CreateResolver(
             absl::StrCat("dns:", name_to_resolve), args.args, args.pollset_set,
             work_serializer_, std::move(args.result_handler));
-    CHECK(child_resolver_ != nullptr);
+    ABSL_CHECK(child_resolver_ != nullptr);
     return;
   }
   // Maybe override metadata server name for testing
@@ -141,7 +141,7 @@ GoogleCloud2ProdResolver::GoogleCloud2ProdResolver(ResolverArgs args)
   child_resolver_ = CoreConfiguration::Get().resolver_registry().CreateResolver(
       xds_uri, args.args, args.pollset_set, work_serializer_,
       std::move(args.result_handler));
-  CHECK(child_resolver_ != nullptr);
+  ABSL_CHECK(child_resolver_ != nullptr);
 }

 void GoogleCloud2ProdResolver::StartLocked() {
@@ -278,7 +278,7 @@ class GoogleCloud2ProdResolverFactory final : public ResolverFactory {

   bool IsValidUri(const URI& uri) const override {
     if (GPR_UNLIKELY(!uri.authority().empty())) {
-      LOG(ERROR) << "google-c2p URI scheme does not support authorities";
+      ABSL_LOG(ERROR) << "google-c2p URI scheme does not support authorities";
       return false;
     }
     return true;
@@ -301,7 +301,7 @@ class ExperimentalGoogleCloud2ProdResolverFactory final

   bool IsValidUri(const URI& uri) const override {
     if (GPR_UNLIKELY(!uri.authority().empty())) {
-      LOG(ERROR) << "google-c2p-experimental URI scheme does not support "
+      ABSL_LOG(ERROR) << "google-c2p-experimental URI scheme does not support "
                     "authorities";
       return false;
     }
diff --git a/third_party/grpc/source/src/core/resolver/polling_resolver.cc b/third_party/grpc/source/src/core/resolver/polling_resolver.cc
index 55576591fff93..dc5193f4c7e17 100644
--- a/third_party/grpc/source/src/core/resolver/polling_resolver.cc
+++ b/third_party/grpc/source/src/core/resolver/polling_resolver.cc
@@ -24,8 +24,8 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -58,13 +58,13 @@ PollingResolver::PollingResolver(ResolverArgs args,
       min_time_between_resolutions_(min_time_between_resolutions),
       backoff_(backoff_options) {
   if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
-    LOG(INFO) << "[polling resolver " << this << "] created";
+    ABSL_LOG(INFO) << "[polling resolver " << this << "] created";
   }
 }

 PollingResolver::~PollingResolver() {
   if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
-    LOG(INFO) << "[polling resolver " << this << "] destroying";
+    ABSL_LOG(INFO) << "[polling resolver " << this << "] destroying";
   }
 }

@@ -95,7 +95,7 @@ void PollingResolver::ResetBackoffLocked() {

 void PollingResolver::ShutdownLocked() {
   if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
-    LOG(INFO) << "[polling resolver " << this << "] shutting down";
+    ABSL_LOG(INFO) << "[polling resolver " << this << "] shutting down";
   }
   shutdown_ = true;
   MaybeCancelNextResolutionTimer();
@@ -116,7 +116,7 @@ void PollingResolver::ScheduleNextResolutionTimer(Duration delay) {

 void PollingResolver::OnNextResolutionLocked() {
   if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
-    LOG(INFO) << "[polling resolver " << this
+    ABSL_LOG(INFO) << "[polling resolver " << this
               << "] re-resolution timer fired: shutdown_=" << shutdown_;
   }
   // If we haven't been cancelled nor shutdown, then start resolving.
@@ -129,7 +129,7 @@ void PollingResolver::OnNextResolutionLocked() {
 void PollingResolver::MaybeCancelNextResolutionTimer() {
   if (next_resolution_timer_handle_.has_value()) {
     if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
-      LOG(INFO) << "[polling resolver " << this
+      ABSL_LOG(INFO) << "[polling resolver " << this
                 << "] cancel re-resolution timer";
     }
     channel_args_.GetObject<EventEngine>()->Cancel(
@@ -146,12 +146,12 @@ void PollingResolver::OnRequestComplete(Result result) {

 void PollingResolver::OnRequestCompleteLocked(Result result) {
   if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
-    LOG(INFO) << "[polling resolver " << this << "] request complete";
+    ABSL_LOG(INFO) << "[polling resolver " << this << "] request complete";
   }
   request_.reset();
   if (!shutdown_) {
     if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
-      LOG(INFO)
+      ABSL_LOG(INFO)
           << "[polling resolver " << this << "] returning result: addresses="
           << (result.addresses.ok()
                   ? absl::StrCat("<", result.addresses->size(), " addresses>")
@@ -165,7 +165,7 @@ void PollingResolver::OnRequestCompleteLocked(Result result) {
                   : result.service_config.status().ToString())
           << ", resolution_note=" << result.resolution_note;
     }
-    CHECK(result.result_health_callback == nullptr);
+    ABSL_CHECK(result.result_health_callback == nullptr);
     result.result_health_callback =
         [self = RefAsSubclass<PollingResolver>(
              DEBUG_LOCATION, "result_health_callback")](absl::Status status) {
@@ -179,7 +179,7 @@ void PollingResolver::OnRequestCompleteLocked(Result result) {

 void PollingResolver::GetResultStatus(absl::Status status) {
   if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
-    LOG(INFO) << "[polling resolver " << this
+    ABSL_LOG(INFO) << "[polling resolver " << this
               << "] result status from channel: " << status;
   }
   if (status.ok()) {
@@ -195,9 +195,9 @@ void PollingResolver::GetResultStatus(absl::Status status) {
   } else {
     // Set up for retry.
     const Duration delay = backoff_.NextAttemptDelay();
-    CHECK(!next_resolution_timer_handle_.has_value());
+    ABSL_CHECK(!next_resolution_timer_handle_.has_value());
     if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
-      LOG(INFO) << "[polling resolver " << this << "] retrying in "
+      ABSL_LOG(INFO) << "[polling resolver " << this << "] retrying in "
                 << delay.millis() << " ms";
     }
     ScheduleNextResolutionTimer(delay);
@@ -225,7 +225,7 @@ void PollingResolver::MaybeStartResolvingLocked() {
       if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
         const Duration last_resolution_ago =
             Timestamp::Now() - *last_resolution_timestamp_;
-        LOG(INFO) << "[polling resolver " << this
+        ABSL_LOG(INFO) << "[polling resolver " << this
                   << "] in cooldown from last resolution (from "
                   << last_resolution_ago.millis()
                   << " ms ago); will resolve again in "
@@ -243,10 +243,10 @@ void PollingResolver::StartResolvingLocked() {
   last_resolution_timestamp_ = Timestamp::Now();
   if (GPR_UNLIKELY(tracer_ != nullptr && tracer_->enabled())) {
     if (request_ != nullptr) {
-      LOG(INFO) << "[polling resolver " << this
+      ABSL_LOG(INFO) << "[polling resolver " << this
                 << "] starting resolution, request_=" << request_.get();
     } else {
-      LOG(INFO) << "[polling resolver " << this << "] StartRequest failed";
+      ABSL_LOG(INFO) << "[polling resolver " << this << "] StartRequest failed";
     }
   }
 }
diff --git a/third_party/grpc/source/src/core/resolver/resolver_registry.cc b/third_party/grpc/source/src/core/resolver/resolver_registry.cc
index ccc5e8506817c..ae442021f274f 100644
--- a/third_party/grpc/source/src/core/resolver/resolver_registry.cc
+++ b/third_party/grpc/source/src/core/resolver/resolver_registry.cc
@@ -18,8 +18,8 @@

 #include <grpc/support/port_platform.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/ascii.h"
@@ -51,10 +51,10 @@ bool IsLowerCase(absl::string_view str) {

 void ResolverRegistry::Builder::RegisterResolverFactory(
     std::unique_ptr<ResolverFactory> factory) {
-  CHECK(IsLowerCase(factory->scheme())) << factory->scheme();
+  ABSL_CHECK(IsLowerCase(factory->scheme())) << factory->scheme();
   auto [_, inserted] =
       state_.factories.try_emplace(factory->scheme(), std::move(factory));
-  CHECK(inserted) << "scheme " << factory->scheme() << " already registered";
+  ABSL_CHECK(inserted) << "scheme " << factory->scheme() << " already registered";
 }

 bool ResolverRegistry::Builder::HasResolverFactory(
@@ -132,7 +132,7 @@ ResolverFactory* ResolverRegistry::LookupResolverFactory(
 // point to the parsed URI.
 ResolverFactory* ResolverRegistry::FindResolverFactory(
     absl::string_view target, URI* uri, std::string* canonical_target) const {
-  CHECK_NE(uri, nullptr);
+  ABSL_CHECK_NE(uri, nullptr);
   absl::StatusOr<URI> tmp_uri = URI::Parse(target);
   ResolverFactory* factory =
       tmp_uri.ok() ? LookupResolverFactory(tmp_uri->scheme()) : nullptr;
@@ -148,12 +148,12 @@ ResolverFactory* ResolverRegistry::FindResolverFactory(
     return factory;
   }
   if (!tmp_uri.ok() || !tmp_uri2.ok()) {
-    LOG(ERROR) << "Error parsing URI(s). '" << target
+    ABSL_LOG(ERROR) << "Error parsing URI(s). '" << target
                << "':" << tmp_uri.status() << "; '" << *canonical_target
                << "':" << tmp_uri2.status();
     return nullptr;
   }
-  LOG(ERROR) << "Don't know how to resolve '" << target << "' or '"
+  ABSL_LOG(ERROR) << "Don't know how to resolve '" << target << "' or '"
              << *canonical_target << "'.";
   return nullptr;
 }
diff --git a/third_party/grpc/source/src/core/resolver/sockaddr/sockaddr_resolver.cc b/third_party/grpc/source/src/core/resolver/sockaddr/sockaddr_resolver.cc
index 0e433d29ad051..bfae1d88468a0 100644
--- a/third_party/grpc/source/src/core/resolver/sockaddr/sockaddr_resolver.cc
+++ b/third_party/grpc/source/src/core/resolver/sockaddr/sockaddr_resolver.cc
@@ -21,7 +21,7 @@
 #include <string>
 #include <utility>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_split.h"
 #include "absl/strings/string_view.h"
@@ -75,7 +75,7 @@ bool ParseUri(const URI& uri,
               bool parse(const URI& uri, grpc_resolved_address* dst),
               EndpointAddressesList* addresses) {
   if (!uri.authority().empty()) {
-    LOG(ERROR) << "authority-based URIs not supported by the " << uri.scheme()
+    ABSL_LOG(ERROR) << "authority-based URIs not supported by the " << uri.scheme()
                << " scheme";
     return false;
   }
diff --git a/third_party/grpc/source/src/core/resolver/xds/xds_dependency_manager.cc b/third_party/grpc/source/src/core/resolver/xds/xds_dependency_manager.cc
index 61b61875f24a4..199ad6d81e327 100644
--- a/third_party/grpc/source/src/core/resolver/xds/xds_dependency_manager.cc
+++ b/third_party/grpc/source/src/core/resolver/xds/xds_dependency_manager.cc
@@ -18,8 +18,8 @@

 #include <set>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_join.h"
 #include "src/core/config/core_configuration.h"
 #include "src/core/load_balancing/xds/xds_channel_args.h"
@@ -652,7 +652,7 @@ bool XdsDependencyManager::PopulateClusterConfigMap(
     std::set<absl::string_view>* eds_resources_seen,
     std::set<absl::string_view>* dns_names_seen,
     absl::StatusOr<std::vector<absl::string_view>>* leaf_clusters) {
-  if (depth > 0) CHECK_NE(leaf_clusters, nullptr);
+  if (depth > 0) ABSL_CHECK_NE(leaf_clusters, nullptr);
   if (depth == kMaxXdsAggregateClusterRecursionDepth) {
     *leaf_clusters =
         absl::UnavailableError("aggregate cluster graph exceeds max depth");
diff --git a/third_party/grpc/source/src/core/resolver/xds/xds_resolver.cc b/third_party/grpc/source/src/core/resolver/xds/xds_resolver.cc
index 27172e69a704a..3dcb7fb04bd64 100644
--- a/third_party/grpc/source/src/core/resolver/xds/xds_resolver.cc
+++ b/third_party/grpc/source/src/core/resolver/xds/xds_resolver.cc
@@ -32,8 +32,8 @@
 #include <variant>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/meta/type_traits.h"
 #include "absl/random/random.h"
 #include "absl/status/status.h"
@@ -620,7 +620,7 @@ XdsResolver::XdsConfigSelector::XdsConfigSelector(
     const XdsHttpFilterImpl* filter_impl =
         http_filter_registry.GetFilterForType(
             http_filter.config.config_proto_type_name);
-    CHECK_NE(filter_impl, nullptr);
+    ABSL_CHECK_NE(filter_impl, nullptr);
     // Add filter to list.
     filters_.push_back(filter_impl);
   }
@@ -660,7 +660,7 @@ std::optional<uint64_t> HeaderHashHelper(
 absl::Status XdsResolver::XdsConfigSelector::GetCallConfig(
     GetCallConfigArgs args) {
   Slice* path = args.initial_metadata->get_pointer(HttpPathMetadata());
-  CHECK_NE(path, nullptr);
+  ABSL_CHECK_NE(path, nullptr);
   auto* entry = route_config_data_->GetRouteForRequest(path->as_string_view(),
                                                        args.initial_metadata);
   if (entry == nullptr) {
@@ -708,7 +708,7 @@ absl::Status XdsResolver::XdsConfigSelector::GetCallConfig(
           }
         }
         if (index == 0) index = start_index;
-        CHECK(entry->weighted_cluster_state[index].range_end > key);
+        ABSL_CHECK(entry->weighted_cluster_state[index].range_end > key);
         cluster_name = absl::StrCat(
             "cluster:", entry->weighted_cluster_state[index].cluster);
         method_config = entry->weighted_cluster_state[index].method_config;
@@ -722,7 +722,7 @@ absl::Status XdsResolver::XdsConfigSelector::GetCallConfig(
         method_config = entry->method_config;
       });
   auto cluster = route_config_data_->FindClusterRef(cluster_name);
-  CHECK(cluster != nullptr);
+  ABSL_CHECK(cluster != nullptr);
   // Generate a hash.
   std::optional<uint64_t> hash;
   for (const auto& hash_policy : route_action->hash_policies) {
@@ -842,7 +842,7 @@ void XdsResolver::ClusterSelectionFilter::Call::OnClientInitialMetadata(
     ClientMetadata&) {
   auto* service_config_call_data =
       GetContext<ClientChannelServiceConfigCallData>();
-  CHECK_NE(service_config_call_data, nullptr);
+  ABSL_CHECK_NE(service_config_call_data, nullptr);
   auto* route_state_attribute = static_cast<XdsRouteStateAttributeImpl*>(
       service_config_call_data->GetCallAttribute<XdsRouteStateAttribute>());
   auto* cluster_name_attribute =
@@ -865,7 +865,7 @@ void XdsResolver::StartLocked() {
   auto xds_client =
       GrpcXdsClient::GetOrCreate(uri_.ToString(), args_, "xds resolver");
   if (!xds_client.ok()) {
-    LOG(ERROR) << "Failed to create xds client -- channel will remain in "
+    ABSL_LOG(ERROR) << "Failed to create xds client -- channel will remain in "
                   "TRANSIENT_FAILURE: "
                << xds_client.status();
     absl::Status status = absl::UnavailableError(absl::StrCat(
@@ -949,7 +949,7 @@ void XdsResolver::OnUpdate(
       << "[xds_resolver " << this << "] received updated xDS config";
   if (xds_client_ == nullptr) return;
   if (!config.ok()) {
-    LOG(ERROR) << "[xds_resolver " << this << "] config error ("
+    ABSL_LOG(ERROR) << "[xds_resolver " << this << "] config error ("
                << config.status()
                << ") -- clearing update and returning empty service config";
     current_config_.reset();
@@ -1047,7 +1047,7 @@ void XdsResolver::GenerateErrorResult(std::string error) {
   Result result;
   result.addresses.emplace();
   result.service_config = ServiceConfigImpl::Create(args_, "{}");
-  CHECK(result.service_config.ok());
+  ABSL_CHECK(result.service_config.ok());
   result.resolution_note = std::move(error);
   result.args = args_;
   result_handler_->ReportResult(std::move(result));
@@ -1077,7 +1077,7 @@ class XdsResolverFactory final : public ResolverFactory {

   bool IsValidUri(const URI& uri) const override {
     if (uri.path().empty() || uri.path().back() == '/') {
-      LOG(ERROR) << "URI path does not contain valid data plane authority";
+      ABSL_LOG(ERROR) << "URI path does not contain valid data plane authority";
       return false;
     }
     return true;
diff --git a/third_party/grpc/source/src/core/server/server.cc b/third_party/grpc/source/src/core/server/server.cc
index c6691b4edfe47..8495d3190d640 100644
--- a/third_party/grpc/source/src/core/server/server.cc
+++ b/third_party/grpc/source/src/core/server/server.cc
@@ -41,8 +41,8 @@

 #include "absl/cleanup/cleanup.h"
 #include "absl/container/flat_hash_map.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "src/core/channelz/channel_trace.h"
 #include "src/core/channelz/channelz.h"
@@ -170,7 +170,7 @@ void Server::ListenerState::Stop() {
       is_serving_ = false;
     }
     if (config_fetcher_watcher_ != nullptr) {
-      CHECK_NE(server_->config_fetcher(), nullptr);
+      ABSL_CHECK_NE(server_->config_fetcher(), nullptr);
       server_->config_fetcher()->CancelWatch(config_fetcher_watcher_);
     }
   }
@@ -503,7 +503,7 @@ struct Server::RequestedCall {
         md.get(GrpcTimeoutMetadata()).value_or(Timestamp::InfFuture());
     switch (type) {
       case RequestedCall::Type::BATCH_CALL:
-        CHECK(!payload.has_value());
+        ABSL_CHECK(!payload.has_value());
         data.batch.details->host =
             CSliceRef(md.get_pointer(HttpAuthorityMetadata())->c_slice());
         data.batch.details->method =
@@ -560,10 +560,10 @@ class Server::RealRequestMatcher : public RequestMatcherInterface {

   ~RealRequestMatcher() override {
     for (LockedMultiProducerSingleConsumerQueue& queue : requests_per_cq_) {
-      CHECK_EQ(queue.Pop(), nullptr);
+      ABSL_CHECK_EQ(queue.Pop(), nullptr);
     }
-    CHECK(pending_filter_stack_.empty());
-    CHECK(pending_promises_.empty());
+    ABSL_CHECK(pending_filter_stack_.empty());
+    ABSL_CHECK(pending_promises_.empty());
   }

   void ZombifyPending() override {
@@ -787,7 +787,7 @@ class Server::RealRequestMatcher : public RequestMatcherInterface {
       if (!result.compare_exchange_strong(expected, new_value,
                                           std::memory_order_acq_rel,
                                           std::memory_order_acquire)) {
-        CHECK(new_value->value().TakeCall() == requested_call);
+        ABSL_CHECK(new_value->value().TakeCall() == requested_call);
         delete new_value;
         return false;
       }
@@ -822,7 +822,7 @@ class Server::AllocatingRequestMatcherBase : public RequestMatcherInterface {
         break;
       }
     }
-    CHECK(idx < server->cqs_.size());
+    ABSL_CHECK(idx < server->cqs_.size());
     cq_idx_ = idx;
   }

@@ -868,7 +868,7 @@ class Server::AllocatingRequestMatcherBatch
         absl::MakeCleanup([this] { server()->ShutdownUnrefOnRequest(); });
     if (still_running) {
       BatchCallAllocation call_info = allocator_();
-      CHECK(server()->ValidateServerRequest(cq(),
+      ABSL_CHECK(server()->ValidateServerRequest(cq(),
                                             static_cast<void*>(call_info.tag),
                                             nullptr, nullptr) == GRPC_CALL_OK);
       RequestedCall* rc = new RequestedCall(
@@ -884,7 +884,7 @@ class Server::AllocatingRequestMatcherBatch
   ArenaPromise<absl::StatusOr<MatchResult>> MatchRequest(
       size_t /*start_request_queue_index*/) override {
     BatchCallAllocation call_info = allocator_();
-    CHECK(server()->ValidateServerRequest(cq(),
+    ABSL_CHECK(server()->ValidateServerRequest(cq(),
                                           static_cast<void*>(call_info.tag),
                                           nullptr, nullptr) == GRPC_CALL_OK);
     RequestedCall* rc = new RequestedCall(
@@ -914,7 +914,7 @@ class Server::AllocatingRequestMatcherRegistered
         absl::MakeCleanup([this] { server()->ShutdownUnrefOnRequest(); });
     if (server()->ShutdownRefOnRequest()) {
       RegisteredCallAllocation call_info = allocator_();
-      CHECK(server()->ValidateServerRequest(
+      ABSL_CHECK(server()->ValidateServerRequest(
                 cq(), call_info.tag, call_info.optional_payload,
                 registered_method_) == GRPC_CALL_OK);
       RequestedCall* rc =
@@ -931,7 +931,7 @@ class Server::AllocatingRequestMatcherRegistered
   ArenaPromise<absl::StatusOr<MatchResult>> MatchRequest(
       size_t /*start_request_queue_index*/) override {
     RegisteredCallAllocation call_info = allocator_();
-    CHECK(server()->ValidateServerRequest(cq(), call_info.tag,
+    ABSL_CHECK(server()->ValidateServerRequest(cq(), call_info.tag,
                                           call_info.optional_payload,
                                           registered_method_) == GRPC_CALL_OK);
     RequestedCall* rc = new RequestedCall(
@@ -958,7 +958,7 @@ class ChannelBroadcaster {

   // Copies over the channels from the locked server.
   void FillChannelsLocked(std::vector<RefCountedPtr<Channel>> channels) {
-    DCHECK(channels_.empty());
+    ABSL_DCHECK(channels_.empty());
     channels_ = std::move(channels);
   }

@@ -1270,15 +1270,15 @@ grpc_error_handle Server::SetupTransport(
     connections_.emplace(std::move(t));
     ++connections_open_;
   } else {
-    CHECK(transport->filter_stack_transport() != nullptr);
+    ABSL_CHECK(transport->filter_stack_transport() != nullptr);
     absl::StatusOr<RefCountedPtr<Channel>> channel = LegacyChannel::Create(
         "", args.SetObject(transport), GRPC_SERVER_CHANNEL);
     if (!channel.ok()) {
       return absl_status_to_grpc_error(channel.status());
     }
-    CHECK(*channel != nullptr);
+    ABSL_CHECK(*channel != nullptr);
     auto* channel_stack = (*channel)->channel_stack();
-    CHECK(channel_stack != nullptr);
+    ABSL_CHECK(channel_stack != nullptr);
     ChannelData* chand = static_cast<ChannelData*>(
         grpc_channel_stack_element(channel_stack, 0)->channel_data);
     // Set up CQs.
@@ -1317,7 +1317,7 @@ void Server::SetRegisteredMethodAllocator(

 void Server::SetBatchMethodAllocator(
     grpc_completion_queue* cq, std::function<BatchCallAllocation()> allocator) {
-  DCHECK(unregistered_request_matcher_ == nullptr);
+  ABSL_DCHECK(unregistered_request_matcher_ == nullptr);
   unregistered_request_matcher_ =
       std::make_unique<AllocatingRequestMatcherBatch>(this, cq,
                                                       std::move(allocator));
@@ -1340,17 +1340,17 @@ Server::RegisteredMethod* Server::RegisterMethod(
   }

   if (!method) {
-    LOG(ERROR) << "grpc_server_register_method method string cannot be NULL";
+    ABSL_LOG(ERROR) << "grpc_server_register_method method string cannot be NULL";
     return nullptr;
   }
   auto key = std::make_pair(host ? host : "", method);
   if (registered_methods_.find(key) != registered_methods_.end()) {
-    LOG(ERROR) << "duplicate registration for " << method << "@"
+    ABSL_LOG(ERROR) << "duplicate registration for " << method << "@"
                << (host ? host : "*");
     return nullptr;
   }
   if (flags != 0) {
-    LOG(ERROR) << "grpc_server_register_method invalid flags "
+    ABSL_LOG(ERROR) << "grpc_server_register_method invalid flags "
                << absl::StrFormat("0x%08x", flags);
     return nullptr;
   }
@@ -1368,7 +1368,7 @@ void Server::FailCall(size_t cq_idx, RequestedCall* rc,
                       grpc_error_handle error) {
   *rc->call = nullptr;
   rc->initial_metadata->count = 0;
-  CHECK(!error.ok());
+  ABSL_CHECK(!error.ok());
   grpc_cq_end_op(cqs_[cq_idx], rc->tag, error, DoneRequestEvent, rc,
                  &rc->completion);
 }
@@ -1389,7 +1389,7 @@ void Server::MaybeFinishShutdown() {
                                   last_shutdown_message_time_),
                      gpr_time_from_seconds(1, GPR_TIMESPAN)) >= 0) {
       last_shutdown_message_time_ = gpr_now(GPR_CLOCK_REALTIME);
-      VLOG(2) << "Waiting for " << channels_.size() << " channels "
+      ABSL_VLOG(2) << "Waiting for " << channels_.size() << " channels "
               << connections_open_ << " connections and "
               << listener_states_.size() - listeners_destroyed_ << "/"
               << listener_states_.size()
@@ -1464,7 +1464,7 @@ void Server::ShutdownAndNotify(grpc_completion_queue* cq, void* tag) {
       starting_cv_.Wait(&mu_global_);
     }
     // Stay locked, and gather up some stuff to do.
-    CHECK(grpc_cq_begin_op(cq, tag));
+    ABSL_CHECK(grpc_cq_begin_op(cq, tag));
     if (shutdown_published_) {
       grpc_cq_end_op(cq, tag, absl::OkStatus(), DonePublishedShutdown, nullptr,
                      new grpc_cq_completion);
@@ -1523,8 +1523,8 @@ void Server::SendGoaways() {
 void Server::Orphan() {
   {
     MutexLock lock(&mu_global_);
-    CHECK(ShutdownCalled() || listener_states_.empty());
-    CHECK(listeners_destroyed_ == listener_states_.size());
+    ABSL_CHECK(ShutdownCalled() || listener_states_.empty());
+    ABSL_CHECK(listeners_destroyed_ == listener_states_.size());
   }
   listener_states_.clear();
   Unref();
@@ -1677,7 +1677,7 @@ void Server::ChannelData::InitTransport(RefCountedPtr<Server> server,
   }
   // Start accept_stream transport op.
   grpc_transport_op* op = grpc_make_transport_op(nullptr);
-  CHECK(transport->filter_stack_transport() != nullptr);
+  ABSL_CHECK(transport->filter_stack_transport() != nullptr);
   op->set_accept_stream = true;
   op->set_accept_stream_fn = AcceptStream;
   op->set_registered_method_matcher_fn = [](void* arg,
@@ -1745,7 +1745,7 @@ void Server::ChannelData::AcceptStream(void* arg, Transport* /*transport*/,
   grpc_call* call;
   grpc_error_handle error = grpc_call_create(&args, &call);
   grpc_call_stack* call_stack = grpc_call_get_call_stack(call);
-  CHECK_NE(call_stack, nullptr);
+  ABSL_CHECK_NE(call_stack, nullptr);
   grpc_call_element* elem = grpc_call_stack_element(call_stack, 0);
   auto* calld = static_cast<Server::CallData*>(elem->call_data);
   if (!error.ok()) {
@@ -1767,7 +1767,7 @@ void Server::ChannelData::FinishDestroy(void* arg,

 void Server::ChannelData::Destroy() {
   if (!list_position_.has_value()) return;
-  CHECK(server_ != nullptr);
+  ABSL_CHECK(server_ != nullptr);
   server_->channels_.erase(*list_position_);
   list_position_.reset();
   server_->Ref().release();
@@ -1787,8 +1787,8 @@ void Server::ChannelData::Destroy() {

 grpc_error_handle Server::ChannelData::InitChannelElement(
     grpc_channel_element* elem, grpc_channel_element_args* args) {
-  CHECK(args->is_first);
-  CHECK(!args->is_last);
+  ABSL_CHECK(args->is_first);
+  ABSL_CHECK(!args->is_last);
   new (elem->channel_data) ChannelData();
   return absl::OkStatus();
 }
@@ -1815,7 +1815,7 @@ Server::CallData::CallData(grpc_call_element* elem,
 }

 Server::CallData::~CallData() {
-  CHECK(state_.load(std::memory_order_relaxed) != CallState::PENDING);
+  ABSL_CHECK(state_.load(std::memory_order_relaxed) != CallState::PENDING);
   grpc_metadata_array_destroy(&initial_metadata_);
   grpc_byte_buffer_destroy(payload_);
 }
@@ -1866,8 +1866,8 @@ void Server::CallData::Publish(size_t cq_idx, RequestedCall* rc) {
   std::swap(*rc->initial_metadata, initial_metadata_);
   switch (rc->type) {
     case RequestedCall::Type::BATCH_CALL:
-      CHECK(host_.has_value());
-      CHECK(path_.has_value());
+      ABSL_CHECK(host_.has_value());
+      ABSL_CHECK(path_.has_value());
       rc->data.batch.details->host = CSliceRef(host_->c_slice());
       rc->data.batch.details->method = CSliceRef(path_->c_slice());
       rc->data.batch.details->deadline =
@@ -1959,7 +1959,7 @@ void Server::CallData::RecvInitialMetadataBatchComplete(
   grpc_call_element* elem = static_cast<grpc_call_element*>(arg);
   auto* calld = static_cast<Server::CallData*>(elem->call_data);
   if (!error.ok()) {
-    VLOG(2) << "Failed call creation: " << StatusToString(error);
+    ABSL_VLOG(2) << "Failed call creation: " << StatusToString(error);
     calld->FailCallCreation();
     return;
   }
@@ -2081,10 +2081,10 @@ void grpc_server_register_completion_queue(grpc_server* server,
   GRPC_TRACE_LOG(api, INFO)
       << "grpc_server_register_completion_queue(server=" << server
       << ", cq=" << cq << ", reserved=" << reserved << ")";
-  CHECK(!reserved);
+  ABSL_CHECK(!reserved);
   auto cq_type = grpc_get_cq_completion_type(cq);
   if (cq_type != GRPC_CQ_NEXT && cq_type != GRPC_CQ_CALLBACK) {
-    VLOG(2) << "Completion queue of type " << static_cast<int>(cq_type)
+    ABSL_VLOG(2) << "Completion queue of type " << static_cast<int>(cq_type)
             << " is being registered as a server-completion-queue";
     // Ideally we should log an error and abort but ruby-wrapped-language API
     // calls grpc_completion_queue_pluck() on server completion queues
diff --git a/third_party/grpc/source/src/core/server/server_config_selector_filter.cc b/third_party/grpc/source/src/core/server/server_config_selector_filter.cc
index 33b4335ead09c..20198942fa233 100644
--- a/third_party/grpc/source/src/core/server/server_config_selector_filter.cc
+++ b/third_party/grpc/source/src/core/server/server_config_selector_filter.cc
@@ -22,7 +22,7 @@
 #include <utility>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "src/core/lib/channel/channel_args.h"
@@ -123,7 +123,7 @@ ServerConfigSelectorFilter::ServerConfigSelectorFilter(
     RefCountedPtr<ServerConfigSelectorProvider> server_config_selector_provider)
     : server_config_selector_provider_(
           std::move(server_config_selector_provider)) {
-  CHECK(server_config_selector_provider_ != nullptr);
+  ABSL_CHECK(server_config_selector_provider_ != nullptr);
   auto server_config_selector_watcher =
       std::make_unique<ServerConfigSelectorWatcher>(Ref());
   auto config_selector = server_config_selector_provider_->Watch(
diff --git a/third_party/grpc/source/src/core/server/xds_server_config_fetcher.cc b/third_party/grpc/source/src/core/server/xds_server_config_fetcher.cc
index 415d73fc93453..930c78e946efd 100644
--- a/third_party/grpc/source/src/core/server/xds_server_config_fetcher.cc
+++ b/third_party/grpc/source/src/core/server/xds_server_config_fetcher.cc
@@ -35,8 +35,8 @@
 #include <vector>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/match.h"
@@ -396,7 +396,7 @@ class XdsServerConfigFetcher::ListenerWatcher::FilterChainMatchManager::
   absl::StatusOr<RefCountedPtr<ServerConfigSelector>> Watch(
       std::unique_ptr<ServerConfigSelectorProvider::ServerConfigSelectorWatcher>
           watcher) override {
-    CHECK(watcher_ == nullptr);
+    ABSL_CHECK(watcher_ == nullptr);
     watcher_ = std::move(watcher);
     if (!static_resource_.ok()) {
       return static_resource_.status();
@@ -504,7 +504,7 @@ XdsServerConfigFetcher::XdsServerConfigFetcher(
     RefCountedPtr<GrpcXdsClient> xds_client,
     grpc_server_xds_status_notifier notifier)
     : xds_client_(std::move(xds_client)), serving_status_notifier_(notifier) {
-  CHECK(xds_client_ != nullptr);
+  ABSL_CHECK(xds_client_ != nullptr);
 }

 std::string ListenerResourceName(absl::string_view resource_name_template,
@@ -614,7 +614,7 @@ void XdsServerConfigFetcher::ListenerWatcher::OnResourceChanged(

 void XdsServerConfigFetcher::ListenerWatcher::OnAmbientError(
     absl::Status status, RefCountedPtr<ReadDelayHandle> /*read_delay_handle*/) {
-  LOG(ERROR) << "ListenerWatcher:" << this
+  ABSL_LOG(ERROR) << "ListenerWatcher:" << this
              << " XdsClient reports ambient error: " << status << " for "
              << listening_address_
              << "; ignoring in favor of existing resource";
@@ -635,7 +635,7 @@ void XdsServerConfigFetcher::ListenerWatcher::OnFatalError(
         {static_cast<grpc_status_code>(status.raw_code()),
          std::string(status.message()).c_str()});
   } else {
-    LOG(ERROR) << "ListenerWatcher:" << this << " Encountered fatal error "
+    ABSL_LOG(ERROR) << "ListenerWatcher:" << this << " Encountered fatal error "
                << status << "; not serving on " << listening_address_;
   }
 }
@@ -664,7 +664,7 @@ void XdsServerConfigFetcher::ListenerWatcher::
           serving_status_notifier_.user_data, listening_address_.c_str(),
           {GRPC_STATUS_OK, ""});
     } else {
-      LOG(INFO) << "xDS Listener resource obtained; will start serving on "
+      ABSL_LOG(INFO) << "xDS Listener resource obtained; will start serving on "
                 << listening_address_;
     }
   }
@@ -844,7 +844,7 @@ void XdsServerConfigFetcher::ListenerWatcher::FilterChainMatchManager::

 void XdsServerConfigFetcher::ListenerWatcher::FilterChainMatchManager::
     OnAmbientError(const std::string& resource_name, absl::Status status) {
-  LOG(ERROR) << "RouteConfigWatcher:" << this
+  ABSL_LOG(ERROR) << "RouteConfigWatcher:" << this
              << " XdsClient reports ambient error: " << status << " for "
              << resource_name << "; ignoring in favor of existing resource";
 }
@@ -928,7 +928,7 @@ const XdsListenerResource::FilterChainData* FindFilterChainDataForSourceType(
   }
   auto source_addr = StringToSockaddr(host, 0);  // Port doesn't matter here.
   if (!source_addr.ok()) {
-    VLOG(2) << "Could not parse \"" << host
+    ABSL_VLOG(2) << "Could not parse \"" << host
             << "\" as socket address: " << source_addr.status();
     return nullptr;
   }
@@ -977,7 +977,7 @@ const XdsListenerResource::FilterChainData* FindFilterChainDataForDestinationIp(
   auto destination_addr =
       StringToSockaddr(host, 0);  // Port doesn't matter here.
   if (!destination_addr.ok()) {
-    VLOG(2) << "Could not parse \"" << host
+    ABSL_VLOG(2) << "Could not parse \"" << host
             << "\" as socket address: " << destination_addr.status();
     return nullptr;
   }
@@ -1035,7 +1035,7 @@ absl::StatusOr<ChannelArgs> XdsServerConfigFetcher::ListenerWatcher::
     const XdsHttpFilterImpl* filter_impl =
         http_filter_registry.GetFilterForType(
             http_filter.config.config_proto_type_name);
-    CHECK_NE(filter_impl, nullptr);
+    ABSL_CHECK_NE(filter_impl, nullptr);
     // Some filters like the router filter are no-op filters and do not have
     // an implementation.
     if (filter_impl->channel_filter() != nullptr) {
@@ -1084,7 +1084,7 @@ absl::StatusOr<ChannelArgs> XdsServerConfigFetcher::ListenerWatcher::
       return result.status();
     }
     xds_certificate_provider = std::move(*result);
-    CHECK(xds_certificate_provider != nullptr);
+    ABSL_CHECK(xds_certificate_provider != nullptr);
     args = args.SetObject(xds_certificate_provider);
   }
   return args;
@@ -1202,7 +1202,7 @@ XdsServerConfigFetcher::ListenerWatcher::FilterChainMatchManager::
       resource_name_(std::move(resource_name)),
       http_filters_(std::move(http_filters)),
       resource_(std::move(initial_resource)) {
-  CHECK(!resource_name_.empty());
+  ABSL_CHECK(!resource_name_.empty());
   // RouteConfigWatcher is being created here instead of in Watch() to avoid
   // deadlocks from invoking XdsRouteConfigResourceType::StartWatch whilst in a
   // critical region.
@@ -1229,7 +1229,7 @@ XdsServerConfigFetcher::ListenerWatcher::FilterChainMatchManager::
   absl::StatusOr<std::shared_ptr<const XdsRouteConfigResource>> resource;
   {
     MutexLock lock(&mu_);
-    CHECK(watcher_ == nullptr);
+    ABSL_CHECK(watcher_ == nullptr);
     watcher_ = std::move(watcher);
     resource = resource_;
   }
@@ -1278,7 +1278,7 @@ void XdsServerConfigFetcher::ListenerWatcher::FilterChainMatchManager::
 void XdsServerConfigFetcher::ListenerWatcher::FilterChainMatchManager::
     DynamicXdsServerConfigSelectorProvider::OnAmbientError(
         absl::Status status) {
-  LOG(ERROR) << "RouteConfigWatcher:" << this
+  ABSL_LOG(ERROR) << "RouteConfigWatcher:" << this
              << " XdsClient reports ambient error: " << status << " for "
              << resource_name_ << "; ignoring in favor of existing resource";
 }
@@ -1302,14 +1302,14 @@ grpc_server_config_fetcher* grpc_server_config_fetcher_xds_create(
       grpc_core::GrpcXdsClient::kServerKey, channel_args,
       "XdsServerConfigFetcher");
   if (!xds_client.ok()) {
-    LOG(ERROR) << "Failed to create xds client: " << xds_client.status();
+    ABSL_LOG(ERROR) << "Failed to create xds client: " << xds_client.status();
     return nullptr;
   }
   if (static_cast<const grpc_core::GrpcXdsBootstrap&>(
           (*xds_client)->bootstrap())
           .server_listener_resource_name_template()
           .empty()) {
-    LOG(ERROR) << "server_listener_resource_name_template not provided in "
+    ABSL_LOG(ERROR) << "server_listener_resource_name_template not provided in "
                   "bootstrap file.";
     return nullptr;
   }
diff --git a/third_party/grpc/source/src/core/service_config/service_config_channel_arg_filter.cc b/third_party/grpc/source/src/core/service_config/service_config_channel_arg_filter.cc
index 3278534c49594..c3d064b0900a4 100644
--- a/third_party/grpc/source/src/core/service_config/service_config_channel_arg_filter.cc
+++ b/third_party/grpc/source/src/core/service_config/service_config_channel_arg_filter.cc
@@ -26,7 +26,7 @@
 #include <string>
 #include <utility>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "src/core/config/core_configuration.h"
@@ -70,7 +70,7 @@ class ServiceConfigChannelArgFilter final
       auto service_config =
           ServiceConfigImpl::Create(args, *service_config_str);
       if (!service_config.ok()) {
-        LOG(ERROR) << service_config.status().ToString();
+        ABSL_LOG(ERROR) << service_config.status().ToString();
       } else {
         service_config_ = std::move(*service_config);
       }
diff --git a/third_party/grpc/source/src/core/service_config/service_config_impl.h b/third_party/grpc/source/src/core/service_config/service_config_impl.h
index 9d6ae2a46d34c..b23797122e04f 100644
--- a/third_party/grpc/source/src/core/service_config/service_config_impl.h
+++ b/third_party/grpc/source/src/core/service_config/service_config_impl.h
@@ -26,7 +26,7 @@
 #include <unordered_map>
 #include <vector>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/string_view.h"
 #include "src/core/lib/channel/channel_args.h"
@@ -87,7 +87,7 @@ class ServiceConfigImpl final : public ServiceConfig {
   /// ServiceConfig object.
   ServiceConfigParser::ParsedConfig* GetGlobalParsedConfig(
       size_t index) override {
-    DCHECK(index < parsed_global_configs_.size());
+    ABSL_DCHECK(index < parsed_global_configs_.size());
     return parsed_global_configs_[index].get();
   }

diff --git a/third_party/grpc/source/src/core/service_config/service_config_parser.cc b/third_party/grpc/source/src/core/service_config/service_config_parser.cc
index b3ff739251493..2670e76aea816 100644
--- a/third_party/grpc/source/src/core/service_config/service_config_parser.cc
+++ b/third_party/grpc/source/src/core/service_config/service_config_parser.cc
@@ -21,7 +21,7 @@

 #include <string>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"

 namespace grpc_core {

@@ -33,7 +33,7 @@ void ServiceConfigParser::Builder::RegisterParser(
     std::unique_ptr<Parser> parser) {
   for (const auto& registered_parser : registered_parsers_) {
     if (registered_parser->name() == parser->name()) {
-      LOG(ERROR) << "Parser with name '" << parser->name()
+      ABSL_LOG(ERROR) << "Parser with name '" << parser->name()
                  << "' already registered";
       // We'll otherwise crash later.
       abort();
diff --git a/third_party/grpc/source/src/core/telemetry/call_tracer.cc b/third_party/grpc/source/src/core/telemetry/call_tracer.cc
index 49467582cb115..d749b547c58fa 100644
--- a/third_party/grpc/source/src/core/telemetry/call_tracer.cc
+++ b/third_party/grpc/source/src/core/telemetry/call_tracer.cc
@@ -24,7 +24,7 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/promise/context.h"
 #include "src/core/telemetry/tcp_tracer.h"

@@ -86,7 +86,7 @@ class DelegatingClientCallTracer : public ClientCallTracer {
     explicit DelegatingClientCallAttemptTracer(
         std::vector<CallAttemptTracer*> tracers)
         : tracers_(std::move(tracers)) {
-      DCHECK(!tracers_.empty());
+      ABSL_DCHECK(!tracers_.empty());
     }
     ~DelegatingClientCallAttemptTracer() override {}
     void RecordSendInitialMetadata(
@@ -198,7 +198,7 @@ class DelegatingClientCallTracer : public ClientCallTracer {
     attempt_tracers.reserve(tracers_.size());
     for (auto* tracer : tracers_) {
       auto* attempt_tracer = tracer->StartNewAttempt(is_transparent_retry);
-      DCHECK_NE(attempt_tracer, nullptr);
+      ABSL_DCHECK_NE(attempt_tracer, nullptr);
       attempt_tracers.push_back(attempt_tracer);
     }
     return GetContext<Arena>()->ManagedNew<DelegatingClientCallAttemptTracer>(
@@ -356,7 +356,7 @@ void AddClientCallTracerToContext(Arena* arena, ClientCallTracer* tracer) {
 }

 void AddServerCallTracerToContext(Arena* arena, ServerCallTracer* tracer) {
-  DCHECK_EQ(arena->GetContext<CallTracerInterface>(),
+  ABSL_DCHECK_EQ(arena->GetContext<CallTracerInterface>(),
             arena->GetContext<CallTracerAnnotationInterface>());
   if (arena->GetContext<CallTracerAnnotationInterface>() == nullptr) {
     // This is the first call tracer. Set it directly.
diff --git a/third_party/grpc/source/src/core/telemetry/metrics.cc b/third_party/grpc/source/src/core/telemetry/metrics.cc
index 92441a914d4cd..9e38ff4130a4a 100644
--- a/third_party/grpc/source/src/core/telemetry/metrics.cc
+++ b/third_party/grpc/source/src/core/telemetry/metrics.cc
@@ -19,7 +19,7 @@
 #include <memory>
 #include <optional>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/util/crash.h"

 namespace grpc_core {
@@ -50,7 +50,7 @@ GlobalInstrumentsRegistry::RegisterInstrument(
     }
   }
   InstrumentID index = instruments.size();
-  CHECK_LT(index, std::numeric_limits<uint32_t>::max());
+  ABSL_CHECK_LT(index, std::numeric_limits<uint32_t>::max());
   GlobalInstrumentDescriptor descriptor;
   descriptor.value_type = value_type;
   descriptor.instrument_type = instrument_type;
diff --git a/third_party/grpc/source/src/core/tsi/alts/frame_protector/alts_frame_protector.cc b/third_party/grpc/source/src/core/tsi/alts/frame_protector/alts_frame_protector.cc
index 534e8555465de..1e5b42590793d 100644
--- a/third_party/grpc/source/src/core/tsi/alts/frame_protector/alts_frame_protector.cc
+++ b/third_party/grpc/source/src/core/tsi/alts/frame_protector/alts_frame_protector.cc
@@ -26,7 +26,7 @@
 #include <algorithm>
 #include <memory>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/types/span.h"
 #include "src/core/tsi/alts/crypt/gsec.h"
 #include "src/core/tsi/alts/frame_protector/alts_crypter.h"
@@ -68,7 +68,7 @@ static tsi_result seal(alts_frame_protector* impl) {
       &output_size, &error_details);
   impl->in_place_protect_bytes_buffered = output_size;
   if (status != GRPC_STATUS_OK) {
-    LOG(ERROR) << error_details;
+    ABSL_LOG(ERROR) << error_details;
     gpr_free(error_details);
     return TSI_INTERNAL_ERROR;
   }
@@ -86,7 +86,7 @@ static tsi_result alts_protect_flush(tsi_frame_protector* self,
   if (self == nullptr || protected_output_frames == nullptr ||
       protected_output_frames_size == nullptr ||
       still_pending_size == nullptr) {
-    LOG(ERROR) << "Invalid nullptr arguments to alts_protect_flush().";
+    ABSL_LOG(ERROR) << "Invalid nullptr arguments to alts_protect_flush().";
     return TSI_INVALID_ARGUMENT;
   }
   alts_frame_protector* impl = reinterpret_cast<alts_frame_protector*>(self);
@@ -111,7 +111,7 @@ static tsi_result alts_protect_flush(tsi_frame_protector* self,
     }
     if (!alts_reset_frame_writer(impl->writer, impl->in_place_protect_buffer,
                                  impl->in_place_protect_bytes_buffered)) {
-      LOG(ERROR) << "Couldn't reset frame writer.";
+      ABSL_LOG(ERROR) << "Couldn't reset frame writer.";
       return TSI_INTERNAL_ERROR;
     }
   }
@@ -124,7 +124,7 @@ static tsi_result alts_protect_flush(tsi_frame_protector* self,
   size_t written_frame_bytes = *protected_output_frames_size;
   if (!alts_write_frame_bytes(impl->writer, protected_output_frames,
                               &written_frame_bytes)) {
-    LOG(ERROR) << "Couldn't write frame bytes.";
+    ABSL_LOG(ERROR) << "Couldn't write frame bytes.";
     return TSI_INTERNAL_ERROR;
   }
   *protected_output_frames_size = written_frame_bytes;
@@ -147,7 +147,7 @@ static tsi_result alts_protect(tsi_frame_protector* self,
   if (self == nullptr || unprotected_bytes == nullptr ||
       unprotected_bytes_size == nullptr || protected_output_frames == nullptr ||
       protected_output_frames_size == nullptr) {
-    LOG(ERROR) << "Invalid nullptr arguments to alts_protect().";
+    ABSL_LOG(ERROR) << "Invalid nullptr arguments to alts_protect().";
     return TSI_INVALID_ARGUMENT;
   }
   alts_frame_protector* impl = reinterpret_cast<alts_frame_protector*>(self);
@@ -200,7 +200,7 @@ static tsi_result unseal(alts_frame_protector* impl) {
       impl->max_unprotected_frame_size,
       alts_get_output_bytes_read(impl->reader), &output_size, &error_details);
   if (status != GRPC_STATUS_OK) {
-    LOG(ERROR) << error_details;
+    ABSL_LOG(ERROR) << error_details;
     gpr_free(error_details);
     return TSI_DATA_CORRUPTED;
   }
@@ -239,7 +239,7 @@ static tsi_result alts_unprotect(tsi_frame_protector* self,
   if (self == nullptr || protected_frames_bytes == nullptr ||
       protected_frames_bytes_size == nullptr || unprotected_bytes == nullptr ||
       unprotected_bytes_size == nullptr) {
-    LOG(ERROR) << "Invalid nullptr arguments to alts_unprotect().";
+    ABSL_LOG(ERROR) << "Invalid nullptr arguments to alts_unprotect().";
     return TSI_INVALID_ARGUMENT;
   }
   alts_frame_protector* impl = reinterpret_cast<alts_frame_protector*>(self);
@@ -254,7 +254,7 @@ static tsi_result alts_unprotect(tsi_frame_protector* self,
         impl->in_place_unprotect_bytes_processed + impl->overhead_length))) {
     if (!alts_reset_frame_reader(impl->reader,
                                  impl->in_place_unprotect_buffer)) {
-      LOG(ERROR) << "Couldn't reset frame reader.";
+      ABSL_LOG(ERROR) << "Couldn't reset frame reader.";
       return TSI_INTERNAL_ERROR;
     }
     impl->in_place_unprotect_bytes_processed = 0;
@@ -274,7 +274,7 @@ static tsi_result alts_unprotect(tsi_frame_protector* self,
     size_t read_frames_bytes_size = *protected_frames_bytes_size;
     if (!alts_read_frame_bytes(impl->reader, protected_frames_bytes,
                                &read_frames_bytes_size)) {
-      LOG(ERROR) << "Failed to process frame.";
+      ABSL_LOG(ERROR) << "Failed to process frame.";
       return TSI_INTERNAL_ERROR;
     }
     *protected_frames_bytes_size = read_frames_bytes_size;
@@ -368,7 +368,7 @@ tsi_result alts_create_frame_protector(const uint8_t* key, size_t key_size,
                                        size_t* max_protected_frame_size,
                                        tsi_frame_protector** self) {
   if (key == nullptr || self == nullptr) {
-    LOG(ERROR) << "Invalid nullptr arguments to alts_create_frame_protector().";
+    ABSL_LOG(ERROR) << "Invalid nullptr arguments to alts_create_frame_protector().";
     return TSI_INTERNAL_ERROR;
   }
   char* error_details = nullptr;
@@ -376,7 +376,7 @@ tsi_result alts_create_frame_protector(const uint8_t* key, size_t key_size,
   grpc_status_code status = create_alts_crypters(
       key, key_size, is_client, is_rekey, impl, &error_details);
   if (status != GRPC_STATUS_OK) {
-    LOG(ERROR) << "Failed to create ALTS crypters, " << error_details;
+    ABSL_LOG(ERROR) << "Failed to create ALTS crypters, " << error_details;
     gpr_free(error_details);
     gpr_free(impl);
     return TSI_INTERNAL_ERROR;
diff --git a/third_party/grpc/source/src/core/tsi/alts/frame_protector/frame_handler.cc b/third_party/grpc/source/src/core/tsi/alts/frame_protector/frame_handler.cc
index 7fcbcce34bb90..452dbc6428986 100644
--- a/third_party/grpc/source/src/core/tsi/alts/frame_protector/frame_handler.cc
+++ b/third_party/grpc/source/src/core/tsi/alts/frame_protector/frame_handler.cc
@@ -26,7 +26,7 @@

 #include <algorithm>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/util/crash.h"
 #include "src/core/util/memory.h"

@@ -56,7 +56,7 @@ bool alts_reset_frame_writer(alts_frame_writer* writer,
   if (buffer == nullptr) return false;
   size_t max_input_size = SIZE_MAX - kFrameLengthFieldSize;
   if (length > max_input_size) {
-    LOG(ERROR) << "length must be at most " << max_input_size;
+    ABSL_LOG(ERROR) << "length must be at most " << max_input_size;
     return false;
   }
   writer->input_buffer = buffer;
@@ -180,7 +180,7 @@ bool alts_read_frame_bytes(alts_frame_reader* reader,
     size_t frame_length = load_32_le(reader->header_buffer);
     if (frame_length < kFrameMessageTypeFieldSize ||
         frame_length > kFrameMaxSize) {
-      LOG(ERROR) << "Bad frame length (should be at least "
+      ABSL_LOG(ERROR) << "Bad frame length (should be at least "
                  << kFrameMessageTypeFieldSize << ", and at most "
                  << kFrameMaxSize << ")";
       *bytes_size = 0;
@@ -189,7 +189,7 @@ bool alts_read_frame_bytes(alts_frame_reader* reader,
     size_t message_type =
         load_32_le(reader->header_buffer + kFrameLengthFieldSize);
     if (message_type != kFrameMessageType) {
-      LOG(ERROR) << "Unsupported message type " << message_type
+      ABSL_LOG(ERROR) << "Unsupported message type " << message_type
                  << " (should be " << kFrameMessageType << ")";
       *bytes_size = 0;
       return false;
diff --git a/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_handshaker_client.cc b/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_handshaker_client.cc
index bf74e0d297d86..bd4b953a430a5 100644
--- a/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_handshaker_client.cc
+++ b/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_handshaker_client.cc
@@ -24,8 +24,8 @@

 #include <list>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/numbers.h"
 #include "src/core/lib/slice/slice_internal.h"
 #include "src/core/lib/surface/call.h"
@@ -117,13 +117,13 @@ typedef struct alts_grpc_handshaker_client {

 static void handshaker_client_send_buffer_destroy(
     alts_grpc_handshaker_client* client) {
-  CHECK_NE(client, nullptr);
+  ABSL_CHECK_NE(client, nullptr);
   grpc_byte_buffer_destroy(client->send_buffer);
   client->send_buffer = nullptr;
 }

 static bool is_handshake_finished_properly(grpc_gcp_HandshakerResp* resp) {
-  CHECK_NE(resp, nullptr);
+  ABSL_CHECK_NE(resp, nullptr);
   return grpc_gcp_HandshakerResp_result(resp) != nullptr;
 }

@@ -156,7 +156,7 @@ static void maybe_complete_tsi_next(
     grpc_core::MutexLock lock(&client->mu);
     client->receive_status_finished |= receive_status_finished;
     if (pending_recv_message_result != nullptr) {
-      CHECK_EQ(client->pending_recv_message_result, nullptr);
+      ABSL_CHECK_EQ(client->pending_recv_message_result, nullptr);
       client->pending_recv_message_result = pending_recv_message_result;
     }
     if (client->pending_recv_message_result == nullptr) {
@@ -197,19 +197,19 @@ static void handle_response_done(alts_grpc_handshaker_client* client,

 void alts_handshaker_client_handle_response(alts_handshaker_client* c,
                                             bool is_ok) {
-  CHECK_NE(c, nullptr);
+  ABSL_CHECK_NE(c, nullptr);
   alts_grpc_handshaker_client* client =
       reinterpret_cast<alts_grpc_handshaker_client*>(c);
   grpc_byte_buffer* recv_buffer = client->recv_buffer;
   alts_tsi_handshaker* handshaker = client->handshaker;
   // Invalid input check.
   if (client->cb == nullptr) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "client->cb is nullptr in alts_tsi_handshaker_handle_response()";
     return;
   }
   if (handshaker == nullptr) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "handshaker is nullptr in alts_tsi_handshaker_handle_response()";
     handle_response_done(
         client, TSI_INTERNAL_ERROR,
@@ -219,21 +219,21 @@ void alts_handshaker_client_handle_response(alts_handshaker_client* c,
   }
   // TSI handshake has been shutdown.
   if (alts_tsi_handshaker_has_shutdown(handshaker)) {
-    VLOG(2) << "TSI handshake shutdown";
+    ABSL_VLOG(2) << "TSI handshake shutdown";
     handle_response_done(client, TSI_HANDSHAKE_SHUTDOWN,
                          "TSI handshake shutdown", nullptr, 0, nullptr);
     return;
   }
   // Check for failed grpc read.
   if (!is_ok || client->inject_read_failure) {
-    VLOG(2) << "read failed on grpc call to handshaker service";
+    ABSL_VLOG(2) << "read failed on grpc call to handshaker service";
     handle_response_done(client, TSI_INTERNAL_ERROR,
                          "read failed on grpc call to handshaker service",
                          nullptr, 0, nullptr);
     return;
   }
   if (recv_buffer == nullptr) {
-    VLOG(2)
+    ABSL_VLOG(2)
         << "recv_buffer is nullptr in alts_tsi_handshaker_handle_response()";
     handle_response_done(
         client, TSI_INTERNAL_ERROR,
@@ -248,7 +248,7 @@ void alts_handshaker_client_handle_response(alts_handshaker_client* c,
   client->recv_buffer = nullptr;
   // Invalid handshaker response check.
   if (resp == nullptr) {
-    LOG(ERROR) << "alts_tsi_utils_deserialize_response() failed";
+    ABSL_LOG(ERROR) << "alts_tsi_utils_deserialize_response() failed";
     handle_response_done(client, TSI_DATA_CORRUPTED,
                          "alts_tsi_utils_deserialize_response() failed",
                          nullptr, 0, nullptr);
@@ -257,7 +257,7 @@ void alts_handshaker_client_handle_response(alts_handshaker_client* c,
   const grpc_gcp_HandshakerStatus* resp_status =
       grpc_gcp_HandshakerResp_status(resp);
   if (resp_status == nullptr) {
-    LOG(ERROR) << "No status in HandshakerResp";
+    ABSL_LOG(ERROR) << "No status in HandshakerResp";
     handle_response_done(client, TSI_DATA_CORRUPTED,
                          "No status in HandshakerResp", nullptr, 0, nullptr);
     return;
@@ -280,7 +280,7 @@ void alts_handshaker_client_handle_response(alts_handshaker_client* c,
     tsi_result status =
         alts_tsi_handshaker_result_create(resp, client->is_client, &result);
     if (status != TSI_OK) {
-      LOG(ERROR) << "alts_tsi_handshaker_result_create() failed";
+      ABSL_LOG(ERROR) << "alts_tsi_handshaker_result_create() failed";
       handle_response_done(client, status,
                            "alts_tsi_handshaker_result_create() failed",
                            nullptr, 0, nullptr);
@@ -298,7 +298,7 @@ void alts_handshaker_client_handle_response(alts_handshaker_client* c,
     if (details.size > 0) {
       error = absl::StrCat("Status ", code, " from handshaker service: ",
                            absl::string_view(details.data, details.size));
-      LOG_EVERY_N_SEC(INFO, 1) << error;
+      ABSL_LOG_EVERY_N_SEC(INFO, 1) << error;
     }
   }
   // TODO(apolcyn): consider short ciruiting handle_response_done and
@@ -312,7 +312,7 @@ void alts_handshaker_client_handle_response(alts_handshaker_client* c,

 static tsi_result continue_make_grpc_call(alts_grpc_handshaker_client* client,
                                           bool is_start) {
-  CHECK_NE(client, nullptr);
+  ABSL_CHECK_NE(client, nullptr);
   grpc_op ops[kHandshakerClientOpNum];
   memset(ops, 0, sizeof(ops));
   grpc_op* op = ops;
@@ -325,38 +325,38 @@ static tsi_result continue_make_grpc_call(alts_grpc_handshaker_client* client,
     op->flags = 0;
     op->reserved = nullptr;
     op++;
-    CHECK(op - ops <= kHandshakerClientOpNum);
+    ABSL_CHECK(op - ops <= kHandshakerClientOpNum);
     gpr_ref(&client->refs);
     grpc_call_error call_error =
         client->grpc_caller(client->call, ops, static_cast<size_t>(op - ops),
                             &client->on_status_received);
     // TODO(apolcyn): return the error here instead, as done for other ops?
-    CHECK_EQ(call_error, GRPC_CALL_OK);
+    ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
     memset(ops, 0, sizeof(ops));
     op = ops;
     op->op = GRPC_OP_SEND_INITIAL_METADATA;
     op->data.send_initial_metadata.count = 0;
     op++;
-    CHECK(op - ops <= kHandshakerClientOpNum);
+    ABSL_CHECK(op - ops <= kHandshakerClientOpNum);
     op->op = GRPC_OP_RECV_INITIAL_METADATA;
     op->data.recv_initial_metadata.recv_initial_metadata =
         &client->recv_initial_metadata;
     op++;
-    CHECK(op - ops <= kHandshakerClientOpNum);
+    ABSL_CHECK(op - ops <= kHandshakerClientOpNum);
   }
   op->op = GRPC_OP_SEND_MESSAGE;
   op->data.send_message.send_message = client->send_buffer;
   op++;
-  CHECK(op - ops <= kHandshakerClientOpNum);
+  ABSL_CHECK(op - ops <= kHandshakerClientOpNum);
   op->op = GRPC_OP_RECV_MESSAGE;
   op->data.recv_message.recv_message = &client->recv_buffer;
   op++;
-  CHECK(op - ops <= kHandshakerClientOpNum);
-  CHECK_NE(client->grpc_caller, nullptr);
+  ABSL_CHECK(op - ops <= kHandshakerClientOpNum);
+  ABSL_CHECK_NE(client->grpc_caller, nullptr);
   if (client->grpc_caller(client->call, ops, static_cast<size_t>(op - ops),
                           &client->on_handshaker_service_resp_recv) !=
       GRPC_CALL_OK) {
-    LOG(ERROR) << "Start batch operation failed";
+    ABSL_LOG(ERROR) << "Start batch operation failed";
     return TSI_INTERNAL_ERROR;
   }
   return TSI_OK;
@@ -450,7 +450,7 @@ void HandshakeDone(bool is_client) {
 /// make a grpc call.
 ///
 static tsi_result make_grpc_call(alts_handshaker_client* c, bool is_start) {
-  CHECK_NE(c, nullptr);
+  ABSL_CHECK_NE(c, nullptr);
   alts_grpc_handshaker_client* client =
       reinterpret_cast<alts_grpc_handshaker_client*>(c);
   if (is_start) {
@@ -469,7 +469,7 @@ static void on_status_received(void* arg, grpc_error_handle error) {
     // status from the final ALTS message with the status here.
     char* status_details =
         grpc_slice_to_c_string(client->handshake_status_details);
-    VLOG(2) << "alts_grpc_handshaker_client:" << client
+    ABSL_VLOG(2) << "alts_grpc_handshaker_client:" << client
             << " on_status_received status:" << client->handshake_status_code
             << " details:|" << status_details << "| error:|"
             << grpc_core::StatusToString(error) << "|";
@@ -499,7 +499,7 @@ static grpc_byte_buffer* get_serialized_handshaker_req(
 // Create and populate a client_start handshaker request, then serialize it.
 static grpc_byte_buffer* get_serialized_start_client(
     alts_handshaker_client* c) {
-  CHECK_NE(c, nullptr);
+  ABSL_CHECK_NE(c, nullptr);
   alts_grpc_handshaker_client* client =
       reinterpret_cast<alts_grpc_handshaker_client*>(c);
   upb::Arena arena;
@@ -542,21 +542,21 @@ static grpc_byte_buffer* get_serialized_start_client(

 static tsi_result handshaker_client_start_client(alts_handshaker_client* c) {
   if (c == nullptr) {
-    LOG(ERROR) << "client is nullptr in handshaker_client_start_client()";
+    ABSL_LOG(ERROR) << "client is nullptr in handshaker_client_start_client()";
     return TSI_INVALID_ARGUMENT;
   }
   grpc_byte_buffer* buffer = get_serialized_start_client(c);
   alts_grpc_handshaker_client* client =
       reinterpret_cast<alts_grpc_handshaker_client*>(c);
   if (buffer == nullptr) {
-    LOG(ERROR) << "get_serialized_start_client() failed";
+    ABSL_LOG(ERROR) << "get_serialized_start_client() failed";
     return TSI_INTERNAL_ERROR;
   }
   handshaker_client_send_buffer_destroy(client);
   client->send_buffer = buffer;
   tsi_result result = make_grpc_call(&client->base, true /* is_start */);
   if (result != TSI_OK) {
-    LOG(ERROR) << "make_grpc_call() failed";
+    ABSL_LOG(ERROR) << "make_grpc_call() failed";
   }
   return result;
 }
@@ -564,8 +564,8 @@ static tsi_result handshaker_client_start_client(alts_handshaker_client* c) {
 // Create and populate a start_server handshaker request, then serialize it.
 static grpc_byte_buffer* get_serialized_start_server(
     alts_handshaker_client* c, grpc_slice* bytes_received) {
-  CHECK_NE(c, nullptr);
-  CHECK_NE(bytes_received, nullptr);
+  ABSL_CHECK_NE(c, nullptr);
+  ABSL_CHECK_NE(bytes_received, nullptr);
   alts_grpc_handshaker_client* client =
       reinterpret_cast<alts_grpc_handshaker_client*>(c);

@@ -601,28 +601,28 @@ static grpc_byte_buffer* get_serialized_start_server(
 static tsi_result handshaker_client_start_server(alts_handshaker_client* c,
                                                  grpc_slice* bytes_received) {
   if (c == nullptr || bytes_received == nullptr) {
-    LOG(ERROR) << "Invalid arguments to handshaker_client_start_server()";
+    ABSL_LOG(ERROR) << "Invalid arguments to handshaker_client_start_server()";
     return TSI_INVALID_ARGUMENT;
   }
   alts_grpc_handshaker_client* client =
       reinterpret_cast<alts_grpc_handshaker_client*>(c);
   grpc_byte_buffer* buffer = get_serialized_start_server(c, bytes_received);
   if (buffer == nullptr) {
-    LOG(ERROR) << "get_serialized_start_server() failed";
+    ABSL_LOG(ERROR) << "get_serialized_start_server() failed";
     return TSI_INTERNAL_ERROR;
   }
   handshaker_client_send_buffer_destroy(client);
   client->send_buffer = buffer;
   tsi_result result = make_grpc_call(&client->base, true /* is_start */);
   if (result != TSI_OK) {
-    LOG(ERROR) << "make_grpc_call() failed";
+    ABSL_LOG(ERROR) << "make_grpc_call() failed";
   }
   return result;
 }

 // Create and populate a next handshaker request, then serialize it.
 static grpc_byte_buffer* get_serialized_next(grpc_slice* bytes_received) {
-  CHECK_NE(bytes_received, nullptr);
+  ABSL_CHECK_NE(bytes_received, nullptr);
   upb::Arena arena;
   grpc_gcp_HandshakerReq* req = grpc_gcp_HandshakerReq_new(arena.ptr());
   grpc_gcp_NextHandshakeMessageReq* next =
@@ -638,7 +638,7 @@ static grpc_byte_buffer* get_serialized_next(grpc_slice* bytes_received) {
 static tsi_result handshaker_client_next(alts_handshaker_client* c,
                                          grpc_slice* bytes_received) {
   if (c == nullptr || bytes_received == nullptr) {
-    LOG(ERROR) << "Invalid arguments to handshaker_client_next()";
+    ABSL_LOG(ERROR) << "Invalid arguments to handshaker_client_next()";
     return TSI_INVALID_ARGUMENT;
   }
   alts_grpc_handshaker_client* client =
@@ -647,20 +647,20 @@ static tsi_result handshaker_client_next(alts_handshaker_client* c,
   client->recv_bytes = grpc_core::CSliceRef(*bytes_received);
   grpc_byte_buffer* buffer = get_serialized_next(bytes_received);
   if (buffer == nullptr) {
-    LOG(ERROR) << "get_serialized_next() failed";
+    ABSL_LOG(ERROR) << "get_serialized_next() failed";
     return TSI_INTERNAL_ERROR;
   }
   handshaker_client_send_buffer_destroy(client);
   client->send_buffer = buffer;
   tsi_result result = make_grpc_call(&client->base, false /* is_start */);
   if (result != TSI_OK) {
-    LOG(ERROR) << "make_grpc_call() failed";
+    ABSL_LOG(ERROR) << "make_grpc_call() failed";
   }
   return result;
 }

 static void handshaker_client_shutdown(alts_handshaker_client* c) {
-  CHECK_NE(c, nullptr);
+  ABSL_CHECK_NE(c, nullptr);
   alts_grpc_handshaker_client* client =
       reinterpret_cast<alts_grpc_handshaker_client*>(c);
   if (client->call != nullptr) {
@@ -714,7 +714,7 @@ alts_handshaker_client* alts_grpc_handshaker_client_create(
     void* user_data, alts_handshaker_client_vtable* vtable_for_testing,
     bool is_client, size_t max_frame_size, std::string* error) {
   if (channel == nullptr || handshaker_service_url == nullptr) {
-    LOG(ERROR) << "Invalid arguments to alts_handshaker_client_create()";
+    ABSL_LOG(ERROR) << "Invalid arguments to alts_handshaker_client_create()";
     return nullptr;
   }
   alts_grpc_handshaker_client* client = new alts_grpc_handshaker_client();
@@ -758,8 +758,8 @@ namespace internal {

 void alts_handshaker_client_set_grpc_caller_for_testing(
     alts_handshaker_client* c, alts_grpc_caller caller) {
-  CHECK(c != nullptr);
-  CHECK_NE(caller, nullptr);
+  ABSL_CHECK(c != nullptr);
+  ABSL_CHECK_NE(caller, nullptr);
   alts_grpc_handshaker_client* client =
       reinterpret_cast<alts_grpc_handshaker_client*>(c);
   client->grpc_caller = caller;
@@ -767,7 +767,7 @@ void alts_handshaker_client_set_grpc_caller_for_testing(

 grpc_byte_buffer* alts_handshaker_client_get_send_buffer_for_testing(
     alts_handshaker_client* c) {
-  CHECK_NE(c, nullptr);
+  ABSL_CHECK_NE(c, nullptr);
   alts_grpc_handshaker_client* client =
       reinterpret_cast<alts_grpc_handshaker_client*>(c);
   return client->send_buffer;
@@ -775,7 +775,7 @@ grpc_byte_buffer* alts_handshaker_client_get_send_buffer_for_testing(

 grpc_byte_buffer** alts_handshaker_client_get_recv_buffer_addr_for_testing(
     alts_handshaker_client* c) {
-  CHECK_NE(c, nullptr);
+  ABSL_CHECK_NE(c, nullptr);
   alts_grpc_handshaker_client* client =
       reinterpret_cast<alts_grpc_handshaker_client*>(c);
   return &client->recv_buffer;
@@ -783,7 +783,7 @@ grpc_byte_buffer** alts_handshaker_client_get_recv_buffer_addr_for_testing(

 grpc_metadata_array* alts_handshaker_client_get_initial_metadata_for_testing(
     alts_handshaker_client* c) {
-  CHECK_NE(c, nullptr);
+  ABSL_CHECK_NE(c, nullptr);
   alts_grpc_handshaker_client* client =
       reinterpret_cast<alts_grpc_handshaker_client*>(c);
   return &client->recv_initial_metadata;
@@ -791,7 +791,7 @@ grpc_metadata_array* alts_handshaker_client_get_initial_metadata_for_testing(

 void alts_handshaker_client_set_recv_bytes_for_testing(
     alts_handshaker_client* c, grpc_slice* recv_bytes) {
-  CHECK_NE(c, nullptr);
+  ABSL_CHECK_NE(c, nullptr);
   alts_grpc_handshaker_client* client =
       reinterpret_cast<alts_grpc_handshaker_client*>(c);
   client->recv_bytes = CSliceRef(*recv_bytes);
@@ -801,7 +801,7 @@ void alts_handshaker_client_set_fields_for_testing(
     alts_handshaker_client* c, alts_tsi_handshaker* handshaker,
     tsi_handshaker_on_next_done_cb cb, void* user_data,
     grpc_byte_buffer* recv_buffer, bool inject_read_failure) {
-  CHECK_NE(c, nullptr);
+  ABSL_CHECK_NE(c, nullptr);
   alts_grpc_handshaker_client* client =
       reinterpret_cast<alts_grpc_handshaker_client*>(c);
   client->handshaker = handshaker;
@@ -814,22 +814,22 @@ void alts_handshaker_client_set_fields_for_testing(
 void alts_handshaker_client_check_fields_for_testing(
     alts_handshaker_client* c, tsi_handshaker_on_next_done_cb cb,
     void* user_data, bool has_sent_start_message, grpc_slice* recv_bytes) {
-  CHECK_NE(c, nullptr);
+  ABSL_CHECK_NE(c, nullptr);
   alts_grpc_handshaker_client* client =
       reinterpret_cast<alts_grpc_handshaker_client*>(c);
-  CHECK(client->cb == cb);
-  CHECK(client->user_data == user_data);
+  ABSL_CHECK(client->cb == cb);
+  ABSL_CHECK(client->user_data == user_data);
   if (recv_bytes != nullptr) {
-    CHECK_EQ(grpc_slice_cmp(client->recv_bytes, *recv_bytes), 0);
+    ABSL_CHECK_EQ(grpc_slice_cmp(client->recv_bytes, *recv_bytes), 0);
   }
-  CHECK(alts_tsi_handshaker_get_has_sent_start_message_for_testing(
+  ABSL_CHECK(alts_tsi_handshaker_get_has_sent_start_message_for_testing(
             client->handshaker) == has_sent_start_message);
 }

 void alts_handshaker_client_set_vtable_for_testing(
     alts_handshaker_client* c, alts_handshaker_client_vtable* vtable) {
-  CHECK_NE(c, nullptr);
-  CHECK_NE(vtable, nullptr);
+  ABSL_CHECK_NE(c, nullptr);
+  ABSL_CHECK_NE(vtable, nullptr);
   alts_grpc_handshaker_client* client =
       reinterpret_cast<alts_grpc_handshaker_client*>(c);
   client->base.vtable = vtable;
@@ -837,7 +837,7 @@ void alts_handshaker_client_set_vtable_for_testing(

 alts_tsi_handshaker* alts_handshaker_client_get_handshaker_for_testing(
     alts_handshaker_client* c) {
-  CHECK_NE(c, nullptr);
+  ABSL_CHECK_NE(c, nullptr);
   alts_grpc_handshaker_client* client =
       reinterpret_cast<alts_grpc_handshaker_client*>(c);
   return client->handshaker;
@@ -845,7 +845,7 @@ alts_tsi_handshaker* alts_handshaker_client_get_handshaker_for_testing(

 void alts_handshaker_client_set_cb_for_testing(
     alts_handshaker_client* c, tsi_handshaker_on_next_done_cb cb) {
-  CHECK_NE(c, nullptr);
+  ABSL_CHECK_NE(c, nullptr);
   alts_grpc_handshaker_client* client =
       reinterpret_cast<alts_grpc_handshaker_client*>(c);
   client->cb = cb;
@@ -853,7 +853,7 @@ void alts_handshaker_client_set_cb_for_testing(

 grpc_closure* alts_handshaker_client_get_closure_for_testing(
     alts_handshaker_client* c) {
-  CHECK_NE(c, nullptr);
+  ABSL_CHECK_NE(c, nullptr);
   alts_grpc_handshaker_client* client =
       reinterpret_cast<alts_grpc_handshaker_client*>(c);
   return &client->on_handshaker_service_resp_recv;
@@ -889,7 +889,7 @@ tsi_result alts_handshaker_client_start_client(alts_handshaker_client* client) {
       client->vtable->client_start != nullptr) {
     return client->vtable->client_start(client);
   }
-  LOG(ERROR) << "client or client->vtable has not been initialized properly";
+  ABSL_LOG(ERROR) << "client or client->vtable has not been initialized properly";
   return TSI_INVALID_ARGUMENT;
 }

@@ -899,7 +899,7 @@ tsi_result alts_handshaker_client_start_server(alts_handshaker_client* client,
       client->vtable->server_start != nullptr) {
     return client->vtable->server_start(client, bytes_received);
   }
-  LOG(ERROR) << "client or client->vtable has not been initialized properly";
+  ABSL_LOG(ERROR) << "client or client->vtable has not been initialized properly";
   return TSI_INVALID_ARGUMENT;
 }

@@ -909,7 +909,7 @@ tsi_result alts_handshaker_client_next(alts_handshaker_client* client,
       client->vtable->next != nullptr) {
     return client->vtable->next(client, bytes_received);
   }
-  LOG(ERROR) << "client or client->vtable has not been initialized properly";
+  ABSL_LOG(ERROR) << "client or client->vtable has not been initialized properly";
   return TSI_INVALID_ARGUMENT;
 }

diff --git a/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_shared_resource.cc b/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_shared_resource.cc
index ec1fe8129632f..cd84083c3ca94 100644
--- a/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_shared_resource.cc
+++ b/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_shared_resource.cc
@@ -20,7 +20,7 @@

 #include <grpc/support/port_platform.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/channel/channel_args.h"
 #include "src/core/tsi/alts/handshaker/alts_handshaker_client.h"
 #include "src/core/util/crash.h"
@@ -36,11 +36,11 @@ static void thread_worker(void* /*arg*/) {
     grpc_event event =
         grpc_completion_queue_next(g_alts_resource_dedicated.cq,
                                    gpr_inf_future(GPR_CLOCK_REALTIME), nullptr);
-    CHECK(event.type != GRPC_QUEUE_TIMEOUT);
+    ABSL_CHECK(event.type != GRPC_QUEUE_TIMEOUT);
     if (event.type == GRPC_QUEUE_SHUTDOWN) {
       break;
     }
-    CHECK(event.type == GRPC_OP_COMPLETE);
+    ABSL_CHECK(event.type == GRPC_OP_COMPLETE);
     alts_handshaker_client* client =
         static_cast<alts_handshaker_client*>(event.tag);
     alts_handshaker_client_handle_response(client, event.success);
diff --git a/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_tsi_handshaker.cc b/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_tsi_handshaker.cc
index b42f9994e72e5..e930b4dac9e44 100644
--- a/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_tsi_handshaker.cc
+++ b/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_tsi_handshaker.cc
@@ -29,8 +29,8 @@
 #include <stdlib.h>
 #include <string.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/iomgr/closure.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
 #include "src/core/lib/surface/channel.h"
@@ -85,68 +85,68 @@ typedef struct alts_tsi_handshaker_result {
 static tsi_result handshaker_result_extract_peer(
     const tsi_handshaker_result* self, tsi_peer* peer) {
   if (self == nullptr || peer == nullptr) {
-    LOG(ERROR) << "Invalid argument to handshaker_result_extract_peer()";
+    ABSL_LOG(ERROR) << "Invalid argument to handshaker_result_extract_peer()";
     return TSI_INVALID_ARGUMENT;
   }
   alts_tsi_handshaker_result* result =
       reinterpret_cast<alts_tsi_handshaker_result*>(
           const_cast<tsi_handshaker_result*>(self));
-  CHECK_EQ(kTsiAltsNumOfPeerProperties, 5u);
+  ABSL_CHECK_EQ(kTsiAltsNumOfPeerProperties, 5u);
   tsi_result ok = tsi_construct_peer(kTsiAltsNumOfPeerProperties, peer);
   int index = 0;
   if (ok != TSI_OK) {
-    LOG(ERROR) << "Failed to construct tsi peer";
+    ABSL_LOG(ERROR) << "Failed to construct tsi peer";
     return ok;
   }
-  CHECK_NE(&peer->properties[index], nullptr);
+  ABSL_CHECK_NE(&peer->properties[index], nullptr);
   ok = tsi_construct_string_peer_property_from_cstring(
       TSI_CERTIFICATE_TYPE_PEER_PROPERTY, TSI_ALTS_CERTIFICATE_TYPE,
       &peer->properties[index]);
   if (ok != TSI_OK) {
     tsi_peer_destruct(peer);
-    LOG(ERROR) << "Failed to set tsi peer property";
+    ABSL_LOG(ERROR) << "Failed to set tsi peer property";
     return ok;
   }
   index++;
-  CHECK_NE(&peer->properties[index], nullptr);
+  ABSL_CHECK_NE(&peer->properties[index], nullptr);
   ok = tsi_construct_string_peer_property_from_cstring(
       TSI_ALTS_SERVICE_ACCOUNT_PEER_PROPERTY, result->peer_identity,
       &peer->properties[index]);
   if (ok != TSI_OK) {
     tsi_peer_destruct(peer);
-    LOG(ERROR) << "Failed to set tsi peer property";
+    ABSL_LOG(ERROR) << "Failed to set tsi peer property";
   }
   index++;
-  CHECK_NE(&peer->properties[index], nullptr);
+  ABSL_CHECK_NE(&peer->properties[index], nullptr);
   ok = tsi_construct_string_peer_property(
       TSI_ALTS_RPC_VERSIONS,
       reinterpret_cast<char*>(GRPC_SLICE_START_PTR(result->rpc_versions)),
       GRPC_SLICE_LENGTH(result->rpc_versions), &peer->properties[index]);
   if (ok != TSI_OK) {
     tsi_peer_destruct(peer);
-    LOG(ERROR) << "Failed to set tsi peer property";
+    ABSL_LOG(ERROR) << "Failed to set tsi peer property";
   }
   index++;
-  CHECK_NE(&peer->properties[index], nullptr);
+  ABSL_CHECK_NE(&peer->properties[index], nullptr);
   ok = tsi_construct_string_peer_property(
       TSI_ALTS_CONTEXT,
       reinterpret_cast<char*>(GRPC_SLICE_START_PTR(result->serialized_context)),
       GRPC_SLICE_LENGTH(result->serialized_context), &peer->properties[index]);
   if (ok != TSI_OK) {
     tsi_peer_destruct(peer);
-    LOG(ERROR) << "Failed to set tsi peer property";
+    ABSL_LOG(ERROR) << "Failed to set tsi peer property";
   }
   index++;
-  CHECK_NE(&peer->properties[index], nullptr);
+  ABSL_CHECK_NE(&peer->properties[index], nullptr);
   ok = tsi_construct_string_peer_property_from_cstring(
       TSI_SECURITY_LEVEL_PEER_PROPERTY,
       tsi_security_level_to_string(TSI_PRIVACY_AND_INTEGRITY),
       &peer->properties[index]);
   if (ok != TSI_OK) {
     tsi_peer_destruct(peer);
-    LOG(ERROR) << "Failed to set tsi peer property";
+    ABSL_LOG(ERROR) << "Failed to set tsi peer property";
   }
-  CHECK(++index == kTsiAltsNumOfPeerProperties);
+  ABSL_CHECK(++index == kTsiAltsNumOfPeerProperties);
   return ok;
 }

@@ -161,7 +161,7 @@ static tsi_result handshaker_result_create_zero_copy_grpc_protector(
     const tsi_handshaker_result* self, size_t* max_output_protected_frame_size,
     tsi_zero_copy_grpc_protector** protector) {
   if (self == nullptr || protector == nullptr) {
-    LOG(ERROR) << "Invalid arguments to create_zero_copy_grpc_protector()";
+    ABSL_LOG(ERROR) << "Invalid arguments to create_zero_copy_grpc_protector()";
     return TSI_INVALID_ARGUMENT;
   }
   alts_tsi_handshaker_result* result =
@@ -183,7 +183,7 @@ static tsi_result handshaker_result_create_zero_copy_grpc_protector(
     max_frame_size = std::max<size_t>(max_frame_size, kTsiAltsMinFrameSize);
   }
   max_output_protected_frame_size = &max_frame_size;
-  VLOG(2) << "After Frame Size Negotiation, maximum frame size used by frame "
+  ABSL_VLOG(2) << "After Frame Size Negotiation, maximum frame size used by frame "
              "protector equals "
           << *max_output_protected_frame_size;
   tsi_result ok = alts_zero_copy_grpc_protector_create(
@@ -194,7 +194,7 @@ static tsi_result handshaker_result_create_zero_copy_grpc_protector(
       /*is_integrity_only=*/false, /*enable_extra_copy=*/false,
       max_output_protected_frame_size, protector);
   if (ok != TSI_OK) {
-    LOG(ERROR) << "Failed to create zero-copy grpc protector";
+    ABSL_LOG(ERROR) << "Failed to create zero-copy grpc protector";
   }
   return ok;
 }
@@ -203,7 +203,7 @@ static tsi_result handshaker_result_create_frame_protector(
     const tsi_handshaker_result* self, size_t* max_output_protected_frame_size,
     tsi_frame_protector** protector) {
   if (self == nullptr || protector == nullptr) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "Invalid arguments to handshaker_result_create_frame_protector()";
     return TSI_INVALID_ARGUMENT;
   }
@@ -215,7 +215,7 @@ static tsi_result handshaker_result_create_frame_protector(
       kAltsAes128GcmRekeyKeyLength, result->is_client, /*is_rekey=*/true,
       max_output_protected_frame_size, protector);
   if (ok != TSI_OK) {
-    LOG(ERROR) << "Failed to create frame protector";
+    ABSL_LOG(ERROR) << "Failed to create frame protector";
   }
   return ok;
 }
@@ -224,7 +224,7 @@ static tsi_result handshaker_result_get_unused_bytes(
     const tsi_handshaker_result* self, const unsigned char** bytes,
     size_t* bytes_size) {
   if (self == nullptr || bytes == nullptr || bytes_size == nullptr) {
-    LOG(ERROR) << "Invalid arguments to handshaker_result_get_unused_bytes()";
+    ABSL_LOG(ERROR) << "Invalid arguments to handshaker_result_get_unused_bytes()";
     return TSI_INVALID_ARGUMENT;
   }
   alts_tsi_handshaker_result* result =
@@ -262,7 +262,7 @@ tsi_result alts_tsi_handshaker_result_create(grpc_gcp_HandshakerResp* resp,
                                              bool is_client,
                                              tsi_handshaker_result** result) {
   if (result == nullptr || resp == nullptr) {
-    LOG(ERROR) << "Invalid arguments to create_handshaker_result()";
+    ABSL_LOG(ERROR) << "Invalid arguments to create_handshaker_result()";
     return TSI_INVALID_ARGUMENT;
   }
   const grpc_gcp_HandshakerResult* hresult =
@@ -270,42 +270,42 @@ tsi_result alts_tsi_handshaker_result_create(grpc_gcp_HandshakerResp* resp,
   const grpc_gcp_Identity* identity =
       grpc_gcp_HandshakerResult_peer_identity(hresult);
   if (identity == nullptr) {
-    LOG(ERROR) << "Invalid identity";
+    ABSL_LOG(ERROR) << "Invalid identity";
     return TSI_FAILED_PRECONDITION;
   }
   upb_StringView peer_service_account =
       grpc_gcp_Identity_service_account(identity);
   if (peer_service_account.size == 0) {
-    LOG(ERROR) << "Invalid peer service account";
+    ABSL_LOG(ERROR) << "Invalid peer service account";
     return TSI_FAILED_PRECONDITION;
   }
   upb_StringView key_data = grpc_gcp_HandshakerResult_key_data(hresult);
   if (key_data.size < kAltsAes128GcmRekeyKeyLength) {
-    LOG(ERROR) << "Bad key length";
+    ABSL_LOG(ERROR) << "Bad key length";
     return TSI_FAILED_PRECONDITION;
   }
   const grpc_gcp_RpcProtocolVersions* peer_rpc_version =
       grpc_gcp_HandshakerResult_peer_rpc_versions(hresult);
   if (peer_rpc_version == nullptr) {
-    LOG(ERROR) << "Peer does not set RPC protocol versions.";
+    ABSL_LOG(ERROR) << "Peer does not set RPC protocol versions.";
     return TSI_FAILED_PRECONDITION;
   }
   upb_StringView application_protocol =
       grpc_gcp_HandshakerResult_application_protocol(hresult);
   if (application_protocol.size == 0) {
-    LOG(ERROR) << "Invalid application protocol";
+    ABSL_LOG(ERROR) << "Invalid application protocol";
     return TSI_FAILED_PRECONDITION;
   }
   upb_StringView record_protocol =
       grpc_gcp_HandshakerResult_record_protocol(hresult);
   if (record_protocol.size == 0) {
-    LOG(ERROR) << "Invalid record protocol";
+    ABSL_LOG(ERROR) << "Invalid record protocol";
     return TSI_FAILED_PRECONDITION;
   }
   const grpc_gcp_Identity* local_identity =
       grpc_gcp_HandshakerResult_local_identity(hresult);
   if (local_identity == nullptr) {
-    LOG(ERROR) << "Invalid local identity";
+    ABSL_LOG(ERROR) << "Invalid local identity";
     return TSI_FAILED_PRECONDITION;
   }
   upb_StringView local_service_account =
@@ -326,7 +326,7 @@ tsi_result alts_tsi_handshaker_result_create(grpc_gcp_HandshakerResp* resp,
   bool serialized = grpc_gcp_rpc_protocol_versions_encode(
       peer_rpc_version, rpc_versions_arena.ptr(), &sresult->rpc_versions);
   if (!serialized) {
-    LOG(ERROR) << "Failed to serialize peer's RPC protocol versions.";
+    ABSL_LOG(ERROR) << "Failed to serialize peer's RPC protocol versions.";
     return TSI_FAILED_PRECONDITION;
   }
   upb::Arena context_arena;
@@ -343,7 +343,7 @@ tsi_result alts_tsi_handshaker_result_create(grpc_gcp_HandshakerResp* resp,
       context, const_cast<grpc_gcp_RpcProtocolVersions*>(peer_rpc_version));
   grpc_gcp_Identity* peer_identity = const_cast<grpc_gcp_Identity*>(identity);
   if (peer_identity == nullptr) {
-    LOG(ERROR) << "Null peer identity in ALTS context.";
+    ABSL_LOG(ERROR) << "Null peer identity in ALTS context.";
     return TSI_FAILED_PRECONDITION;
   }
   if (grpc_gcp_Identity_attributes_size(identity) != 0) {
@@ -367,7 +367,7 @@ tsi_result alts_tsi_handshaker_result_create(grpc_gcp_HandshakerResp* resp,
   char* serialized_ctx = grpc_gcp_AltsContext_serialize(
       context, context_arena.ptr(), &serialized_ctx_length);
   if (serialized_ctx == nullptr) {
-    LOG(ERROR) << "Failed to serialize peer's ALTS context.";
+    ABSL_LOG(ERROR) << "Failed to serialize peer's ALTS context.";
     return TSI_FAILED_PRECONDITION;
   }
   sresult->serialized_context =
@@ -383,12 +383,12 @@ static void on_handshaker_service_resp_recv(void* arg,
                                             grpc_error_handle error) {
   alts_handshaker_client* client = static_cast<alts_handshaker_client*>(arg);
   if (client == nullptr) {
-    LOG(ERROR) << "ALTS handshaker client is nullptr";
+    ABSL_LOG(ERROR) << "ALTS handshaker client is nullptr";
     return;
   }
   bool success = true;
   if (!error.ok()) {
-    VLOG(2) << "ALTS handshaker on_handshaker_service_resp_recv error: "
+    ABSL_VLOG(2) << "ALTS handshaker on_handshaker_service_resp_recv error: "
             << grpc_core::StatusToString(error);
     success = false;
   }
@@ -418,7 +418,7 @@ static tsi_result alts_tsi_handshaker_continue_handshaker_next(
           handshaker->handshaker_service_url);
       handshaker->interested_parties =
           grpc_alts_get_shared_resource_dedicated()->interested_parties;
-      CHECK_NE(handshaker->interested_parties, nullptr);
+      ABSL_CHECK_NE(handshaker->interested_parties, nullptr);
     }
     grpc_iomgr_cb_func grpc_cb = handshaker->channel == nullptr
                                      ? on_handshaker_service_resp_recv_dedicated
@@ -434,16 +434,16 @@ static tsi_result alts_tsi_handshaker_continue_handshaker_next(
         handshaker->client_vtable_for_testing, handshaker->is_client,
         handshaker->max_frame_size, error);
     if (client == nullptr) {
-      LOG(ERROR) << "Failed to create ALTS handshaker client";
+      ABSL_LOG(ERROR) << "Failed to create ALTS handshaker client";
       if (error != nullptr) *error = "Failed to create ALTS handshaker client";
       return TSI_FAILED_PRECONDITION;
     }
     {
       grpc_core::MutexLock lock(&handshaker->mu);
-      CHECK_EQ(handshaker->client, nullptr);
+      ABSL_CHECK_EQ(handshaker->client, nullptr);
       handshaker->client = client;
       if (handshaker->shutdown) {
-        VLOG(2) << "TSI handshake shutdown";
+        ABSL_VLOG(2) << "TSI handshake shutdown";
         if (error != nullptr) *error = "TSI handshaker shutdown";
         return TSI_HANDSHAKE_SHUTDOWN;
       }
@@ -452,7 +452,7 @@ static tsi_result alts_tsi_handshaker_continue_handshaker_next(
   }
   if (handshaker->channel == nullptr &&
       handshaker->client_vtable_for_testing == nullptr) {
-    CHECK(grpc_cq_begin_op(grpc_alts_get_shared_resource_dedicated()->cq,
+    ABSL_CHECK(grpc_cq_begin_op(grpc_alts_get_shared_resource_dedicated()->cq,
                            handshaker->client));
   }
   grpc_slice slice = (received_bytes == nullptr || received_bytes_size == 0)
@@ -495,7 +495,7 @@ static void alts_tsi_handshaker_create_channel(
   alts_tsi_handshaker_continue_handshaker_next_args* next_args =
       static_cast<alts_tsi_handshaker_continue_handshaker_next_args*>(arg);
   alts_tsi_handshaker* handshaker = next_args->handshaker;
-  CHECK_EQ(handshaker->channel, nullptr);
+  ABSL_CHECK_EQ(handshaker->channel, nullptr);
   grpc_channel_credentials* creds = grpc_insecure_credentials_create();
   // Disable retries so that we quickly get a signal when the
   // handshake server is not reachable.
@@ -523,7 +523,7 @@ static tsi_result handshaker_next(
     size_t* /*bytes_to_send_size*/, tsi_handshaker_result** /*result*/,
     tsi_handshaker_on_next_done_cb cb, void* user_data, std::string* error) {
   if (self == nullptr || cb == nullptr) {
-    LOG(ERROR) << "Invalid arguments to handshaker_next()";
+    ABSL_LOG(ERROR) << "Invalid arguments to handshaker_next()";
     if (error != nullptr) *error = "invalid argument";
     return TSI_INVALID_ARGUMENT;
   }
@@ -532,7 +532,7 @@ static tsi_result handshaker_next(
   {
     grpc_core::MutexLock lock(&handshaker->mu);
     if (handshaker->shutdown) {
-      LOG(INFO) << "TSI handshake shutdown";
+      ABSL_LOG(INFO) << "TSI handshake shutdown";
       if (error != nullptr) *error = "handshake shutdown";
       return TSI_HANDSHAKE_SHUTDOWN;
     }
@@ -567,7 +567,7 @@ static tsi_result handshaker_next(
     tsi_result ok = alts_tsi_handshaker_continue_handshaker_next(
         handshaker, received_bytes, received_bytes_size, cb, user_data, error);
     if (ok != TSI_OK) {
-      LOG(ERROR) << "Failed to schedule ALTS handshaker requests";
+      ABSL_LOG(ERROR) << "Failed to schedule ALTS handshaker requests";
       return ok;
     }
   }
@@ -591,7 +591,7 @@ static tsi_result handshaker_next_dedicated(
 }

 static void handshaker_shutdown(tsi_handshaker* self) {
-  CHECK_NE(self, nullptr);
+  ABSL_CHECK_NE(self, nullptr);
   alts_tsi_handshaker* handshaker =
       reinterpret_cast<alts_tsi_handshaker*>(self);
   grpc_core::MutexLock lock(&handshaker->mu);
@@ -637,7 +637,7 @@ static const tsi_handshaker_vtable handshaker_vtable_dedicated = {
     handshaker_shutdown};

 bool alts_tsi_handshaker_has_shutdown(alts_tsi_handshaker* handshaker) {
-  CHECK_NE(handshaker, nullptr);
+  ABSL_CHECK_NE(handshaker, nullptr);
   grpc_core::MutexLock lock(&handshaker->mu);
   return handshaker->shutdown;
 }
@@ -649,7 +649,7 @@ tsi_result alts_tsi_handshaker_create(
     size_t user_specified_max_frame_size) {
   if (handshaker_service_url == nullptr || self == nullptr ||
       options == nullptr || (is_client && target_name == nullptr)) {
-    LOG(ERROR) << "Invalid arguments to alts_tsi_handshaker_create()";
+    ABSL_LOG(ERROR) << "Invalid arguments to alts_tsi_handshaker_create()";
     return TSI_INVALID_ARGUMENT;
   }
   bool use_dedicated_cq = interested_parties == nullptr;
@@ -675,8 +675,8 @@ tsi_result alts_tsi_handshaker_create(
 void alts_tsi_handshaker_result_set_unused_bytes(tsi_handshaker_result* result,
                                                  grpc_slice* recv_bytes,
                                                  size_t bytes_consumed) {
-  CHECK(recv_bytes != nullptr);
-  CHECK_NE(result, nullptr);
+  ABSL_CHECK(recv_bytes != nullptr);
+  ABSL_CHECK_NE(result, nullptr);
   if (GRPC_SLICE_LENGTH(*recv_bytes) == bytes_consumed) {
     return;
   }
@@ -695,19 +695,19 @@ namespace internal {

 bool alts_tsi_handshaker_get_has_sent_start_message_for_testing(
     alts_tsi_handshaker* handshaker) {
-  CHECK_NE(handshaker, nullptr);
+  ABSL_CHECK_NE(handshaker, nullptr);
   return handshaker->has_sent_start_message;
 }

 void alts_tsi_handshaker_set_client_vtable_for_testing(
     alts_tsi_handshaker* handshaker, alts_handshaker_client_vtable* vtable) {
-  CHECK_NE(handshaker, nullptr);
+  ABSL_CHECK_NE(handshaker, nullptr);
   handshaker->client_vtable_for_testing = vtable;
 }

 bool alts_tsi_handshaker_get_is_client_for_testing(
     alts_tsi_handshaker* handshaker) {
-  CHECK_NE(handshaker, nullptr);
+  ABSL_CHECK_NE(handshaker, nullptr);
   return handshaker->is_client;
 }

diff --git a/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_tsi_utils.cc b/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_tsi_utils.cc
index cc8f6dc78bd59..907987be79410 100644
--- a/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_tsi_utils.cc
+++ b/third_party/grpc/source/src/core/tsi/alts/handshaker/alts_tsi_utils.cc
@@ -21,8 +21,8 @@
 #include <grpc/byte_buffer_reader.h>
 #include <grpc/support/port_platform.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/slice/slice.h"
 #include "src/core/lib/slice/slice_internal.h"

@@ -45,8 +45,8 @@ tsi_result alts_tsi_utils_convert_to_tsi_result(grpc_status_code code) {

 grpc_gcp_HandshakerResp* alts_tsi_utils_deserialize_response(
     grpc_byte_buffer* resp_buffer, upb_Arena* arena) {
-  CHECK_NE(resp_buffer, nullptr);
-  CHECK_NE(arena, nullptr);
+  ABSL_CHECK_NE(resp_buffer, nullptr);
+  ABSL_CHECK_NE(arena, nullptr);
   grpc_byte_buffer_reader bbr;
   grpc_byte_buffer_reader_init(&bbr, resp_buffer);
   grpc_slice slice = grpc_byte_buffer_reader_readall(&bbr);
@@ -59,7 +59,7 @@ grpc_gcp_HandshakerResp* alts_tsi_utils_deserialize_response(
   grpc_core::CSliceUnref(slice);
   grpc_byte_buffer_reader_destroy(&bbr);
   if (resp == nullptr) {
-    LOG(ERROR) << "grpc_gcp_handshaker_resp_decode() failed";
+    ABSL_LOG(ERROR) << "grpc_gcp_handshaker_resp_decode() failed";
     return nullptr;
   }
   return resp;
diff --git a/third_party/grpc/source/src/core/tsi/alts/handshaker/transport_security_common_api.cc b/third_party/grpc/source/src/core/tsi/alts/handshaker/transport_security_common_api.cc
index a7881e0d71f78..77ca832cd234a 100644
--- a/third_party/grpc/source/src/core/tsi/alts/handshaker/transport_security_common_api.cc
+++ b/third_party/grpc/source/src/core/tsi/alts/handshaker/transport_security_common_api.cc
@@ -20,14 +20,14 @@

 #include <grpc/support/port_platform.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "upb/mem/arena.hpp"

 bool grpc_gcp_rpc_protocol_versions_set_max(
     grpc_gcp_rpc_protocol_versions* versions, uint32_t max_major,
     uint32_t max_minor) {
   if (versions == nullptr) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "versions is nullptr in grpc_gcp_rpc_protocol_versions_set_max().";
     return false;
   }
@@ -40,7 +40,7 @@ bool grpc_gcp_rpc_protocol_versions_set_min(
     grpc_gcp_rpc_protocol_versions* versions, uint32_t min_major,
     uint32_t min_minor) {
   if (versions == nullptr) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "versions is nullptr in grpc_gcp_rpc_protocol_versions_set_min().";
     return false;
   }
@@ -52,7 +52,7 @@ bool grpc_gcp_rpc_protocol_versions_set_min(
 bool grpc_gcp_rpc_protocol_versions_encode(
     const grpc_gcp_rpc_protocol_versions* versions, grpc_slice* slice) {
   if (versions == nullptr || slice == nullptr) {
-    LOG(ERROR) << "Invalid nullptr arguments to "
+    ABSL_LOG(ERROR) << "Invalid nullptr arguments to "
                   "grpc_gcp_rpc_protocol_versions_encode().";
     return false;
   }
@@ -69,7 +69,7 @@ bool grpc_gcp_rpc_protocol_versions_encode(
     const grpc_gcp_RpcProtocolVersions* versions, upb_Arena* arena,
     grpc_slice* slice) {
   if (versions == nullptr || arena == nullptr || slice == nullptr) {
-    LOG(ERROR) << "Invalid nullptr arguments to "
+    ABSL_LOG(ERROR) << "Invalid nullptr arguments to "
                   "grpc_gcp_rpc_protocol_versions_encode().";
     return false;
   }
@@ -86,7 +86,7 @@ bool grpc_gcp_rpc_protocol_versions_encode(
 bool grpc_gcp_rpc_protocol_versions_decode(
     const grpc_slice& slice, grpc_gcp_rpc_protocol_versions* versions) {
   if (versions == nullptr) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "version is nullptr in grpc_gcp_rpc_protocol_versions_decode().";
     return false;
   }
@@ -96,7 +96,7 @@ bool grpc_gcp_rpc_protocol_versions_decode(
           reinterpret_cast<const char*>(GRPC_SLICE_START_PTR(slice)),
           GRPC_SLICE_LENGTH(slice), arena.ptr());
   if (versions_msg == nullptr) {
-    LOG(ERROR) << "cannot deserialize RpcProtocolVersions message";
+    ABSL_LOG(ERROR) << "cannot deserialize RpcProtocolVersions message";
     return false;
   }
   grpc_gcp_rpc_protocol_versions_assign_from_upb(versions, versions_msg);
@@ -152,7 +152,7 @@ bool grpc_gcp_rpc_protocol_versions_copy(
     grpc_gcp_rpc_protocol_versions* dst) {
   if ((src == nullptr && dst != nullptr) ||
       (src != nullptr && dst == nullptr)) {
-    LOG(ERROR) << "Invalid arguments to grpc_gcp_rpc_protocol_versions_copy().";
+    ABSL_LOG(ERROR) << "Invalid arguments to grpc_gcp_rpc_protocol_versions_copy().";
     return false;
   }
   if (src == nullptr) {
@@ -190,7 +190,7 @@ bool grpc_gcp_rpc_protocol_versions_check(
     const grpc_gcp_rpc_protocol_versions* peer_versions,
     grpc_gcp_rpc_protocol_versions_version* highest_common_version) {
   if (local_versions == nullptr || peer_versions == nullptr) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "Invalid arguments to grpc_gcp_rpc_protocol_versions_check().";
     return false;
   }
diff --git a/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_integrity_only_record_protocol.cc b/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_integrity_only_record_protocol.cc
index 5bde0334f503b..1d9946877fafe 100644
--- a/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_integrity_only_record_protocol.cc
+++ b/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_integrity_only_record_protocol.cc
@@ -22,8 +22,8 @@
 #include <grpc/support/port_platform.h>
 #include <string.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/slice/slice.h"
 #include "src/core/lib/slice/slice_internal.h"
 #include "src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_record_protocol_common.h"
@@ -67,7 +67,7 @@ static tsi_result alts_grpc_integrity_only_extra_copy_protect(
   grpc_status_code status = alts_iovec_record_protocol_integrity_only_protect(
       rp->iovec_rp, rp->iovec_buf, 1, header_iovec, tag_iovec, &error_details);
   if (status != GRPC_STATUS_OK) {
-    LOG(ERROR) << "Failed to protect, " << error_details;
+    ABSL_LOG(ERROR) << "Failed to protect, " << error_details;
     gpr_free(error_details);
     return TSI_INTERNAL_ERROR;
   }
@@ -82,7 +82,7 @@ static tsi_result alts_grpc_integrity_only_protect(
   // Input sanity check.
   if (rp == nullptr || unprotected_slices == nullptr ||
       protected_slices == nullptr) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "Invalid nullptr arguments to alts_grpc_record_protocol protect.";
     return TSI_INVALID_ARGUMENT;
   }
@@ -107,7 +107,7 @@ static tsi_result alts_grpc_integrity_only_protect(
       rp->iovec_rp, rp->iovec_buf, unprotected_slices->count, header_iovec,
       tag_iovec, &error_details);
   if (status != GRPC_STATUS_OK) {
-    LOG(ERROR) << "Failed to protect, " << error_details;
+    ABSL_LOG(ERROR) << "Failed to protect, " << error_details;
     gpr_free(error_details);
     return TSI_INTERNAL_ERROR;
   }
@@ -124,12 +124,12 @@ static tsi_result alts_grpc_integrity_only_unprotect(
   // Input sanity check.
   if (rp == nullptr || protected_slices == nullptr ||
       unprotected_slices == nullptr) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "Invalid nullptr arguments to alts_grpc_record_protocol unprotect.";
     return TSI_INVALID_ARGUMENT;
   }
   if (protected_slices->length < rp->header_length + rp->tag_length) {
-    LOG(ERROR) << "Protected slices do not have sufficient data.";
+    ABSL_LOG(ERROR) << "Protected slices do not have sufficient data.";
     return TSI_INVALID_ARGUMENT;
   }
   // In this method, rp points to alts_grpc_record_protocol struct
@@ -141,14 +141,14 @@ static tsi_result alts_grpc_integrity_only_unprotect(
   grpc_slice_buffer_reset_and_unref(&rp->header_sb);
   grpc_slice_buffer_move_first(protected_slices, rp->header_length,
                                &rp->header_sb);
-  CHECK(rp->header_sb.length == rp->header_length);
+  ABSL_CHECK(rp->header_sb.length == rp->header_length);
   iovec_t header_iovec = alts_grpc_record_protocol_get_header_iovec(rp);
   // Moves protected slices data to data_sb and leaves the remaining tag.
   grpc_slice_buffer_reset_and_unref(&integrity_only_record_protocol->data_sb);
   grpc_slice_buffer_move_first(protected_slices,
                                protected_slices->length - rp->tag_length,
                                &integrity_only_record_protocol->data_sb);
-  CHECK(protected_slices->length == rp->tag_length);
+  ABSL_CHECK(protected_slices->length == rp->tag_length);
   iovec_t tag_iovec = {nullptr, rp->tag_length};
   if (protected_slices->count == 1) {
     tag_iovec.iov_base = GRPC_SLICE_START_PTR(protected_slices->slices[0]);
@@ -168,7 +168,7 @@ static tsi_result alts_grpc_integrity_only_unprotect(
       integrity_only_record_protocol->data_sb.count, header_iovec, tag_iovec,
       &error_details);
   if (status != GRPC_STATUS_OK) {
-    LOG(ERROR) << "Failed to unprotect, " << error_details;
+    ABSL_LOG(ERROR) << "Failed to unprotect, " << error_details;
     gpr_free(error_details);
     return TSI_INTERNAL_ERROR;
   }
@@ -198,7 +198,7 @@ tsi_result alts_grpc_integrity_only_record_protocol_create(
     gsec_aead_crypter* crypter, size_t overflow_size, bool is_client,
     bool is_protect, bool enable_extra_copy, alts_grpc_record_protocol** rp) {
   if (crypter == nullptr || rp == nullptr) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "Invalid nullptr arguments to alts_grpc_record_protocol create.";
     return TSI_INVALID_ARGUMENT;
   }
diff --git a/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_privacy_integrity_record_protocol.cc b/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_privacy_integrity_record_protocol.cc
index cc10ddb8eb487..06218824ee609 100644
--- a/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_privacy_integrity_record_protocol.cc
+++ b/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_privacy_integrity_record_protocol.cc
@@ -21,7 +21,7 @@
 #include <grpc/support/alloc.h>
 #include <grpc/support/port_platform.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/slice/slice.h"
 #include "src/core/lib/slice/slice_internal.h"
 #include "src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_record_protocol_common.h"
@@ -39,7 +39,7 @@ static tsi_result alts_grpc_privacy_integrity_protect(
   // Input sanity check.
   if (rp == nullptr || unprotected_slices == nullptr ||
       protected_slices == nullptr) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "Invalid nullptr arguments to alts_grpc_record_protocol protect.";
     return TSI_INVALID_ARGUMENT;
   }
@@ -60,7 +60,7 @@ static tsi_result alts_grpc_privacy_integrity_protect(
           rp->iovec_rp, rp->iovec_buf, unprotected_slices->count,
           protected_iovec, &error_details);
   if (status != GRPC_STATUS_OK) {
-    LOG(ERROR) << "Failed to protect, " << error_details;
+    ABSL_LOG(ERROR) << "Failed to protect, " << error_details;
     gpr_free(error_details);
     grpc_core::CSliceUnref(protected_slice);
     return TSI_INTERNAL_ERROR;
@@ -76,14 +76,14 @@ static tsi_result alts_grpc_privacy_integrity_unprotect(
   // Input sanity check.
   if (rp == nullptr || protected_slices == nullptr ||
       unprotected_slices == nullptr) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "Invalid nullptr arguments to alts_grpc_record_protocol unprotect.";
     return TSI_INVALID_ARGUMENT;
   }
   // Allocates memory for output frame. In privacy-integrity unprotect, the
   // unprotected data are stored in a newly allocated buffer.
   if (protected_slices->length < rp->header_length + rp->tag_length) {
-    LOG(ERROR) << "Protected slices do not have sufficient data.";
+    ABSL_LOG(ERROR) << "Protected slices do not have sufficient data.";
     return TSI_INVALID_ARGUMENT;
   }
   size_t unprotected_frame_size =
@@ -104,7 +104,7 @@ static tsi_result alts_grpc_privacy_integrity_unprotect(
           rp->iovec_rp, header_iovec, rp->iovec_buf, protected_slices->count,
           unprotected_iovec, &error_details);
   if (status != GRPC_STATUS_OK) {
-    LOG(ERROR) << "Failed to unprotect, " << error_details;
+    ABSL_LOG(ERROR) << "Failed to unprotect, " << error_details;
     gpr_free(error_details);
     grpc_core::CSliceUnref(unprotected_slice);
     return TSI_INTERNAL_ERROR;
@@ -124,7 +124,7 @@ tsi_result alts_grpc_privacy_integrity_record_protocol_create(
     gsec_aead_crypter* crypter, size_t overflow_size, bool is_client,
     bool is_protect, alts_grpc_record_protocol** rp) {
   if (crypter == nullptr || rp == nullptr) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "Invalid nullptr arguments to alts_grpc_record_protocol create.";
     return TSI_INVALID_ARGUMENT;
   }
diff --git a/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_record_protocol_common.cc b/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_record_protocol_common.cc
index 76cf72290cc99..c51aca05288be 100644
--- a/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_record_protocol_common.cc
+++ b/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_record_protocol_common.cc
@@ -22,8 +22,8 @@
 #include <grpc/support/port_platform.h>
 #include <string.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
 #include "src/core/lib/slice/slice_internal.h"
 #include "src/core/util/crash.h"
@@ -34,8 +34,8 @@ const size_t kInitialIovecBufferSize = 8;
 // Makes sure iovec_buf in alts_grpc_record_protocol is large enough.
 static void ensure_iovec_buf_size(alts_grpc_record_protocol* rp,
                                   const grpc_slice_buffer* sb) {
-  CHECK(rp != nullptr);
-  CHECK_NE(sb, nullptr);
+  ABSL_CHECK(rp != nullptr);
+  ABSL_CHECK_NE(sb, nullptr);
   if (sb->count <= rp->iovec_buf_length) {
     return;
   }
@@ -50,8 +50,8 @@ static void ensure_iovec_buf_size(alts_grpc_record_protocol* rp,

 void alts_grpc_record_protocol_convert_slice_buffer_to_iovec(
     alts_grpc_record_protocol* rp, const grpc_slice_buffer* sb) {
-  CHECK(rp != nullptr);
-  CHECK_NE(sb, nullptr);
+  ABSL_CHECK(rp != nullptr);
+  ABSL_CHECK_NE(sb, nullptr);
   ensure_iovec_buf_size(rp, sb);
   for (size_t i = 0; i < sb->count; i++) {
     rp->iovec_buf[i].iov_base = GRPC_SLICE_START_PTR(sb->slices[i]);
@@ -61,8 +61,8 @@ void alts_grpc_record_protocol_convert_slice_buffer_to_iovec(

 void alts_grpc_record_protocol_copy_slice_buffer(const grpc_slice_buffer* src,
                                                  unsigned char* dst) {
-  CHECK(src != nullptr);
-  CHECK_NE(dst, nullptr);
+  ABSL_CHECK(src != nullptr);
+  ABSL_CHECK_NE(dst, nullptr);
   for (size_t i = 0; i < src->count; i++) {
     size_t slice_length = GRPC_SLICE_LENGTH(src->slices[i]);
     memcpy(dst, GRPC_SLICE_START_PTR(src->slices[i]), slice_length);
@@ -94,7 +94,7 @@ tsi_result alts_grpc_record_protocol_init(alts_grpc_record_protocol* rp,
                                           bool is_integrity_only,
                                           bool is_protect) {
   if (rp == nullptr || crypter == nullptr) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "Invalid nullptr arguments to alts_grpc_record_protocol init.";
     return TSI_INVALID_ARGUMENT;
   }
@@ -104,7 +104,7 @@ tsi_result alts_grpc_record_protocol_init(alts_grpc_record_protocol* rp,
       crypter, overflow_size, is_client, is_integrity_only, is_protect,
       &rp->iovec_rp, &error_details);
   if (status != GRPC_STATUS_OK) {
-    LOG(ERROR) << "Failed to create alts_iovec_record_protocol, "
+    ABSL_LOG(ERROR) << "Failed to create alts_iovec_record_protocol, "
                << error_details;
     gpr_free(error_details);
     return TSI_INTERNAL_ERROR;
diff --git a/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_zero_copy_grpc_protector.cc b/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_zero_copy_grpc_protector.cc
index 65c3e21a801ab..689593c9b6fd4 100644
--- a/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_zero_copy_grpc_protector.cc
+++ b/third_party/grpc/source/src/core/tsi/alts/zero_copy_frame_protector/alts_zero_copy_grpc_protector.cc
@@ -25,8 +25,8 @@
 #include <memory>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/tsi/alts/crypt/gsec.h"
 #include "src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_integrity_only_record_protocol.h"
 #include "src/core/tsi/alts/zero_copy_frame_protector/alts_grpc_privacy_integrity_record_protocol.h"
@@ -84,14 +84,14 @@ static bool read_frame_size(const grpc_slice_buffer* sb,
       remaining -= slice_length;
     }
   }
-  CHECK_EQ(remaining, 0u);
+  ABSL_CHECK_EQ(remaining, 0u);
   // Gets little-endian frame size.
   uint32_t frame_size = (static_cast<uint32_t>(frame_size_buffer[3]) << 24) |
                         (static_cast<uint32_t>(frame_size_buffer[2]) << 16) |
                         (static_cast<uint32_t>(frame_size_buffer[1]) << 8) |
                         static_cast<uint32_t>(frame_size_buffer[0]);
   if (frame_size > kMaxFrameLength) {
-    LOG(ERROR) << "Frame size is larger than maximum frame size";
+    ABSL_LOG(ERROR) << "Frame size is larger than maximum frame size";
     return false;
   }
   // Returns frame size including frame length field.
@@ -122,7 +122,7 @@ static tsi_result create_alts_grpc_record_protocol(
                                             kAesGcmTagLength, &crypter,
                                             &error_details);
   if (status != GRPC_STATUS_OK) {
-    LOG(ERROR) << "Failed to create AEAD crypter, " << error_details;
+    ABSL_LOG(ERROR) << "Failed to create AEAD crypter, " << error_details;
     gpr_free(error_details);
     return TSI_INTERNAL_ERROR;
   }
@@ -151,7 +151,7 @@ static tsi_result alts_zero_copy_grpc_protector_protect(
     grpc_slice_buffer* protected_slices) {
   if (self == nullptr || unprotected_slices == nullptr ||
       protected_slices == nullptr) {
-    LOG(ERROR) << "Invalid nullptr arguments to zero-copy grpc protect.";
+    ABSL_LOG(ERROR) << "Invalid nullptr arguments to zero-copy grpc protect.";
     return TSI_INVALID_ARGUMENT;
   }
   alts_zero_copy_grpc_protector* protector =
@@ -177,7 +177,7 @@ static tsi_result alts_zero_copy_grpc_protector_unprotect(
     grpc_slice_buffer* unprotected_slices, int* min_progress_size) {
   if (self == nullptr || unprotected_slices == nullptr ||
       protected_slices == nullptr) {
-    LOG(ERROR) << "Invalid nullptr arguments to zero-copy grpc unprotect.";
+    ABSL_LOG(ERROR) << "Invalid nullptr arguments to zero-copy grpc unprotect.";
     return TSI_INVALID_ARGUMENT;
   }
   alts_zero_copy_grpc_protector* protector =
@@ -262,7 +262,7 @@ tsi_result alts_zero_copy_grpc_protector_create(
     size_t* max_protected_frame_size,
     tsi_zero_copy_grpc_protector** protector) {
   if (protector == nullptr) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "Invalid nullptr arguments to alts_zero_copy_grpc_protector create.";
     return TSI_INVALID_ARGUMENT;
   }
@@ -292,7 +292,7 @@ tsi_result alts_zero_copy_grpc_protector_create(
       impl->max_unprotected_data_size =
           alts_grpc_record_protocol_max_unprotected_data_size(
               impl->record_protocol, max_protected_frame_size_to_set);
-      CHECK_GT(impl->max_unprotected_data_size, 0u);
+      ABSL_CHECK_GT(impl->max_unprotected_data_size, 0u);
       // Allocates internal slice buffers.
       grpc_slice_buffer_init(&impl->unprotected_staging_sb);
       grpc_slice_buffer_init(&impl->protected_sb);
diff --git a/third_party/grpc/source/src/core/tsi/fake_transport_security.cc b/third_party/grpc/source/src/core/tsi/fake_transport_security.cc
index 595a239051bf3..8e9f17b0854c3 100644
--- a/third_party/grpc/source/src/core/tsi/fake_transport_security.cc
+++ b/third_party/grpc/source/src/core/tsi/fake_transport_security.cc
@@ -23,8 +23,8 @@
 #include <stdlib.h>
 #include <string.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/slice/slice_internal.h"
 #include "src/core/tsi/transport_security_grpc.h"
 #include "src/core/tsi/transport_security_interface.h"
@@ -89,7 +89,7 @@ static const char* tsi_fake_handshake_message_strings[] = {

 static const char* tsi_fake_handshake_message_to_string(int msg) {
   if (msg < 0 || msg >= TSI_FAKE_HANDSHAKE_MESSAGE_MAX) {
-    LOG(ERROR) << "Invalid message " << msg;
+    ABSL_LOG(ERROR) << "Invalid message " << msg;
     return "UNKNOWN";
   }
   return tsi_fake_handshake_message_strings[msg];
@@ -105,7 +105,7 @@ static tsi_result tsi_fake_handshake_message_from_string(
       return TSI_OK;
     }
   }
-  LOG(ERROR) << "Invalid handshake message.";
+  ABSL_LOG(ERROR) << "Invalid handshake message.";
   if (error != nullptr) *error = "invalid handshake message";
   return TSI_DATA_CORRUPTED;
 }
@@ -124,8 +124,8 @@ static void store32_little_endian(uint32_t value, unsigned char* buf) {
 }

 static uint32_t read_frame_size(const grpc_slice_buffer* sb) {
-  CHECK(sb != nullptr);
-  CHECK(sb->length >= TSI_FAKE_FRAME_HEADER_SIZE);
+  ABSL_CHECK(sb != nullptr);
+  ABSL_CHECK(sb->length >= TSI_FAKE_FRAME_HEADER_SIZE);
   uint8_t frame_size_buffer[TSI_FAKE_FRAME_HEADER_SIZE];
   uint8_t* buf = frame_size_buffer;
   // Copies the first 4 bytes to a temporary buffer.
@@ -142,7 +142,7 @@ static uint32_t read_frame_size(const grpc_slice_buffer* sb) {
       remaining -= slice_length;
     }
   }
-  CHECK_EQ(remaining, 0u);
+  ABSL_CHECK_EQ(remaining, 0u);
   return load32_little_endian(frame_size_buffer);
 }

@@ -317,7 +317,7 @@ static tsi_result fake_protector_protect(tsi_frame_protector* self,
     result = tsi_fake_frame_decode(frame_header, &written_in_frame_size, frame,
                                    /*error=*/nullptr);
     if (result != TSI_INCOMPLETE_DATA) {
-      LOG(ERROR) << "tsi_fake_frame_decode returned "
+      ABSL_LOG(ERROR) << "tsi_fake_frame_decode returned "
                  << tsi_result_to_string(result);
       return result;
     }
@@ -474,7 +474,7 @@ static tsi_result fake_zero_copy_grpc_protector_unprotect(
     if (impl->parsed_frame_size == 0) {
       impl->parsed_frame_size = read_frame_size(&impl->protected_sb);
       if (impl->parsed_frame_size <= 4) {
-        LOG(ERROR) << "Invalid frame size.";
+        ABSL_LOG(ERROR) << "Invalid frame size.";
         return TSI_DATA_CORRUPTED;
       }
     }
@@ -690,7 +690,7 @@ static tsi_result fake_handshaker_process_bytes_from_peer(
     return result;
   }
   if (received_msg != expected_msg) {
-    LOG(ERROR) << "Invalid received message ("
+    ABSL_LOG(ERROR) << "Invalid received message ("
                << tsi_fake_handshake_message_to_string(received_msg)
                << " instead of "
                << tsi_fake_handshake_message_to_string(expected_msg) << ")";
diff --git a/third_party/grpc/source/src/core/tsi/local_transport_security.cc b/third_party/grpc/source/src/core/tsi/local_transport_security.cc
index ced2ef2baa16f..f104b120d5f61 100644
--- a/third_party/grpc/source/src/core/tsi/local_transport_security.cc
+++ b/third_party/grpc/source/src/core/tsi/local_transport_security.cc
@@ -25,7 +25,7 @@
 #include <stdlib.h>
 #include <string.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
 #include "src/core/tsi/transport_security_grpc.h"
 #include "src/core/util/crash.h"
@@ -67,7 +67,7 @@ tsi_result handshaker_result_get_unused_bytes(const tsi_handshaker_result* self,
                                               const unsigned char** bytes,
                                               size_t* bytes_size) {
   if (self == nullptr || bytes == nullptr || bytes_size == nullptr) {
-    LOG(ERROR) << "Invalid arguments to get_unused_bytes()";
+    ABSL_LOG(ERROR) << "Invalid arguments to get_unused_bytes()";
     return TSI_INVALID_ARGUMENT;
   }
   auto* result = reinterpret_cast<local_tsi_handshaker_result*>(
@@ -100,7 +100,7 @@ tsi_result create_handshaker_result(const unsigned char* received_bytes,
                                     size_t received_bytes_size,
                                     tsi_handshaker_result** self) {
   if (self == nullptr) {
-    LOG(ERROR) << "Invalid arguments to create_handshaker_result()";
+    ABSL_LOG(ERROR) << "Invalid arguments to create_handshaker_result()";
     return TSI_INVALID_ARGUMENT;
   }
   local_tsi_handshaker_result* result =
@@ -127,7 +127,7 @@ tsi_result handshaker_next(tsi_handshaker* self,
                            tsi_handshaker_on_next_done_cb /*cb*/,
                            void* /*user_data*/, std::string* error) {
   if (self == nullptr) {
-    LOG(ERROR) << "Invalid arguments to handshaker_next()";
+    ABSL_LOG(ERROR) << "Invalid arguments to handshaker_next()";
     if (error != nullptr) *error = "invalid argument";
     return TSI_INVALID_ARGUMENT;
   }
@@ -163,7 +163,7 @@ const tsi_handshaker_vtable handshaker_vtable = {

 tsi_result tsi_local_handshaker_create(tsi_handshaker** self) {
   if (self == nullptr) {
-    LOG(ERROR) << "Invalid arguments to local_tsi_handshaker_create()";
+    ABSL_LOG(ERROR) << "Invalid arguments to local_tsi_handshaker_create()";
     return TSI_INVALID_ARGUMENT;
   }
   local_tsi_handshaker* handshaker = grpc_core::Zalloc<local_tsi_handshaker>();
diff --git a/third_party/grpc/source/src/core/tsi/ssl/key_logging/ssl_key_logging.cc b/third_party/grpc/source/src/core/tsi/ssl/key_logging/ssl_key_logging.cc
index b0f961a41c827..98d94259fed8c 100644
--- a/third_party/grpc/source/src/core/tsi/ssl/key_logging/ssl_key_logging.cc
+++ b/third_party/grpc/source/src/core/tsi/ssl/key_logging/ssl_key_logging.cc
@@ -18,8 +18,8 @@

 #include <map>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/iomgr/error.h"
 #include "src/core/lib/slice/slice_internal.h"
 #include "src/core/util/crash.h"
@@ -48,12 +48,12 @@ TlsSessionKeyLoggerCache::TlsSessionKeyLogger::TlsSessionKeyLogger(
     grpc_core::RefCountedPtr<TlsSessionKeyLoggerCache> cache)
     : tls_session_key_log_file_path_(std::move(tls_session_key_log_file_path)),
       cache_(std::move(cache)) {
-  CHECK(!tls_session_key_log_file_path_.empty());
-  CHECK(cache_ != nullptr);
+  ABSL_CHECK(!tls_session_key_log_file_path_.empty());
+  ABSL_CHECK(cache_ != nullptr);
   fd_ = fopen(tls_session_key_log_file_path_.c_str(), "a");
   if (fd_ == nullptr) {
     grpc_error_handle error = GRPC_OS_ERROR(errno, "fopen");
-    LOG(ERROR) << "Ignoring TLS Key logging. ERROR Opening TLS Keylog file: "
+    ABSL_LOG(ERROR) << "Ignoring TLS Key logging. ERROR Opening TLS Keylog file: "
                << grpc_core::StatusToString(error);
   }
   cache_->tls_session_key_logger_map_.emplace(tls_session_key_log_file_path_,
@@ -86,7 +86,7 @@ void TlsSessionKeyLoggerCache::TlsSessionKeyLogger::LogSessionKeys(

   if (err) {
     grpc_error_handle error = GRPC_OS_ERROR(errno, "fwrite");
-    LOG(ERROR) << "Error Appending to TLS session key log file: "
+    ABSL_LOG(ERROR) << "Error Appending to TLS session key log file: "
                << grpc_core::StatusToString(error);
     fclose(fd_);
     fd_ = nullptr;  // disable future attempts to write to this file
@@ -108,7 +108,7 @@ TlsSessionKeyLoggerCache::~TlsSessionKeyLoggerCache() {
 grpc_core::RefCountedPtr<TlsSessionKeyLogger> TlsSessionKeyLoggerCache::Get(
     std::string tls_session_key_log_file_path) {
   gpr_once_init(&g_cache_mutex_init, do_cache_mutex_init);
-  DCHECK_NE(g_tls_session_key_log_cache_mu, nullptr);
+  ABSL_DCHECK_NE(g_tls_session_key_log_cache_mu, nullptr);
   if (tls_session_key_log_file_path.empty()) {
     return nullptr;
   }
diff --git a/third_party/grpc/source/src/core/tsi/ssl/session_cache/ssl_session_cache.cc b/third_party/grpc/source/src/core/tsi/ssl/session_cache/ssl_session_cache.cc
index 6e107c066c51e..eec3eefe9f1ba 100644
--- a/third_party/grpc/source/src/core/tsi/ssl/session_cache/ssl_session_cache.cc
+++ b/third_party/grpc/source/src/core/tsi/ssl/session_cache/ssl_session_cache.cc
@@ -21,8 +21,8 @@
 #include <grpc/support/port_platform.h>
 #include <grpc/support/string_util.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/slice/slice_internal.h"
 #include "src/core/tsi/ssl/session_cache/ssl_session.h"
 #include "src/core/util/crash.h"
@@ -63,7 +63,7 @@ class SslSessionLRUCache::Node {

 SslSessionLRUCache::SslSessionLRUCache(size_t capacity) : capacity_(capacity) {
   if (capacity == 0) {
-    LOG(ERROR) << "SslSessionLRUCache capacity is zero. SSL sessions cannot be "
+    ABSL_LOG(ERROR) << "SslSessionLRUCache capacity is zero. SSL sessions cannot be "
                   "resumed.";
   }
 }
@@ -98,7 +98,7 @@ SslSessionLRUCache::Node* SslSessionLRUCache::FindLocked(

 void SslSessionLRUCache::Put(const char* key, SslSessionPtr session) {
   if (session == nullptr) {
-    LOG(ERROR) << "Attempted to put null SSL session in session cache.";
+    ABSL_LOG(ERROR) << "Attempted to put null SSL session in session cache.";
     return;
   }
   grpc_core::MutexLock lock(&lock_);
@@ -112,7 +112,7 @@ void SslSessionLRUCache::Put(const char* key, SslSessionPtr session) {
   entry_by_key_.emplace(key, node);
   AssertInvariants();
   if (use_order_list_size_ > capacity_) {
-    CHECK(use_order_list_tail_);
+    ABSL_CHECK(use_order_list_tail_);
     node = use_order_list_tail_;
     Remove(node);
     // Order matters, key is destroyed after deleting node.
@@ -143,7 +143,7 @@ void SslSessionLRUCache::Remove(SslSessionLRUCache::Node* node) {
   } else {
     node->next_->prev_ = node->prev_;
   }
-  CHECK_GE(use_order_list_size_, 1u);
+  ABSL_CHECK_GE(use_order_list_size_, 1u);
   use_order_list_size_--;
 }

@@ -169,16 +169,16 @@ void SslSessionLRUCache::AssertInvariants() {
   Node* current = use_order_list_head_;
   while (current != nullptr) {
     size++;
-    CHECK(current->prev_ == prev);
+    ABSL_CHECK(current->prev_ == prev);
     auto it = entry_by_key_.find(current->key());
-    CHECK(it != entry_by_key_.end());
-    CHECK(it->second == current);
+    ABSL_CHECK(it != entry_by_key_.end());
+    ABSL_CHECK(it->second == current);
     prev = current;
     current = current->next_;
   }
-  CHECK(prev == use_order_list_tail_);
-  CHECK(size == use_order_list_size_);
-  CHECK(entry_by_key_.size() == use_order_list_size_);
+  ABSL_CHECK(prev == use_order_list_tail_);
+  ABSL_CHECK(size == use_order_list_size_);
+  ABSL_CHECK(entry_by_key_.size() == use_order_list_size_);
 }
 #else
 void SslSessionLRUCache::AssertInvariants() {}
diff --git a/third_party/grpc/source/src/core/tsi/ssl/session_cache/ssl_session_openssl.cc b/third_party/grpc/source/src/core/tsi/ssl/session_cache/ssl_session_openssl.cc
index f44b4cb7335ef..6628fc91ebbb1 100644
--- a/third_party/grpc/source/src/core/tsi/ssl/session_cache/ssl_session_openssl.cc
+++ b/third_party/grpc/source/src/core/tsi/ssl/session_cache/ssl_session_openssl.cc
@@ -17,7 +17,7 @@
 //
 #include <grpc/support/port_platform.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/tsi/ssl/session_cache/ssl_session.h"
 #include "src/core/util/crash.h"

@@ -41,11 +41,11 @@ class OpenSslCachedSession : public SslCachedSession {
  public:
   OpenSslCachedSession(SslSessionPtr session) {
     int size = i2d_SSL_SESSION(session.get(), nullptr);
-    CHECK_GT(size, 0);
+    ABSL_CHECK_GT(size, 0);
     grpc_slice slice = grpc_slice_malloc(size_t(size));
     unsigned char* start = GRPC_SLICE_START_PTR(slice);
     int second_size = i2d_SSL_SESSION(session.get(), &start);
-    CHECK(size == second_size);
+    ABSL_CHECK(size == second_size);
     serialized_session_ = slice;
   }

diff --git a/third_party/grpc/source/src/core/tsi/ssl_transport_security.cc b/third_party/grpc/source/src/core/tsi/ssl_transport_security.cc
index 9310314e00855..edd099773c392 100644
--- a/third_party/grpc/source/src/core/tsi/ssl_transport_security.cc
+++ b/third_party/grpc/source/src/core/tsi/ssl_transport_security.cc
@@ -55,8 +55,8 @@
 #include <memory>
 #include <string>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/match.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
@@ -202,7 +202,7 @@ static void init_openssl(void) {
 #if OPENSSL_VERSION_NUMBER < 0x10100000
   if (!CRYPTO_get_locking_callback()) {
     int num_locks = CRYPTO_num_locks();
-    CHECK_GT(num_locks, 0);
+    ABSL_CHECK_GT(num_locks, 0);
     g_openssl_mutexes = static_cast<gpr_mu*>(
         gpr_malloc(static_cast<size_t>(num_locks) * sizeof(gpr_mu)));
     for (int i = 0; i < num_locks; i++) {
@@ -216,15 +216,15 @@ static void init_openssl(void) {
 #endif
   g_ssl_ctx_ex_factory_index =
       SSL_CTX_get_ex_new_index(0, nullptr, nullptr, nullptr, nullptr);
-  CHECK_NE(g_ssl_ctx_ex_factory_index, -1);
+  ABSL_CHECK_NE(g_ssl_ctx_ex_factory_index, -1);

   g_ssl_ctx_ex_crl_provider_index =
       SSL_CTX_get_ex_new_index(0, nullptr, nullptr, nullptr, nullptr);
-  CHECK_NE(g_ssl_ctx_ex_crl_provider_index, -1);
+  ABSL_CHECK_NE(g_ssl_ctx_ex_crl_provider_index, -1);

   g_ssl_ex_verified_root_cert_index = SSL_get_ex_new_index(
       0, nullptr, nullptr, nullptr, verified_root_cert_free);
-  CHECK_NE(g_ssl_ex_verified_root_cert_index, -1);
+  ABSL_CHECK_NE(g_ssl_ex_verified_root_cert_index, -1);
 }

 // --- Ssl utils. ---
@@ -233,7 +233,7 @@ static void init_openssl(void) {
 static void ssl_log_where_info(const SSL* ssl, int where, int flag,
                                const char* msg) {
   if ((where & flag) && GRPC_TRACE_FLAG_ENABLED(tsi)) {
-    LOG(INFO) << absl::StrFormat("%20.20s - %s  - %s", msg,
+    ABSL_LOG(INFO) << absl::StrFormat("%20.20s - %s  - %s", msg,
                                  SSL_state_string_long(ssl),
                                  SSL_state_string(ssl));
   }
@@ -242,7 +242,7 @@ static void ssl_log_where_info(const SSL* ssl, int where, int flag,
 // Used for debugging. TODO(jboeuf): Remove when code is mature enough.
 static void ssl_info_callback(const SSL* ssl, int where, int ret) {
   if (ret == 0) {
-    LOG(ERROR) << "ssl_info_callback: error occurred.\n";
+    ABSL_LOG(ERROR) << "ssl_info_callback: error occurred.\n";
     return;
   }

@@ -285,28 +285,28 @@ static tsi_result ssl_get_x509_common_name(X509* cert, unsigned char** utf8,
   X509_NAME* subject_name = X509_get_subject_name(cert);
   int utf8_returned_size = 0;
   if (subject_name == nullptr) {
-    VLOG(2) << "Could not get subject name from certificate.";
+    ABSL_VLOG(2) << "Could not get subject name from certificate.";
     return TSI_NOT_FOUND;
   }
   common_name_index =
       X509_NAME_get_index_by_NID(subject_name, NID_commonName, -1);
   if (common_name_index == -1) {
-    VLOG(2) << "Could not get common name of subject from certificate.";
+    ABSL_VLOG(2) << "Could not get common name of subject from certificate.";
     return TSI_NOT_FOUND;
   }
   common_name_entry = X509_NAME_get_entry(subject_name, common_name_index);
   if (common_name_entry == nullptr) {
-    LOG(ERROR) << "Could not get common name entry from certificate.";
+    ABSL_LOG(ERROR) << "Could not get common name entry from certificate.";
     return TSI_INTERNAL_ERROR;
   }
   common_name_asn1 = X509_NAME_ENTRY_get_data(common_name_entry);
   if (common_name_asn1 == nullptr) {
-    LOG(ERROR) << "Could not get common name entry asn1 from certificate.";
+    ABSL_LOG(ERROR) << "Could not get common name entry asn1 from certificate.";
     return TSI_INTERNAL_ERROR;
   }
   utf8_returned_size = ASN1_STRING_to_UTF8(utf8, common_name_asn1);
   if (utf8_returned_size < 0) {
-    LOG(ERROR) << "Could not extract utf8 from asn1 string.";
+    ABSL_LOG(ERROR) << "Could not extract utf8 from asn1 string.";
     return TSI_OUT_OF_RESOURCES;
   }
   *utf8_size = static_cast<size_t>(utf8_returned_size);
@@ -350,7 +350,7 @@ static tsi_result peer_property_from_x509_subject(X509* cert,
   char* contents;
   long len = BIO_get_mem_data(bio, &contents);
   if (len < 0) {
-    LOG(ERROR) << "Could not get subject entry from certificate.";
+    ABSL_LOG(ERROR) << "Could not get subject entry from certificate.";
     BIO_free(bio);
     return TSI_INTERNAL_ERROR;
   }
@@ -415,7 +415,7 @@ static tsi_result add_subject_alt_names_properties_to_peer(
         property_name = TSI_X509_URI_PEER_PROPERTY;
       }
       if (name_size < 0) {
-        LOG(ERROR) << "Could not get utf8 from asn1 string.";
+        ABSL_LOG(ERROR) << "Could not get utf8 from asn1 string.";
         result = TSI_INTERNAL_ERROR;
         break;
       }
@@ -441,14 +441,14 @@ static tsi_result add_subject_alt_names_properties_to_peer(
       } else if (subject_alt_name->d.iPAddress->length == 16) {
         af = AF_INET6;
       } else {
-        LOG(ERROR) << "SAN IP Address contained invalid IP";
+        ABSL_LOG(ERROR) << "SAN IP Address contained invalid IP";
         result = TSI_INTERNAL_ERROR;
         break;
       }
       const char* name = inet_ntop(af, subject_alt_name->d.iPAddress->data,
                                    ntop_buf, INET6_ADDRSTRLEN);
       if (name == nullptr) {
-        LOG(ERROR) << "Could not get IP string from asn1 octet.";
+        ABSL_LOG(ERROR) << "Could not get IP string from asn1 octet.";
         result = TSI_INTERNAL_ERROR;
         break;
       }
@@ -482,7 +482,7 @@ static tsi_result peer_from_x509(X509* cert, int include_certificate_type,
           : 0;
   size_t property_count;
   tsi_result result;
-  CHECK_GE(subject_alt_name_count, 0);
+  ABSL_CHECK_GE(subject_alt_name_count, 0);
   property_count = (include_certificate_type ? size_t{1} : 0) +
                    3 /* subject, common name, certificate */ +
                    static_cast<size_t>(subject_alt_name_count);
@@ -537,7 +537,7 @@ static tsi_result peer_from_x509(X509* cert, int include_certificate_type,
   }
   if (result != TSI_OK) tsi_peer_destruct(peer);

-  CHECK((int)peer->property_count == current_insert_index);
+  ABSL_CHECK((int)peer->property_count == current_insert_index);
   return result;
 }

@@ -548,7 +548,7 @@ static tsi_result ssl_ctx_use_certificate_chain(SSL_CTX* context,
   tsi_result result = TSI_OK;
   X509* certificate = nullptr;
   BIO* pem;
-  CHECK_LE(pem_cert_chain_size, static_cast<size_t>(INT_MAX));
+  ABSL_CHECK_LE(pem_cert_chain_size, static_cast<size_t>(INT_MAX));
   pem = BIO_new_mem_buf(pem_cert_chain, static_cast<int>(pem_cert_chain_size));
   if (pem == nullptr) return TSI_OUT_OF_RESOURCES;

@@ -611,7 +611,7 @@ static tsi_result ssl_ctx_use_engine_private_key(SSL_CTX* context,
     }
     engine_name = static_cast<char*>(gpr_zalloc(engine_name_length + 1));
     memcpy(engine_name, engine_start, engine_name_length);
-    VLOG(2) << "ENGINE key: " << engine_name;
+    ABSL_VLOG(2) << "ENGINE key: " << engine_name;
     ENGINE_load_dynamic();
     engine = ENGINE_by_id(engine_name);
     if (engine == nullptr) {
@@ -619,7 +619,7 @@ static tsi_result ssl_ctx_use_engine_private_key(SSL_CTX* context,
       // current working directory.
       engine = ENGINE_by_id("dynamic");
       if (engine == nullptr) {
-        LOG(ERROR) << "Cannot load dynamic engine";
+        ABSL_LOG(ERROR) << "Cannot load dynamic engine";
         result = TSI_INVALID_ARGUMENT;
         break;
       }
@@ -628,29 +628,29 @@ static tsi_result ssl_ctx_use_engine_private_key(SSL_CTX* context,
           !ENGINE_ctrl_cmd_string(engine, "DIR_ADD", ".", 0) ||
           !ENGINE_ctrl_cmd_string(engine, "LIST_ADD", "1", 0) ||
           !ENGINE_ctrl_cmd_string(engine, "LOAD", NULL, 0)) {
-        LOG(ERROR) << "Cannot find engine";
+        ABSL_LOG(ERROR) << "Cannot find engine";
         result = TSI_INVALID_ARGUMENT;
         break;
       }
     }
     if (!ENGINE_set_default(engine, ENGINE_METHOD_ALL)) {
-      LOG(ERROR) << "ENGINE_set_default with ENGINE_METHOD_ALL failed";
+      ABSL_LOG(ERROR) << "ENGINE_set_default with ENGINE_METHOD_ALL failed";
       result = TSI_INVALID_ARGUMENT;
       break;
     }
     if (!ENGINE_init(engine)) {
-      LOG(ERROR) << "ENGINE_init failed";
+      ABSL_LOG(ERROR) << "ENGINE_init failed";
       result = TSI_INVALID_ARGUMENT;
       break;
     }
     private_key = ENGINE_load_private_key(engine, key_id, 0, 0);
     if (private_key == nullptr) {
-      LOG(ERROR) << "ENGINE_load_private_key failed";
+      ABSL_LOG(ERROR) << "ENGINE_load_private_key failed";
       result = TSI_INVALID_ARGUMENT;
       break;
     }
     if (!SSL_CTX_use_PrivateKey(context, private_key)) {
-      LOG(ERROR) << "SSL_CTX_use_PrivateKey failed";
+      ABSL_LOG(ERROR) << "SSL_CTX_use_PrivateKey failed";
       result = TSI_INVALID_ARGUMENT;
       break;
     }
@@ -668,7 +668,7 @@ static tsi_result ssl_ctx_use_pem_private_key(SSL_CTX* context,
   tsi_result result = TSI_OK;
   EVP_PKEY* private_key = nullptr;
   BIO* pem;
-  CHECK_LE(pem_key_size, static_cast<size_t>(INT_MAX));
+  ABSL_CHECK_LE(pem_key_size, static_cast<size_t>(INT_MAX));
   pem = BIO_new_mem_buf(pem_key, static_cast<int>(pem_key_size));
   if (pem == nullptr) return TSI_OUT_OF_RESOURCES;
   do {
@@ -713,7 +713,7 @@ static tsi_result x509_store_load_certs(X509_STORE* cert_store,
   X509* root = nullptr;
   X509_NAME* root_name = nullptr;
   BIO* pem;
-  CHECK_LE(pem_roots_size, static_cast<size_t>(INT_MAX));
+  ABSL_CHECK_LE(pem_roots_size, static_cast<size_t>(INT_MAX));
   pem = BIO_new_mem_buf(pem_roots, static_cast<int>(pem_roots_size));
   if (cert_store == nullptr) return TSI_INVALID_ARGUMENT;
   if (pem == nullptr) return TSI_OUT_OF_RESOURCES;
@@ -731,7 +731,7 @@ static tsi_result x509_store_load_certs(X509_STORE* cert_store,
     if (root_names != nullptr) {
       root_name = X509_get_subject_name(root);
       if (root_name == nullptr) {
-        LOG(ERROR) << "Could not get name from root certificate.";
+        ABSL_LOG(ERROR) << "Could not get name from root certificate.";
         result = TSI_INVALID_ARGUMENT;
         break;
       }
@@ -748,7 +748,7 @@ static tsi_result x509_store_load_certs(X509_STORE* cert_store,
       unsigned long error = ERR_get_error();
       if (ERR_GET_LIB(error) != ERR_LIB_X509 ||
           ERR_GET_REASON(error) != X509_R_CERT_ALREADY_IN_HASH_TABLE) {
-        LOG(ERROR) << "Could not add root certificate to ssl context.";
+        ABSL_LOG(ERROR) << "Could not add root certificate to ssl context.";
         result = TSI_INTERNAL_ERROR;
         break;
       }
@@ -757,7 +757,7 @@ static tsi_result x509_store_load_certs(X509_STORE* cert_store,
     num_roots++;
   }
   if (num_roots == 0) {
-    LOG(ERROR) << "Could not load any root certificate.";
+    ABSL_LOG(ERROR) << "Could not load any root certificate.";
     result = TSI_INVALID_ARGUMENT;
   }

@@ -796,7 +796,7 @@ static tsi_result populate_ssl_context(
       result = ssl_ctx_use_certificate_chain(context, key_cert_pair->cert_chain,
                                              strlen(key_cert_pair->cert_chain));
       if (result != TSI_OK) {
-        LOG(ERROR) << "Invalid cert chain file.";
+        ABSL_LOG(ERROR) << "Invalid cert chain file.";
         return result;
       }
     }
@@ -804,21 +804,21 @@ static tsi_result populate_ssl_context(
       result = ssl_ctx_use_private_key(context, key_cert_pair->private_key,
                                        strlen(key_cert_pair->private_key));
       if (result != TSI_OK || !SSL_CTX_check_private_key(context)) {
-        LOG(ERROR) << "Invalid private key.";
+        ABSL_LOG(ERROR) << "Invalid private key.";
         return result != TSI_OK ? result : TSI_INVALID_ARGUMENT;
       }
     }
   }
   if ((cipher_list != nullptr) &&
       !SSL_CTX_set_cipher_list(context, cipher_list)) {
-    LOG(ERROR) << "Invalid cipher list: " << cipher_list;
+    ABSL_LOG(ERROR) << "Invalid cipher list: " << cipher_list;
     return TSI_INVALID_ARGUMENT;
   }
   {
 #if OPENSSL_VERSION_NUMBER < 0x30000000L
     EC_KEY* ecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
     if (!SSL_CTX_set_tmp_ecdh(context, ecdh)) {
-      LOG(ERROR) << "Could not set ephemeral ECDH key.";
+      ABSL_LOG(ERROR) << "Could not set ephemeral ECDH key.";
       EC_KEY_free(ecdh);
       return TSI_INTERNAL_ERROR;
     }
@@ -826,7 +826,7 @@ static tsi_result populate_ssl_context(
     EC_KEY_free(ecdh);
 #else
     if (!SSL_CTX_set1_groups(context, kSslEcCurveNames, 1)) {
-      LOG(ERROR) << "Could not set ephemeral ECDH key.";
+      ABSL_LOG(ERROR) << "Could not set ephemeral ECDH key.";
       return TSI_INTERNAL_ERROR;
     }
     SSL_CTX_set_options(context, SSL_OP_SINGLE_ECDH_USE);
@@ -846,7 +846,7 @@ tsi_result tsi_ssl_extract_x509_subject_names_from_pem_cert(

   cert = PEM_read_bio_X509(pem, nullptr, nullptr, const_cast<char*>(""));
   if (cert == nullptr) {
-    LOG(ERROR) << "Invalid certificate";
+    ABSL_LOG(ERROR) << "Invalid certificate";
     result = TSI_INVALID_ARGUMENT;
   } else {
     result = peer_from_x509(cert, 0, peer);
@@ -869,7 +869,7 @@ static tsi_result build_alpn_protocol_name_list(
     size_t length =
         alpn_protocols[i] == nullptr ? 0 : strlen(alpn_protocols[i]);
     if (length == 0 || length > 255) {
-      LOG(ERROR) << "Invalid protocol name length: " << length;
+      ABSL_LOG(ERROR) << "Invalid protocol name length: " << length;
       return TSI_INVALID_ARGUMENT;
     }
     *protocol_name_list_length += length + 1;
@@ -904,7 +904,7 @@ static int verify_cb(int ok, X509_STORE_CTX* ctx) {
     return 1;
   }
   if (cert_error != 0) {
-    LOG(ERROR) << "Certificate verify failed with code " << cert_error;
+    ABSL_LOG(ERROR) << "Certificate verify failed with code " << cert_error;
   }
   return ok;
 }
@@ -948,7 +948,7 @@ static int RootCertExtractCallback(X509_STORE_CTX* ctx, void* /*arg*/) {
   if (ssl_index < 0) {
     char err_str[256];
     ERR_error_string_n(ERR_get_error(), err_str, sizeof(err_str));
-    LOG(ERROR) << "error getting the SSL index from the X509_STORE_CTX: "
+    ABSL_LOG(ERROR) << "error getting the SSL index from the X509_STORE_CTX: "
                << err_str;
     return ret;
   }
@@ -1053,12 +1053,12 @@ static bool ValidateCrl(X509* cert, X509* issuer, X509_CRL* crl) {
   // 6.3.3b verify issuer and scope
   valid = grpc_core::VerifyCrlCertIssuerNamesMatch(crl, cert);
   if (!valid) {
-    VLOG(2) << "CRL and cert issuer names mismatched.";
+    ABSL_VLOG(2) << "CRL and cert issuer names mismatched.";
     return valid;
   }
   valid = grpc_core::HasCrlSignBit(issuer);
   if (!valid) {
-    VLOG(2) << "CRL issuer not allowed to sign CRLs.";
+    ABSL_VLOG(2) << "CRL issuer not allowed to sign CRLs.";
     return valid;
   }
   // 6.3.3c Not supporting deltas
@@ -1069,7 +1069,7 @@ static bool ValidateCrl(X509* cert, X509* issuer, X509_CRL* crl) {
   // 6.3.3g Verify CRL Signature
   valid = grpc_core::VerifyCrlSignature(crl, issuer);
   if (!valid) {
-    VLOG(2) << "Crl signature check failed.";
+    ABSL_VLOG(2) << "Crl signature check failed.";
   }
   return valid;
 }
@@ -1159,7 +1159,7 @@ static int CheckChainRevocation(
 static int CustomVerificationFunction(X509_STORE_CTX* ctx, void* arg) {
   int ret = X509_verify_cert(ctx);
   if (ret <= 0) {
-    VLOG(2) << "Failed to verify cert chain.";
+    ABSL_VLOG(2) << "Failed to verify cert chain.";
     // Verification failed. We shouldn't expect to have a verified chain, so
     // there is no need to attempt to extract the root cert from it, check for
     // revocation, or check anything else.
@@ -1169,7 +1169,7 @@ static int CustomVerificationFunction(X509_STORE_CTX* ctx, void* arg) {
   if (provider != nullptr) {
     ret = CheckChainRevocation(ctx, provider);
     if (ret <= 0) {
-      VLOG(2) << "The chain failed revocation checks.";
+      ABSL_VLOG(2) << "The chain failed revocation checks.";
       return ret;
     }
   }
@@ -1236,25 +1236,25 @@ static tsi_result tsi_set_min_and_max_tls_versions(
 tsi_ssl_root_certs_store* tsi_ssl_root_certs_store_create(
     const char* pem_roots) {
   if (pem_roots == nullptr) {
-    LOG(ERROR) << "The root certificates are empty.";
+    ABSL_LOG(ERROR) << "The root certificates are empty.";
     return nullptr;
   }
   tsi_ssl_root_certs_store* root_store = static_cast<tsi_ssl_root_certs_store*>(
       gpr_zalloc(sizeof(tsi_ssl_root_certs_store)));
   if (root_store == nullptr) {
-    LOG(ERROR) << "Could not allocate buffer for ssl_root_certs_store.";
+    ABSL_LOG(ERROR) << "Could not allocate buffer for ssl_root_certs_store.";
     return nullptr;
   }
   root_store->store = X509_STORE_new();
   if (root_store->store == nullptr) {
-    LOG(ERROR) << "Could not allocate buffer for X509_STORE.";
+    ABSL_LOG(ERROR) << "Could not allocate buffer for X509_STORE.";
     gpr_free(root_store);
     return nullptr;
   }
   tsi_result result = x509_store_load_certs(root_store->store, pem_roots,
                                             strlen(pem_roots), nullptr);
   if (result != TSI_OK) {
-    LOG(ERROR) << "Could not load root certificates.";
+    ABSL_LOG(ERROR) << "Could not load root certificates.";
     X509_STORE_free(root_store->store);
     gpr_free(root_store);
     return nullptr;
@@ -1380,7 +1380,7 @@ static tsi_ssl_handshaker_factory_vtable handshaker_factory_vtable = {nullptr};
 // allocating memory for the factory.
 static void tsi_ssl_handshaker_factory_init(
     tsi_ssl_handshaker_factory* factory) {
-  CHECK_NE(factory, nullptr);
+  ABSL_CHECK_NE(factory, nullptr);

   factory->vtable = &handshaker_factory_vtable;
   gpr_ref_init(&factory->refcount, 1);
@@ -1484,7 +1484,7 @@ static tsi_result ssl_handshaker_result_extract_peer(
     result = peer_property_from_x509_subject(
         verified_root_cert, &peer->properties[peer->property_count], true);
     if (result != TSI_OK) {
-      VLOG(2) << "Problem extracting subject from verified_root_cert. result: "
+      ABSL_VLOG(2) << "Problem extracting subject from verified_root_cert. result: "
               << result;
     }
     peer->property_count++;
@@ -1529,7 +1529,7 @@ static tsi_result ssl_handshaker_result_create_frame_protector(
   protector_impl->buffer =
       static_cast<unsigned char*>(gpr_malloc(protector_impl->buffer_size));
   if (protector_impl->buffer == nullptr) {
-    LOG(ERROR) << "Could not allocate buffer for tsi_ssl_frame_protector.";
+    ABSL_LOG(ERROR) << "Could not allocate buffer for tsi_ssl_frame_protector.";
     gpr_free(protector_impl);
     return TSI_INTERNAL_ERROR;
   }
@@ -1606,7 +1606,7 @@ static tsi_result ssl_handshaker_get_bytes_to_send_to_peer(
     if (error != nullptr) *error = "invalid argument";
     return TSI_INVALID_ARGUMENT;
   }
-  CHECK_LE(*bytes_size, static_cast<size_t>(INT_MAX));
+  ABSL_CHECK_LE(*bytes_size, static_cast<size_t>(INT_MAX));
   bytes_read_from_ssl =
       BIO_read(impl->network_io, bytes, static_cast<int>(*bytes_size));
   if (bytes_read_from_ssl < 0) {
@@ -1662,7 +1662,7 @@ static tsi_result ssl_handshaker_do_handshake(tsi_ssl_handshaker* impl,
           const char* verify_err = X509_verify_cert_error_string(verify_result);
           verify_result_str = absl::StrCat(": ", verify_err);
         }
-        LOG(INFO) << "Handshake failed with error "
+        ABSL_LOG(INFO) << "Handshake failed with error "
                   << grpc_core::SslErrorString(ssl_result) << ": " << err_str
                   << verify_result_str;
         if (error != nullptr) {
@@ -1684,11 +1684,11 @@ static tsi_result ssl_handshaker_process_bytes_from_peer(
     if (error != nullptr) *error = "invalid argument";
     return TSI_INVALID_ARGUMENT;
   }
-  CHECK_LE(*bytes_size, static_cast<size_t>(INT_MAX));
+  ABSL_CHECK_LE(*bytes_size, static_cast<size_t>(INT_MAX));
   bytes_written_into_ssl_size =
       BIO_write(impl->network_io, bytes, static_cast<int>(*bytes_size));
   if (bytes_written_into_ssl_size < 0) {
-    LOG(ERROR) << "Could not write to memory BIO.";
+    ABSL_LOG(ERROR) << "Could not write to memory BIO.";
     if (error != nullptr) *error = "could not write to memory BIO";
     impl->result = TSI_INTERNAL_ERROR;
     return impl->result;
@@ -1728,7 +1728,7 @@ static tsi_result ssl_bytes_remaining(tsi_ssl_handshaker* impl,
   // If an unexpected number of bytes were read, return an error status and
   // free all of the bytes that were read.
   if (bytes_read < 0 || static_cast<size_t>(bytes_read) != bytes_in_ssl) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "Failed to read the expected number of bytes from SSL object.";
     gpr_free(*bytes_remaining);
     *bytes_remaining = nullptr;
@@ -1835,7 +1835,7 @@ static tsi_result ssl_handshaker_next(tsi_handshaker* self,
         ssl_bytes_remaining(impl, &unused_bytes, &unused_bytes_size, error);
     if (status != TSI_OK) return status;
     if (unused_bytes_size > received_bytes_size) {
-      LOG(ERROR) << "More unused bytes than received bytes.";
+      ABSL_LOG(ERROR) << "More unused bytes than received bytes.";
       gpr_free(unused_bytes);
       if (error != nullptr) *error = "More unused bytes than received bytes.";
       return TSI_INTERNAL_ERROR;
@@ -1900,7 +1900,7 @@ static tsi_result create_tsi_ssl_handshaker(SSL_CTX* ctx, int is_client,
   tsi_ssl_handshaker* impl = nullptr;
   *handshaker = nullptr;
   if (ctx == nullptr) {
-    LOG(ERROR) << "SSL Context is null. Should never happen.";
+    ABSL_LOG(ERROR) << "SSL Context is null. Should never happen.";
     return TSI_INTERNAL_ERROR;
   }
   if (ssl == nullptr) {
@@ -1910,7 +1910,7 @@ static tsi_result create_tsi_ssl_handshaker(SSL_CTX* ctx, int is_client,

   if (!BIO_new_bio_pair(&network_io, network_bio_buf_size, &ssl_io,
                         ssl_bio_buf_size)) {
-    LOG(ERROR) << "BIO_new_bio_pair failed.";
+    ABSL_LOG(ERROR) << "BIO_new_bio_pair failed.";
     SSL_free(ssl);
     return TSI_OUT_OF_RESOURCES;
   }
@@ -1923,7 +1923,7 @@ static tsi_result create_tsi_ssl_handshaker(SSL_CTX* ctx, int is_client,
     if (server_name_indication != nullptr &&
         !looks_like_ip_address(server_name_indication)) {
       if (!SSL_set_tlsext_host_name(ssl, server_name_indication)) {
-        LOG(ERROR) << "Invalid server name indication "
+        ABSL_LOG(ERROR) << "Invalid server name indication "
                    << server_name_indication;
         SSL_free(ssl);
         BIO_free(network_io);
@@ -1940,7 +1940,7 @@ static tsi_result create_tsi_ssl_handshaker(SSL_CTX* ctx, int is_client,
     ssl_result = SSL_do_handshake(ssl);
     ssl_result = SSL_get_error(ssl, ssl_result);
     if (ssl_result != SSL_ERROR_WANT_READ) {
-      LOG(ERROR)
+      ABSL_LOG(ERROR)
           << "Unexpected error received from first SSL_do_handshake call: "
           << grpc_core::SslErrorString(ssl_result);
       SSL_free(ssl);
@@ -2099,7 +2099,7 @@ static int does_entry_match_name(absl::string_view entry,

   // Wildchar subdomain matching.
   if (entry.size() < 3 || entry[1] != '.') {  // At least *.x
-    LOG(ERROR) << "Invalid wildchar entry.";
+    ABSL_LOG(ERROR) << "Invalid wildchar entry.";
     return 0;
   }
   size_t name_subdomain_pos = name.find('.');
@@ -2110,7 +2110,7 @@ static int does_entry_match_name(absl::string_view entry,
   entry.remove_prefix(2);                   // Remove *.
   size_t dot = name_subdomain.find('.');
   if (dot == absl::string_view::npos || dot == name_subdomain.size() - 1) {
-    LOG(ERROR) << "Invalid toplevel subdomain: " << name_subdomain;
+    ABSL_LOG(ERROR) << "Invalid toplevel subdomain: " << name_subdomain;
     return 0;
   }
   if (name_subdomain.back() == '.') {
@@ -2137,7 +2137,7 @@ static int ssl_server_handshaker_factory_servername_callback(SSL* ssl,
       return SSL_TLSEXT_ERR_OK;
     }
   }
-  LOG(ERROR) << "No match found for server name: " << servername;
+  ABSL_LOG(ERROR) << "No match found for server name: " << servername;
   return SSL_TLSEXT_ERR_NOACK;
 }

@@ -2158,7 +2158,7 @@ static int server_handshaker_factory_npn_advertised_callback(
   tsi_ssl_server_handshaker_factory* factory =
       static_cast<tsi_ssl_server_handshaker_factory*>(arg);
   *out = factory->alpn_protocol_list;
-  CHECK(factory->alpn_protocol_list_length <= UINT_MAX);
+  ABSL_CHECK(factory->alpn_protocol_list_length <= UINT_MAX);
   *outlen = static_cast<unsigned int>(factory->alpn_protocol_list_length);
   return SSL_TLSEXT_ERR_OK;
 }
@@ -2192,7 +2192,7 @@ static int server_handshaker_factory_new_session_callback(
 template <typename T>
 static void ssl_keylogging_callback(const SSL* ssl, const char* info) {
   SSL_CTX* ssl_context = SSL_get_SSL_CTX(ssl);
-  CHECK_NE(ssl_context, nullptr);
+  ABSL_CHECK_NE(ssl_context, nullptr);
   void* arg = SSL_CTX_get_ex_data(ssl_context, g_ssl_ctx_ex_factory_index);
   T* factory = static_cast<T*>(arg);
   factory->key_logger->LogSessionKeys(ssl_context, info);
@@ -2244,7 +2244,7 @@ tsi_result tsi_create_ssl_client_handshaker_factory_with_options(
 #endif
   if (ssl_context == nullptr) {
     grpc_core::LogSslErrorStack();
-    LOG(ERROR) << "Could not create ssl context.";
+    ABSL_LOG(ERROR) << "Could not create ssl context.";
     return TSI_INVALID_ARGUMENT;
   }

@@ -2311,7 +2311,7 @@ tsi_result tsi_create_ssl_client_handshaker_factory_with_options(

       X509_VERIFY_PARAM_set_depth(param, kMaxChainLength);
       if (result != TSI_OK) {
-        LOG(ERROR) << "Cannot load server root certificates.";
+        ABSL_LOG(ERROR) << "Cannot load server root certificates.";
         break;
       }
     }
@@ -2321,16 +2321,16 @@ tsi_result tsi_create_ssl_client_handshaker_factory_with_options(
           options->alpn_protocols, options->num_alpn_protocols,
           &impl->alpn_protocol_list, &impl->alpn_protocol_list_length);
       if (result != TSI_OK) {
-        LOG(ERROR) << "Building alpn list failed with error "
+        ABSL_LOG(ERROR) << "Building alpn list failed with error "
                    << tsi_result_to_string(result);
         break;
       }
 #if TSI_OPENSSL_ALPN_SUPPORT
-      CHECK(impl->alpn_protocol_list_length < UINT_MAX);
+      ABSL_CHECK(impl->alpn_protocol_list_length < UINT_MAX);
       if (SSL_CTX_set_alpn_protos(
               ssl_context, impl->alpn_protocol_list,
               static_cast<unsigned int>(impl->alpn_protocol_list_length))) {
-        LOG(ERROR) << "Could not set alpn protocol list to context.";
+        ABSL_LOG(ERROR) << "Could not set alpn protocol list to context.";
         result = TSI_INVALID_ARGUMENT;
         break;
       }
@@ -2360,7 +2360,7 @@ tsi_result tsi_create_ssl_client_handshaker_factory_with_options(
     X509_STORE_set_verify_cb(cert_store, verify_cb);
     if (!X509_STORE_load_locations(cert_store, nullptr,
                                    options->crl_directory)) {
-      LOG(ERROR) << "Failed to load CRL File from directory.";
+      ABSL_LOG(ERROR) << "Failed to load CRL File from directory.";
     } else {
       X509_VERIFY_PARAM* param = X509_STORE_get0_param(cert_store);
       X509_VERIFY_PARAM_set_flags(
@@ -2465,7 +2465,7 @@ tsi_result tsi_create_ssl_server_handshaker_factory_with_options(
 #endif
       if (impl->ssl_contexts[i] == nullptr) {
         grpc_core::LogSslErrorStack();
-        LOG(ERROR) << "Could not create ssl context.";
+        ABSL_LOG(ERROR) << "Could not create ssl context.";
         result = TSI_OUT_OF_RESOURCES;
         break;
       }
@@ -2487,7 +2487,7 @@ tsi_result tsi_create_ssl_server_handshaker_factory_with_options(
           impl->ssl_contexts[i], kSslSessionIdContext,
           GPR_ARRAY_SIZE(kSslSessionIdContext));
       if (set_sid_ctx_result == 0) {
-        LOG(ERROR) << "Failed to set session id context.";
+        ABSL_LOG(ERROR) << "Failed to set session id context.";
         result = TSI_INTERNAL_ERROR;
         break;
       }
@@ -2497,7 +2497,7 @@ tsi_result tsi_create_ssl_server_handshaker_factory_with_options(
                 impl->ssl_contexts[i],
                 const_cast<char*>(options->session_ticket_key),
                 options->session_ticket_key_size) == 0) {
-          LOG(ERROR) << "Invalid STEK size.";
+          ABSL_LOG(ERROR) << "Invalid STEK size.";
           result = TSI_INVALID_ARGUMENT;
           break;
         }
@@ -2510,7 +2510,7 @@ tsi_result tsi_create_ssl_server_handshaker_factory_with_options(
             strlen(options->pem_client_root_certs),
             options->send_client_ca_list ? &root_names : nullptr);
         if (result != TSI_OK) {
-          LOG(ERROR) << "Invalid verification certs.";
+          ABSL_LOG(ERROR) << "Invalid verification certs.";
           break;
         }
         if (options->send_client_ca_list) {
@@ -2558,7 +2558,7 @@ tsi_result tsi_create_ssl_server_handshaker_factory_with_options(
         X509_STORE_set_verify_cb(cert_store, verify_cb);
         if (!X509_STORE_load_locations(cert_store, nullptr,
                                        options->crl_directory)) {
-          LOG(ERROR) << "Failed to load CRL File from directory.";
+          ABSL_LOG(ERROR) << "Failed to load CRL File from directory.";
         } else {
           X509_VERIFY_PARAM* param = X509_STORE_get0_param(cert_store);
           X509_VERIFY_PARAM_set_flags(
@@ -2654,8 +2654,8 @@ int tsi_ssl_peer_matches_name(const tsi_peer* peer, absl::string_view name) {
 const tsi_ssl_handshaker_factory_vtable* tsi_ssl_handshaker_factory_swap_vtable(
     tsi_ssl_handshaker_factory* factory,
     tsi_ssl_handshaker_factory_vtable* new_vtable) {
-  CHECK_NE(factory, nullptr);
-  CHECK_NE(factory->vtable, nullptr);
+  ABSL_CHECK_NE(factory, nullptr);
+  ABSL_CHECK_NE(factory->vtable, nullptr);

   const tsi_ssl_handshaker_factory_vtable* orig_vtable = factory->vtable;
   factory->vtable = new_vtable;
diff --git a/third_party/grpc/source/src/core/tsi/ssl_transport_security_utils.cc b/third_party/grpc/source/src/core/tsi/ssl_transport_security_utils.cc
index 5c3b828751ebc..0dbfbd9615b1b 100644
--- a/third_party/grpc/source/src/core/tsi/ssl_transport_security_utils.cc
+++ b/third_party/grpc/source/src/core/tsi/ssl_transport_security_utils.cc
@@ -30,8 +30,8 @@
 #include <openssl/x509.h>
 #include <openssl/x509v3.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "src/core/tsi/transport_security_interface.h"
@@ -68,24 +68,24 @@ void LogSslErrorStack(void) {
   while ((err = ERR_get_error()) != 0) {
     char details[256];
     ERR_error_string_n(static_cast<uint32_t>(err), details, sizeof(details));
-    LOG(ERROR) << details;
+    ABSL_LOG(ERROR) << details;
   }
 }

 tsi_result DoSslWrite(SSL* ssl, unsigned char* unprotected_bytes,
                       size_t unprotected_bytes_size) {
-  CHECK_LE(unprotected_bytes_size, static_cast<size_t>(INT_MAX));
+  ABSL_CHECK_LE(unprotected_bytes_size, static_cast<size_t>(INT_MAX));
   ERR_clear_error();
   int ssl_write_result = SSL_write(ssl, unprotected_bytes,
                                    static_cast<int>(unprotected_bytes_size));
   if (ssl_write_result < 0) {
     ssl_write_result = SSL_get_error(ssl, ssl_write_result);
     if (ssl_write_result == SSL_ERROR_WANT_READ) {
-      LOG(ERROR)
+      ABSL_LOG(ERROR)
           << "Peer tried to renegotiate SSL connection. This is unsupported.";
       return TSI_UNIMPLEMENTED;
     } else {
-      LOG(ERROR) << "SSL_write failed with error "
+      ABSL_LOG(ERROR) << "SSL_write failed with error "
                  << SslErrorString(ssl_write_result);
       return TSI_INTERNAL_ERROR;
     }
@@ -95,7 +95,7 @@ tsi_result DoSslWrite(SSL* ssl, unsigned char* unprotected_bytes,

 tsi_result DoSslRead(SSL* ssl, unsigned char* unprotected_bytes,
                      size_t* unprotected_bytes_size) {
-  CHECK_LE(*unprotected_bytes_size, static_cast<size_t>(INT_MAX));
+  ABSL_CHECK_LE(*unprotected_bytes_size, static_cast<size_t>(INT_MAX));
   ERR_clear_error();
   int read_from_ssl = SSL_read(ssl, unprotected_bytes,
                                static_cast<int>(*unprotected_bytes_size));
@@ -107,15 +107,15 @@ tsi_result DoSslRead(SSL* ssl, unsigned char* unprotected_bytes,
         *unprotected_bytes_size = 0;
         return TSI_OK;
       case SSL_ERROR_WANT_WRITE:
-        LOG(ERROR)
+        ABSL_LOG(ERROR)
             << "Peer tried to renegotiate SSL connection. This is unsupported.";
         return TSI_UNIMPLEMENTED;
       case SSL_ERROR_SSL:
-        LOG(ERROR) << "Corruption detected.";
+        ABSL_LOG(ERROR) << "Corruption detected.";
         LogSslErrorStack();
         return TSI_DATA_CORRUPTED;
       default:
-        LOG(ERROR) << "SSL_read failed with error "
+        ABSL_LOG(ERROR) << "SSL_read failed with error "
                    << SslErrorString(read_from_ssl);
         return TSI_PROTOCOL_FAILURE;
     }
@@ -139,11 +139,11 @@ tsi_result SslProtectorProtect(const unsigned char* unprotected_bytes,
   int pending_in_ssl = static_cast<int>(BIO_pending(network_io));
   if (pending_in_ssl > 0) {
     *unprotected_bytes_size = 0;
-    CHECK_LE(*protected_output_frames_size, static_cast<size_t>(INT_MAX));
+    ABSL_CHECK_LE(*protected_output_frames_size, static_cast<size_t>(INT_MAX));
     read_from_ssl = BIO_read(network_io, protected_output_frames,
                              static_cast<int>(*protected_output_frames_size));
     if (read_from_ssl < 0) {
-      LOG(ERROR) << "Could not read from BIO even though some data is pending";
+      ABSL_LOG(ERROR) << "Could not read from BIO even though some data is pending";
       return TSI_INTERNAL_ERROR;
     }
     *protected_output_frames_size = static_cast<size_t>(read_from_ssl);
@@ -165,11 +165,11 @@ tsi_result SslProtectorProtect(const unsigned char* unprotected_bytes,
   result = DoSslWrite(ssl, buffer, buffer_size);
   if (result != TSI_OK) return result;

-  CHECK_LE(*protected_output_frames_size, static_cast<size_t>(INT_MAX));
+  ABSL_CHECK_LE(*protected_output_frames_size, static_cast<size_t>(INT_MAX));
   read_from_ssl = BIO_read(network_io, protected_output_frames,
                            static_cast<int>(*protected_output_frames_size));
   if (read_from_ssl < 0) {
-    LOG(ERROR) << "Could not read from BIO after SSL_write.";
+    ABSL_LOG(ERROR) << "Could not read from BIO after SSL_write.";
     return TSI_INTERNAL_ERROR;
   }
   *protected_output_frames_size = static_cast<size_t>(read_from_ssl);
@@ -195,20 +195,20 @@ tsi_result SslProtectorProtectFlush(size_t& buffer_offset,
   }

   pending = static_cast<int>(BIO_pending(network_io));
-  CHECK_GE(pending, 0);
+  ABSL_CHECK_GE(pending, 0);
   *still_pending_size = static_cast<size_t>(pending);
   if (*still_pending_size == 0) return TSI_OK;

-  CHECK_LE(*protected_output_frames_size, static_cast<size_t>(INT_MAX));
+  ABSL_CHECK_LE(*protected_output_frames_size, static_cast<size_t>(INT_MAX));
   read_from_ssl = BIO_read(network_io, protected_output_frames,
                            static_cast<int>(*protected_output_frames_size));
   if (read_from_ssl <= 0) {
-    LOG(ERROR) << "Could not read from BIO after SSL_write.";
+    ABSL_LOG(ERROR) << "Could not read from BIO after SSL_write.";
     return TSI_INTERNAL_ERROR;
   }
   *protected_output_frames_size = static_cast<size_t>(read_from_ssl);
   pending = static_cast<int>(BIO_pending(network_io));
-  CHECK_GE(pending, 0);
+  ABSL_CHECK_GE(pending, 0);
   *still_pending_size = static_cast<size_t>(pending);
   return TSI_OK;
 }
@@ -236,11 +236,11 @@ tsi_result SslProtectorUnprotect(const unsigned char* protected_frames_bytes,
   *unprotected_bytes_size = output_bytes_size - output_bytes_offset;

   // Then, try to write some data to ssl.
-  CHECK_LE(*protected_frames_bytes_size, static_cast<size_t>(INT_MAX));
+  ABSL_CHECK_LE(*protected_frames_bytes_size, static_cast<size_t>(INT_MAX));
   written_into_ssl = BIO_write(network_io, protected_frames_bytes,
                                static_cast<int>(*protected_frames_bytes_size));
   if (written_into_ssl < 0) {
-    LOG(ERROR) << "Sending protected frame to ssl failed with "
+    ABSL_LOG(ERROR) << "Sending protected frame to ssl failed with "
                << written_into_ssl;
     return TSI_INTERNAL_ERROR;
   }
@@ -263,15 +263,15 @@ bool VerifyCrlSignature(X509_CRL* crl, X509* issuer) {
   if (ikey == nullptr) {
     // Can't verify signature because we couldn't get the pubkey, fail the
     // check.
-    VLOG(2) << "Could not get public key from certificate.";
+    ABSL_VLOG(2) << "Could not get public key from certificate.";
     EVP_PKEY_free(ikey);
     return false;
   }
   int ret = X509_CRL_verify(crl, ikey);
   if (ret < 0) {
-    VLOG(2) << "There was an unexpected problem checking the CRL signature.";
+    ABSL_VLOG(2) << "There was an unexpected problem checking the CRL signature.";
   } else if (ret == 0) {
-    VLOG(2) << "CRL failed verification.";
+    ABSL_VLOG(2) << "CRL failed verification.";
   }
   EVP_PKEY_free(ikey);
   return ret == 1;
diff --git a/third_party/grpc/source/src/core/util/alloc.cc b/third_party/grpc/source/src/core/util/alloc.cc
index 2ce94f9db7834..1cb9700b7088c 100644
--- a/third_party/grpc/source/src/core/util/alloc.cc
+++ b/third_party/grpc/source/src/core/util/alloc.cc
@@ -21,7 +21,7 @@
 #include <stdlib.h>
 #include <string.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/util/crash.h"

 void* gpr_malloc(size_t size) {
@@ -57,7 +57,7 @@ void* gpr_realloc(void* p, size_t size) {
 }

 void* gpr_malloc_aligned(size_t size, size_t alignment) {
-  CHECK_EQ(((alignment - 1) & alignment), 0u);  // Must be power of 2.
+  ABSL_CHECK_EQ(((alignment - 1) & alignment), 0u);  // Must be power of 2.
   size_t extra = alignment - 1 + sizeof(void*);
   void* p = gpr_malloc(size + extra);
   void** ret = reinterpret_cast<void**>(
diff --git a/third_party/grpc/source/src/core/util/chunked_vector.h b/third_party/grpc/source/src/core/util/chunked_vector.h
index d3a1d6ba93002..927839a24ab71 100644
--- a/third_party/grpc/source/src/core/util/chunked_vector.h
+++ b/third_party/grpc/source/src/core/util/chunked_vector.h
@@ -21,7 +21,7 @@
 #include <iterator>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/resource_quota/arena.h"
 #include "src/core/util/manual_constructor.h"

@@ -86,9 +86,9 @@ class ChunkedVector {

   // Remove the last element and return it.
   T PopBack() {
-    CHECK_NE(append_, nullptr);
+    ABSL_CHECK_NE(append_, nullptr);
     if (append_->count == 0) {
-      CHECK(first_ != append_);
+      ABSL_CHECK(first_ != append_);
       Chunk* chunk = first_;
       while (chunk->next != append_) {
         chunk = chunk->next;
@@ -234,7 +234,7 @@ class ChunkedVector {
  private:
   ManualConstructor<T>* AppendSlot() {
     if (append_ == nullptr) {
-      CHECK_EQ(first_, nullptr);
+      ABSL_CHECK_EQ(first_, nullptr);
       first_ = arena_->New<Chunk>();
       append_ = first_;
     } else if (append_->count == kChunkSize) {
diff --git a/third_party/grpc/source/src/core/util/crash.cc b/third_party/grpc/source/src/core/util/crash.cc
index c77412e2b96ac..66d1e21dab824 100644
--- a/third_party/grpc/source/src/core/util/crash.cc
+++ b/third_party/grpc/source/src/core/util/crash.cc
@@ -20,13 +20,13 @@

 #include <string>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"

 namespace grpc_core {

 void Crash(absl::string_view message, SourceLocation location) {
-  LOG(ERROR).AtLocation(location.file(), location.line()) << message;
+  ABSL_LOG(ERROR).AtLocation(location.file(), location.line()) << message;
   abort();
 }

diff --git a/third_party/grpc/source/src/core/util/down_cast.h b/third_party/grpc/source/src/core/util/down_cast.h
index b658f5bab38e8..e46a2f90916eb 100644
--- a/third_party/grpc/source/src/core/util/down_cast.h
+++ b/third_party/grpc/source/src/core/util/down_cast.h
@@ -20,7 +20,7 @@
 #include <type_traits>

 #include "absl/base/config.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 namespace grpc_core {

@@ -32,7 +32,7 @@ GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline To DownCast(From* f) {
 // If we have RTTI & we're in debug, assert that the cast is legal.
 #if ABSL_INTERNAL_HAS_RTTI
 #ifndef NDEBUG
-  if (f != nullptr) CHECK_NE(dynamic_cast<To>(f), nullptr);
+  if (f != nullptr) ABSL_CHECK_NE(dynamic_cast<To>(f), nullptr);
 #endif
 #endif
   return static_cast<To>(f);
diff --git a/third_party/grpc/source/src/core/util/dual_ref_counted.h b/third_party/grpc/source/src/core/util/dual_ref_counted.h
index 4742c62bc2c6c..953035b18220f 100644
--- a/third_party/grpc/source/src/core/util/dual_ref_counted.h
+++ b/third_party/grpc/source/src/core/util/dual_ref_counted.h
@@ -22,8 +22,8 @@
 #include <atomic>
 #include <cstdint>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/util/debug_location.h"
 #include "src/core/util/down_cast.h"
 #include "src/core/util/orphanable.h"
@@ -92,11 +92,11 @@ class DualRefCounted : public Impl {
 #ifndef NDEBUG
     const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
     if (trace_ != nullptr) {
-      VLOG(2) << trace_ << ":" << this << " unref " << strong_refs << " -> "
+      ABSL_VLOG(2) << trace_ << ":" << this << " unref " << strong_refs << " -> "
               << strong_refs - 1 << ", weak_ref " << weak_refs << " -> "
               << weak_refs + 1;
     }
-    CHECK_GT(strong_refs, 0u);
+    ABSL_CHECK_GT(strong_refs, 0u);
 #endif
     if (GPR_UNLIKELY(strong_refs == 1)) {
       Orphaned();
@@ -111,12 +111,12 @@ class DualRefCounted : public Impl {
 #ifndef NDEBUG
     const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
     if (trace_ != nullptr) {
-      VLOG(2) << trace_ << ":" << this << " " << location.file() << ":"
+      ABSL_VLOG(2) << trace_ << ":" << this << " " << location.file() << ":"
               << location.line() << " unref " << strong_refs << " -> "
               << strong_refs - 1 << ", weak_ref " << weak_refs << " -> "
               << weak_refs + 1 << ") " << reason;
     }
-    CHECK_GT(strong_refs, 0u);
+    ABSL_CHECK_GT(strong_refs, 0u);
 #else
     // Avoid unused-parameter warnings for debug-only parameters
     (void)location;
@@ -136,7 +136,7 @@ class DualRefCounted : public Impl {
 #ifndef NDEBUG
       const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
       if (trace_ != nullptr) {
-        VLOG(2) << trace_ << ":" << this << " ref_if_non_zero " << strong_refs
+        ABSL_VLOG(2) << trace_ << ":" << this << " ref_if_non_zero " << strong_refs
                 << " -> " << strong_refs + 1 << " (weak_refs=" << weak_refs
                 << ")";
       }
@@ -155,7 +155,7 @@ class DualRefCounted : public Impl {
 #ifndef NDEBUG
       const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
       if (trace_ != nullptr) {
-        VLOG(2) << trace_ << ":" << this << " " << location.file() << ":"
+        ABSL_VLOG(2) << trace_ << ":" << this << " " << location.file() << ":"
                 << location.line() << " ref_if_non_zero " << strong_refs
                 << " -> " << strong_refs + 1 << " (weak_refs=" << weak_refs
                 << ") " << reason;
@@ -213,10 +213,10 @@ class DualRefCounted : public Impl {
     const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
     const uint32_t strong_refs = GetStrongRefs(prev_ref_pair);
     if (trace != nullptr) {
-      VLOG(2) << trace << ":" << this << " weak_unref " << weak_refs << " -> "
+      ABSL_VLOG(2) << trace << ":" << this << " weak_unref " << weak_refs << " -> "
               << weak_refs - 1 << " (refs=" << strong_refs << ")";
     }
-    CHECK_GT(weak_refs, 0u);
+    ABSL_CHECK_GT(weak_refs, 0u);
 #endif
     if (GPR_UNLIKELY(prev_ref_pair == MakeRefPair(0, 1))) {
       unref_behavior_(static_cast<Child*>(this));
@@ -235,11 +235,11 @@ class DualRefCounted : public Impl {
     const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
     const uint32_t strong_refs = GetStrongRefs(prev_ref_pair);
     if (trace != nullptr) {
-      VLOG(2) << trace << ":" << this << " " << location.file() << ":"
+      ABSL_VLOG(2) << trace << ":" << this << " " << location.file() << ":"
               << location.line() << " weak_unref " << weak_refs << " -> "
               << weak_refs - 1 << " (refs=" << strong_refs << ") " << reason;
     }
-    CHECK_GT(weak_refs, 0u);
+    ABSL_CHECK_GT(weak_refs, 0u);
 #else
     // Avoid unused-parameter warnings for debug-only parameters
     (void)location;
@@ -298,9 +298,9 @@ class DualRefCounted : public Impl {
         refs_.fetch_add(MakeRefPair(1, 0), std::memory_order_relaxed);
     const uint32_t strong_refs = GetStrongRefs(prev_ref_pair);
     const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
-    CHECK_NE(strong_refs, 0u);
+    ABSL_CHECK_NE(strong_refs, 0u);
     if (trace_ != nullptr) {
-      VLOG(2) << trace_ << ":" << this << " ref " << strong_refs << " -> "
+      ABSL_VLOG(2) << trace_ << ":" << this << " ref " << strong_refs << " -> "
               << strong_refs + 1 << "; (weak_refs=" << weak_refs << ")";
     }
 #else
@@ -313,9 +313,9 @@ class DualRefCounted : public Impl {
         refs_.fetch_add(MakeRefPair(1, 0), std::memory_order_relaxed);
     const uint32_t strong_refs = GetStrongRefs(prev_ref_pair);
     const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
-    CHECK_NE(strong_refs, 0u);
+    ABSL_CHECK_NE(strong_refs, 0u);
     if (trace_ != nullptr) {
-      VLOG(2) << trace_ << ":" << this << " " << location.file() << ":"
+      ABSL_VLOG(2) << trace_ << ":" << this << " " << location.file() << ":"
               << location.line() << " ref " << strong_refs << " -> "
               << strong_refs + 1 << " (weak_refs=" << weak_refs << ") "
               << reason;
@@ -335,10 +335,10 @@ class DualRefCounted : public Impl {
     const uint32_t strong_refs = GetStrongRefs(prev_ref_pair);
     const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
     if (trace_ != nullptr) {
-      VLOG(2) << trace_ << ":" << this << " weak_ref " << weak_refs << " -> "
+      ABSL_VLOG(2) << trace_ << ":" << this << " weak_ref " << weak_refs << " -> "
               << weak_refs + 1 << "; (refs=" << strong_refs << ")";
     }
-    if (strong_refs == 0) CHECK_NE(weak_refs, 0u);
+    if (strong_refs == 0) ABSL_CHECK_NE(weak_refs, 0u);
 #else
     refs_.fetch_add(MakeRefPair(0, 1), std::memory_order_relaxed);
 #endif
@@ -351,11 +351,11 @@ class DualRefCounted : public Impl {
     const uint32_t strong_refs = GetStrongRefs(prev_ref_pair);
     const uint32_t weak_refs = GetWeakRefs(prev_ref_pair);
     if (trace_ != nullptr) {
-      VLOG(2) << trace_ << ":" << this << " " << location.file() << ":"
+      ABSL_VLOG(2) << trace_ << ":" << this << " " << location.file() << ":"
               << location.line() << " weak_ref " << weak_refs << " -> "
               << weak_refs + 1 << " (refs=" << strong_refs << ") " << reason;
     }
-    if (strong_refs == 0) CHECK_NE(weak_refs, 0u);
+    if (strong_refs == 0) ABSL_CHECK_NE(weak_refs, 0u);
 #else
     // Use conditionally-important parameters
     (void)location;
diff --git a/third_party/grpc/source/src/core/util/dump_args.cc b/third_party/grpc/source/src/core/util/dump_args.cc
index bd82483bfcd95..515536a500ef9 100644
--- a/third_party/grpc/source/src/core/util/dump_args.cc
+++ b/third_party/grpc/source/src/core/util/dump_args.cc
@@ -14,7 +14,7 @@

 #include "src/core/util/dump_args.h"

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/ascii.h"
 #include "absl/strings/string_view.h"

@@ -41,7 +41,7 @@ void DumpArgs::Stringify(CustomSink& sink) const {
     }
   }
   keys.push_back(start);
-  CHECK_EQ(keys.size(), arg_dumpers_.size());
+  ABSL_CHECK_EQ(keys.size(), arg_dumpers_.size());
   for (size_t i = 0; i < keys.size(); i++) {
     if (i != 0) sink.Append(", ");
     sink.Append(absl::StripAsciiWhitespace(keys[i]));
diff --git a/third_party/grpc/source/src/core/util/dump_args.h b/third_party/grpc/source/src/core/util/dump_args.h
index 8e1d44335cb86..dbc6eae34dc6f 100644
--- a/third_party/grpc/source/src/core/util/dump_args.h
+++ b/third_party/grpc/source/src/core/util/dump_args.h
@@ -105,7 +105,7 @@ class DumpArgs {
 // Usage:
 //   int a = 1;
 //   int b = 2;
-//   LOG(INFO) << GRPC_DUMP_ARGS(a, b)
+//   ABSL_LOG(INFO) << GRPC_DUMP_ARGS(a, b)
 // Output:
 //   a = 1, b = 2
 #define GRPC_DUMP_ARGS(...) \
diff --git a/third_party/grpc/source/src/core/util/event_log.cc b/third_party/grpc/source/src/core/util/event_log.cc
index 66611150e6fa0..c2edb636e8632 100644
--- a/third_party/grpc/source/src/core/util/event_log.cc
+++ b/third_party/grpc/source/src/core/util/event_log.cc
@@ -19,7 +19,7 @@
 #include <algorithm>
 #include <atomic>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_join.h"

@@ -28,7 +28,7 @@ namespace grpc_core {
 std::atomic<EventLog*> EventLog::g_instance_{nullptr};

 EventLog::~EventLog() {
-  CHECK(g_instance_.load(std::memory_order_acquire) != this);
+  ABSL_CHECK(g_instance_.load(std::memory_order_acquire) != this);
 }

 void EventLog::BeginCollection() {
diff --git a/third_party/grpc/source/src/core/util/gcp_metadata_query.cc b/third_party/grpc/source/src/core/util/gcp_metadata_query.cc
index cc9fd80cd1b45..770c88aa1586a 100644
--- a/third_party/grpc/source/src/core/util/gcp_metadata_query.cc
+++ b/third_party/grpc/source/src/core/util/gcp_metadata_query.cc
@@ -27,8 +27,8 @@
 #include <memory>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_format.h"
@@ -70,7 +70,7 @@ GcpMetadataQuery::GcpMetadataQuery(
   GRPC_CLOSURE_INIT(&on_done_, OnDone, this, nullptr);
   auto uri = URI::Create("http", std::move(metadata_server_name), attribute_,
                          {} /* query params */, "" /* fragment */);
-  CHECK(uri.ok());  // params are hardcoded
+  ABSL_CHECK(uri.ok());  // params are hardcoded
   grpc_http_request request;
   memset(&request, 0, sizeof(grpc_http_request));
   grpc_http_header header = {const_cast<char*>("Metadata-Flavor"),
diff --git a/third_party/grpc/source/src/core/util/gpr_time.cc b/third_party/grpc/source/src/core/util/gpr_time.cc
index 657da132f5eb1..115f2d467d0f8 100644
--- a/third_party/grpc/source/src/core/util/gpr_time.cc
+++ b/third_party/grpc/source/src/core/util/gpr_time.cc
@@ -24,11 +24,11 @@
 #include <stdio.h>
 #include <string.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 int gpr_time_cmp(gpr_timespec a, gpr_timespec b) {
   int cmp = (a.tv_sec > b.tv_sec) - (a.tv_sec < b.tv_sec);
-  CHECK(a.clock_type == b.clock_type);
+  ABSL_CHECK(a.clock_type == b.clock_type);
   if (cmp == 0 && a.tv_sec != INT64_MAX && a.tv_sec != INT64_MIN) {
     cmp = (a.tv_nsec > b.tv_nsec) - (a.tv_nsec < b.tv_nsec);
   }
@@ -76,7 +76,7 @@ static gpr_timespec to_seconds_from_sub_second_time(int64_t time_in_units,
   } else if (time_in_units == INT64_MIN) {
     out = gpr_inf_past(type);
   } else {
-    DCHECK_EQ(GPR_NS_PER_SEC % units_per_sec, 0);
+    ABSL_DCHECK_EQ(GPR_NS_PER_SEC % units_per_sec, 0);

     out.tv_sec = time_in_units / units_per_sec;
     out.tv_nsec =
@@ -136,11 +136,11 @@ gpr_timespec gpr_time_from_hours(int64_t h, gpr_clock_type clock_type) {
 gpr_timespec gpr_time_add(gpr_timespec a, gpr_timespec b) {
   gpr_timespec sum;
   int64_t inc = 0;
-  CHECK(b.clock_type == GPR_TIMESPAN);
+  ABSL_CHECK(b.clock_type == GPR_TIMESPAN);
   // tv_nsec in a timespan is always +ve. -ve timespan is represented as (-ve
   // tv_sec, +ve tv_nsec). For example, timespan = -2.5 seconds is represented
   // as {-3, 5e8, GPR_TIMESPAN}
-  CHECK_GE(b.tv_nsec, 0);
+  ABSL_CHECK_GE(b.tv_nsec, 0);
   sum.clock_type = a.clock_type;
   sum.tv_nsec = a.tv_nsec + b.tv_nsec;
   if (sum.tv_nsec >= GPR_NS_PER_SEC) {
@@ -174,9 +174,9 @@ gpr_timespec gpr_time_sub(gpr_timespec a, gpr_timespec b) {
     // tv_nsec in a timespan is always +ve. -ve timespan is represented as (-ve
     // tv_sec, +ve tv_nsec). For example, timespan = -2.5 seconds is represented
     // as {-3, 5e8, GPR_TIMESPAN}
-    CHECK_GE(b.tv_nsec, 0);
+    ABSL_CHECK_GE(b.tv_nsec, 0);
   } else {
-    CHECK(a.clock_type == b.clock_type);
+    ABSL_CHECK(a.clock_type == b.clock_type);
     diff.clock_type = GPR_TIMESPAN;
   }
   diff.tv_nsec = a.tv_nsec - b.tv_nsec;
@@ -207,8 +207,8 @@ gpr_timespec gpr_time_sub(gpr_timespec a, gpr_timespec b) {
 int gpr_time_similar(gpr_timespec a, gpr_timespec b, gpr_timespec threshold) {
   int cmp_ab;

-  CHECK(a.clock_type == b.clock_type);
-  CHECK(threshold.clock_type == GPR_TIMESPAN);
+  ABSL_CHECK(a.clock_type == b.clock_type);
+  ABSL_CHECK(threshold.clock_type == GPR_TIMESPAN);

   cmp_ab = gpr_time_cmp(a, b);
   if (cmp_ab == 0) return 1;
diff --git a/third_party/grpc/source/src/core/util/grpc_if_nametoindex_posix.cc b/third_party/grpc/source/src/core/util/grpc_if_nametoindex_posix.cc
index 1d5b866e5e044..f77fcddef3a24 100644
--- a/third_party/grpc/source/src/core/util/grpc_if_nametoindex_posix.cc
+++ b/third_party/grpc/source/src/core/util/grpc_if_nametoindex_posix.cc
@@ -25,14 +25,14 @@
 #include <errno.h>
 #include <net/if.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/util/crash.h"
 #include "src/core/util/grpc_if_nametoindex.h"

 uint32_t grpc_if_nametoindex(char* name) {
   uint32_t out = if_nametoindex(name);
   if (out == 0) {
-    VLOG(2) << "if_nametoindex failed for name " << name << ". errno " << errno;
+    ABSL_VLOG(2) << "if_nametoindex failed for name " << name << ". errno " << errno;
   }
   return out;
 }
diff --git a/third_party/grpc/source/src/core/util/grpc_if_nametoindex_unsupported.cc b/third_party/grpc/source/src/core/util/grpc_if_nametoindex_unsupported.cc
index cabca947c60c7..7db85c8187fd8 100644
--- a/third_party/grpc/source/src/core/util/grpc_if_nametoindex_unsupported.cc
+++ b/third_party/grpc/source/src/core/util/grpc_if_nametoindex_unsupported.cc
@@ -22,12 +22,12 @@

 #if GRPC_IF_NAMETOINDEX == 0 || !defined(GRPC_POSIX_SOCKET_IF_NAMETOINDEX)

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/util/crash.h"
 #include "src/core/util/grpc_if_nametoindex.h"

 uint32_t grpc_if_nametoindex(char* name) {
-  VLOG(2) << "Not attempting to convert interface name " << name
+  ABSL_VLOG(2) << "Not attempting to convert interface name " << name
           << " to index for current platform.";
   return 0;
 }
diff --git a/third_party/grpc/source/src/core/util/host_port.cc b/third_party/grpc/source/src/core/util/host_port.cc
index 3f2608951e361..980a57be773bc 100644
--- a/third_party/grpc/source/src/core/util/host_port.cc
+++ b/third_party/grpc/source/src/core/util/host_port.cc
@@ -21,7 +21,7 @@
 #include <grpc/support/port_platform.h>
 #include <stddef.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_format.h"
 #include "absl/strings/string_view.h"

@@ -91,10 +91,10 @@ bool SplitHostPort(absl::string_view name, absl::string_view* host,

 bool SplitHostPort(absl::string_view name, std::string* host,
                    std::string* port) {
-  DCHECK(host != nullptr);
-  DCHECK(host->empty());
-  DCHECK(port != nullptr);
-  DCHECK(port->empty());
+  ABSL_DCHECK(host != nullptr);
+  ABSL_DCHECK(host->empty());
+  ABSL_DCHECK(port != nullptr);
+  ABSL_DCHECK(port->empty());
   absl::string_view host_view;
   absl::string_view port_view;
   bool has_port;
diff --git a/third_party/grpc/source/src/core/util/http_client/httpcli.cc b/third_party/grpc/source/src/core/util/http_client/httpcli.cc
index 2a92a2553b5fc..601911c65efd0 100644
--- a/third_party/grpc/source/src/core/util/http_client/httpcli.cc
+++ b/third_party/grpc/source/src/core/util/http_client/httpcli.cc
@@ -28,7 +28,7 @@
 #include <utility>

 #include "absl/functional/bind_front.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_format.h"
 #include "src/core/config/core_configuration.h"
@@ -196,7 +196,7 @@ HttpRequest::HttpRequest(
   GRPC_CLOSURE_INIT(&continue_done_write_after_schedule_on_exec_ctx_,
                     ContinueDoneWriteAfterScheduleOnExecCtx, this,
                     grpc_schedule_on_exec_ctx);
-  CHECK(pollent);
+  ABSL_CHECK(pollent);
   grpc_polling_entity_add_to_pollset_set(pollent, pollset_set_);
 }

@@ -254,7 +254,7 @@ void HttpRequest::Start() {
 void HttpRequest::Orphan() {
   {
     MutexLock lock(&mu_);
-    CHECK(!cancelled_);
+    ABSL_CHECK(!cancelled_);
     cancelled_ = true;
     // cancel potentially pending DNS resolution.
     if (use_event_engine_dns_resolver_) {
diff --git a/third_party/grpc/source/src/core/util/http_client/httpcli_security_connector.cc b/third_party/grpc/source/src/core/util/http_client/httpcli_security_connector.cc
index 4fba0765c8707..10b69ecd24840 100644
--- a/third_party/grpc/source/src/core/util/http_client/httpcli_security_connector.cc
+++ b/third_party/grpc/source/src/core/util/http_client/httpcli_security_connector.cc
@@ -28,7 +28,7 @@
 #include <optional>
 #include <string>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
@@ -92,7 +92,7 @@ class grpc_httpcli_ssl_channel_security_connector final
           handshaker_factory_, secure_peer_name_, /*network_bio_buf_size=*/0,
           /*ssl_bio_buf_size=*/0, &handshaker);
       if (result != TSI_OK) {
-        LOG(ERROR) << "Handshaker creation failed with error "
+        ABSL_LOG(ERROR) << "Handshaker creation failed with error "
                    << tsi_result_to_string(result);
       }
     }
@@ -146,7 +146,7 @@ httpcli_ssl_channel_security_connector_create(
     const char* pem_root_certs, const tsi_ssl_root_certs_store* root_store,
     const char* secure_peer_name) {
   if (secure_peer_name != nullptr && pem_root_certs == nullptr) {
-    LOG(ERROR) << "Cannot assert a secure peer name without a trust root.";
+    ABSL_LOG(ERROR) << "Cannot assert a secure peer name without a trust root.";
     return nullptr;
   }
   RefCountedPtr<grpc_httpcli_ssl_channel_security_connector> c =
@@ -154,7 +154,7 @@ httpcli_ssl_channel_security_connector_create(
           secure_peer_name == nullptr ? nullptr : gpr_strdup(secure_peer_name));
   tsi_result result = c->InitHandshakerFactory(pem_root_certs, root_store);
   if (result != TSI_OK) {
-    LOG(ERROR) << "Handshaker factory creation failed with "
+    ABSL_LOG(ERROR) << "Handshaker factory creation failed with "
                << tsi_result_to_string(result);
     return nullptr;
   }
@@ -170,7 +170,7 @@ class HttpRequestSSLCredentials : public grpc_channel_credentials {
     const tsi_ssl_root_certs_store* root_store =
         DefaultSslRootStore::GetRootStore();
     if (root_store == nullptr) {
-      LOG(ERROR) << "Could not get default pem root certs.";
+      ABSL_LOG(ERROR) << "Could not get default pem root certs.";
       return nullptr;
     }
     std::optional<std::string> target_string =
diff --git a/third_party/grpc/source/src/core/util/http_client/parser.cc b/third_party/grpc/source/src/core/util/http_client/parser.cc
index a490f212ee91c..64e2b477e8358 100644
--- a/third_party/grpc/source/src/core/util/http_client/parser.cc
+++ b/third_party/grpc/source/src/core/util/http_client/parser.cc
@@ -24,8 +24,8 @@

 #include <algorithm>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"

 static char* buf2str(void* buffer, size_t length) {
@@ -175,7 +175,7 @@ static grpc_error_handle add_header(grpc_http_parser* parser) {
   grpc_http_header hdr = {nullptr, nullptr};
   grpc_error_handle error;

-  CHECK(cur != end);
+  ABSL_CHECK(cur != end);

   if (*cur == ' ' || *cur == '\t') {
     error = GRPC_ERROR_CREATE("Continued header lines not supported yet");
@@ -189,14 +189,14 @@ static grpc_error_handle add_header(grpc_http_parser* parser) {
     error = GRPC_ERROR_CREATE("Didn't find ':' in header string");
     goto done;
   }
-  CHECK(cur >= beg);
+  ABSL_CHECK(cur >= beg);
   hdr.key = buf2str(beg, static_cast<size_t>(cur - beg));
   cur++;  // skip :

   while (cur != end && (*cur == ' ' || *cur == '\t')) {
     cur++;
   }
-  CHECK((size_t)(end - cur) >= parser->cur_line_end_length);
+  ABSL_CHECK((size_t)(end - cur) >= parser->cur_line_end_length);
   size = static_cast<size_t>(end - cur) - parser->cur_line_end_length;
   if ((size != 0) && (cur[size - 1] == '\r')) {
     size--;
diff --git a/third_party/grpc/source/src/core/util/json/json_reader.cc b/third_party/grpc/source/src/core/util/json/json_reader.cc
index 5b437af925ef2..50091e23443e1 100644
--- a/third_party/grpc/source/src/core/util/json/json_reader.cc
+++ b/third_party/grpc/source/src/core/util/json/json_reader.cc
@@ -27,7 +27,7 @@
 #include <vector>

 #include "absl/base/attributes.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -277,14 +277,14 @@ bool JsonReader::StartContainer(Json::Type type) {
   if (type == Json::Type::kObject) {
     scope.data = Json::Object();
   } else {
-    CHECK(type == Json::Type::kArray);
+    ABSL_CHECK(type == Json::Type::kArray);
     scope.data = Json::Array();
   }
   return true;
 }

 void JsonReader::EndContainer() {
-  CHECK(!stack_.empty());
+  ABSL_CHECK(!stack_.empty());
   Scope scope = std::move(stack_.back());
   stack_.pop_back();
   key_ = std::move(scope.parent_object_key);
diff --git a/third_party/grpc/source/src/core/util/latent_see.cc b/third_party/grpc/source/src/core/util/latent_see.cc
index 97d483cf7faa8..9ab12d0c63c67 100644
--- a/third_party/grpc/source/src/core/util/latent_see.cc
+++ b/third_party/grpc/source/src/core/util/latent_see.cc
@@ -54,7 +54,7 @@ void Log::TryPullEventsAndFlush(
   // This is relatively quick and ensures that we don't stall capture for
   // long.
   for (auto& fragment : fragments_) {
-    CHECK_EQ(fragment.flushing.size(), 0);
+    ABSL_CHECK_EQ(fragment.flushing.size(), 0);
     MutexLock lock(&fragment.mu_active);
     fragment.flushing.swap(fragment.active);
   }
diff --git a/third_party/grpc/source/src/core/util/latent_see.h b/third_party/grpc/source/src/core/util/latent_see.h
index c0b5831eb7900..95525dea6565f 100644
--- a/third_party/grpc/source/src/core/util/latent_see.h
+++ b/third_party/grpc/source/src/core/util/latent_see.h
@@ -34,7 +34,7 @@
 #include "absl/base/thread_annotations.h"
 #include "absl/functional/any_invocable.h"
 #include "absl/functional/function_ref.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/string_view.h"
 #include "src/core/util/per_cpu.h"
 #include "src/core/util/sync.h"
@@ -123,7 +123,7 @@ class Log {
       atexit([] {
         auto json = log->TryGenerateJson();
         if (!json.has_value()) {
-          LOG(INFO) << "Failed to generate latent_see.json (contention with "
+          ABSL_LOG(INFO) << "Failed to generate latent_see.json (contention with "
                        "another writer)";
           return;
         }
@@ -131,7 +131,7 @@ class Log {
           log->stats_flusher_(*json);
           return;
         }
-        LOG(INFO) << "Writing latent_see.json in " << get_current_dir_name();
+        ABSL_LOG(INFO) << "Writing latent_see.json in " << get_current_dir_name();
         FILE* f = fopen("latent_see.json", "w");
         if (f == nullptr) return;
         fprintf(f, "%s", json->c_str());
@@ -182,7 +182,7 @@ class Scope {
       bin_descriptor_ = Log::StartBin(this);
       bin_ = Log::ToBin(bin_descriptor_);
     }
-    CHECK_NE(bin_, nullptr);
+    ABSL_CHECK_NE(bin_, nullptr);
     bin_->Append(metadata_, EventType::kBegin, 0);
   }
   GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION ~Scope() {
diff --git a/third_party/grpc/source/src/core/util/linux/cpu.cc b/third_party/grpc/source/src/core/util/linux/cpu.cc
index 41730292e89fe..b32e43f99ea70 100644
--- a/third_party/grpc/source/src/core/util/linux/cpu.cc
+++ b/third_party/grpc/source/src/core/util/linux/cpu.cc
@@ -31,7 +31,7 @@
 #include <string.h>
 #include <unistd.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/util/crash.h"
 #include "src/core/util/strerror.h"

@@ -40,7 +40,7 @@ static int ncpus = 0;
 static void init_num_cpus() {
 #ifndef GPR_MUSL_LIBC_COMPAT
   if (sched_getcpu() < 0) {
-    LOG(ERROR) << "Error determining current CPU: "
+    ABSL_LOG(ERROR) << "Error determining current CPU: "
                << grpc_core::StrError(errno) << "\n";
     ncpus = 1;
     return;
@@ -50,7 +50,7 @@ static void init_num_cpus() {
   // determined
   ncpus = static_cast<int>(sysconf(_SC_NPROCESSORS_CONF));
   if (ncpus < 1) {
-    LOG(ERROR) << "Cannot determine number of CPUs: assuming 1";
+    ABSL_LOG(ERROR) << "Cannot determine number of CPUs: assuming 1";
     ncpus = 1;
   }
 }
@@ -71,12 +71,12 @@ unsigned gpr_cpu_current_cpu(void) {
   }
   int cpu = sched_getcpu();
   if (cpu < 0) {
-    LOG(ERROR) << "Error determining current CPU: "
+    ABSL_LOG(ERROR) << "Error determining current CPU: "
                << grpc_core::StrError(errno) << "\n";
     return 0;
   }
   if (static_cast<unsigned>(cpu) >= gpr_cpu_num_cores()) {
-    VLOG(2) << "Cannot handle hot-plugged CPUs";
+    ABSL_VLOG(2) << "Cannot handle hot-plugged CPUs";
     return 0;
   }
   return static_cast<unsigned>(cpu);
diff --git a/third_party/grpc/source/src/core/util/log.cc b/third_party/grpc/source/src/core/util/log.cc
index f627f7622a304..39c265de31c5d 100644
--- a/third_party/grpc/source/src/core/util/log.cc
+++ b/third_party/grpc/source/src/core/util/log.cc
@@ -16,7 +16,7 @@
 //
 //

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"

 #include <grpc/support/alloc.h>
 #include <grpc/support/atm.h>
@@ -25,7 +25,7 @@
 #include <stdio.h>
 #include <string.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/log/globals.h"
 #include "absl/strings/match.h"
 #include "absl/strings/str_cat.h"
@@ -42,16 +42,16 @@ GPRAPI void grpc_absl_log(const char* file, int line, gpr_log_severity severity,
                           const char* message_str) {
   switch (severity) {
     case GPR_LOG_SEVERITY_DEBUG:
-      VLOG(2).AtLocation(file, line) << message_str;
+      ABSL_VLOG(2).AtLocation(file, line) << message_str;
       return;
     case GPR_LOG_SEVERITY_INFO:
-      LOG(INFO).AtLocation(file, line) << message_str;
+      ABSL_LOG(INFO).AtLocation(file, line) << message_str;
       return;
     case GPR_LOG_SEVERITY_ERROR:
-      LOG(ERROR).AtLocation(file, line) << message_str;
+      ABSL_LOG(ERROR).AtLocation(file, line) << message_str;
       return;
     default:
-      DCHECK(false) << "Invalid severity";
+      ABSL_DCHECK(false) << "Invalid severity";
   }
 }

@@ -60,16 +60,16 @@ GPRAPI void grpc_absl_log_int(const char* file, int line,
                               const char* message_str, intptr_t num) {
   switch (severity) {
     case GPR_LOG_SEVERITY_DEBUG:
-      VLOG(2).AtLocation(file, line) << message_str << num;
+      ABSL_VLOG(2).AtLocation(file, line) << message_str << num;
       return;
     case GPR_LOG_SEVERITY_INFO:
-      LOG(INFO).AtLocation(file, line) << message_str << num;
+      ABSL_LOG(INFO).AtLocation(file, line) << message_str << num;
       return;
     case GPR_LOG_SEVERITY_ERROR:
-      LOG(ERROR).AtLocation(file, line) << message_str << num;
+      ABSL_LOG(ERROR).AtLocation(file, line) << message_str << num;
       return;
     default:
-      DCHECK(false) << "Invalid severity";
+      ABSL_DCHECK(false) << "Invalid severity";
   }
 }

@@ -79,16 +79,16 @@ GPRAPI void grpc_absl_log_str(const char* file, int line,
                               const char* message_str2) {
   switch (severity) {
     case GPR_LOG_SEVERITY_DEBUG:
-      VLOG(2).AtLocation(file, line) << message_str1 << message_str2;
+      ABSL_VLOG(2).AtLocation(file, line) << message_str1 << message_str2;
       return;
     case GPR_LOG_SEVERITY_INFO:
-      LOG(INFO).AtLocation(file, line) << message_str1 << message_str2;
+      ABSL_LOG(INFO).AtLocation(file, line) << message_str1 << message_str2;
       return;
     case GPR_LOG_SEVERITY_ERROR:
-      LOG(ERROR).AtLocation(file, line) << message_str1 << message_str2;
+      ABSL_LOG(ERROR).AtLocation(file, line) << message_str1 << message_str2;
       return;
     default:
-      DCHECK(false) << "Invalid severity";
+      ABSL_DCHECK(false) << "Invalid severity";
   }
 }

@@ -99,14 +99,14 @@ void gpr_log_verbosity_init(void) {
   // to grpc.
   absl::string_view verbosity = grpc_core::ConfigVars::Get().Verbosity();
   if (absl::EqualsIgnoreCase(verbosity, "INFO")) {
-    LOG_FIRST_N(WARNING, 1)
+    ABSL_LOG_FIRST_N(WARNING, 1)
         << "Log level INFO is not suitable for production. Prefer WARNING or "
            "ERROR. However if you see this message in a debug environment or "
            "test environment it is safe to ignore this message.";
     absl::SetVLogLevel("*grpc*/*", -1);
     absl::SetMinLogLevel(absl::LogSeverityAtLeast::kInfo);
   } else if (absl::EqualsIgnoreCase(verbosity, "DEBUG")) {
-    LOG_FIRST_N(WARNING, 1)
+    ABSL_LOG_FIRST_N(WARNING, 1)
         << "Log level DEBUG is not suitable for production. Prefer WARNING or "
            "ERROR. However if you see this message in a debug environment or "
            "test environment it is safe to ignore this message.";
@@ -121,7 +121,7 @@ void gpr_log_verbosity_init(void) {
   } else if (verbosity.empty()) {
     // Do not alter absl settings if GRPC_VERBOSITY flag is not set.
   } else {
-    LOG(ERROR) << "Unknown log verbosity: " << verbosity;
+    ABSL_LOG(ERROR) << "Unknown log verbosity: " << verbosity;
   }
 #endif  // GRPC_VERBOSITY_MACRO
 }
diff --git a/third_party/grpc/source/src/core/util/lru_cache.h b/third_party/grpc/source/src/core/util/lru_cache.h
index cfacc595d88d9..cbcf48e4e44cc 100644
--- a/third_party/grpc/source/src/core/util/lru_cache.h
+++ b/third_party/grpc/source/src/core/util/lru_cache.h
@@ -24,7 +24,7 @@

 #include "absl/container/flat_hash_map.h"
 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 namespace grpc_core {

@@ -35,7 +35,7 @@ template <typename Key, typename Value>
 class LruCache {
  public:
   explicit LruCache(size_t max_size) : max_size_(max_size) {
-    CHECK_GT(max_size, 0UL);
+    ABSL_CHECK_GT(max_size, 0UL);
   }

   // Returns the value for key, or nullopt if not present.
@@ -110,9 +110,9 @@ void LruCache<Key, Value>::SetMaxSize(size_t max_size) {
 template <typename Key, typename Value>
 void LruCache<Key, Value>::RemoveOldestEntry() {
   auto lru_it = lru_list_.begin();
-  CHECK(lru_it != lru_list_.end());
+  ABSL_CHECK(lru_it != lru_list_.end());
   auto cache_it = cache_.find(*lru_it);
-  CHECK(cache_it != cache_.end());
+  ABSL_CHECK(cache_it != cache_.end());
   cache_.erase(cache_it);
   lru_list_.pop_front();
 }
diff --git a/third_party/grpc/source/src/core/util/mpscq.h b/third_party/grpc/source/src/core/util/mpscq.h
index 44502a0b352e9..d581458cbeeff 100644
--- a/third_party/grpc/source/src/core/util/mpscq.h
+++ b/third_party/grpc/source/src/core/util/mpscq.h
@@ -23,7 +23,7 @@

 #include <atomic>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/util/sync.h"

 namespace grpc_core {
@@ -40,8 +40,8 @@ class MultiProducerSingleConsumerQueue {

   MultiProducerSingleConsumerQueue() : head_{&stub_}, tail_(&stub_) {}
   ~MultiProducerSingleConsumerQueue() {
-    CHECK(head_.load(std::memory_order_relaxed) == &stub_);
-    CHECK(tail_ == &stub_);
+    ABSL_CHECK(head_.load(std::memory_order_relaxed) == &stub_);
+    ABSL_CHECK(tail_ == &stub_);
   }

   // Push a node
diff --git a/third_party/grpc/source/src/core/util/posix/cpu.cc b/third_party/grpc/source/src/core/util/posix/cpu.cc
index 92a9e45635e51..d85e95e0d6352 100644
--- a/third_party/grpc/source/src/core/util/posix/cpu.cc
+++ b/third_party/grpc/source/src/core/util/posix/cpu.cc
@@ -27,7 +27,7 @@
 #include <string.h>
 #include <unistd.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/util/crash.h"
 #include "src/core/util/useful.h"

@@ -38,7 +38,7 @@ static pthread_key_t thread_id_key;
 static void init_ncpus() {
   ncpus = sysconf(_SC_NPROCESSORS_CONF);
   if (ncpus < 1 || ncpus > INT32_MAX) {
-    LOG(ERROR) << "Cannot determine number of CPUs: assuming 1";
+    ABSL_LOG(ERROR) << "Cannot determine number of CPUs: assuming 1";
     ncpus = 1;
   }
 }
diff --git a/third_party/grpc/source/src/core/util/posix/stat.cc b/third_party/grpc/source/src/core/util/posix/stat.cc
index 5de6f456321e5..3c08fb19f4d63 100644
--- a/third_party/grpc/source/src/core/util/posix/stat.cc
+++ b/third_party/grpc/source/src/core/util/posix/stat.cc
@@ -27,20 +27,20 @@
 #include <errno.h>
 #include <sys/stat.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/util/stat.h"
 #include "src/core/util/strerror.h"

 namespace grpc_core {

 absl::Status GetFileModificationTime(const char* filename, time_t* timestamp) {
-  CHECK_NE(filename, nullptr);
-  CHECK_NE(timestamp, nullptr);
+  ABSL_CHECK_NE(filename, nullptr);
+  ABSL_CHECK_NE(timestamp, nullptr);
   struct stat buf;
   if (stat(filename, &buf) != 0) {
     std::string error_msg = StrError(errno);
-    LOG(ERROR) << "stat failed for filename " << filename << " with error "
+    ABSL_LOG(ERROR) << "stat failed for filename " << filename << " with error "
                << error_msg;
     return absl::Status(absl::StatusCode::kInternal, error_msg);
   }
diff --git a/third_party/grpc/source/src/core/util/posix/sync.cc b/third_party/grpc/source/src/core/util/posix/sync.cc
index ad6431bbeb227..09425a88c68a5 100644
--- a/third_party/grpc/source/src/core/util/posix/sync.cc
+++ b/third_party/grpc/source/src/core/util/posix/sync.cc
@@ -27,40 +27,40 @@
 #include <grpc/support/time.h>
 #include <time.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 void gpr_mu_init(gpr_mu* mu) {
 #ifdef GRPC_ASAN_ENABLED
-  CHECK_EQ(pthread_mutex_init(&mu->mutex, nullptr), 0);
+  ABSL_CHECK_EQ(pthread_mutex_init(&mu->mutex, nullptr), 0);
   mu->leak_checker = static_cast<int*>(malloc(sizeof(*mu->leak_checker)));
-  CHECK_NE(mu->leak_checker, nullptr);
+  ABSL_CHECK_NE(mu->leak_checker, nullptr);
 #else
-  CHECK_EQ(pthread_mutex_init(mu, nullptr), 0);
+  ABSL_CHECK_EQ(pthread_mutex_init(mu, nullptr), 0);
 #endif
 }

 void gpr_mu_destroy(gpr_mu* mu) {
 #ifdef GRPC_ASAN_ENABLED
-  CHECK_EQ(pthread_mutex_destroy(&mu->mutex), 0);
+  ABSL_CHECK_EQ(pthread_mutex_destroy(&mu->mutex), 0);
   free(mu->leak_checker);
 #else
-  CHECK_EQ(pthread_mutex_destroy(mu), 0);
+  ABSL_CHECK_EQ(pthread_mutex_destroy(mu), 0);
 #endif
 }

 void gpr_mu_lock(gpr_mu* mu) {
 #ifdef GRPC_ASAN_ENABLED
-  CHECK_EQ(pthread_mutex_lock(&mu->mutex), 0);
+  ABSL_CHECK_EQ(pthread_mutex_lock(&mu->mutex), 0);
 #else
-  CHECK_EQ(pthread_mutex_lock(mu), 0);
+  ABSL_CHECK_EQ(pthread_mutex_lock(mu), 0);
 #endif
 }

 void gpr_mu_unlock(gpr_mu* mu) {
 #ifdef GRPC_ASAN_ENABLED
-  CHECK_EQ(pthread_mutex_unlock(&mu->mutex), 0);
+  ABSL_CHECK_EQ(pthread_mutex_unlock(&mu->mutex), 0);
 #else
-  CHECK_EQ(pthread_mutex_unlock(mu), 0);
+  ABSL_CHECK_EQ(pthread_mutex_unlock(mu), 0);
 #endif
 }

@@ -71,7 +71,7 @@ int gpr_mu_trylock(gpr_mu* mu) {
 #else
   err = pthread_mutex_trylock(mu);
 #endif
-  CHECK(err == 0 || err == EBUSY);
+  ABSL_CHECK(err == 0 || err == EBUSY);
   return err == 0;
 }

@@ -79,26 +79,26 @@ int gpr_mu_trylock(gpr_mu* mu) {

 void gpr_cv_init(gpr_cv* cv) {
   pthread_condattr_t attr;
-  CHECK_EQ(pthread_condattr_init(&attr), 0);
+  ABSL_CHECK_EQ(pthread_condattr_init(&attr), 0);
 #if GPR_LINUX
-  CHECK_EQ(pthread_condattr_setclock(&attr, CLOCK_MONOTONIC), 0);
+  ABSL_CHECK_EQ(pthread_condattr_setclock(&attr, CLOCK_MONOTONIC), 0);
 #endif  // GPR_LINUX

 #ifdef GRPC_ASAN_ENABLED
-  CHECK_EQ(pthread_cond_init(&cv->cond_var, &attr), 0);
+  ABSL_CHECK_EQ(pthread_cond_init(&cv->cond_var, &attr), 0);
   cv->leak_checker = static_cast<int*>(malloc(sizeof(*cv->leak_checker)));
-  CHECK_NE(cv->leak_checker, nullptr);
+  ABSL_CHECK_NE(cv->leak_checker, nullptr);
 #else
-  CHECK_EQ(pthread_cond_init(cv, &attr), 0);
+  ABSL_CHECK_EQ(pthread_cond_init(cv, &attr), 0);
 #endif
 }

 void gpr_cv_destroy(gpr_cv* cv) {
 #ifdef GRPC_ASAN_ENABLED
-  CHECK_EQ(pthread_cond_destroy(&cv->cond_var), 0);
+  ABSL_CHECK_EQ(pthread_cond_destroy(&cv->cond_var), 0);
   free(cv->leak_checker);
 #else
-  CHECK_EQ(pthread_cond_destroy(cv), 0);
+  ABSL_CHECK_EQ(pthread_cond_destroy(cv), 0);
 #endif
 }

@@ -127,30 +127,30 @@ int gpr_cv_wait(gpr_cv* cv, gpr_mu* mu, gpr_timespec abs_deadline) {
     err = pthread_cond_timedwait(cv, mu, &abs_deadline_ts);
 #endif
   }
-  CHECK(err == 0 || err == ETIMEDOUT || err == EAGAIN);
+  ABSL_CHECK(err == 0 || err == ETIMEDOUT || err == EAGAIN);
   return err == ETIMEDOUT;
 }

 void gpr_cv_signal(gpr_cv* cv) {
 #ifdef GRPC_ASAN_ENABLED
-  CHECK_EQ(pthread_cond_signal(&cv->cond_var), 0);
+  ABSL_CHECK_EQ(pthread_cond_signal(&cv->cond_var), 0);
 #else
-  CHECK_EQ(pthread_cond_signal(cv), 0);
+  ABSL_CHECK_EQ(pthread_cond_signal(cv), 0);
 #endif
 }

 void gpr_cv_broadcast(gpr_cv* cv) {
 #ifdef GRPC_ASAN_ENABLED
-  CHECK_EQ(pthread_cond_broadcast(&cv->cond_var), 0);
+  ABSL_CHECK_EQ(pthread_cond_broadcast(&cv->cond_var), 0);
 #else
-  CHECK_EQ(pthread_cond_broadcast(cv), 0);
+  ABSL_CHECK_EQ(pthread_cond_broadcast(cv), 0);
 #endif
 }

 //----------------------------------------

 void gpr_once_init(gpr_once* once, void (*init_function)(void)) {
-  CHECK_EQ(pthread_once(once, init_function), 0);
+  ABSL_CHECK_EQ(pthread_once(once, init_function), 0);
 }

 #endif  // defined(GPR_POSIX_SYNC) && !defined(GPR_ABSEIL_SYNC) &&
diff --git a/third_party/grpc/source/src/core/util/posix/thd.cc b/third_party/grpc/source/src/core/util/posix/thd.cc
index 764882dd676d5..759eacbbd206d 100644
--- a/third_party/grpc/source/src/core/util/posix/thd.cc
+++ b/third_party/grpc/source/src/core/util/posix/thd.cc
@@ -34,8 +34,8 @@
 #include <string.h>
 #include <unistd.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/util/crash.h"
 #include "src/core/util/fork.h"
 #include "src/core/util/strerror.h"
@@ -87,7 +87,7 @@ class ThreadInternalsPosix : public internal::ThreadInternalsInterface {
     // don't use gpr_malloc as we may cause an infinite recursion with
     // the profiling code
     thd_arg* info = static_cast<thd_arg*>(malloc(sizeof(*info)));
-    CHECK_NE(info, nullptr);
+    ABSL_CHECK_NE(info, nullptr);
     info->thread = this;
     info->body = thd_body;
     info->arg = arg;
@@ -98,16 +98,16 @@ class ThreadInternalsPosix : public internal::ThreadInternalsInterface {
       Fork::IncThreadCount();
     }

-    CHECK_EQ(pthread_attr_init(&attr), 0);
+    ABSL_CHECK_EQ(pthread_attr_init(&attr), 0);
     if (options.joinable()) {
-      CHECK(pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE) == 0);
+      ABSL_CHECK(pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE) == 0);
     } else {
-      CHECK(pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED) == 0);
+      ABSL_CHECK(pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED) == 0);
     }

     if (options.stack_size() != 0) {
       size_t stack_size = MinValidStackSize(options.stack_size());
-      CHECK_EQ(pthread_attr_setstacksize(&attr, stack_size), 0);
+      ABSL_CHECK_EQ(pthread_attr_setstacksize(&attr, stack_size), 0);
     }

     int pthread_create_err = pthread_create(
@@ -151,10 +151,10 @@ class ThreadInternalsPosix : public internal::ThreadInternalsInterface {
         info);
     *success = (pthread_create_err == 0);

-    CHECK_EQ(pthread_attr_destroy(&attr), 0);
+    ABSL_CHECK_EQ(pthread_attr_destroy(&attr), 0);

     if (!(*success)) {
-      LOG(ERROR) << "pthread_create failed: " << StrError(pthread_create_err);
+      ABSL_LOG(ERROR) << "pthread_create failed: " << StrError(pthread_create_err);
       // don't use gpr_free, as this was allocated using malloc (see above)
       free(info);
       if (options.tracked()) {
@@ -194,7 +194,7 @@ class ThreadInternalsPosix : public internal::ThreadInternalsInterface {
 void Thread::Signal(gpr_thd_id tid, int sig) {
   auto kill_err = pthread_kill((pthread_t)tid, sig);
   if (kill_err != 0) {
-    LOG(ERROR) << "pthread_kill for tid " << tid
+    ABSL_LOG(ERROR) << "pthread_kill for tid " << tid
                << " failed: " << StrError(kill_err);
   }
 }
@@ -203,13 +203,13 @@ void Thread::Signal(gpr_thd_id tid, int sig) {
 void Thread::Kill(gpr_thd_id tid) {
   auto cancel_err = pthread_cancel((pthread_t)tid);
   if (cancel_err != 0) {
-    LOG(ERROR) << "pthread_cancel for tid " << tid
+    ABSL_LOG(ERROR) << "pthread_cancel for tid " << tid
                << " failed: " << StrError(cancel_err);
   }
 }
 #else  // GPR_ANDROID
 void Thread::Kill(gpr_thd_id /* tid */) {
-  VLOG(2) << "Thread::Kill is not supported on Android.";
+  ABSL_VLOG(2) << "Thread::Kill is not supported on Android.";
 }
 #endif

diff --git a/third_party/grpc/source/src/core/util/posix/time.cc b/third_party/grpc/source/src/core/util/posix/time.cc
index 8231cc588c745..553b737193dee 100644
--- a/third_party/grpc/source/src/core/util/posix/time.cc
+++ b/third_party/grpc/source/src/core/util/posix/time.cc
@@ -31,14 +31,14 @@
 #include <grpc/support/atm.h>
 #include <grpc/support/time.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 static struct timespec timespec_from_gpr(gpr_timespec gts) {
   struct timespec rv;
   if (sizeof(time_t) < sizeof(int64_t)) {
     // fine to assert, as this is only used in gpr_sleep_until
-    CHECK(gts.tv_sec <= INT32_MAX);
-    CHECK(gts.tv_sec >= INT32_MIN);
+    ABSL_CHECK(gts.tv_sec <= INT32_MAX);
+    ABSL_CHECK(gts.tv_sec >= INT32_MIN);
   }
   rv.tv_sec = static_cast<time_t>(gts.tv_sec);
   rv.tv_nsec = gts.tv_nsec;
@@ -67,7 +67,7 @@ void gpr_time_init(void) { gpr_precise_clock_init(); }

 static gpr_timespec now_impl(gpr_clock_type clock_type) {
   struct timespec now;
-  CHECK(clock_type != GPR_TIMESPAN);
+  ABSL_CHECK(clock_type != GPR_TIMESPAN);
   if (clock_type == GPR_CLOCK_PRECISE) {
     gpr_timespec ret;
     gpr_precise_clock_now(&ret);
@@ -87,12 +87,12 @@ gpr_timespec (*gpr_now_impl)(gpr_clock_type clock_type) = now_impl;

 gpr_timespec gpr_now(gpr_clock_type clock_type) {
   // validate clock type
-  CHECK(clock_type == GPR_CLOCK_MONOTONIC || clock_type == GPR_CLOCK_REALTIME ||
+  ABSL_CHECK(clock_type == GPR_CLOCK_MONOTONIC || clock_type == GPR_CLOCK_REALTIME ||
         clock_type == GPR_CLOCK_PRECISE);
   gpr_timespec ts = gpr_now_impl(clock_type);
   // tv_nsecs must be in the range [0, 1e9).
-  CHECK(ts.tv_nsec >= 0);
-  CHECK(ts.tv_nsec < 1e9);
+  ABSL_CHECK(ts.tv_nsec >= 0);
+  ABSL_CHECK(ts.tv_nsec < 1e9);
   return ts;
 }

diff --git a/third_party/grpc/source/src/core/util/posix/tmpfile.cc b/third_party/grpc/source/src/core/util/posix/tmpfile.cc
index 832391f1599e7..a2031cac4d2f4 100644
--- a/third_party/grpc/source/src/core/util/posix/tmpfile.cc
+++ b/third_party/grpc/source/src/core/util/posix/tmpfile.cc
@@ -27,8 +27,8 @@
 #include <string.h>
 #include <unistd.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/util/crash.h"
 #include "src/core/util/strerror.h"
 #include "src/core/util/string.h"
@@ -42,17 +42,17 @@ FILE* gpr_tmpfile(const char* prefix, char** tmp_filename) {
   if (tmp_filename != nullptr) *tmp_filename = nullptr;

   gpr_asprintf(&filename_template, "/tmp/%s_XXXXXX", prefix);
-  CHECK_NE(filename_template, nullptr);
+  ABSL_CHECK_NE(filename_template, nullptr);

   fd = mkstemp(filename_template);
   if (fd == -1) {
-    LOG(ERROR) << "mkstemp failed for filename_template " << filename_template
+    ABSL_LOG(ERROR) << "mkstemp failed for filename_template " << filename_template
                << " with error " << grpc_core::StrError(errno);
     goto end;
   }
   result = fdopen(fd, "w+");
   if (result == nullptr) {
-    LOG(ERROR) << "Could not open file " << filename_template << " from fd "
+    ABSL_LOG(ERROR) << "Could not open file " << filename_template << " from fd "
                << fd << " (error = " << grpc_core::StrError(errno) << ").";
     unlink(filename_template);
     close(fd);
diff --git a/third_party/grpc/source/src/core/util/ref_counted.h b/third_party/grpc/source/src/core/util/ref_counted.h
index b82a99b83f717..57503b97b331e 100644
--- a/third_party/grpc/source/src/core/util/ref_counted.h
+++ b/third_party/grpc/source/src/core/util/ref_counted.h
@@ -25,8 +25,8 @@
 #include <cassert>
 #include <cinttypes>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/util/atomic_utils.h"
 #include "src/core/util/debug_location.h"
 #include "src/core/util/down_cast.h"
@@ -72,7 +72,7 @@ class RefCount {
 #ifndef NDEBUG
     const Value prior = value_.fetch_add(n, std::memory_order_relaxed);
     if (trace_ != nullptr) {
-      LOG(INFO) << trace_ << ":" << this << " ref " << prior << " -> "
+      ABSL_LOG(INFO) << trace_ << ":" << this << " ref " << prior << " -> "
                 << prior + n;
     }
 #else
@@ -83,7 +83,7 @@ class RefCount {
 #ifndef NDEBUG
     const Value prior = value_.fetch_add(n, std::memory_order_relaxed);
     if (trace_ != nullptr) {
-      LOG(INFO) << trace_ << ":" << this << " " << location.file() << ":"
+      ABSL_LOG(INFO) << trace_ << ":" << this << " " << location.file() << ":"
                 << location.line() << " ref " << prior << " -> " << prior + n
                 << " " << reason;
     }
@@ -100,7 +100,7 @@ class RefCount {
 #ifndef NDEBUG
     const Value prior = value_.fetch_add(1, std::memory_order_relaxed);
     if (trace_ != nullptr) {
-      LOG(INFO) << trace_ << ":" << this << " ref " << prior << " -> "
+      ABSL_LOG(INFO) << trace_ << ":" << this << " ref " << prior << " -> "
                 << prior + 1;
     }
     assert(prior > 0);
@@ -112,7 +112,7 @@ class RefCount {
 #ifndef NDEBUG
     const Value prior = value_.fetch_add(1, std::memory_order_relaxed);
     if (trace_ != nullptr) {
-      LOG(INFO) << trace_ << ":" << this << " " << location.file() << ":"
+      ABSL_LOG(INFO) << trace_ << ":" << this << " " << location.file() << ":"
                 << location.line() << " ref " << prior << " -> " << prior + 1
                 << " " << reason;
     }
@@ -129,7 +129,7 @@ class RefCount {
 #ifndef NDEBUG
     if (trace_ != nullptr) {
       const Value prior = get();
-      LOG(INFO) << trace_ << ":" << this << " ref_if_non_zero " << prior
+      ABSL_LOG(INFO) << trace_ << ":" << this << " ref_if_non_zero " << prior
                 << " -> " << prior + 1;
     }
 #endif
@@ -139,7 +139,7 @@ class RefCount {
 #ifndef NDEBUG
     if (trace_ != nullptr) {
       const Value prior = get();
-      LOG(INFO) << trace_ << ":" << this << " " << location.file() << ":"
+      ABSL_LOG(INFO) << trace_ << ":" << this << " " << location.file() << ":"
                 << location.line() << " ref_if_non_zero " << prior << " -> "
                 << prior + 1 << " " << reason;
     }
@@ -161,10 +161,10 @@ class RefCount {
     const Value prior = value_.fetch_sub(1, std::memory_order_acq_rel);
 #ifndef NDEBUG
     if (trace != nullptr) {
-      LOG(INFO) << trace << ":" << this << " unref " << prior << " -> "
+      ABSL_LOG(INFO) << trace << ":" << this << " unref " << prior << " -> "
                 << prior - 1;
     }
-    DCHECK_GT(prior, 0);
+    ABSL_DCHECK_GT(prior, 0);
 #endif
     return prior == 1;
   }
@@ -178,11 +178,11 @@ class RefCount {
     const Value prior = value_.fetch_sub(1, std::memory_order_acq_rel);
 #ifndef NDEBUG
     if (trace != nullptr) {
-      LOG(INFO) << trace << ":" << this << " " << location.file() << ":"
+      ABSL_LOG(INFO) << trace << ":" << this << " " << location.file() << ":"
                 << location.line() << " unref " << prior << " -> " << prior - 1
                 << " " << reason;
     }
-    DCHECK_GT(prior, 0);
+    ABSL_DCHECK_GT(prior, 0);
 #else
     // Avoid unused-parameter warnings for debug-only parameters
     (void)location;
diff --git a/third_party/grpc/source/src/core/util/single_set_ptr.h b/third_party/grpc/source/src/core/util/single_set_ptr.h
index 9508e53eb6db6..b4167093ec7b8 100644
--- a/third_party/grpc/source/src/core/util/single_set_ptr.h
+++ b/third_party/grpc/source/src/core/util/single_set_ptr.h
@@ -20,7 +20,7 @@
 #include <atomic>
 #include <memory>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 namespace grpc_core {

@@ -70,7 +70,7 @@ class SingleSetPtr {

   T* operator->() const {
     T* p = Get();
-    DCHECK_NE(p, nullptr);
+    ABSL_DCHECK_NE(p, nullptr);
     return p;
   }

diff --git a/third_party/grpc/source/src/core/util/status_helper.cc b/third_party/grpc/source/src/core/util/status_helper.cc
index f4b8e8a1c5b23..b5591c31dd984 100644
--- a/third_party/grpc/source/src/core/util/status_helper.cc
+++ b/third_party/grpc/source/src/core/util/status_helper.cc
@@ -23,7 +23,7 @@

 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/cord.h"
 #include "absl/strings/escaping.h"
 #include "absl/strings/match.h"
@@ -121,7 +121,7 @@ std::vector<absl::Status> ParseChildren(absl::Cord children) {
   while (buf.size() - cur >= sizeof(uint32_t)) {
     size_t msg_size = DecodeUInt32FromBytes(buf.data() + cur);
     cur += sizeof(uint32_t);
-    CHECK(buf.size() - cur >= msg_size);
+    ABSL_CHECK(buf.size() - cur >= msg_size);
     google_rpc_Status* msg =
         google_rpc_Status_parse(buf.data() + cur, msg_size, arena.ptr());
     cur += msg_size;
diff --git a/third_party/grpc/source/src/core/util/subprocess_posix.cc b/third_party/grpc/source/src/core/util/subprocess_posix.cc
index ef4512b3734f7..e7c319d1e653f 100644
--- a/third_party/grpc/source/src/core/util/subprocess_posix.cc
+++ b/third_party/grpc/source/src/core/util/subprocess_posix.cc
@@ -29,8 +29,8 @@

 #include <iostream>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/substitute.h"
 #include "src/core/util/memory.h"
 #include "src/core/util/strerror.h"
@@ -59,7 +59,7 @@ gpr_subprocess* gpr_subprocess_create(int argc, const char** argv) {
     exec_args[argc] = nullptr;
     execv(exec_args[0], exec_args);
     // if we reach here, an error has occurred
-    LOG(ERROR) << "execv '" << exec_args[0]
+    ABSL_LOG(ERROR) << "execv '" << exec_args[0]
                << "' failed: " << grpc_core::StrError(errno);
     _exit(1);
   } else {
@@ -80,8 +80,8 @@ gpr_subprocess* gpr_subprocess_create_with_envp(int argc, const char** argv,
   int stdout_pipe[2];
   int p0 = pipe(stdin_pipe);
   int p1 = pipe(stdout_pipe);
-  CHECK_NE(p0, -1);
-  CHECK_NE(p1, -1);
+  ABSL_CHECK_NE(p0, -1);
+  ABSL_CHECK_NE(p1, -1);
   pid = fork();
   if (pid == -1) {
     return nullptr;
@@ -102,7 +102,7 @@ gpr_subprocess* gpr_subprocess_create_with_envp(int argc, const char** argv,
     envp_args[envc] = nullptr;
     execve(exec_args[0], exec_args, envp_args);
     // if we reach here, an error has occurred
-    LOG(ERROR) << "execvpe '" << exec_args[0]
+    ABSL_LOG(ERROR) << "execvpe '" << exec_args[0]
                << "' failed: " << grpc_core::StrError(errno);
     _exit(1);
   } else {
@@ -144,7 +144,7 @@ bool gpr_subprocess_communicate(gpr_subprocess* p, std::string& input_data,
         continue;
       } else {
         std::cerr << "select: " << strerror(errno) << std::endl;
-        CHECK(0);
+        ABSL_CHECK(0);
       }
     }

@@ -191,7 +191,7 @@ bool gpr_subprocess_communicate(gpr_subprocess* p, std::string& input_data,
   while (waitpid(p->pid, &status, 0) == -1) {
     if (errno != EINTR) {
       std::cerr << "waitpid: " << strerror(errno) << std::endl;
-      CHECK(0);
+      ABSL_CHECK(0);
     }
   }

@@ -232,7 +232,7 @@ retry:
     if (errno == EINTR) {
       goto retry;
     }
-    LOG(ERROR) << "waitpid failed for pid " << p->pid << ": "
+    ABSL_LOG(ERROR) << "waitpid failed for pid " << p->pid << ": "
                << grpc_core::StrError(errno);
     return -1;
   }
diff --git a/third_party/grpc/source/src/core/util/subprocess_windows.cc b/third_party/grpc/source/src/core/util/subprocess_windows.cc
index 71fd6497e785a..1585de0fe9009 100644
--- a/third_party/grpc/source/src/core/util/subprocess_windows.cc
+++ b/third_party/grpc/source/src/core/util/subprocess_windows.cc
@@ -25,7 +25,7 @@
 #include <tchar.h>
 #include <windows.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_join.h"
 #include "absl/types/span.h"
 #include "src/core/util/crash.h"
@@ -112,7 +112,7 @@ void gpr_subprocess_interrupt(gpr_subprocess* p) {
   DWORD dwExitCode;
   if (GetExitCodeProcess(p->pi.hProcess, &dwExitCode)) {
     if (dwExitCode == STILL_ACTIVE) {
-      VLOG(2) << "sending ctrl-break";
+      ABSL_VLOG(2) << "sending ctrl-break";
       GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, p->pi.dwProcessId);
       p->joined = 1;
       p->interrupted = 1;
diff --git a/third_party/grpc/source/src/core/util/sync.cc b/third_party/grpc/source/src/core/util/sync.cc
index 7a5f24409eeb8..ffff953718e16 100644
--- a/third_party/grpc/source/src/core/util/sync.cc
+++ b/third_party/grpc/source/src/core/util/sync.cc
@@ -23,7 +23,7 @@
 #include <grpc/support/port_platform.h>
 #include <grpc/support/sync.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 // Number of mutexes to allocate for events, to avoid lock contention.
 // Should be a prime.
@@ -58,11 +58,11 @@ void gpr_event_init(gpr_event* ev) {
 void gpr_event_set(gpr_event* ev, void* value) {
   struct sync_array_s* s = hash(ev);
   gpr_mu_lock(&s->mu);
-  CHECK_EQ(gpr_atm_acq_load(&ev->state), 0);
+  ABSL_CHECK_EQ(gpr_atm_acq_load(&ev->state), 0);
   gpr_atm_rel_store(&ev->state, (gpr_atm)value);
   gpr_cv_broadcast(&s->cv);
   gpr_mu_unlock(&s->mu);
-  CHECK_NE(value, nullptr);
+  ABSL_CHECK_NE(value, nullptr);
 }

 void* gpr_event_get(gpr_event* ev) {
@@ -101,7 +101,7 @@ void gpr_refn(gpr_refcount* r, int n) {

 int gpr_unref(gpr_refcount* r) {
   gpr_atm prior = gpr_atm_full_fetch_add(&r->count, -1);
-  CHECK_GT(prior, 0);
+  ABSL_CHECK_GT(prior, 0);
   return prior == 1;
 }

diff --git a/third_party/grpc/source/src/core/util/sync.h b/third_party/grpc/source/src/core/util/sync.h
index 77d1a54206ffe..1a6ee75cb97a8 100644
--- a/third_party/grpc/source/src/core/util/sync.h
+++ b/third_party/grpc/source/src/core/util/sync.h
@@ -23,7 +23,7 @@
 #include <grpc/support/sync.h>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/synchronization/mutex.h"

 #ifndef GPR_ABSEIL_SYNC
@@ -112,7 +112,7 @@ class ABSL_SCOPED_LOCKABLE ReleasableMutexLock {
   ReleasableMutexLock& operator=(const ReleasableMutexLock&) = delete;

   void Release() ABSL_UNLOCK_FUNCTION() {
-    DCHECK(!released_);
+    ABSL_DCHECK(!released_);
     released_ = true;
     mu_->Unlock();
   }
@@ -178,13 +178,13 @@ class ABSL_SCOPED_LOCKABLE LockableAndReleasableMutexLock {
       const LockableAndReleasableMutexLock&) = delete;

   void Lock() ABSL_EXCLUSIVE_LOCK_FUNCTION() {
-    DCHECK(released_);
+    ABSL_DCHECK(released_);
     mu_->Lock();
     released_ = false;
   }

   void Release() ABSL_UNLOCK_FUNCTION() {
-    DCHECK(!released_);
+    ABSL_DCHECK(!released_);
     released_ = true;
     mu_->Unlock();
   }
diff --git a/third_party/grpc/source/src/core/util/tdigest.cc b/third_party/grpc/source/src/core/util/tdigest.cc
index 90d63bb3c0be6..5f6b7e65b4016 100644
--- a/third_party/grpc/source/src/core/util/tdigest.cc
+++ b/third_party/grpc/source/src/core/util/tdigest.cc
@@ -14,8 +14,8 @@

 #include "src/core/util/tdigest.h"

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_split.h"

@@ -42,9 +42,9 @@ size_t MaxCentroids(double compression) {

 double LinearInterpolate(double val1, double val2, double weight1,
                          double weight2) {
-  DCHECK_GE(weight1, 0);
-  DCHECK_GE(weight2, 0);
-  DCHECK_GT(weight1 + weight2, 0);
+  ABSL_DCHECK_GE(weight1, 0);
+  ABSL_DCHECK_GE(weight2, 0);
+  ABSL_DCHECK_GT(weight1 + weight2, 0);
   return (val1 * weight1 + val2 * weight2) / (weight1 + weight2);
 }

@@ -56,7 +56,7 @@ void TDigest::Reset(double compression) {
   compression_ = BoundedCompression(compression);
   // Set the default batch_size to 4 times the number of centroids.
   batch_size_ = static_cast<int64_t>(4 * MaxCentroids(compression_));
-  DCHECK(compression_ == 0.0 || batch_size_ > 0);
+  ABSL_DCHECK(compression_ == 0.0 || batch_size_ > 0);
   centroids_.reserve(MaxCentroids(compression_) + batch_size_);
   centroids_.clear();
   merged_ = 0;
@@ -77,7 +77,7 @@ void TDigest::Add(double val, int64_t count) {
 }

 void TDigest::AddUnmergedCentroid(const CentroidPod& centroid) {
-  DCHECK_LT(unmerged_, batch_size_);
+  ABSL_DCHECK_LT(unmerged_, batch_size_);

   centroids_.push_back(centroid);
   ++unmerged_;
@@ -117,7 +117,7 @@ void TDigest::DoMerge() {

   // We first sort the centroids, and assume the first centroid is merged,
   // and the rest are unmerged.
-  DCHECK(!centroids_.empty());
+  ABSL_DCHECK(!centroids_.empty());
   std::sort(centroids_.begin(), centroids_.end());
   unmerged_ += merged_ - 1;
   merged_ = 1;
@@ -170,7 +170,7 @@ void TDigest::DoMerge() {
     min_ = std::min(min_, centroids_.front().mean);
     max_ = std::max(max_, centroids_.back().mean);
   }
-  DCHECK_LE(centroids_.size(), MaxCentroids(compression_));
+  ABSL_DCHECK_LE(centroids_.size(), MaxCentroids(compression_));
 }

 // We use linear interpolation between mid points of centroids when calculating
@@ -213,7 +213,7 @@ double TDigest::Cdf(double val) {
   if (val >= max_) {
     return 1;
   }
-  DCHECK_NE(min_, max_);
+  ABSL_DCHECK_NE(min_, max_);

   if (merged_ == 1) {
     return (val - min_) / (min_ - max_);
@@ -259,13 +259,13 @@ double TDigest::Cdf(double val) {
     accum_count += (centroids_[i].count + centroids_[i + 1].count) / 2.0;
   }

-  LOG(DFATAL) << "Cannot measure CDF for: " << val;
+  ABSL_LOG(DFATAL) << "Cannot measure CDF for: " << val;
   return kNan;
 }

 double TDigest::Quantile(double quantile) {
-  DCHECK_LE(quantile, 1);
-  DCHECK_GE(quantile, 0);
+  ABSL_DCHECK_LE(quantile, 1);
+  ABSL_DCHECK_GE(quantile, 0);

   DoMerge();

@@ -407,7 +407,7 @@ absl::Status TDigest::FromString(absl::string_view string) {
   }

   // Validate min/max/sum/count.
-  DCHECK_LT(std::abs(sum - sum_), 1e-10) << "Invalid sum value.";
+  ABSL_DCHECK_LT(std::abs(sum - sum_), 1e-10) << "Invalid sum value.";

   if (count != count_) {
     return absl::InvalidArgumentError("Invalid count value.");
diff --git a/third_party/grpc/source/src/core/util/thd.h b/third_party/grpc/source/src/core/util/thd.h
index 61f229af97ef0..93ca30c8afddf 100644
--- a/third_party/grpc/source/src/core/util/thd.h
+++ b/third_party/grpc/source/src/core/util/thd.h
@@ -29,7 +29,7 @@
 #include <utility>

 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 namespace grpc_core {
 namespace internal {
@@ -123,7 +123,7 @@ class Thread {
   Thread& operator=(Thread&& other) noexcept {
     if (this != &other) {
       // TODO(vjpai): if we can be sure that all Thread's are actually
-      // constructed, then we should assert CHECK(impl_ == nullptr) here.
+      // constructed, then we should assert ABSL_CHECK(impl_ == nullptr) here.
       // However, as long as threads come in structures that are
       // allocated via gpr_malloc, this will not be the case, so we cannot
       // assert it for the time being.
@@ -142,11 +142,11 @@ class Thread {
   /// the Join function kills it, or it was detached (non-joinable) and it has
   /// run to completion and is now killing itself. The destructor shouldn't have
   /// to do anything.
-  ~Thread() { CHECK(!options_.joinable() || impl_ == nullptr); }
+  ~Thread() { ABSL_CHECK(!options_.joinable() || impl_ == nullptr); }

   void Start() {
     if (impl_ != nullptr) {
-      CHECK(state_ == ALIVE);
+      ABSL_CHECK(state_ == ALIVE);
       state_ = STARTED;
       impl_->Start();
       // If the Thread is not joinable, then the impl_ will cause the deletion
@@ -155,7 +155,7 @@ class Thread {
       // no need to change the value of the impl_ or state_ . The next operation
       // on this object will be the deletion, which will trigger the destructor.
     } else {
-      CHECK(state_ == FAILED);
+      ABSL_CHECK(state_ == FAILED);
     }
   }

@@ -167,7 +167,7 @@ class Thread {
       state_ = DONE;
       impl_ = nullptr;
     } else {
-      CHECK(state_ == FAILED);
+      ABSL_CHECK(state_ == FAILED);
     }
   }

diff --git a/third_party/grpc/source/src/core/util/time.cc b/third_party/grpc/source/src/core/util/time.cc
index 2d7c6873c1084..8c42b2b350aaf 100644
--- a/third_party/grpc/source/src/core/util/time.cc
+++ b/third_party/grpc/source/src/core/util/time.cc
@@ -23,8 +23,8 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_format.h"
 #include "src/core/util/no_destruct.h"

@@ -59,19 +59,19 @@ GPR_ATTRIBUTE_NOINLINE std::pair<int64_t, gpr_cycle_counter> InitTime() {
     if (process_epoch_seconds > 1) {
       break;
     }
-    LOG(INFO) << "gpr_now(GPR_CLOCK_MONOTONIC) returns a very small number: "
+    ABSL_LOG(INFO) << "gpr_now(GPR_CLOCK_MONOTONIC) returns a very small number: "
                  "sleeping for 100ms";
     gpr_sleep_until(gpr_time_add(now, gpr_time_from_millis(100, GPR_TIMESPAN)));
   }

   // Check time has increased past 1 second.
-  CHECK_GT(process_epoch_seconds, 1);
+  ABSL_CHECK_GT(process_epoch_seconds, 1);
   // Fake the epoch to always return >=1 second from our monotonic clock (to
   // avoid bugs elsewhere)
   process_epoch_seconds -= 1;
   int64_t expected = 0;
   gpr_cycle_counter process_epoch_cycles = (cycles_start + cycles_end) / 2;
-  CHECK_NE(process_epoch_cycles, 0);
+  ABSL_CHECK_NE(process_epoch_cycles, 0);
   if (!g_process_epoch_seconds.compare_exchange_strong(
           expected, process_epoch_seconds, std::memory_order_relaxed,
           std::memory_order_relaxed)) {
@@ -118,7 +118,7 @@ gpr_timespec MillisecondsAsTimespec(int64_t millis, gpr_clock_type clock_type) {
 }

 int64_t TimespanToMillisRoundUp(gpr_timespec ts) {
-  CHECK(ts.clock_type == GPR_TIMESPAN);
+  ABSL_CHECK(ts.clock_type == GPR_TIMESPAN);
   double x = GPR_MS_PER_SEC * static_cast<double>(ts.tv_sec) +
              (static_cast<double>(ts.tv_nsec) / GPR_NS_PER_MS) +
              (static_cast<double>(GPR_NS_PER_SEC - 1) /
@@ -133,7 +133,7 @@ int64_t TimespanToMillisRoundUp(gpr_timespec ts) {
 }

 int64_t TimespanToMillisRoundDown(gpr_timespec ts) {
-  CHECK(ts.clock_type == GPR_TIMESPAN);
+  ABSL_CHECK(ts.clock_type == GPR_TIMESPAN);
   double x = GPR_MS_PER_SEC * static_cast<double>(ts.tv_sec) +
              (static_cast<double>(ts.tv_nsec) / GPR_NS_PER_MS);
   if (x <= static_cast<double>(std::numeric_limits<int64_t>::min())) {
diff --git a/third_party/grpc/source/src/core/util/time.h b/third_party/grpc/source/src/core/util/time.h
index 1de2b4ff99768..20a5ce4ad9f36 100644
--- a/third_party/grpc/source/src/core/util/time.h
+++ b/third_party/grpc/source/src/core/util/time.h
@@ -37,7 +37,7 @@
     if (prev == 0) prev = now;                                  \
     if (now - prev > (n) * 1000) {                              \
       prev = now;                                               \
-      VLOG(2) << absl::StrFormat(format, __VA_ARGS__);          \
+      ABSL_VLOG(2) << absl::StrFormat(format, __VA_ARGS__);          \
     }                                                           \
   } while (0)

diff --git a/third_party/grpc/source/src/core/util/time_precise.cc b/third_party/grpc/source/src/core/util/time_precise.cc
index 76dce6d57dfba..ccbf039b3b6f0 100644
--- a/third_party/grpc/source/src/core/util/time_precise.cc
+++ b/third_party/grpc/source/src/core/util/time_precise.cc
@@ -27,7 +27,7 @@

 #include <algorithm>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/util/time_precise.h"

 #ifndef GPR_CYCLE_COUNTER_CUSTOM
@@ -71,7 +71,7 @@ static bool is_fake_clock() {
 }

 void gpr_precise_clock_init(void) {
-  VLOG(2) << "Calibrating timers";
+  ABSL_VLOG(2) << "Calibrating timers";

 #if GPR_LINUX
   if (read_freq_from_kernel(&cycles_per_second)) {
@@ -109,7 +109,7 @@ void gpr_precise_clock_init(void) {
     last_freq = freq;
   }
   cycles_per_second = last_freq;
-  VLOG(2) << "... cycles_per_second = " << cycles_per_second << "\n";
+  ABSL_VLOG(2) << "... cycles_per_second = " << cycles_per_second << "\n";
 }

 gpr_timespec gpr_cycle_counter_to_time(gpr_cycle_counter cycles) {
diff --git a/third_party/grpc/source/src/core/util/time_util.cc b/third_party/grpc/source/src/core/util/time_util.cc
index d20dca30e52aa..3ef5322bbf30e 100644
--- a/third_party/grpc/source/src/core/util/time_util.cc
+++ b/third_party/grpc/source/src/core/util/time_util.cc
@@ -21,7 +21,7 @@
 #include <stdint.h>
 #include <time.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 namespace grpc_core {

@@ -54,7 +54,7 @@ gpr_timespec ToGprTimeSpec(absl::Time time) {
 }

 absl::Duration ToAbslDuration(gpr_timespec ts) {
-  CHECK(ts.clock_type == GPR_TIMESPAN);
+  ABSL_CHECK(ts.clock_type == GPR_TIMESPAN);
   if (gpr_time_cmp(ts, gpr_inf_future(GPR_TIMESPAN)) == 0) {
     return absl::InfiniteDuration();
   } else if (gpr_time_cmp(ts, gpr_inf_past(GPR_TIMESPAN)) == 0) {
@@ -65,7 +65,7 @@ absl::Duration ToAbslDuration(gpr_timespec ts) {
 }

 absl::Time ToAbslTime(gpr_timespec ts) {
-  CHECK(ts.clock_type != GPR_TIMESPAN);
+  ABSL_CHECK(ts.clock_type != GPR_TIMESPAN);
   gpr_timespec rts = gpr_convert_clock_type(ts, GPR_CLOCK_REALTIME);
   if (gpr_time_cmp(rts, gpr_inf_future(GPR_CLOCK_REALTIME)) == 0) {
     return absl::InfiniteFuture();
diff --git a/third_party/grpc/source/src/core/util/unique_ptr_with_bitset.h b/third_party/grpc/source/src/core/util/unique_ptr_with_bitset.h
index 112c3ea49ec6c..4569c700c700c 100644
--- a/third_party/grpc/source/src/core/util/unique_ptr_with_bitset.h
+++ b/third_party/grpc/source/src/core/util/unique_ptr_with_bitset.h
@@ -18,7 +18,7 @@
 #include <memory>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/numeric/bits.h"

 namespace grpc_core {
@@ -36,7 +36,7 @@ class UniquePtrWithBitset {
   UniquePtrWithBitset(std::unique_ptr<T>&& p)
       : UniquePtrWithBitset(p.release()) {}
   ~UniquePtrWithBitset() {
-    DCHECK_LE(kBits, static_cast<size_t>(absl::countr_zero(alignof(T))));
+    ABSL_DCHECK_LE(kBits, static_cast<size_t>(absl::countr_zero(alignof(T))));
     delete get();
   }
   UniquePtrWithBitset(const UniquePtrWithBitset&) = delete;
@@ -59,15 +59,15 @@ class UniquePtrWithBitset {
   }

   void SetBit(size_t bit) {
-    DCHECK_LT(bit, kBits);
+    ABSL_DCHECK_LT(bit, kBits);
     p_ |= 1 << bit;
   }
   void ClearBit(size_t bit) {
-    DCHECK_LT(bit, kBits);
+    ABSL_DCHECK_LT(bit, kBits);
     p_ &= ~(1 << bit);
   }
   bool TestBit(size_t bit) const {
-    DCHECK_LT(bit, kBits);
+    ABSL_DCHECK_LT(bit, kBits);
     return p_ & (1 << bit);
   }

diff --git a/third_party/grpc/source/src/core/util/uri.cc b/third_party/grpc/source/src/core/util/uri.cc
index 0469c640d703d..66dbac898d4d7 100644
--- a/third_party/grpc/source/src/core/util/uri.cc
+++ b/third_party/grpc/source/src/core/util/uri.cc
@@ -26,7 +26,7 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/strings/ascii.h"
 #include "absl/strings/escaping.h"
@@ -140,7 +140,7 @@ std::string PercentEncode(absl::string_view str,
   for (char c : str) {
     if (!is_allowed_char(c)) {
       std::string hex = absl::BytesToHexString(absl::string_view(&c, 1));
-      CHECK_EQ(hex.size(), 2u);
+      ABSL_CHECK_EQ(hex.size(), 2u);
       // BytesToHexString() returns lower case, but
       // https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1 says
       // to prefer upper-case.
diff --git a/third_party/grpc/source/src/core/util/useful.h b/third_party/grpc/source/src/core/util/useful.h
index 834e3b32b9b0a..749856554a275 100644
--- a/third_party/grpc/source/src/core/util/useful.h
+++ b/third_party/grpc/source/src/core/util/useful.h
@@ -21,7 +21,7 @@
 #include <limits>
 #include <variant>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/numeric/bits.h"
 #include "absl/strings/string_view.h"

diff --git a/third_party/grpc/source/src/core/util/validation_errors.cc b/third_party/grpc/source/src/core/util/validation_errors.cc
index 850ea674a5fae..0ebf5e1e4d72d 100644
--- a/third_party/grpc/source/src/core/util/validation_errors.cc
+++ b/third_party/grpc/source/src/core/util/validation_errors.cc
@@ -19,7 +19,7 @@

 #include <utility>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_join.h"
@@ -38,7 +38,7 @@ void ValidationErrors::PopField() { fields_.pop_back(); }
 void ValidationErrors::AddError(absl::string_view error) {
   auto key = absl::StrJoin(fields_, "");
   if (field_errors_[key].size() >= max_error_count_) {
-    VLOG(2) << "Ignoring validation error: too many errors found ("
+    ABSL_VLOG(2) << "Ignoring validation error: too many errors found ("
             << max_error_count_ << ")";
     return;
   }
diff --git a/third_party/grpc/source/src/core/util/wait_for_single_owner.h b/third_party/grpc/source/src/core/util/wait_for_single_owner.h
index 2b201a94f6996..2efc7f1b9b753 100644
--- a/third_party/grpc/source/src/core/util/wait_for_single_owner.h
+++ b/third_party/grpc/source/src/core/util/wait_for_single_owner.h
@@ -17,7 +17,7 @@

 #include <memory>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/util/crash.h"
 #include "src/core/util/time.h"

@@ -49,7 +49,7 @@ void WaitForSingleOwnerWithTimeout(std::shared_ptr<T> obj, Duration timeout) {
     }
     // To avoid log spam, wait a few seconds to begin logging the wait time.
     if (elapsed >= Duration::Seconds(2)) {
-      LOG_EVERY_N_SEC(INFO, 2)
+      ABSL_LOG_EVERY_N_SEC(INFO, 2)
           << "obj.use_count() = " << obj.use_count() << " timeout_remaining = "
           << absl::FormatDuration(absl::Milliseconds(remaining.millis()));
     }
diff --git a/third_party/grpc/source/src/core/util/windows/stat.cc b/third_party/grpc/source/src/core/util/windows/stat.cc
index 5ac15a407cfd8..1380bde94b4c6 100644
--- a/third_party/grpc/source/src/core/util/windows/stat.cc
+++ b/third_party/grpc/source/src/core/util/windows/stat.cc
@@ -22,8 +22,8 @@
 #include <sys/stat.h>
 #include <sys/types.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/util/crash.h"
 #include "src/core/util/stat.h"
 #include "src/core/util/strerror.h"
@@ -31,12 +31,12 @@
 namespace grpc_core {

 absl::Status GetFileModificationTime(const char* filename, time_t* timestamp) {
-  CHECK_NE(filename, nullptr);
-  CHECK_NE(timestamp, nullptr);
+  ABSL_CHECK_NE(filename, nullptr);
+  ABSL_CHECK_NE(timestamp, nullptr);
   struct _stat buf;
   if (_stat(filename, &buf) != 0) {
     std::string error_msg = StrError(errno);
-    LOG(ERROR) << "_stat failed for filename " << filename << " with error "
+    ABSL_LOG(ERROR) << "_stat failed for filename " << filename << " with error "
                << error_msg;
     return absl::Status(absl::StatusCode::kInternal, error_msg);
   }
diff --git a/third_party/grpc/source/src/core/util/windows/sync.cc b/third_party/grpc/source/src/core/util/windows/sync.cc
index 3bde6dad729d6..d14d87094e3ec 100644
--- a/third_party/grpc/source/src/core/util/windows/sync.cc
+++ b/third_party/grpc/source/src/core/util/windows/sync.cc
@@ -26,7 +26,7 @@
 #include <grpc/support/sync.h>
 #include <grpc/support/time.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 void gpr_mu_init(gpr_mu* mu) {
   InitializeCriticalSection(&mu->cs);
@@ -37,7 +37,7 @@ void gpr_mu_destroy(gpr_mu* mu) { DeleteCriticalSection(&mu->cs); }

 void gpr_mu_lock(gpr_mu* mu) {
   EnterCriticalSection(&mu->cs);
-  CHECK(!mu->locked);
+  ABSL_CHECK(!mu->locked);
   mu->locked = 1;
 }

diff --git a/third_party/grpc/source/src/core/util/windows/thd.cc b/third_party/grpc/source/src/core/util/windows/thd.cc
index 464d8a6d06ccd..be3ca122cd181 100644
--- a/third_party/grpc/source/src/core/util/windows/thd.cc
+++ b/third_party/grpc/source/src/core/util/windows/thd.cc
@@ -27,8 +27,8 @@
 #include <grpc/support/time.h>
 #include <string.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/util/crash.h"
 #include "src/core/util/memory.h"
 #include "src/core/util/thd.h"
@@ -101,7 +101,7 @@ class ThreadInternalsWindows

   void Join() override {
     DWORD ret = WaitForSingleObject(info_->join_event, INFINITE);
-    CHECK(ret == WAIT_OBJECT_0);
+    ABSL_CHECK(ret == WAIT_OBJECT_0);
     destroy_thread();
   }

@@ -121,7 +121,7 @@ class ThreadInternalsWindows
     g_thd_info->body(g_thd_info->arg);
     if (g_thd_info->joinable) {
       BOOL ret = SetEvent(g_thd_info->join_event);
-      CHECK(ret);
+      ABSL_CHECK(ret);
     } else {
       gpr_free(g_thd_info);
     }
@@ -147,12 +147,12 @@ namespace grpc_core {

 void Thread::Signal(gpr_thd_id /* tid */, int /* sig */) {
   // TODO(hork): Implement
-  VLOG(2) << "Thread signals are not supported on Windows.";
+  ABSL_VLOG(2) << "Thread signals are not supported on Windows.";
 }

 void Thread::Kill(gpr_thd_id /* tid */) {
   // TODO(hork): Implement
-  VLOG(2) << "Thread::Kill is not supported on Windows.";
+  ABSL_VLOG(2) << "Thread::Kill is not supported on Windows.";
 }

 Thread::Thread(const char* /* thd_name */, void (*thd_body)(void* arg),
diff --git a/third_party/grpc/source/src/core/util/windows/time.cc b/third_party/grpc/source/src/core/util/windows/time.cc
index 1e8bb4b068712..1de729dafc003 100644
--- a/third_party/grpc/source/src/core/util/windows/time.cc
+++ b/third_party/grpc/source/src/core/util/windows/time.cc
@@ -27,7 +27,7 @@
 #include <process.h>
 #include <sys/timeb.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/util/time_precise.h"

 static LARGE_INTEGER g_start_time = []() {
@@ -95,8 +95,8 @@ void gpr_sleep_until(gpr_timespec until) {
     delta = gpr_time_sub(until, now);
     sleep_millis =
         delta.tv_sec * GPR_MS_PER_SEC + delta.tv_nsec / GPR_NS_PER_MS;
-    CHECK_GE(sleep_millis, 0);
-    CHECK_LE(sleep_millis, INT_MAX);
+    ABSL_CHECK_GE(sleep_millis, 0);
+    ABSL_CHECK_LE(sleep_millis, INT_MAX);
     Sleep((DWORD)sleep_millis);
   }
 }
diff --git a/third_party/grpc/source/src/core/util/work_serializer.cc b/third_party/grpc/source/src/core/util/work_serializer.cc
index 4aa6154e33c0a..b83658f86deb8 100644
--- a/third_party/grpc/source/src/core/util/work_serializer.cc
+++ b/third_party/grpc/source/src/core/util/work_serializer.cc
@@ -29,8 +29,8 @@
 #include <utility>

 #include "absl/container/inlined_vector.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/lib/experiments/experiments.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
@@ -175,7 +175,7 @@ void WorkSerializer::WorkSerializerImpl::Run(
     running_start_time_ = std::chrono::steady_clock::now();
     items_processed_during_run_ = 0;
     time_running_items_ = std::chrono::steady_clock::duration();
-    CHECK(processing_.empty());
+    ABSL_CHECK(processing_.empty());
     processing_.emplace_back(std::move(callback), location);
     event_engine_->Run(this);
   } else {
diff --git a/third_party/grpc/source/src/core/xds/grpc/certificate_provider_store.cc b/third_party/grpc/source/src/core/xds/grpc/certificate_provider_store.cc
index a68a8a7974bc3..b65890627eef8 100644
--- a/third_party/grpc/source/src/core/xds/grpc/certificate_provider_store.cc
+++ b/third_party/grpc/source/src/core/xds/grpc/certificate_provider_store.cc
@@ -21,7 +21,7 @@
 #include <grpc/support/json.h>
 #include <grpc/support/port_platform.h>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/config/core_configuration.h"
 #include "src/core/lib/security/certificate_provider/certificate_provider_registry.h"
@@ -126,7 +126,7 @@ CertificateProviderStore::CreateCertificateProviderLocked(
     // This should never happen since an entry is only inserted in the
     // plugin_config_map_ if the corresponding factory was found when parsing
     // the xDS bootstrap file.
-    LOG(ERROR) << "Certificate provider factory " << definition.plugin_name
+    ABSL_LOG(ERROR) << "Certificate provider factory " << definition.plugin_name
                << " not found";
     return nullptr;
   }
diff --git a/third_party/grpc/source/src/core/xds/grpc/file_watcher_certificate_provider_factory.cc b/third_party/grpc/source/src/core/xds/grpc/file_watcher_certificate_provider_factory.cc
index f668d3f381226..8de1f5510c335 100644
--- a/third_party/grpc/source/src/core/xds/grpc/file_watcher_certificate_provider_factory.cc
+++ b/third_party/grpc/source/src/core/xds/grpc/file_watcher_certificate_provider_factory.cc
@@ -26,7 +26,7 @@
 #include <memory>
 #include <vector>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_format.h"
 #include "absl/strings/str_join.h"
 #include "src/core/config/core_configuration.h"
@@ -114,7 +114,7 @@ RefCountedPtr<grpc_tls_certificate_provider>
 FileWatcherCertificateProviderFactory::CreateCertificateProvider(
     RefCountedPtr<CertificateProviderFactory::Config> config) {
   if (config->name() != name()) {
-    LOG(ERROR) << "Wrong config type Actual:" << config->name()
+    ABSL_LOG(ERROR) << "Wrong config type Actual:" << config->name()
                << " vs Expected:" << name();
     return nullptr;
   }
diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_certificate_provider.cc b/third_party/grpc/source/src/core/xds/grpc/xds_certificate_provider.cc
index 17ab5aac4d9b1..c8f2f36c533c7 100644
--- a/third_party/grpc/source/src/core/xds/grpc/xds_certificate_provider.cc
+++ b/third_party/grpc/source/src/core/xds/grpc/xds_certificate_provider.cc
@@ -24,7 +24,7 @@
 #include <utility>

 #include "absl/functional/bind_front.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/channel/channel_args.h"
 #include "src/core/lib/iomgr/error.h"
 #include "src/core/lib/security/security_connector/ssl_utils.h"
@@ -186,7 +186,7 @@ void XdsCertificateProvider::WatchStatusCallback(std::string cert_name,
     }
   } else if (!root_being_watched && root_cert_watcher_ != nullptr) {
     // Cancel root cert watch.
-    CHECK(root_cert_provider_ != nullptr);
+    ABSL_CHECK(root_cert_provider_ != nullptr);
     root_cert_provider_->distributor()->CancelTlsCertificatesWatch(
         root_cert_watcher_);
     root_cert_watcher_ = nullptr;
@@ -206,7 +206,7 @@ void XdsCertificateProvider::WatchStatusCallback(std::string cert_name,
           std::move(watcher), std::nullopt, identity_cert_name_);
     }
   } else if (!identity_being_watched && identity_cert_watcher_ != nullptr) {
-    CHECK(identity_cert_provider_ != nullptr);
+    ABSL_CHECK(identity_cert_provider_ != nullptr);
     identity_cert_provider_->distributor()->CancelTlsCertificatesWatch(
         identity_cert_watcher_);
     identity_cert_watcher_ = nullptr;
diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_client_grpc.cc b/third_party/grpc/source/src/core/xds/grpc/xds_client_grpc.cc
index 5171a6d454c13..aa537475fff52 100644
--- a/third_party/grpc/source/src/core/xds/grpc/xds_client_grpc.cc
+++ b/third_party/grpc/source/src/core/xds/grpc/xds_client_grpc.cc
@@ -32,7 +32,7 @@
 #include <vector>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/string_view.h"
diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_cluster_parser.cc b/third_party/grpc/source/src/core/xds/grpc/xds_cluster_parser.cc
index 42f9f65287c4a..441954620a3e7 100644
--- a/third_party/grpc/source/src/core/xds/grpc/xds_cluster_parser.cc
+++ b/third_party/grpc/source/src/core/xds/grpc/xds_cluster_parser.cc
@@ -19,8 +19,8 @@
 #include <memory>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -446,7 +446,7 @@ absl::StatusOr<std::shared_ptr<const XdsClusterResource>> CdsResourceParse(
     ValidationErrors::ScopedField field(&errors, ".cluster_type");
     const auto* custom_cluster_type =
         envoy_config_cluster_v3_Cluster_cluster_type(cluster);
-    CHECK_NE(custom_cluster_type, nullptr);
+    ABSL_CHECK_NE(custom_cluster_type, nullptr);
     ValidationErrors::ScopedField field2(&errors, ".typed_config");
     const auto* typed_config =
         envoy_config_cluster_v3_Cluster_CustomClusterType_typed_config(
@@ -729,7 +729,7 @@ void MaybeLogCluster(const XdsResourceType::DecodeContext& context,
     char buf[10240];
     upb_TextEncode(reinterpret_cast<const upb_Message*>(cluster), msg_type,
                    nullptr, 0, buf, sizeof(buf));
-    VLOG(2) << "[xds_client " << context.client << "] Cluster: " << buf;
+    ABSL_VLOG(2) << "[xds_client " << context.client << "] Cluster: " << buf;
   }
 }

@@ -754,13 +754,13 @@ XdsResourceType::DecodeResult XdsClusterResourceType::Decode(
   auto cds_resource = CdsResourceParse(context, resource);
   if (!cds_resource.ok()) {
     if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
-      LOG(ERROR) << "[xds_client " << context.client << "] invalid Cluster "
+      ABSL_LOG(ERROR) << "[xds_client " << context.client << "] invalid Cluster "
                  << *result.name << ": " << cds_resource.status();
     }
     result.resource = cds_resource.status();
   } else {
     if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
-      LOG(INFO) << "[xds_client " << context.client << "] parsed Cluster "
+      ABSL_LOG(INFO) << "[xds_client " << context.client << "] parsed Cluster "
                 << *result.name << ": " << (*cds_resource)->ToString();
     }
     result.resource = std::move(*cds_resource);
diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_cluster_specifier_plugin.cc b/third_party/grpc/source/src/core/xds/grpc/xds_cluster_specifier_plugin.cc
index 12d56543813f5..a21214ca4e241 100644
--- a/third_party/grpc/source/src/core/xds/grpc/xds_cluster_specifier_plugin.cc
+++ b/third_party/grpc/source/src/core/xds/grpc/xds_cluster_specifier_plugin.cc
@@ -24,7 +24,7 @@
 #include <utility>
 #include <variant>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/util/json/json.h"
@@ -89,7 +89,7 @@ Json XdsRouteLookupClusterSpecifierPlugin::GenerateLoadBalancingPolicyConfig(
   upb_JsonEncode(plugin_config, msg_type, symtab, 0,
                  reinterpret_cast<char*>(buf), json_size + 1, status.ptr());
   auto json = JsonParse(reinterpret_cast<char*>(buf));
-  CHECK(json.ok());
+  ABSL_CHECK(json.ok());
   return Json::FromArray({Json::FromObject(
       {{"rls_experimental",
         Json::FromObject({
diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_endpoint_parser.cc b/third_party/grpc/source/src/core/xds/grpc/xds_endpoint_parser.cc
index 0980eb51149b4..282176adb047b 100644
--- a/third_party/grpc/source/src/core/xds/grpc/xds_endpoint_parser.cc
+++ b/third_party/grpc/source/src/core/xds/grpc/xds_endpoint_parser.cc
@@ -27,8 +27,8 @@
 #include <set>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -95,7 +95,7 @@ void MaybeLogClusterLoadAssignment(
     char buf[10240];
     upb_TextEncode(reinterpret_cast<const upb_Message*>(cla), msg_type, nullptr,
                    0, buf, sizeof(buf));
-    VLOG(2) << "[xds_client " << context.client
+    ABSL_VLOG(2) << "[xds_client " << context.client
             << "] ClusterLoadAssignment: " << buf;
   }
 }
@@ -366,7 +366,7 @@ absl::StatusOr<std::shared_ptr<const XdsEndpointResource>> EdsResourceParse(
       auto parsed_locality =
           LocalityParse(context, endpoints[i], &address_set, &errors);
       if (parsed_locality.has_value()) {
-        CHECK_NE(parsed_locality->locality.lb_weight, 0u);
+        ABSL_CHECK_NE(parsed_locality->locality.lb_weight, 0u);
         // Make sure prorities is big enough. Note that they might not
         // arrive in priority order.
         if (eds_resource->priorities.size() < parsed_locality->priority + 1) {
@@ -456,14 +456,14 @@ XdsResourceType::DecodeResult XdsEndpointResourceType::Decode(
   auto eds_resource = EdsResourceParse(context, resource);
   if (!eds_resource.ok()) {
     if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
-      LOG(ERROR) << "[xds_client " << context.client
+      ABSL_LOG(ERROR) << "[xds_client " << context.client
                  << "] invalid ClusterLoadAssignment " << *result.name << ": "
                  << eds_resource.status();
     }
     result.resource = eds_resource.status();
   } else {
     if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
-      LOG(INFO) << "[xds_client " << context.client
+      ABSL_LOG(INFO) << "[xds_client " << context.client
                 << "] parsed ClusterLoadAssignment " << *result.name << ": "
                 << (*eds_resource)->ToString();
     }
diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_http_filter_registry.cc b/third_party/grpc/source/src/core/xds/grpc/xds_http_filter_registry.cc
index ec64f365599e5..9bf71bb4c3a77 100644
--- a/third_party/grpc/source/src/core/xds/grpc/xds_http_filter_registry.cc
+++ b/third_party/grpc/source/src/core/xds/grpc/xds_http_filter_registry.cc
@@ -23,7 +23,7 @@
 #include <variant>
 #include <vector>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "envoy/extensions/filters/http/router/v3/router.upb.h"
 #include "envoy/extensions/filters/http/router/v3/router.upbdefs.h"
 #include "src/core/util/json/json.h"
@@ -98,10 +98,10 @@ XdsHttpFilterRegistry::XdsHttpFilterRegistry(bool register_builtins) {

 void XdsHttpFilterRegistry::RegisterFilter(
     std::unique_ptr<XdsHttpFilterImpl> filter) {
-  CHECK(registry_map_.emplace(filter->ConfigProtoName(), filter.get()).second);
+  ABSL_CHECK(registry_map_.emplace(filter->ConfigProtoName(), filter.get()).second);
   auto override_proto_name = filter->OverrideConfigProtoName();
   if (!override_proto_name.empty()) {
-    CHECK(registry_map_.emplace(override_proto_name, filter.get()).second);
+    ABSL_CHECK(registry_map_.emplace(override_proto_name, filter.get()).second);
   }
   owning_list_.push_back(std::move(filter));
 }
diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_listener_parser.cc b/third_party/grpc/source/src/core/xds/grpc/xds_listener_parser.cc
index 9360f1db025ba..e6ecbd9962e5f 100644
--- a/third_party/grpc/source/src/core/xds/grpc/xds_listener_parser.cc
+++ b/third_party/grpc/source/src/core/xds/grpc/xds_listener_parser.cc
@@ -22,8 +22,8 @@
 #include <set>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -143,7 +143,7 @@ void MaybeLogHttpConnectionManager(
     upb_TextEncode(
         reinterpret_cast<const upb_Message*>(http_connection_manager_config),
         msg_type, nullptr, 0, buf, sizeof(buf));
-    VLOG(2) << "[xds_client " << context.client
+    ABSL_VLOG(2) << "[xds_client " << context.client
             << "] HttpConnectionManager: " << buf;
   }
 }
@@ -739,7 +739,7 @@ void AddFilterChainDataForSourceType(
     const FilterChain& filter_chain,
     InternalFilterChainMap::DestinationIp* destination_ip,
     ValidationErrors* errors) {
-  CHECK(static_cast<unsigned int>(filter_chain.filter_chain_match.source_type) <
+  ABSL_CHECK(static_cast<unsigned int>(filter_chain.filter_chain_match.source_type) <
         3u);
   AddFilterChainDataForSourceIpRange(
       filter_chain,
@@ -958,7 +958,7 @@ void MaybeLogListener(const XdsResourceType::DecodeContext& context,
     char buf[10240];
     upb_TextEncode(reinterpret_cast<const upb_Message*>(listener), msg_type,
                    nullptr, 0, buf, sizeof(buf));
-    VLOG(2) << "[xds_client " << context.client << "] Listener: " << buf;
+    ABSL_VLOG(2) << "[xds_client " << context.client << "] Listener: " << buf;
   }
 }

@@ -983,13 +983,13 @@ XdsResourceType::DecodeResult XdsListenerResourceType::Decode(
   auto listener = LdsResourceParse(context, resource);
   if (!listener.ok()) {
     if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
-      LOG(ERROR) << "[xds_client " << context.client << "] invalid Listener "
+      ABSL_LOG(ERROR) << "[xds_client " << context.client << "] invalid Listener "
                  << *result.name << ": " << listener.status();
     }
     result.resource = listener.status();
   } else {
     if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
-      LOG(INFO) << "[xds_client " << context.client << "] parsed Listener "
+      ABSL_LOG(INFO) << "[xds_client " << context.client << "] parsed Listener "
                 << *result.name << ": " << (*listener)->ToString();
     }
     result.resource = std::move(*listener);
diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_metadata.cc b/third_party/grpc/source/src/core/xds/grpc/xds_metadata.cc
index 4e2d5b2ca2cef..654a5f85bdaa4 100644
--- a/third_party/grpc/source/src/core/xds/grpc/xds_metadata.cc
+++ b/third_party/grpc/source/src/core/xds/grpc/xds_metadata.cc
@@ -21,7 +21,7 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_join.h"
 #include "absl/strings/string_view.h"
@@ -30,8 +30,8 @@ namespace grpc_core {

 void XdsMetadataMap::Insert(absl::string_view key,
                             std::unique_ptr<XdsMetadataValue> value) {
-  CHECK(value != nullptr);
-  CHECK(map_.emplace(key, std::move(value)).second) << "duplicate key: " << key;
+  ABSL_CHECK(value != nullptr);
+  ABSL_CHECK(map_.emplace(key, std::move(value)).second) << "duplicate key: " << key;
 }

 const XdsMetadataValue* XdsMetadataMap::Find(absl::string_view key) const {
diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_metadata_parser.cc b/third_party/grpc/source/src/core/xds/grpc/xds_metadata_parser.cc
index d6660248356aa..f9abfdbf546ce 100644
--- a/third_party/grpc/source/src/core/xds/grpc/xds_metadata_parser.cc
+++ b/third_party/grpc/source/src/core/xds/grpc/xds_metadata_parser.cc
@@ -71,7 +71,7 @@ std::unique_ptr<XdsMetadataValue> ParseGcpAuthnAudience(
     char buf[10240];
     upb_TextEncode(reinterpret_cast<const upb_Message*>(proto), msg_type,
                    nullptr, 0, buf, sizeof(buf));
-    VLOG(2) << "[xds_client " << context.client
+    ABSL_VLOG(2) << "[xds_client " << context.client
             << "] cluster metadata Audience: " << buf;
   }
   absl::string_view url = UpbStringToAbsl(
@@ -105,7 +105,7 @@ std::unique_ptr<XdsMetadataValue> ParseAddress(
     char buf[10240];
     upb_TextEncode(reinterpret_cast<const upb_Message*>(proto), msg_type,
                    nullptr, 0, buf, sizeof(buf));
-    VLOG(2) << "[xds_client " << context.client
+    ABSL_VLOG(2) << "[xds_client " << context.client
             << "] cluster metadata Address: " << buf;
   }
   auto addr = ParseXdsAddress(proto, errors);
diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_route_config_parser.cc b/third_party/grpc/source/src/core/xds/grpc/xds_route_config_parser.cc
index 7b14d16492cd0..37bd458756ad4 100644
--- a/third_party/grpc/source/src/core/xds/grpc/xds_route_config_parser.cc
+++ b/third_party/grpc/source/src/core/xds/grpc/xds_route_config_parser.cc
@@ -31,8 +31,8 @@
 #include <variant>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_cat.h"
@@ -228,7 +228,7 @@ std::optional<StringMatcher> RoutePathMatchParse(
   } else if (envoy_config_route_v3_RouteMatch_has_safe_regex(match)) {
     const envoy_type_matcher_v3_RegexMatcher* regex_matcher =
         envoy_config_route_v3_RouteMatch_safe_regex(match);
-    CHECK_NE(regex_matcher, nullptr);
+    ABSL_CHECK_NE(regex_matcher, nullptr);
     type = StringMatcher::Type::kSafeRegex;
     match_string = UpbStringToStdString(
         envoy_type_matcher_v3_RegexMatcher_regex(regex_matcher));
@@ -256,7 +256,7 @@ void RouteHeaderMatchersParse(const envoy_config_route_v3_RouteMatch* match,
     ValidationErrors::ScopedField field(errors,
                                         absl::StrCat(".headers[", i, "]"));
     const envoy_config_route_v3_HeaderMatcher* header = headers[i];
-    CHECK_NE(header, nullptr);
+    ABSL_CHECK_NE(header, nullptr);
     const std::string name =
         UpbStringToStdString(envoy_config_route_v3_HeaderMatcher_name(header));
     HeaderMatcher::Type type;
@@ -285,7 +285,7 @@ void RouteHeaderMatchersParse(const envoy_config_route_v3_RouteMatch* match,
                    header)) {
       const envoy_type_matcher_v3_RegexMatcher* regex_matcher =
           envoy_config_route_v3_HeaderMatcher_safe_regex_match(header);
-      CHECK_NE(regex_matcher, nullptr);
+      ABSL_CHECK_NE(regex_matcher, nullptr);
       type = HeaderMatcher::Type::kSafeRegex;
       match_string = UpbStringToStdString(
           envoy_type_matcher_v3_RegexMatcher_regex(regex_matcher));
@@ -293,7 +293,7 @@ void RouteHeaderMatchersParse(const envoy_config_route_v3_RouteMatch* match,
       type = HeaderMatcher::Type::kRange;
       const envoy_type_v3_Int64Range* range_matcher =
           envoy_config_route_v3_HeaderMatcher_range_match(header);
-      CHECK_NE(range_matcher, nullptr);
+      ABSL_CHECK_NE(range_matcher, nullptr);
       range_start = envoy_type_v3_Int64Range_start(range_matcher);
       range_end = envoy_type_v3_Int64Range_end(range_matcher);
     } else if (envoy_config_route_v3_HeaderMatcher_has_present_match(header)) {
@@ -303,7 +303,7 @@ void RouteHeaderMatchersParse(const envoy_config_route_v3_RouteMatch* match,
       ValidationErrors::ScopedField field(errors, ".string_match");
       const auto* matcher =
           envoy_config_route_v3_HeaderMatcher_string_match(header);
-      CHECK_NE(matcher, nullptr);
+      ABSL_CHECK_NE(matcher, nullptr);
       if (envoy_type_matcher_v3_StringMatcher_has_exact(matcher)) {
         type = HeaderMatcher::Type::kExact;
         match_string = UpbStringToStdString(
@@ -324,7 +324,7 @@ void RouteHeaderMatchersParse(const envoy_config_route_v3_RouteMatch* match,
         type = HeaderMatcher::Type::kSafeRegex;
         const auto* regex_matcher =
             envoy_type_matcher_v3_StringMatcher_safe_regex(matcher);
-        CHECK_NE(regex_matcher, nullptr);
+        ABSL_CHECK_NE(regex_matcher, nullptr);
         match_string = UpbStringToStdString(
             envoy_type_matcher_v3_RegexMatcher_regex(regex_matcher));
       } else {
@@ -467,7 +467,7 @@ XdsRouteConfigResource::RetryPolicy RetryPolicyParse(
       retry_policy.retry_on.Add(GRPC_STATUS_UNAVAILABLE);
     } else {
       if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
-        LOG(INFO) << "Unsupported retry_on policy " << code;
+        ABSL_LOG(INFO) << "Unsupported retry_on policy " << code;
       }
     }
   }
@@ -649,7 +649,7 @@ std::optional<XdsRouteConfigResource::Route::RouteAction> RouteActionParse(
     ValidationErrors::ScopedField field(errors, ".weighted_clusters");
     const envoy_config_route_v3_WeightedCluster* weighted_clusters_proto =
         envoy_config_route_v3_RouteAction_weighted_clusters(route_action_proto);
-    CHECK_NE(weighted_clusters_proto, nullptr);
+    ABSL_CHECK_NE(weighted_clusters_proto, nullptr);
     std::vector<XdsRouteConfigResource::Route::RouteAction::ClusterWeight>
         action_weighted_clusters;
     uint64_t total_weight = 0;
@@ -910,7 +910,7 @@ void MaybeLogRouteConfiguration(
     char buf[10240];
     upb_TextEncode(reinterpret_cast<const upb_Message*>(route_config), msg_type,
                    nullptr, 0, buf, sizeof(buf));
-    VLOG(2) << "[xds_client " << context.client
+    ABSL_VLOG(2) << "[xds_client " << context.client
             << "] RouteConfiguration: " << buf;
   }
 }
@@ -940,14 +940,14 @@ XdsResourceType::DecodeResult XdsRouteConfigResourceType::Decode(
         errors.status(absl::StatusCode::kInvalidArgument,
                       "errors validating RouteConfiguration resource");
     if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
-      LOG(ERROR) << "[xds_client " << context.client
+      ABSL_LOG(ERROR) << "[xds_client " << context.client
                  << "] invalid RouteConfiguration " << *result.name << ": "
                  << status;
     }
     result.resource = std::move(status);
   } else {
     if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
-      LOG(INFO) << "[xds_client " << context.client
+      ABSL_LOG(INFO) << "[xds_client " << context.client
                 << "] parsed RouteConfiguration " << *result.name << ": "
                 << rds_update->ToString();
     }
diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_routing.cc b/third_party/grpc/source/src/core/xds/grpc/xds_routing.cc
index ca45f10f825c3..7359eac65ab1c 100644
--- a/third_party/grpc/source/src/core/xds/grpc/xds_routing.cc
+++ b/third_party/grpc/source/src/core/xds/grpc/xds_routing.cc
@@ -26,7 +26,7 @@
 #include <cctype>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/match.h"
@@ -115,7 +115,7 @@ std::optional<size_t> XdsRouting::FindVirtualHostForDomain(
       // than current match.
       const MatchType match_type = DomainPatternMatchType(domain_pattern);
       // This should be caught by RouteConfigParse().
-      CHECK(match_type != INVALID_MATCH);
+      ABSL_CHECK(match_type != INVALID_MATCH);
       if (match_type > best_match_type) continue;
       if (match_type == best_match_type &&
           domain_pattern.size() <= longest_match) {
@@ -231,7 +231,7 @@ GeneratePerHTTPFilterConfigs(
     const XdsHttpFilterImpl* filter_impl =
         http_filter_registry.GetFilterForType(
             http_filter.config.config_proto_type_name);
-    CHECK_NE(filter_impl, nullptr);
+    ABSL_CHECK_NE(filter_impl, nullptr);
     // If there is not actually any C-core filter associated with this
     // xDS filter, then it won't need any config, so skip it.
     if (filter_impl->channel_filter() == nullptr) continue;
diff --git a/third_party/grpc/source/src/core/xds/grpc/xds_transport_grpc.cc b/third_party/grpc/source/src/core/xds/grpc/xds_transport_grpc.cc
index f3e0acd033ecc..f2eb3b69de02a 100644
--- a/third_party/grpc/source/src/core/xds/grpc/xds_transport_grpc.cc
+++ b/third_party/grpc/source/src/core/xds/grpc/xds_transport_grpc.cc
@@ -32,7 +32,7 @@
 #include <string_view>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/client_channel/client_channel_filter.h"
 #include "src/core/config/core_configuration.h"
@@ -77,7 +77,7 @@ GrpcXdsTransportFactory::GrpcXdsTransport::GrpcStreamingCall::GrpcStreamingCall(
       factory_->interested_parties(), Slice::FromStaticString(method),
       /*authority=*/std::nullopt, Timestamp::InfFuture(),
       /*registered_method=*/true);
-  CHECK_NE(call_, nullptr);
+  ABSL_CHECK_NE(call_, nullptr);
   // Init data associated with the call.
   grpc_metadata_array_init(&initial_metadata_recv_);
   grpc_metadata_array_init(&trailing_metadata_recv_);
@@ -107,7 +107,7 @@ GrpcXdsTransportFactory::GrpcXdsTransport::GrpcStreamingCall::GrpcStreamingCall(
       this->Ref(DEBUG_LOCATION, "OnRecvInitialMetadata").release(), nullptr);
   call_error = grpc_call_start_batch_and_execute(
       call_, ops, static_cast<size_t>(op - ops), &on_recv_initial_metadata_);
-  CHECK_EQ(call_error, GRPC_CALL_OK);
+  ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
   // Start a batch for recv_trailing_metadata.
   memset(ops, 0, sizeof(ops));
   op = ops;
@@ -124,7 +124,7 @@ GrpcXdsTransportFactory::GrpcXdsTransport::GrpcStreamingCall::GrpcStreamingCall(
   GRPC_CLOSURE_INIT(&on_status_received_, OnStatusReceived, this, nullptr);
   call_error = grpc_call_start_batch_and_execute(
       call_, ops, static_cast<size_t>(op - ops), &on_status_received_);
-  CHECK_EQ(call_error, GRPC_CALL_OK);
+  ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
   GRPC_CLOSURE_INIT(&on_response_received_, OnResponseReceived, this, nullptr);
 }

@@ -134,12 +134,12 @@ GrpcXdsTransportFactory::GrpcXdsTransport::GrpcStreamingCall::
   grpc_byte_buffer_destroy(send_message_payload_);
   grpc_byte_buffer_destroy(recv_message_payload_);
   CSliceUnref(status_details_);
-  CHECK_NE(call_, nullptr);
+  ABSL_CHECK_NE(call_, nullptr);
   grpc_call_unref(call_);
 }

 void GrpcXdsTransportFactory::GrpcXdsTransport::GrpcStreamingCall::Orphan() {
-  CHECK_NE(call_, nullptr);
+  ABSL_CHECK_NE(call_, nullptr);
   // If we are here because xds_client wants to cancel the call,
   // OnStatusReceived() will complete the cancellation and clean up.
   // Otherwise, we are here because xds_client has to orphan a failed call,
@@ -163,7 +163,7 @@ void GrpcXdsTransportFactory::GrpcXdsTransport::GrpcStreamingCall::SendMessage(
   Ref(DEBUG_LOCATION, "OnRequestSent").release();
   grpc_call_error call_error =
       grpc_call_start_batch_and_execute(call_, &op, 1, &on_request_sent_);
-  CHECK_EQ(call_error, GRPC_CALL_OK);
+  ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
 }

 void GrpcXdsTransportFactory::GrpcXdsTransport::GrpcStreamingCall::
@@ -173,10 +173,10 @@ void GrpcXdsTransportFactory::GrpcXdsTransport::GrpcStreamingCall::
   memset(&op, 0, sizeof(op));
   op.op = GRPC_OP_RECV_MESSAGE;
   op.data.recv_message.recv_message = &recv_message_payload_;
-  CHECK_NE(call_, nullptr);
+  ABSL_CHECK_NE(call_, nullptr);
   const grpc_call_error call_error =
       grpc_call_start_batch_and_execute(call_, &op, 1, &on_response_received_);
-  CHECK_EQ(call_error, GRPC_CALL_OK);
+  ABSL_CHECK_EQ(call_error, GRPC_CALL_OK);
 }

 void GrpcXdsTransportFactory::GrpcXdsTransport::GrpcStreamingCall::
@@ -273,7 +273,7 @@ GrpcXdsTransportFactory::GrpcXdsTransport::GrpcXdsTransport(
       << "[GrpcXdsTransport " << this << "] created";
   channel_ = CreateXdsChannel(factory_->args_,
                               static_cast<const GrpcXdsServer&>(server));
-  CHECK(channel_ != nullptr);
+  ABSL_CHECK(channel_ != nullptr);
   if (channel_->IsLame()) {
     *status = absl::UnavailableError("xds client has a lame channel");
   }
diff --git a/third_party/grpc/source/src/core/xds/xds_client/lrs_client.cc b/third_party/grpc/source/src/core/xds/xds_client/lrs_client.cc
index 7fbb86c9b1ebe..09f3b58b025b5 100644
--- a/third_party/grpc/source/src/core/xds/xds_client/lrs_client.cc
+++ b/third_party/grpc/source/src/core/xds/xds_client/lrs_client.cc
@@ -25,8 +25,8 @@
 #include <vector>

 #include "absl/cleanup/cleanup.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/string_view.h"
 #include "envoy/config/core/v3/base.upb.h"
 #include "envoy/config/endpoint/v3/load_report.upb.h"
@@ -400,9 +400,9 @@ LrsClient::LrsChannel::LrsChannel(
       << " for server " << server_->server_uri();
   absl::Status status;
   transport_ = lrs_client_->transport_factory_->GetTransport(*server_, &status);
-  CHECK(transport_ != nullptr);
+  ABSL_CHECK(transport_ != nullptr);
   if (!status.ok()) {
-    LOG(ERROR) << "Error creating LRS channel to " << server_->server_uri()
+    ABSL_LOG(ERROR) << "Error creating LRS channel to " << server_->server_uri()
                << ": " << status;
   }
 }
@@ -484,8 +484,8 @@ void LrsClient::LrsChannel::RetryableCall<T>::OnCallFinishedLocked() {
 template <typename T>
 void LrsClient::LrsChannel::RetryableCall<T>::StartNewCallLocked() {
   if (shutting_down_) return;
-  CHECK(lrs_channel_->transport_ != nullptr);
-  CHECK(call_ == nullptr);
+  ABSL_CHECK(lrs_channel_->transport_ != nullptr);
+  ABSL_CHECK(call_ == nullptr);
   GRPC_TRACE_LOG(xds_client, INFO)
       << "[lrs_client " << lrs_channel()->lrs_client() << "] lrs server "
       << lrs_channel()->server_->server_uri()
@@ -571,7 +571,7 @@ LrsClient::LrsChannel::LrsCall::LrsCall(
   // Init the LRS call. Note that the call will progress every time there's
   // activity in lrs_client()->interested_parties_, which is comprised of
   // the polling entities from client_channel.
-  CHECK_NE(lrs_client(), nullptr);
+  ABSL_CHECK_NE(lrs_client(), nullptr);
   const char* method =
       "/envoy.service.load_stats.v3.LoadReportingService/StreamLoadStats";
   streaming_call_ = lrs_channel()->transport_->CreateStreamingCall(
@@ -579,7 +579,7 @@ LrsClient::LrsChannel::LrsCall::LrsCall(
                   // Passing the initial ref here.  This ref will go away when
                   // the StreamEventHandler is destroyed.
                   RefCountedPtr<LrsCall>(this)));
-  CHECK(streaming_call_ != nullptr);
+  ABSL_CHECK(streaming_call_ != nullptr);
   // Start the call.
   GRPC_TRACE_LOG(xds_client, INFO)
       << "[lrs_client " << lrs_client() << "] lrs server "
@@ -679,14 +679,14 @@ void LrsClient::LrsChannel::LrsCall::OnRecvMessage(absl::string_view payload) {
       payload, &send_all_clusters, &new_cluster_names,
       &new_load_reporting_interval);
   if (!status.ok()) {
-    LOG(ERROR) << "[lrs_client " << lrs_client() << "] lrs server "
+    ABSL_LOG(ERROR) << "[lrs_client " << lrs_client() << "] lrs server "
                << lrs_channel()->server_->server_uri()
                << ": LRS response parsing failed: " << status;
     return;
   }
   seen_response_ = true;
   if (GRPC_TRACE_FLAG_ENABLED(xds_client)) {
-    LOG(INFO) << "[lrs_client " << lrs_client() << "] lrs server "
+    ABSL_LOG(INFO) << "[lrs_client " << lrs_client() << "] lrs server "
               << lrs_channel()->server_->server_uri()
               << ": LRS response received, " << new_cluster_names.size()
               << " cluster names, send_all_clusters=" << send_all_clusters
@@ -694,7 +694,7 @@ void LrsClient::LrsChannel::LrsCall::OnRecvMessage(absl::string_view payload) {
               << new_load_reporting_interval.millis() << "ms";
     size_t i = 0;
     for (const auto& name : new_cluster_names) {
-      LOG(INFO) << "[lrs_client " << lrs_client() << "] cluster_name " << i++
+      ABSL_LOG(INFO) << "[lrs_client " << lrs_client() << "] cluster_name " << i++
                 << ": " << name;
     }
   }
@@ -1054,7 +1054,7 @@ void MaybeLogLrsRequest(
     char buf[10240];
     upb_TextEncode(reinterpret_cast<const upb_Message*>(request), msg_type,
                    nullptr, 0, buf, sizeof(buf));
-    VLOG(2) << "[lrs_client " << context.client
+    ABSL_VLOG(2) << "[lrs_client " << context.client
             << "] constructed LRS request: " << buf;
   }
 }
@@ -1233,7 +1233,7 @@ void MaybeLogLrsResponse(
     char buf[10240];
     upb_TextEncode(reinterpret_cast<const upb_Message*>(response), msg_type,
                    nullptr, 0, buf, sizeof(buf));
-    VLOG(2) << "[lrs_client " << context.client
+    ABSL_VLOG(2) << "[lrs_client " << context.client
             << "] received LRS response: " << buf;
   }
 }
diff --git a/third_party/grpc/source/src/core/xds/xds_client/xds_client.cc b/third_party/grpc/source/src/core/xds/xds_client/xds_client.cc
index da09d1db1be55..608f4cf8ab28d 100644
--- a/third_party/grpc/source/src/core/xds/xds_client/xds_client.cc
+++ b/third_party/grpc/source/src/core/xds/xds_client/xds_client.cc
@@ -30,8 +30,8 @@
 #include <vector>

 #include "absl/cleanup/cleanup.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/match.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_join.h"
@@ -401,7 +401,7 @@ XdsClient::XdsChannel::XdsChannel(WeakRefCountedPtr<XdsClient> xds_client,
       << " for server " << server.server_uri();
   absl::Status status;
   transport_ = xds_client_->transport_factory_->GetTransport(server, &status);
-  CHECK(transport_ != nullptr);
+  ABSL_CHECK(transport_ != nullptr);
   if (!status.ok()) {
     SetChannelStatusLocked(std::move(status));
   } else {
@@ -542,7 +542,7 @@ void XdsClient::XdsChannel::SetChannelStatusLocked(absl::Status status) {
   status = absl::Status(status.code(), absl::StrCat("xDS channel for server ",
                                                     server_.server_uri(), ": ",
                                                     status.message()));
-  LOG(INFO) << "[xds_client " << xds_client() << "] " << status;
+  ABSL_LOG(INFO) << "[xds_client " << xds_client() << "] " << status;
   // If status was previously OK, report that the channel has gone unhealthy.
   if (status_.ok() && xds_client_->metrics_reporter_ != nullptr) {
     xds_client_->metrics_reporter_->ReportServerFailure(server_.server_uri());
@@ -621,8 +621,8 @@ void XdsClient::XdsChannel::RetryableCall<T>::OnCallFinishedLocked() {
 template <typename T>
 void XdsClient::XdsChannel::RetryableCall<T>::StartNewCallLocked() {
   if (shutting_down_) return;
-  CHECK(xds_channel_->transport_ != nullptr);
-  CHECK(call_ == nullptr);
+  ABSL_CHECK(xds_channel_->transport_ != nullptr);
+  ABSL_CHECK(call_ == nullptr);
   GRPC_TRACE_LOG(xds_client, INFO)
       << "[xds_client " << xds_channel()->xds_client() << "] xds server "
       << xds_channel()->server_.server_uri()
@@ -692,7 +692,7 @@ XdsClient::XdsChannel::AdsCall::AdsCall(
     : InternallyRefCounted<AdsCall>(
           GRPC_TRACE_FLAG_ENABLED(xds_client_refcount) ? "AdsCall" : nullptr),
       retryable_call_(std::move(retryable_call)) {
-  CHECK_NE(xds_client(), nullptr);
+  ABSL_CHECK_NE(xds_client(), nullptr);
   // Init the ADS call.
   const char* method =
       "/envoy.service.discovery.v3.AggregatedDiscoveryService/"
@@ -702,7 +702,7 @@ XdsClient::XdsChannel::AdsCall::AdsCall(
                   // Passing the initial ref here.  This ref will go away when
                   // the StreamEventHandler is destroyed.
                   RefCountedPtr<AdsCall>(this)));
-  CHECK(streaming_call_ != nullptr);
+  ABSL_CHECK(streaming_call_ != nullptr);
   // Start the call.
   GRPC_TRACE_LOG(xds_client, INFO)
       << "[xds_client " << xds_client() << "] xds server "
@@ -788,7 +788,7 @@ void MaybeLogDiscoveryRequest(
     char buf[10240];
     upb_TextEncode(reinterpret_cast<const upb_Message*>(request), msg_type,
                    nullptr, 0, buf, sizeof(buf));
-    VLOG(2) << "[xds_client " << client << "] constructed ADS request: " << buf;
+    ABSL_VLOG(2) << "[xds_client " << client << "] constructed ADS request: " << buf;
   }
 }

@@ -1067,7 +1067,7 @@ void MaybeLogDiscoveryResponse(
     char buf[10240];
     upb_TextEncode(reinterpret_cast<const upb_Message*>(response), msg_type,
                    nullptr, 0, buf, sizeof(buf));
-    VLOG(2) << "[xds_client " << client << "] received response: " << buf;
+    ABSL_VLOG(2) << "[xds_client " << client << "] received response: " << buf;
   }
 }

@@ -1162,7 +1162,7 @@ void XdsClient::XdsChannel::AdsCall::OnRecvMessage(absl::string_view payload) {
   absl::Status status = DecodeAdsResponse(payload, &context);
   if (!status.ok()) {
     // Ignore unparsable response.
-    LOG(ERROR) << "[xds_client " << xds_client() << "] xds server "
+    ABSL_LOG(ERROR) << "[xds_client " << xds_client() << "] xds server "
                << xds_channel()->server_.server_uri()
                << ": error parsing ADS response (" << status << ") -- ignoring";
   } else {
@@ -1176,7 +1176,7 @@ void XdsClient::XdsChannel::AdsCall::OnRecvMessage(absl::string_view payload) {
       state.status = absl::UnavailableError(
           absl::StrCat("xDS response validation errors: [",
                        absl::StrJoin(context.errors, "; "), "]"));
-      LOG(ERROR) << "[xds_client " << xds_client() << "] xds server "
+      ABSL_LOG(ERROR) << "[xds_client " << xds_client() << "] xds server "
                  << xds_channel()->server_.server_uri()
                  << ": ADS response invalid for resource type "
                  << context.type_url << " version " << context.version
@@ -1439,7 +1439,7 @@ XdsClient::XdsClient(
       metrics_reporter_(std::move(metrics_reporter)) {
   GRPC_TRACE_LOG(xds_client, INFO)
       << "[xds_client " << this << "] creating xds client";
-  CHECK(bootstrap_ != nullptr);
+  ABSL_CHECK(bootstrap_ != nullptr);
   if (bootstrap_->node() != nullptr) {
     GRPC_TRACE_LOG(xds_client, INFO)
         << "[xds_client " << this
@@ -1629,7 +1629,7 @@ void XdsClient::MaybeRegisterResourceTypeLocked(
     const XdsResourceType* resource_type) {
   auto it = resource_types_.find(resource_type->type_url());
   if (it != resource_types_.end()) {
-    CHECK(it->second == resource_type);
+    ABSL_CHECK(it->second == resource_type);
     return;
   }
   resource_types_.emplace(resource_type->type_url(), resource_type);
@@ -1680,7 +1680,7 @@ std::string XdsClient::ConstructFullXdsResourceName(
     auto uri = URI::Create("xdstp", std::string(authority),
                            absl::StrCat("/", resource_type, "/", key.id),
                            key.query_params, /*fragment=*/"");
-    CHECK(uri.ok());
+    ABSL_CHECK(uri.ok());
     return uri->ToString();
   }
   // Old-style name.
diff --git a/third_party/grpc/source/src/cpp/client/call_credentials.cc b/third_party/grpc/source/src/cpp/client/call_credentials.cc
index 3ecc72d5980dc..543c8f68a3935 100644
--- a/third_party/grpc/source/src/cpp/client/call_credentials.cc
+++ b/third_party/grpc/source/src/cpp/client/call_credentials.cc
@@ -15,7 +15,7 @@
 #include <grpc/support/port_platform.h>
 #include <grpcpp/security/credentials.h>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_cat.h"
 #include "src/core/lib/security/credentials/credentials.h"

@@ -23,7 +23,7 @@ namespace grpc {

 CallCredentials::CallCredentials(grpc_call_credentials* c_creds)
     : c_creds_(c_creds) {
-  CHECK_NE(c_creds, nullptr);
+  ABSL_CHECK_NE(c_creds, nullptr);
 }

 CallCredentials::~CallCredentials() { grpc_call_credentials_release(c_creds_); }
diff --git a/third_party/grpc/source/src/cpp/client/channel_cc.cc b/third_party/grpc/source/src/cpp/client/channel_cc.cc
index e99c416d17577..8b9945a221aff 100644
--- a/third_party/grpc/source/src/cpp/client/channel_cc.cc
+++ b/third_party/grpc/source/src/cpp/client/channel_cc.cc
@@ -39,7 +39,7 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/iomgr/iomgr.h"

 namespace grpc {
@@ -207,7 +207,7 @@ bool Channel::WaitForStateChangeImpl(grpc_connectivity_state last_observed,
   void* tag = nullptr;
   NotifyOnStateChangeImpl(last_observed, deadline, &cq, nullptr);
   cq.Next(&tag, &ok);
-  CHECK_EQ(tag, nullptr);
+  ABSL_CHECK_EQ(tag, nullptr);
   return ok;
 }

diff --git a/third_party/grpc/source/src/cpp/client/client_context.cc b/third_party/grpc/source/src/cpp/client/client_context.cc
index e338d440b9ca0..2d542f6e02da5 100644
--- a/third_party/grpc/source/src/cpp/client/client_context.cc
+++ b/third_party/grpc/source/src/cpp/client/client_context.cc
@@ -37,7 +37,7 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/str_format.h"
 #include "src/core/util/crash.h"

@@ -123,7 +123,7 @@ void ClientContext::AddMetadata(const std::string& meta_key,
 void ClientContext::set_call(grpc_call* call,
                              const std::shared_ptr<Channel>& channel) {
   internal::MutexLock lock(&mu_);
-  CHECK_EQ(call_, nullptr);
+  ABSL_CHECK_EQ(call_, nullptr);
   call_ = call;
   channel_ = channel;
   if (creds_ && !creds_->ApplyToCall(call_)) {
@@ -146,7 +146,7 @@ void ClientContext::set_compression_algorithm(
     grpc_core::Crash(absl::StrFormat(
         "Name for compression algorithm '%d' unknown.", algorithm));
   }
-  CHECK_NE(algorithm_name, nullptr);
+  ABSL_CHECK_NE(algorithm_name, nullptr);
   AddMetadata(GRPC_COMPRESSION_REQUEST_ALGORITHM_MD_KEY, algorithm_name);
 }

@@ -178,9 +178,9 @@ std::string ClientContext::peer() const {
 }

 void ClientContext::SetGlobalCallbacks(GlobalCallbacks* client_callbacks) {
-  CHECK(g_client_callbacks == g_default_client_callbacks);
-  CHECK_NE(client_callbacks, nullptr);
-  CHECK(client_callbacks != g_default_client_callbacks);
+  ABSL_CHECK(g_client_callbacks == g_default_client_callbacks);
+  ABSL_CHECK_NE(client_callbacks, nullptr);
+  ABSL_CHECK(client_callbacks != g_default_client_callbacks);
   g_client_callbacks = client_callbacks;
 }

diff --git a/third_party/grpc/source/src/cpp/client/global_callback_hook.cc b/third_party/grpc/source/src/cpp/client/global_callback_hook.cc
index e117214d1ccd1..af7bc4f07e79c 100644
--- a/third_party/grpc/source/src/cpp/client/global_callback_hook.cc
+++ b/third_party/grpc/source/src/cpp/client/global_callback_hook.cc
@@ -17,7 +17,7 @@
 #include <memory>

 #include "absl/base/no_destructor.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 namespace grpc {

@@ -29,8 +29,8 @@ std::shared_ptr<GlobalCallbackHook> GetGlobalCallbackHook() {
 }

 void SetGlobalCallbackHook(GlobalCallbackHook* hook) {
-  CHECK(hook != nullptr);
-  CHECK(hook != (*g_callback_hook).get());
+  ABSL_CHECK(hook != nullptr);
+  ABSL_CHECK(hook != (*g_callback_hook).get());
   *g_callback_hook = std::shared_ptr<GlobalCallbackHook>(hook);
 }
 }  // namespace grpc
diff --git a/third_party/grpc/source/src/cpp/client/secure_credentials.cc b/third_party/grpc/source/src/cpp/client/secure_credentials.cc
index ece505f9112c4..e4fd883961987 100644
--- a/third_party/grpc/source/src/cpp/client/secure_credentials.cc
+++ b/third_party/grpc/source/src/cpp/client/secure_credentials.cc
@@ -39,8 +39,8 @@
 #include <optional>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/str_join.h"
@@ -271,7 +271,7 @@ std::shared_ptr<CallCredentials> ServiceAccountJWTAccessCredentials(
     const std::string& json_key, long token_lifetime_seconds) {
   grpc::internal::GrpcLibrary init;  // To call grpc_init().
   if (token_lifetime_seconds <= 0) {
-    LOG(ERROR) << "Trying to create JWTCredentials with non-positive lifetime";
+    ABSL_LOG(ERROR) << "Trying to create JWTCredentials with non-positive lifetime";
     return WrapCallCredentials(nullptr);
   }
   gpr_timespec lifetime =
@@ -360,7 +360,7 @@ class MetadataCredentialsPluginWrapper final : private internal::GrpcLibrary {
       grpc_metadata creds_md[GRPC_METADATA_CREDENTIALS_PLUGIN_SYNC_MAX],
       size_t* num_creds_md, grpc_status_code* status,
       const char** error_details) {
-    CHECK(wrapper);
+    ABSL_CHECK(wrapper);
     MetadataCredentialsPluginWrapper* w =
         static_cast<MetadataCredentialsPluginWrapper*>(wrapper);
     if (!w->plugin_) {
@@ -391,7 +391,7 @@ class MetadataCredentialsPluginWrapper final : private internal::GrpcLibrary {
   }

   static char* DebugString(void* wrapper) {
-    CHECK(wrapper);
+    ABSL_CHECK(wrapper);
     MetadataCredentialsPluginWrapper* w =
         static_cast<MetadataCredentialsPluginWrapper*>(wrapper);
     return gpr_strdup(w->plugin_->DebugString().c_str());
diff --git a/third_party/grpc/source/src/cpp/client/xds_credentials.cc b/third_party/grpc/source/src/cpp/client/xds_credentials.cc
index b9771e2d340d6..1d4c06f261294 100644
--- a/third_party/grpc/source/src/cpp/client/xds_credentials.cc
+++ b/third_party/grpc/source/src/cpp/client/xds_credentials.cc
@@ -22,7 +22,7 @@

 #include <memory>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 namespace grpc {
 class XdsChannelCredentialsImpl final : public ChannelCredentials {
@@ -31,13 +31,13 @@ class XdsChannelCredentialsImpl final : public ChannelCredentials {
       const std::shared_ptr<ChannelCredentials>& fallback_creds)
       : ChannelCredentials(
             grpc_xds_credentials_create(fallback_creds->c_creds_)) {
-    CHECK_NE(fallback_creds->c_creds_, nullptr);
+    ABSL_CHECK_NE(fallback_creds->c_creds_, nullptr);
   }
 };

 std::shared_ptr<ChannelCredentials> XdsCredentials(
     const std::shared_ptr<ChannelCredentials>& fallback_creds) {
-  CHECK_NE(fallback_creds, nullptr);
+  ABSL_CHECK_NE(fallback_creds, nullptr);
   return std::make_shared<XdsChannelCredentialsImpl>(fallback_creds);
 }

diff --git a/third_party/grpc/source/src/cpp/common/alarm.cc b/third_party/grpc/source/src/cpp/common/alarm.cc
index 7617ca64670d0..977583d941f79 100644
--- a/third_party/grpc/source/src/cpp/common/alarm.cc
+++ b/third_party/grpc/source/src/cpp/common/alarm.cc
@@ -29,7 +29,7 @@
 #include <memory>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "src/core/lib/event_engine/default_event_engine.h"
 #include "src/core/lib/iomgr/error.h"
@@ -64,10 +64,10 @@ class AlarmImpl : public grpc::internal::CompletionQueueTag {
     GRPC_CQ_INTERNAL_REF(cq->cq(), "alarm");
     cq_ = cq->cq();
     tag_ = tag;
-    CHECK(grpc_cq_begin_op(cq_, this));
+    ABSL_CHECK(grpc_cq_begin_op(cq_, this));
     Ref();
-    CHECK(cq_armed_.exchange(true) == false);
-    CHECK(!callback_armed_.load());
+    ABSL_CHECK(cq_armed_.exchange(true) == false);
+    ABSL_CHECK(!callback_armed_.load());
     cq_timer_handle_ = event_engine_->RunAfter(
         grpc_core::Timestamp::FromTimespecRoundUp(deadline) -
             grpc_core::ExecCtx::Get()->Now(),
@@ -78,8 +78,8 @@ class AlarmImpl : public grpc::internal::CompletionQueueTag {
     // Don't use any CQ at all. Instead just use the timer to fire the function
     callback_ = std::move(f);
     Ref();
-    CHECK(callback_armed_.exchange(true) == false);
-    CHECK(!cq_armed_.load());
+    ABSL_CHECK(callback_armed_.exchange(true) == false);
+    ABSL_CHECK(!cq_armed_.load());
     callback_timer_handle_ = event_engine_->RunAfter(
         grpc_core::Timestamp::FromTimespecRoundUp(deadline) -
             grpc_core::ExecCtx::Get()->Now(),
diff --git a/third_party/grpc/source/src/cpp/common/alts_util.cc b/third_party/grpc/source/src/cpp/common/alts_util.cc
index 1a0a2149b1f4c..324ccf6b3af7b 100644
--- a/third_party/grpc/source/src/cpp/common/alts_util.cc
+++ b/third_party/grpc/source/src/cpp/common/alts_util.cc
@@ -28,7 +28,7 @@
 #include <string>
 #include <vector>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/tsi/alts/handshaker/alts_tsi_handshaker.h"
 #include "src/proto/grpc/gcp/altscontext.upb.h"
 #include "upb/mem/arena.hpp"
@@ -39,25 +39,25 @@ namespace experimental {
 std::unique_ptr<AltsContext> GetAltsContextFromAuthContext(
     const std::shared_ptr<const AuthContext>& auth_context) {
   if (auth_context == nullptr) {
-    LOG(ERROR) << "auth_context is nullptr.";
+    ABSL_LOG(ERROR) << "auth_context is nullptr.";
     return nullptr;
   }
   std::vector<string_ref> ctx_vector =
       auth_context->FindPropertyValues(TSI_ALTS_CONTEXT);
   if (ctx_vector.size() != 1) {
-    LOG(ERROR) << "contains zero or more than one ALTS context.";
+    ABSL_LOG(ERROR) << "contains zero or more than one ALTS context.";
     return nullptr;
   }
   upb::Arena context_arena;
   grpc_gcp_AltsContext* ctx = grpc_gcp_AltsContext_parse(
       ctx_vector[0].data(), ctx_vector[0].size(), context_arena.ptr());
   if (ctx == nullptr) {
-    LOG(ERROR) << "fails to parse ALTS context.";
+    ABSL_LOG(ERROR) << "fails to parse ALTS context.";
     return nullptr;
   }
   if (grpc_gcp_AltsContext_security_level(ctx) < GRPC_SECURITY_MIN ||
       grpc_gcp_AltsContext_security_level(ctx) > GRPC_SECURITY_MAX) {
-    LOG(ERROR) << "security_level is invalid.";
+    ABSL_LOG(ERROR) << "security_level is invalid.";
     return nullptr;
   }
   return std::make_unique<AltsContext>(AltsContext(ctx));
diff --git a/third_party/grpc/source/src/cpp/common/channel_arguments.cc b/third_party/grpc/source/src/cpp/common/channel_arguments.cc
index af1838571ca74..b179328a42f97 100644
--- a/third_party/grpc/source/src/cpp/common/channel_arguments.cc
+++ b/third_party/grpc/source/src/cpp/common/channel_arguments.cc
@@ -26,7 +26,7 @@
 #include <string>
 #include <vector>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
 #include "src/core/lib/iomgr/socket_mutator.h"

@@ -45,7 +45,7 @@ ChannelArguments::ChannelArguments(const ChannelArguments& other)
   for (const auto& a : other.args_) {
     grpc_arg ap;
     ap.type = a.type;
-    CHECK(list_it_src->c_str() == a.key);
+    ABSL_CHECK(list_it_src->c_str() == a.key);
     ap.key = const_cast<char*>(list_it_dst->c_str());
     ++list_it_src;
     ++list_it_dst;
@@ -54,7 +54,7 @@ ChannelArguments::ChannelArguments(const ChannelArguments& other)
         ap.value.integer = a.value.integer;
         break;
       case GRPC_ARG_STRING:
-        CHECK(list_it_src->c_str() == a.value.string);
+        ABSL_CHECK(list_it_src->c_str() == a.value.string);
         ap.value.string = const_cast<char*>(list_it_dst->c_str());
         ++list_it_src;
         ++list_it_dst;
@@ -101,7 +101,7 @@ void ChannelArguments::SetSocketMutator(grpc_socket_mutator* mutator) {
   for (auto& arg : args_) {
     if (arg.type == mutator_arg.type &&
         std::string(arg.key) == std::string(mutator_arg.key)) {
-      CHECK(!replaced);
+      ABSL_CHECK(!replaced);
       arg.value.pointer.vtable->destroy(arg.value.pointer.p);
       arg.value.pointer = mutator_arg.value.pointer;
       replaced = true;
@@ -130,7 +130,7 @@ void ChannelArguments::SetUserAgentPrefix(
     ++strings_it;
     if (arg.type == GRPC_ARG_STRING) {
       if (std::string(arg.key) == GRPC_ARG_PRIMARY_USER_AGENT_STRING) {
-        CHECK(arg.value.string == strings_it->c_str());
+        ABSL_CHECK(arg.value.string == strings_it->c_str());
         *(strings_it) = user_agent_prefix + " " + arg.value.string;
         arg.value.string = const_cast<char*>(strings_it->c_str());
         replaced = true;
diff --git a/third_party/grpc/source/src/cpp/common/completion_queue_cc.cc b/third_party/grpc/source/src/cpp/common/completion_queue_cc.cc
index e82b6260358ab..22e204c4a3127 100644
--- a/third_party/grpc/source/src/cpp/common/completion_queue_cc.cc
+++ b/third_party/grpc/source/src/cpp/common/completion_queue_cc.cc
@@ -26,8 +26,8 @@
 #include <vector>

 #include "absl/base/thread_annotations.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/experiments/experiments.h"
 #include "src/core/util/crash.h"
 #include "src/core/util/sync.h"
@@ -85,7 +85,7 @@ struct CallbackAlternativeCQ {
                                    gpr_time_from_millis(100, GPR_TIMESPAN)));
                   continue;
                 }
-                DCHECK(ev.type == GRPC_OP_COMPLETE);
+                ABSL_DCHECK(ev.type == GRPC_OP_COMPLETE);
                 // We can always execute the callback inline rather than
                 // pushing it to another Executor thread because this
                 // thread is definitely running on a background thread, does not
@@ -135,7 +135,7 @@ CompletionQueue::CompletionQueue(grpc_completion_queue* take)
 void CompletionQueue::Shutdown() {
 #ifndef NDEBUG
   if (!ServerListEmpty()) {
-    LOG(ERROR) << "CompletionQueue shutdown being shutdown before its server.";
+    ABSL_LOG(ERROR) << "CompletionQueue shutdown being shutdown before its server.";
   }
 #endif
   CompleteAvalanching();
@@ -170,7 +170,7 @@ CompletionQueue::CompletionQueueTLSCache::CompletionQueueTLSCache(
 }

 CompletionQueue::CompletionQueueTLSCache::~CompletionQueueTLSCache() {
-  CHECK(flushed_);
+  ABSL_CHECK(flushed_);
 }

 bool CompletionQueue::CompletionQueueTLSCache::Flush(void** tag, bool* ok) {
@@ -203,7 +203,7 @@ void CompletionQueue::ReleaseCallbackAlternativeCQ(CompletionQueue* cq)
   (void)cq;
   // This accesses g_callback_alternative_cq without acquiring the mutex
   // but it's considered safe because it just reads the pointer address.
-  DCHECK(cq == g_callback_alternative_cq.cq);
+  ABSL_DCHECK(cq == g_callback_alternative_cq.cq);
   g_callback_alternative_cq.Unref();
 }

diff --git a/third_party/grpc/source/src/cpp/common/tls_certificate_provider.cc b/third_party/grpc/source/src/cpp/common/tls_certificate_provider.cc
index 091e478b9ba13..ff181a50fb6fd 100644
--- a/third_party/grpc/source/src/cpp/common/tls_certificate_provider.cc
+++ b/third_party/grpc/source/src/cpp/common/tls_certificate_provider.cc
@@ -21,7 +21,7 @@
 #include <string>
 #include <vector>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/lib/security/credentials/tls/grpc_tls_certificate_provider.h"

 namespace grpc {
@@ -30,7 +30,7 @@ namespace experimental {
 StaticDataCertificateProvider::StaticDataCertificateProvider(
     const std::string& root_certificate,
     const std::vector<IdentityKeyCertPair>& identity_key_cert_pairs) {
-  CHECK(!root_certificate.empty() || !identity_key_cert_pairs.empty());
+  ABSL_CHECK(!root_certificate.empty() || !identity_key_cert_pairs.empty());
   grpc_tls_identity_pairs* pairs_core = grpc_tls_identity_pairs_create();
   for (const IdentityKeyCertPair& pair : identity_key_cert_pairs) {
     grpc_tls_identity_pairs_add_pair(pairs_core, pair.private_key.c_str(),
@@ -38,7 +38,7 @@ StaticDataCertificateProvider::StaticDataCertificateProvider(
   }
   c_provider_ = grpc_tls_certificate_provider_static_data_create(
       root_certificate.c_str(), pairs_core);
-  CHECK_NE(c_provider_, nullptr);
+  ABSL_CHECK_NE(c_provider_, nullptr);
 };

 StaticDataCertificateProvider::~StaticDataCertificateProvider() {
@@ -59,7 +59,7 @@ FileWatcherCertificateProvider::FileWatcherCertificateProvider(
   c_provider_ = grpc_tls_certificate_provider_file_watcher_create(
       private_key_path.c_str(), identity_certificate_path.c_str(),
       root_cert_path.c_str(), refresh_interval_sec);
-  CHECK_NE(c_provider_, nullptr);
+  ABSL_CHECK_NE(c_provider_, nullptr);
 };

 FileWatcherCertificateProvider::~FileWatcherCertificateProvider() {
diff --git a/third_party/grpc/source/src/cpp/common/tls_certificate_verifier.cc b/third_party/grpc/source/src/cpp/common/tls_certificate_verifier.cc
index dfbd2e1c3e123..02a4678e9e902 100644
--- a/third_party/grpc/source/src/cpp/common/tls_certificate_verifier.cc
+++ b/third_party/grpc/source/src/cpp/common/tls_certificate_verifier.cc
@@ -31,7 +31,7 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 namespace grpc {
 namespace experimental {
@@ -39,7 +39,7 @@ namespace experimental {
 TlsCustomVerificationCheckRequest::TlsCustomVerificationCheckRequest(
     grpc_tls_custom_verification_check_request* request)
     : c_request_(request) {
-  CHECK_NE(c_request_, nullptr);
+  ABSL_CHECK_NE(c_request_, nullptr);
 }

 grpc::string_ref TlsCustomVerificationCheckRequest::target_name() const {
@@ -119,8 +119,8 @@ CertificateVerifier::~CertificateVerifier() {
 bool CertificateVerifier::Verify(TlsCustomVerificationCheckRequest* request,
                                  std::function<void(grpc::Status)> callback,
                                  grpc::Status* sync_status) {
-  CHECK_NE(request, nullptr);
-  CHECK_NE(request->c_request(), nullptr);
+  ABSL_CHECK_NE(request, nullptr);
+  ABSL_CHECK_NE(request->c_request(), nullptr);
   {
     internal::MutexLock lock(&mu_);
     request_map_.emplace(request->c_request(), std::move(callback));
@@ -143,8 +143,8 @@ bool CertificateVerifier::Verify(TlsCustomVerificationCheckRequest* request,
 }

 void CertificateVerifier::Cancel(TlsCustomVerificationCheckRequest* request) {
-  CHECK_NE(request, nullptr);
-  CHECK_NE(request->c_request(), nullptr);
+  ABSL_CHECK_NE(request, nullptr);
+  ABSL_CHECK_NE(request->c_request(), nullptr);
   grpc_tls_certificate_verifier_cancel(verifier_, request->c_request());
 }

@@ -191,7 +191,7 @@ int ExternalCertificateVerifier::VerifyInCoreExternalVerifier(
     internal::MutexLock lock(&self->mu_);
     auto pair = self->request_map_.emplace(
         request, AsyncRequestState(callback, callback_arg, request));
-    CHECK(pair.second);
+    ABSL_CHECK(pair.second);
     cpp_request = &pair.first->second.cpp_request;
   }
   grpc::Status sync_current_verifier_status;
diff --git a/third_party/grpc/source/src/cpp/common/tls_credentials_options.cc b/third_party/grpc/source/src/cpp/common/tls_credentials_options.cc
index 339a714bd2d44..1d50171ae254a 100644
--- a/third_party/grpc/source/src/cpp/common/tls_credentials_options.cc
+++ b/third_party/grpc/source/src/cpp/common/tls_credentials_options.cc
@@ -28,7 +28,7 @@
 #include <memory>
 #include <string>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 namespace grpc {
 namespace experimental {
@@ -105,13 +105,13 @@ void TlsCredentialsOptions::set_certificate_verifier(

 void TlsCredentialsOptions::set_min_tls_version(grpc_tls_version tls_version) {
   grpc_tls_credentials_options* options = mutable_c_credentials_options();
-  CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
   grpc_tls_credentials_options_set_min_tls_version(options, tls_version);
 }

 void TlsCredentialsOptions::set_max_tls_version(grpc_tls_version tls_version) {
   grpc_tls_credentials_options* options = mutable_c_credentials_options();
-  CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
   grpc_tls_credentials_options_set_max_tls_version(options, tls_version);
 }

@@ -122,14 +122,14 @@ grpc_tls_credentials_options* TlsCredentialsOptions::c_credentials_options()

 void TlsCredentialsOptions::set_check_call_host(bool check_call_host) {
   grpc_tls_credentials_options* options = mutable_c_credentials_options();
-  CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
   grpc_tls_credentials_options_set_check_call_host(options, check_call_host);
 }

 void TlsChannelCredentialsOptions::set_verify_server_certs(
     bool verify_server_certs) {
   grpc_tls_credentials_options* options = mutable_c_credentials_options();
-  CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
   grpc_tls_credentials_options_set_verify_server_cert(options,
                                                       verify_server_certs);
 }
@@ -137,7 +137,7 @@ void TlsChannelCredentialsOptions::set_verify_server_certs(
 void TlsServerCredentialsOptions::set_cert_request_type(
     grpc_ssl_client_certificate_request_type cert_request_type) {
   grpc_tls_credentials_options* options = mutable_c_credentials_options();
-  CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
   grpc_tls_credentials_options_set_cert_request_type(options,
                                                      cert_request_type);
 }
@@ -145,7 +145,7 @@ void TlsServerCredentialsOptions::set_cert_request_type(
 void TlsServerCredentialsOptions::set_send_client_ca_list(
     bool send_client_ca_list) {
   grpc_tls_credentials_options* options = mutable_c_credentials_options();
-  CHECK_NE(options, nullptr);
+  ABSL_CHECK_NE(options, nullptr);
   grpc_tls_credentials_options_set_send_client_ca_list(options,
                                                        send_client_ca_list);
 }
diff --git a/third_party/grpc/source/src/cpp/ext/csm/csm_observability.cc b/third_party/grpc/source/src/cpp/ext/csm/csm_observability.cc
index c2acd8f0ecec4..830e42cb93ef0 100644
--- a/third_party/grpc/source/src/cpp/ext/csm/csm_observability.cc
+++ b/third_party/grpc/source/src/cpp/ext/csm/csm_observability.cc
@@ -27,7 +27,7 @@
 #include <utility>

 #include "absl/functional/any_invocable.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/statusor.h"
 #include "google/cloud/opentelemetry/resource_detector.h"
 #include "opentelemetry/sdk/metrics/meter_provider.h"
@@ -55,7 +55,7 @@ bool CsmChannelTargetSelector(absl::string_view target) {
   if (!g_csm_plugin_enabled) return false;
   auto uri = grpc_core::URI::Parse(target);
   if (!uri.ok()) {
-    LOG(ERROR) << "Failed to parse URI: " << target;
+    ABSL_LOG(ERROR) << "Failed to parse URI: " << target;
     return false;
   }
   // CSM channels should have an "xds" scheme
diff --git a/third_party/grpc/source/src/cpp/ext/csm/metadata_exchange.cc b/third_party/grpc/source/src/cpp/ext/csm/metadata_exchange.cc
index 66cbb28abc5ef..a40cedd30c4dc 100644
--- a/third_party/grpc/source/src/cpp/ext/csm/metadata_exchange.cc
+++ b/third_party/grpc/source/src/cpp/ext/csm/metadata_exchange.cc
@@ -29,7 +29,7 @@
 #include <unordered_map>
 #include <variant>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/statusor.h"
 #include "absl/strings/escaping.h"
 #include "absl/strings/str_split.h"
@@ -206,7 +206,7 @@ NextFromAttributeList(absl::Span<const RemoteAttribute> attributes,
                       size_t start_index, size_t curr,
                       google_protobuf_Struct* decoded_metadata,
                       upb_Arena* arena) {
-  DCHECK_GE(curr, start_index);
+  ABSL_DCHECK_GE(curr, start_index);
   const size_t index = curr - start_index;
   if (index >= attributes.size()) return std::nullopt;
   const auto& attribute = attributes[index];
diff --git a/third_party/grpc/source/src/cpp/ext/filters/census/client_filter.cc b/third_party/grpc/source/src/cpp/ext/filters/census/client_filter.cc
index f43efaac9f1d4..ec4104972a043 100644
--- a/third_party/grpc/source/src/cpp/ext/filters/census/client_filter.cc
+++ b/third_party/grpc/source/src/cpp/ext/filters/census/client_filter.cc
@@ -35,7 +35,7 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_format.h"
@@ -101,7 +101,7 @@ OpenCensusClientFilter::MakeCallPromise(
       path != nullptr ? path->Ref() : grpc_core::Slice(),
       grpc_core::GetContext<grpc_core::Arena>(),
       OpenCensusTracingEnabled() && tracing_enabled_);
-  DCHECK_EQ(arena->GetContext<grpc_core::CallTracerAnnotationInterface>(),
+  ABSL_DCHECK_EQ(arena->GetContext<grpc_core::CallTracerAnnotationInterface>(),
             nullptr);
   grpc_core::SetContext<grpc_core::CallTracerAnnotationInterface>(tracer);
   return next_promise_factory(std::move(call_args));
@@ -412,7 +412,7 @@ void OpenCensusCallTracer::RecordApiLatency(absl::Duration api_latency,

 CensusContext OpenCensusCallTracer::CreateCensusContextForCallAttempt() {
   if (!tracing_enabled_) return CensusContext(context_.tags());
-  DCHECK(context_.Context().IsValid());
+  ABSL_DCHECK(context_.Context().IsValid());
   auto context = CensusContext(absl::StrCat("Attempt.", method_),
                                &(context_.Span()), context_.tags());
   grpc::internal::OpenCensusRegistry::Get()
diff --git a/third_party/grpc/source/src/cpp/ext/gcp/environment_autodetect.cc b/third_party/grpc/source/src/cpp/ext/gcp/environment_autodetect.cc
index 98d9b89c4d187..60fc4e4160f6c 100644
--- a/third_party/grpc/source/src/cpp/ext/gcp/environment_autodetect.cc
+++ b/third_party/grpc/source/src/cpp/ext/gcp/environment_autodetect.cc
@@ -28,8 +28,8 @@
 #include <utility>

 #include "absl/container/flat_hash_map.h"
-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "absl/status/statusor.h"
 #include "src/core/lib/debug/trace.h"
@@ -241,7 +241,7 @@ class EnvironmentAutoDetectHelper

   void FetchMetadataServerAttributesAsynchronouslyLocked()
       ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
-    CHECK(!attributes_to_fetch_.empty());
+    ABSL_CHECK(!attributes_to_fetch_.empty());
     for (auto& element : attributes_to_fetch_) {
       queries_.push_back(grpc_core::MakeOrphanable<grpc_core::GcpMetadataQuery>(
           element.first, &pollent_,
@@ -273,7 +273,7 @@ class EnvironmentAutoDetectHelper
                 attributes_to_fetch_.erase(it);
               } else {
                 // This should not happen
-                LOG(ERROR) << "An unexpected attribute was seen from the "
+                ABSL_LOG(ERROR) << "An unexpected attribute was seen from the "
                               "MetadataServer: "
                            << attribute;
               }
@@ -319,8 +319,8 @@ EnvironmentAutoDetect* g_autodetect = nullptr;
 }  // namespace

 void EnvironmentAutoDetect::Create(std::string project_id) {
-  CHECK_EQ(g_autodetect, nullptr);
-  CHECK(!project_id.empty());
+  ABSL_CHECK_EQ(g_autodetect, nullptr);
+  ABSL_CHECK(!project_id.empty());

   g_autodetect = new EnvironmentAutoDetect(project_id);
 }
@@ -329,7 +329,7 @@ EnvironmentAutoDetect& EnvironmentAutoDetect::Get() { return *g_autodetect; }

 EnvironmentAutoDetect::EnvironmentAutoDetect(std::string project_id)
     : project_id_(std::move(project_id)) {
-  CHECK(!project_id_.empty());
+  ABSL_CHECK(!project_id_.empty());
 }

 void EnvironmentAutoDetect::NotifyOnDone(absl::AnyInvocable<void()> callback) {
diff --git a/third_party/grpc/source/src/cpp/ext/gcp/observability_logging_sink.cc b/third_party/grpc/source/src/cpp/ext/gcp/observability_logging_sink.cc
index 9b3488a649c8b..b8784b4fedbe7 100644
--- a/third_party/grpc/source/src/cpp/ext/gcp/observability_logging_sink.cc
+++ b/third_party/grpc/source/src/cpp/ext/gcp/observability_logging_sink.cc
@@ -31,7 +31,7 @@
 #include <optional>
 #include <utility>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "absl/numeric/int128.h"
 #include "absl/strings/escaping.h"
 #include "absl/strings/match.h"
@@ -359,14 +359,14 @@ void ObservabilityLoggingSink::FlushEntriesHelper(
       &(call->context), &(call->request), &(call->response),
       [this, call](Status status) {
         if (!status.ok()) {
-          LOG(ERROR) << "GCP Observability Logging Error "
+          ABSL_LOG(ERROR) << "GCP Observability Logging Error "
                      << status.error_code() << ": " << status.error_message()
                      << ". Dumping log entries.";
           for (auto& entry : call->request.entries()) {
             std::string output;
             ::google::protobuf::TextFormat::PrintToString(entry.json_payload(),
                                                           &output);
-            LOG(INFO) << "Log Entry recorded at time: "
+            ABSL_LOG(INFO) << "Log Entry recorded at time: "
                       << grpc_core::Timestamp::FromTimespecRoundUp(
                              gpr_timespec{entry.timestamp().seconds(),
                                           entry.timestamp().nanos(),
@@ -412,14 +412,14 @@ void ObservabilityLoggingSink::MaybeTriggerFlushLocked() {
   if (entries_.size() > kMaxEntriesBeforeDump ||
       entries_memory_footprint_ > kMaxMemoryFootprintBeforeDump) {
     // Buffer limits have been reached. Dump entries with LOG
-    LOG(INFO) << "Buffer limit reached. Dumping log entries.";
+    ABSL_LOG(INFO) << "Buffer limit reached. Dumping log entries.";
     for (auto& entry : entries_) {
       google::protobuf::Struct proto;
       std::string timestamp = entry.timestamp.ToString();
       EntryToJsonStructProto(std::move(entry), &proto);
       std::string output;
       ::google::protobuf::TextFormat::PrintToString(proto, &output);
-      LOG(INFO) << "Log Entry recorded at time: " << timestamp << " : "
+      ABSL_LOG(INFO) << "Log Entry recorded at time: " << timestamp << " : "
                 << output;
     }
     entries_.clear();
diff --git a/third_party/grpc/source/src/cpp/ext/otel/key_value_iterable.h b/third_party/grpc/source/src/cpp/ext/otel/key_value_iterable.h
index c6f7f154f3efc..0a517249d0a49 100644
--- a/third_party/grpc/source/src/cpp/ext/otel/key_value_iterable.h
+++ b/third_party/grpc/source/src/cpp/ext/otel/key_value_iterable.h
@@ -25,7 +25,7 @@
 #include <optional>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/strings/string_view.h"
 #include "absl/types/span.h"
 #include "opentelemetry/common/attribute_value.h"
@@ -100,7 +100,7 @@ class OpenTelemetryPluginImpl::KeyValueIterable
     }
     // Add per-call optional labels
     if (!optional_labels_.empty()) {
-      CHECK(optional_labels_.size() ==
+      ABSL_CHECK(optional_labels_.size() ==
             static_cast<size_t>(grpc_core::ClientCallTracer::CallAttemptTracer::
                                     OptionalLabelKey::kSize));
       for (size_t i = 0; i < optional_labels_.size(); ++i) {
diff --git a/third_party/grpc/source/src/cpp/ext/otel/otel_client_call_tracer.cc b/third_party/grpc/source/src/cpp/ext/otel/otel_client_call_tracer.cc
index facf1f4a8447f..f0542fc2ef401 100644
--- a/third_party/grpc/source/src/cpp/ext/otel/otel_client_call_tracer.cc
+++ b/third_party/grpc/source/src/cpp/ext/otel/otel_client_call_tracer.cc
@@ -31,7 +31,7 @@
 #include <utility>

 #include "absl/functional/any_invocable.h"
-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "absl/status/status.h"
 #include "absl/strings/str_format.h"
 #include "absl/strings/string_view.h"
@@ -224,7 +224,7 @@ std::shared_ptr<grpc_core::TcpTracerInterface> OpenTelemetryPluginImpl::
 void OpenTelemetryPluginImpl::ClientCallTracer::CallAttemptTracer::
     SetOptionalLabel(OptionalLabelKey key,
                      grpc_core::RefCountedStringValue value) {
-  CHECK(key < OptionalLabelKey::kSize);
+  ABSL_CHECK(key < OptionalLabelKey::kSize);
   optional_labels_[static_cast<size_t>(key)] = std::move(value);
 }

diff --git a/third_party/grpc/source/src/cpp/ext/otel/otel_plugin.cc b/third_party/grpc/source/src/cpp/ext/otel/otel_plugin.cc
index ae20b68c5678c..76ef4f8b301aa 100644
--- a/third_party/grpc/source/src/cpp/ext/otel/otel_plugin.cc
+++ b/third_party/grpc/source/src/cpp/ext/otel/otel_plugin.cc
@@ -26,7 +26,7 @@
 #include <type_traits>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "opentelemetry/metrics/meter.h"
 #include "opentelemetry/metrics/meter_provider.h"
 #include "opentelemetry/metrics/sync_instruments.h"
@@ -204,7 +204,7 @@ OpenTelemetryPluginBuilderImpl::SetServerSelector(
 OpenTelemetryPluginBuilderImpl& OpenTelemetryPluginBuilderImpl::AddPluginOption(
     std::unique_ptr<InternalOpenTelemetryPluginOption> option) {
   // We allow a limit of 64 plugin options to be registered at this time.
-  CHECK_LT(plugin_options_.size(), 64u);
+  ABSL_CHECK_LT(plugin_options_.size(), 64u);
   plugin_options_.push_back(std::move(option));
   return *this;
 }
@@ -264,7 +264,7 @@ OpenTelemetryPluginImpl::CallbackMetricReporter::CallbackMetricReporter(
   for (const auto& handle : key->metrics()) {
     const auto& descriptor =
         grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor(handle);
-    CHECK(descriptor.instrument_type ==
+    ABSL_CHECK(descriptor.instrument_type ==
           grpc_core::GlobalInstrumentsRegistry::InstrumentType::kCallbackGauge);
     switch (descriptor.value_type) {
       case grpc_core::GlobalInstrumentsRegistry::ValueType::kInt64: {
@@ -296,14 +296,14 @@ void OpenTelemetryPluginImpl::CallbackMetricReporter::ReportInt64(
   auto* callback_gauge_state =
       std::get_if<std::unique_ptr<CallbackGaugeState<int64_t>>>(
           &instrument_data.instrument);
-  CHECK_NE(callback_gauge_state, nullptr);
+  ABSL_CHECK_NE(callback_gauge_state, nullptr);
   const auto& descriptor =
       grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor(handle);
-  CHECK(descriptor.label_keys.size() == label_values.size());
-  CHECK(descriptor.optional_label_keys.size() == optional_values.size());
+  ABSL_CHECK(descriptor.label_keys.size() == label_values.size());
+  ABSL_CHECK(descriptor.optional_label_keys.size() == optional_values.size());
   if ((*callback_gauge_state)->caches.find(key_) ==
       (*callback_gauge_state)->caches.end()) {
-    LOG(ERROR) << "This may occur when the gauge used in AddCallback is "
+    ABSL_LOG(ERROR) << "This may occur when the gauge used in AddCallback is "
                   "different from the gauge used in Report. This indicates a "
                   "misuse of the API. The value "
                << value << " will not be recorded for instrument "
@@ -333,14 +333,14 @@ void OpenTelemetryPluginImpl::CallbackMetricReporter::ReportDouble(
   auto* callback_gauge_state =
       std::get_if<std::unique_ptr<CallbackGaugeState<double>>>(
           &instrument_data.instrument);
-  CHECK_NE(callback_gauge_state, nullptr);
+  ABSL_CHECK_NE(callback_gauge_state, nullptr);
   const auto& descriptor =
       grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor(handle);
-  CHECK(descriptor.label_keys.size() == label_values.size());
-  CHECK(descriptor.optional_label_keys.size() == optional_values.size());
+  ABSL_CHECK(descriptor.label_keys.size() == label_values.size());
+  ABSL_CHECK(descriptor.optional_label_keys.size() == optional_values.size());
   if ((*callback_gauge_state)->caches.find(key_) ==
       (*callback_gauge_state)->caches.end()) {
-    LOG(ERROR) << "This may occur when the gauge used in AddCallback is "
+    ABSL_LOG(ERROR) << "This may occur when the gauge used in AddCallback is "
                   "different from the gauge used in Report. This indicates a "
                   "misuse of the API. The value "
                << value << " will not be recorded for instrument "
@@ -463,7 +463,7 @@ OpenTelemetryPluginImpl::OpenTelemetryPluginImpl(
             "Compressed message bytes received per server call", "By");
   }
   // Store optional label keys for per call metrics
-  CHECK(static_cast<size_t>(grpc_core::ClientCallTracer::CallAttemptTracer::
+  ABSL_CHECK(static_cast<size_t>(grpc_core::ClientCallTracer::CallAttemptTracer::
                                 OptionalLabelKey::kSize) <=
         kOptionalLabelsSizeLimit);
   for (const auto& key : optional_label_keys) {
@@ -477,7 +477,7 @@ OpenTelemetryPluginImpl::OpenTelemetryPluginImpl(
   grpc_core::GlobalInstrumentsRegistry::ForEach(
       [&, this](const grpc_core::GlobalInstrumentsRegistry::
                     GlobalInstrumentDescriptor& descriptor) {
-        CHECK(descriptor.optional_label_keys.size() <=
+        ABSL_CHECK(descriptor.optional_label_keys.size() <=
               kOptionalLabelsSizeLimit);
         if (instruments_data_.size() < descriptor.index + 1) {
           instruments_data_.resize(descriptor.index + 1);
@@ -592,7 +592,7 @@ OpenTelemetryPluginImpl::~OpenTelemetryPluginImpl() {
         [](const std::unique_ptr<opentelemetry::metrics::Histogram<double>>&) {
         },
         [](const std::unique_ptr<CallbackGaugeState<int64_t>>& state) {
-          CHECK(state->caches.empty());
+          ABSL_CHECK(state->caches.empty());
           if (state->ot_callback_registered) {
             state->instrument->RemoveCallback(
                 &CallbackGaugeState<int64_t>::CallbackGaugeCallback,
@@ -601,7 +601,7 @@ OpenTelemetryPluginImpl::~OpenTelemetryPluginImpl() {
           }
         },
         [](const std::unique_ptr<CallbackGaugeState<double>>& state) {
-          CHECK(state->caches.empty());
+          ABSL_CHECK(state->caches.empty());
           if (state->ot_callback_registered) {
             state->instrument->RemoveCallback(
                 &CallbackGaugeState<double>::CallbackGaugeCallback,
@@ -659,14 +659,14 @@ OpenTelemetryPluginImpl::IsEnabledForServer(
 std::shared_ptr<grpc_core::StatsPlugin::ScopeConfig>
 OpenTelemetryPluginImpl::GetChannelScopeConfig(
     const OpenTelemetryPluginBuilder::ChannelScope& scope) const {
-  CHECK(channel_scope_filter_ == nullptr || channel_scope_filter_(scope));
+  ABSL_CHECK(channel_scope_filter_ == nullptr || channel_scope_filter_(scope));
   return std::make_shared<ClientScopeConfig>(this, scope);
 }

 std::shared_ptr<grpc_core::StatsPlugin::ScopeConfig>
 OpenTelemetryPluginImpl::GetServerScopeConfig(
     const grpc_core::ChannelArgs& args) const {
-  CHECK(server_selector_ == nullptr || server_selector_(args));
+  ABSL_CHECK(server_selector_ == nullptr || server_selector_(args));
   return std::make_shared<ServerScopeConfig>(this, args);
 }

@@ -679,13 +679,13 @@ void OpenTelemetryPluginImpl::AddCounter(
     // This instrument is disabled.
     return;
   }
-  CHECK(std::holds_alternative<
+  ABSL_CHECK(std::holds_alternative<
         std::unique_ptr<opentelemetry::metrics::Counter<uint64_t>>>(
       instrument_data.instrument));
   const auto& descriptor =
       grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor(handle);
-  CHECK(descriptor.label_keys.size() == label_values.size());
-  CHECK(descriptor.optional_label_keys.size() == optional_values.size());
+  ABSL_CHECK(descriptor.label_keys.size() == label_values.size());
+  ABSL_CHECK(descriptor.optional_label_keys.size() == optional_values.size());
   if (label_values.empty() && optional_values.empty()) {
     std::get<std::unique_ptr<opentelemetry::metrics::Counter<uint64_t>>>(
         instrument_data.instrument)
@@ -709,13 +709,13 @@ void OpenTelemetryPluginImpl::AddCounter(
     // This instrument is disabled.
     return;
   }
-  CHECK(std::holds_alternative<
+  ABSL_CHECK(std::holds_alternative<
         std::unique_ptr<opentelemetry::metrics::Counter<double>>>(
       instrument_data.instrument));
   const auto& descriptor =
       grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor(handle);
-  CHECK(descriptor.label_keys.size() == label_values.size());
-  CHECK(descriptor.optional_label_keys.size() == optional_values.size());
+  ABSL_CHECK(descriptor.label_keys.size() == label_values.size());
+  ABSL_CHECK(descriptor.optional_label_keys.size() == optional_values.size());
   if (label_values.empty() && optional_values.empty()) {
     std::get<std::unique_ptr<opentelemetry::metrics::Counter<double>>>(
         instrument_data.instrument)
@@ -739,13 +739,13 @@ void OpenTelemetryPluginImpl::RecordHistogram(
     // This instrument is disabled.
     return;
   }
-  CHECK(std::holds_alternative<
+  ABSL_CHECK(std::holds_alternative<
         std::unique_ptr<opentelemetry::metrics::Histogram<uint64_t>>>(
       instrument_data.instrument));
   const auto& descriptor =
       grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor(handle);
-  CHECK(descriptor.label_keys.size() == label_values.size());
-  CHECK(descriptor.optional_label_keys.size() == optional_values.size());
+  ABSL_CHECK(descriptor.label_keys.size() == label_values.size());
+  ABSL_CHECK(descriptor.optional_label_keys.size() == optional_values.size());
   if (label_values.empty() && optional_values.empty()) {
     std::get<std::unique_ptr<opentelemetry::metrics::Histogram<uint64_t>>>(
         instrument_data.instrument)
@@ -771,13 +771,13 @@ void OpenTelemetryPluginImpl::RecordHistogram(
     // This instrument is disabled.
     return;
   }
-  CHECK(std::holds_alternative<
+  ABSL_CHECK(std::holds_alternative<
         std::unique_ptr<opentelemetry::metrics::Histogram<double>>>(
       instrument_data.instrument));
   const auto& descriptor =
       grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor(handle);
-  CHECK(descriptor.label_keys.size() == label_values.size());
-  CHECK(descriptor.optional_label_keys.size() == optional_values.size());
+  ABSL_CHECK(descriptor.label_keys.size() == label_values.size());
+  ABSL_CHECK(descriptor.optional_label_keys.size() == optional_values.size());
   if (label_values.empty() && optional_values.empty()) {
     std::get<std::unique_ptr<opentelemetry::metrics::Histogram<double>>>(
         instrument_data.instrument)
@@ -805,7 +805,7 @@ void OpenTelemetryPluginImpl::AddCallback(
     for (const auto& handle : callback->metrics()) {
       const auto& descriptor =
           grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor(handle);
-      CHECK(
+      ABSL_CHECK(
           descriptor.instrument_type ==
           grpc_core::GlobalInstrumentsRegistry::InstrumentType::kCallbackGauge);
       switch (descriptor.value_type) {
@@ -818,7 +818,7 @@ void OpenTelemetryPluginImpl::AddCallback(
           auto* callback_gauge_state =
               std::get_if<std::unique_ptr<CallbackGaugeState<int64_t>>>(
                   &instrument_data.instrument);
-          CHECK_NE(callback_gauge_state, nullptr);
+          ABSL_CHECK_NE(callback_gauge_state, nullptr);
           (*callback_gauge_state)
               ->caches.emplace(callback, CallbackGaugeState<int64_t>::Cache{});
           if (!std::exchange((*callback_gauge_state)->ot_callback_registered,
@@ -837,7 +837,7 @@ void OpenTelemetryPluginImpl::AddCallback(
           auto* callback_gauge_state =
               std::get_if<std::unique_ptr<CallbackGaugeState<double>>>(
                   &instrument_data.instrument);
-          CHECK_NE(callback_gauge_state, nullptr);
+          ABSL_CHECK_NE(callback_gauge_state, nullptr);
           (*callback_gauge_state)
               ->caches.emplace(callback, CallbackGaugeState<double>::Cache{});
           if (!std::exchange((*callback_gauge_state)->ot_callback_registered,
@@ -878,7 +878,7 @@ void OpenTelemetryPluginImpl::RemoveCallback(
     for (const auto& handle : callback->metrics()) {
       const auto& descriptor =
           grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor(handle);
-      CHECK(
+      ABSL_CHECK(
           descriptor.instrument_type ==
           grpc_core::GlobalInstrumentsRegistry::InstrumentType::kCallbackGauge);
       switch (descriptor.value_type) {
@@ -891,9 +891,9 @@ void OpenTelemetryPluginImpl::RemoveCallback(
           auto* callback_gauge_state =
               std::get_if<std::unique_ptr<CallbackGaugeState<int64_t>>>(
                   &instrument_data.instrument);
-          CHECK_NE(callback_gauge_state, nullptr);
-          CHECK((*callback_gauge_state)->ot_callback_registered);
-          CHECK_EQ((*callback_gauge_state)->caches.erase(callback), 1u);
+          ABSL_CHECK_NE(callback_gauge_state, nullptr);
+          ABSL_CHECK((*callback_gauge_state)->ot_callback_registered);
+          ABSL_CHECK_EQ((*callback_gauge_state)->caches.erase(callback), 1u);
           break;
         }
         case grpc_core::GlobalInstrumentsRegistry::ValueType::kDouble: {
@@ -905,9 +905,9 @@ void OpenTelemetryPluginImpl::RemoveCallback(
           auto* callback_gauge_state =
               std::get_if<std::unique_ptr<CallbackGaugeState<double>>>(
                   &instrument_data.instrument);
-          CHECK_NE(callback_gauge_state, nullptr);
-          CHECK((*callback_gauge_state)->ot_callback_registered);
-          CHECK_EQ((*callback_gauge_state)->caches.erase(callback), 1u);
+          ABSL_CHECK_NE(callback_gauge_state, nullptr);
+          ABSL_CHECK((*callback_gauge_state)->ot_callback_registered);
+          ABSL_CHECK_EQ((*callback_gauge_state)->caches.erase(callback), 1u);
           break;
         }
         default:
@@ -931,7 +931,7 @@ void OpenTelemetryPluginImpl::CallbackGaugeState<ValueType>::Observe(
   const auto& descriptor =
       grpc_core::GlobalInstrumentsRegistry::GetInstrumentDescriptor({id});
   for (const auto& pair : cache) {
-    CHECK(pair.first.size() <= (descriptor.label_keys.size() +
+    ABSL_CHECK(pair.first.size() <= (descriptor.label_keys.size() +
                                 descriptor.optional_label_keys.size()));
     if (descriptor.label_keys.empty() &&
         descriptor.optional_label_keys.empty()) {
@@ -970,7 +970,7 @@ void OpenTelemetryPluginImpl::CallbackGaugeState<ValueType>::
     auto* registered_metric_callback = elem.first;
     auto iter = callback_gauge_state->ot_plugin->callback_timestamps_.find(
         registered_metric_callback);
-    CHECK(iter != callback_gauge_state->ot_plugin->callback_timestamps_.end());
+    ABSL_CHECK(iter != callback_gauge_state->ot_plugin->callback_timestamps_.end());
     if (now - iter->second < registered_metric_callback->min_interval()) {
       // Use cached value.
       callback_gauge_state->Observe(result, elem.second);
diff --git a/third_party/grpc/source/src/cpp/server/backend_metric_recorder.cc b/third_party/grpc/source/src/cpp/server/backend_metric_recorder.cc
index 6670878c7c247..0d188bd6ed7dd 100644
--- a/third_party/grpc/source/src/cpp/server/backend_metric_recorder.cc
+++ b/third_party/grpc/source/src/cpp/server/backend_metric_recorder.cc
@@ -26,7 +26,7 @@
 #include <type_traits>
 #include <utility>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/debug/trace.h"
 #include "src/core/load_balancing/backend_metric_data.h"

@@ -210,7 +210,7 @@ ServerMetricRecorder::GetMetricsIfChanged() const {
   }
   if (GRPC_TRACE_FLAG_ENABLED(backend_metric)) {
     const auto& data = result->data;
-    LOG(INFO) << "[" << this
+    ABSL_LOG(INFO) << "[" << this
               << "] GetMetrics() returned: seq:" << result->sequence_number
               << " cpu:" << data.cpu_utilization
               << " mem:" << data.mem_utilization
diff --git a/third_party/grpc/source/src/cpp/server/external_connection_acceptor_impl.cc b/third_party/grpc/source/src/cpp/server/external_connection_acceptor_impl.cc
index 5623dbfa36c68..a0c65087e268f 100644
--- a/third_party/grpc/source/src/cpp/server/external_connection_acceptor_impl.cc
+++ b/third_party/grpc/source/src/cpp/server/external_connection_acceptor_impl.cc
@@ -25,8 +25,8 @@
 #include <memory>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"

 namespace grpc {
 namespace internal {
@@ -51,14 +51,14 @@ ExternalConnectionAcceptorImpl::ExternalConnectionAcceptorImpl(
     ServerBuilder::experimental_type::ExternalConnectionType type,
     std::shared_ptr<ServerCredentials> creds)
     : name_(name), creds_(std::move(creds)) {
-  CHECK(type ==
+  ABSL_CHECK(type ==
         ServerBuilder::experimental_type::ExternalConnectionType::FROM_FD);
 }

 std::unique_ptr<experimental::ExternalConnectionAcceptor>
 ExternalConnectionAcceptorImpl::GetAcceptor() {
   grpc_core::MutexLock lock(&mu_);
-  CHECK(!has_acceptor_);
+  ABSL_CHECK(!has_acceptor_);
   has_acceptor_ = true;
   return std::unique_ptr<experimental::ExternalConnectionAcceptor>(
       new AcceptorWrapper(shared_from_this()));
@@ -69,7 +69,7 @@ void ExternalConnectionAcceptorImpl::HandleNewConnection(
   grpc_core::MutexLock lock(&mu_);
   if (shutdown_ || !started_) {
     // TODO(yangg) clean up.
-    LOG(ERROR) << "NOT handling external connection with fd " << p->fd
+    ABSL_LOG(ERROR) << "NOT handling external connection with fd " << p->fd
                << ", started " << started_ << ", shutdown " << shutdown_;
     return;
   }
@@ -85,9 +85,9 @@ void ExternalConnectionAcceptorImpl::Shutdown() {

 void ExternalConnectionAcceptorImpl::Start() {
   grpc_core::MutexLock lock(&mu_);
-  CHECK(!started_);
-  CHECK(has_acceptor_);
-  CHECK(!shutdown_);
+  ABSL_CHECK(!started_);
+  ABSL_CHECK(has_acceptor_);
+  ABSL_CHECK(!shutdown_);
   started_ = true;
 }

diff --git a/third_party/grpc/source/src/cpp/server/health/default_health_check_service.cc b/third_party/grpc/source/src/cpp/server/health/default_health_check_service.cc
index bb86083bb54b1..5c45a6f5cc256 100644
--- a/third_party/grpc/source/src/cpp/server/health/default_health_check_service.cc
+++ b/third_party/grpc/source/src/cpp/server/health/default_health_check_service.cc
@@ -28,8 +28,8 @@
 #include <memory>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/proto/grpc/health/v1/health.upb.h"
 #include "upb/base/string_view.h"
 #include "upb/mem/arena.hpp"
@@ -108,7 +108,7 @@ void DefaultHealthCheckService::UnregisterWatch(

 DefaultHealthCheckService::HealthCheckServiceImpl*
 DefaultHealthCheckService::GetHealthCheckService() {
-  CHECK(impl_ == nullptr);
+  ABSL_CHECK(impl_ == nullptr);
   impl_ = std::make_unique<HealthCheckServiceImpl>(this);
   return impl_.get();
 }
@@ -257,7 +257,7 @@ DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::WatchReactor(
     ++service_->num_watches_;
   }
   bool success = DecodeRequest(*request, &service_name_);
-  VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
+  ABSL_VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
           << service_name_ << "\": watch call started";
   if (!success) {
     MaybeFinishLocked(Status(StatusCode::INTERNAL, "could not parse request"));
@@ -269,13 +269,13 @@ DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::WatchReactor(

 void DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::
     SendHealth(ServingStatus status) {
-  VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
+  ABSL_VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
           << service_name_ << "\": SendHealth() for ServingStatus " << status;
   grpc::internal::MutexLock lock(&mu_);
   // If there's already a send in flight, cache the new status, and
   // we'll start a new send for it when the one in flight completes.
   if (write_pending_) {
-    VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
+    ABSL_VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
             << service_name_ << "\": queuing write";
     pending_status_ = status;
     return;
@@ -304,7 +304,7 @@ void DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::
         Status(StatusCode::INTERNAL, "could not encode response"));
     return;
   }
-  VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
+  ABSL_VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
           << service_name_ << "\": starting write for ServingStatus " << status;
   write_pending_ = true;
   StartWrite(&response_);
@@ -312,7 +312,7 @@ void DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::

 void DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::
     OnWriteDone(bool ok) {
-  VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
+  ABSL_VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
           << service_name_ << "\": OnWriteDone(): ok=" << ok;
   response_.Clear();
   grpc::internal::MutexLock lock(&mu_);
@@ -337,7 +337,7 @@ void DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::
 }

 void DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::OnDone() {
-  VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
+  ABSL_VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
           << service_name_ << "\": OnDone()";
   service_->database_->UnregisterWatch(service_name_, this);
   {
@@ -352,12 +352,12 @@ void DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::OnDone() {

 void DefaultHealthCheckService::HealthCheckServiceImpl::WatchReactor::
     MaybeFinishLocked(Status status) {
-  VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
+  ABSL_VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
           << service_name_
           << "\": MaybeFinishLocked() with code=" << status.error_code()
           << " msg=" << status.error_message();
   if (!finish_called_) {
-    VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
+    ABSL_VLOG(2) << "[HCS " << service_ << "] watcher " << this << " \""
             << service_name_ << "\": actually calling Finish()";
     finish_called_ = true;
     Finish(status);
diff --git a/third_party/grpc/source/src/cpp/server/load_reporter/get_cpu_stats_unsupported.cc b/third_party/grpc/source/src/cpp/server/load_reporter/get_cpu_stats_unsupported.cc
index 70b8c0851e39b..59d43faf795f9 100644
--- a/third_party/grpc/source/src/cpp/server/load_reporter/get_cpu_stats_unsupported.cc
+++ b/third_party/grpc/source/src/cpp/server/load_reporter/get_cpu_stats_unsupported.cc
@@ -20,7 +20,7 @@

 #if !defined(GPR_LINUX) && !defined(GPR_WINDOWS) && !defined(GPR_APPLE)

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"
 #include "src/core/util/crash.h"
 #include "src/cpp/server/load_reporter/get_cpu_stats.h"

@@ -29,7 +29,7 @@ namespace load_reporter {

 std::pair<uint64_t, uint64_t> GetCpuStatsImpl() {
   uint64_t busy = 0, total = 0;
-  LOG(ERROR)
+  ABSL_LOG(ERROR)
       << "Platforms other than Linux, Windows, and MacOS are not supported.";
   return std::make_pair(busy, total);
 }
diff --git a/third_party/grpc/source/src/cpp/server/load_reporter/load_data_store.cc b/third_party/grpc/source/src/cpp/server/load_reporter/load_data_store.cc
index 5faa03a4fadcb..ebec64b2e04d7 100644
--- a/third_party/grpc/source/src/cpp/server/load_reporter/load_data_store.cc
+++ b/third_party/grpc/source/src/cpp/server/load_reporter/load_data_store.cc
@@ -27,8 +27,8 @@
 #include <set>
 #include <unordered_map>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/lib/iomgr/socket_utils.h"
 #include "src/cpp/server/load_reporter/constants.h"

@@ -74,7 +74,7 @@ std::set<V> UnorderedMapOfSetExtract(std::unordered_map<K, std::set<V>>& map,
 // From a non-empty container, returns a pointer to a random element.
 template <typename C>
 const typename C::value_type* RandomElement(const C& container) {
-  CHECK(!container.empty());
+  ABSL_CHECK(!container.empty());
   auto it = container.begin();
   std::advance(it, std::rand() % container.size());
   return &(*it);
@@ -85,11 +85,11 @@ const typename C::value_type* RandomElement(const C& container) {
 LoadRecordKey::LoadRecordKey(const std::string& client_ip_and_token,
                              std::string user_id)
     : user_id_(std::move(user_id)) {
-  CHECK_GE(client_ip_and_token.size(), 2u);
+  ABSL_CHECK_GE(client_ip_and_token.size(), 2u);
   int ip_hex_size;
-  CHECK(sscanf(client_ip_and_token.substr(0, 2).c_str(), "%d", &ip_hex_size) ==
+  ABSL_CHECK(sscanf(client_ip_and_token.substr(0, 2).c_str(), "%d", &ip_hex_size) ==
         1);
-  CHECK(ip_hex_size == 0 || ip_hex_size == kIpv4AddressLength ||
+  ABSL_CHECK(ip_hex_size == 0 || ip_hex_size == kIpv4AddressLength ||
         ip_hex_size == kIpv6AddressLength);
   size_t cur_pos = 2;
   client_ip_hex_ = client_ip_and_token.substr(cur_pos, ip_hex_size);
@@ -109,7 +109,7 @@ std::string LoadRecordKey::GetClientIpBytes() const {
   } else if (client_ip_hex_.size() == kIpv4AddressLength) {
     uint32_t ip_bytes;
     if (sscanf(client_ip_hex_.c_str(), "%x", &ip_bytes) != 1) {
-      LOG(ERROR) << "Can't parse client IP (" << client_ip_hex_
+      ABSL_LOG(ERROR) << "Can't parse client IP (" << client_ip_hex_
                  << ") from a hex string to an integer.";
       return "";
     }
@@ -121,7 +121,7 @@ std::string LoadRecordKey::GetClientIpBytes() const {
     for (size_t i = 0; i < 4; ++i) {
       if (sscanf(client_ip_hex_.substr(i * 8, (i + 1) * 8).c_str(), "%x",
                  ip_bytes + i) != 1) {
-        LOG(ERROR) << "Can't parse client IP part ("
+        ABSL_LOG(ERROR) << "Can't parse client IP part ("
                    << client_ip_hex_.substr(i * 8, (i + 1) * 8)
                    << ") from a hex string to an integer.";
         return "";
@@ -146,18 +146,18 @@ void PerBalancerStore::MergeRow(const LoadRecordKey& key,
   // During suspension, the load data received will be dropped.
   if (!suspended_) {
     load_record_map_[key].MergeFrom(value);
-    VLOG(2) << "[PerBalancerStore " << this
+    ABSL_VLOG(2) << "[PerBalancerStore " << this
             << "] Load data merged (Key: " << key.ToString()
             << ", Value: " << value.ToString() << ").";
   } else {
-    VLOG(2) << "[PerBalancerStore " << this
+    ABSL_VLOG(2) << "[PerBalancerStore " << this
             << "] Load data dropped (Key: " << key.ToString()
             << ", Value: " << value.ToString() << ").";
   }
   // We always keep track of num_calls_in_progress_, so that when this
   // store is resumed, we still have a correct value of
   // num_calls_in_progress_.
-  CHECK(static_cast<int64_t>(num_calls_in_progress_) +
+  ABSL_CHECK(static_cast<int64_t>(num_calls_in_progress_) +
             value.GetNumCallsInProgressDelta() >=
         0);
   num_calls_in_progress_ += value.GetNumCallsInProgressDelta();
@@ -166,23 +166,23 @@ void PerBalancerStore::MergeRow(const LoadRecordKey& key,
 void PerBalancerStore::Suspend() {
   suspended_ = true;
   load_record_map_.clear();
-  VLOG(2) << "[PerBalancerStore " << this << "] Suspended.";
+  ABSL_VLOG(2) << "[PerBalancerStore " << this << "] Suspended.";
 }

 void PerBalancerStore::Resume() {
   suspended_ = false;
-  VLOG(2) << "[PerBalancerStore " << this << "] Resumed.";
+  ABSL_VLOG(2) << "[PerBalancerStore " << this << "] Resumed.";
 }

 uint64_t PerBalancerStore::GetNumCallsInProgressForReport() {
-  CHECK(!suspended_);
+  ABSL_CHECK(!suspended_);
   last_reported_num_calls_in_progress_ = num_calls_in_progress_;
   return num_calls_in_progress_;
 }

 void PerHostStore::ReportStreamCreated(const std::string& lb_id,
                                        const std::string& load_key) {
-  CHECK(lb_id != kInvalidLbId);
+  ABSL_CHECK(lb_id != kInvalidLbId);
   SetUpForNewLbId(lb_id, load_key);
   // Prior to this one, there was no load balancer receiving report, so we may
   // have unassigned orphaned stores to assign to this new balancer.
@@ -208,9 +208,9 @@ void PerHostStore::ReportStreamCreated(const std::string& lb_id,

 void PerHostStore::ReportStreamClosed(const std::string& lb_id) {
   auto it_store_for_gone_lb = per_balancer_stores_.find(lb_id);
-  CHECK(it_store_for_gone_lb != per_balancer_stores_.end());
+  ABSL_CHECK(it_store_for_gone_lb != per_balancer_stores_.end());
   // Remove this closed stream from our records.
-  CHECK(UnorderedMapOfSetEraseKeyValue(load_key_to_receiving_lb_ids_,
+  ABSL_CHECK(UnorderedMapOfSetEraseKeyValue(load_key_to_receiving_lb_ids_,
                                        it_store_for_gone_lb->second->load_key(),
                                        lb_id));
   std::set<PerBalancerStore*> orphaned_stores =
@@ -254,9 +254,9 @@ const std::set<PerBalancerStore*>* PerHostStore::GetAssignedStores(
 void PerHostStore::AssignOrphanedStore(PerBalancerStore* orphaned_store,
                                        const std::string& new_receiver) {
   auto it = assigned_stores_.find(new_receiver);
-  CHECK(it != assigned_stores_.end());
+  ABSL_CHECK(it != assigned_stores_.end());
   it->second.insert(orphaned_store);
-  LOG(INFO) << "[PerHostStore " << this << "] Re-assigned orphaned store ("
+  ABSL_LOG(INFO) << "[PerHostStore " << this << "] Re-assigned orphaned store ("
             << orphaned_store << ") with original LB ID of "
             << orphaned_store->lb_id() << " to new receiver " << new_receiver;
 }
@@ -265,8 +265,8 @@ void PerHostStore::SetUpForNewLbId(const std::string& lb_id,
                                    const std::string& load_key) {
   // The top-level caller (i.e., LoadReportService) should guarantee the
   // lb_id is unique for each reporting stream.
-  CHECK(per_balancer_stores_.find(lb_id) == per_balancer_stores_.end());
-  CHECK(assigned_stores_.find(lb_id) == assigned_stores_.end());
+  ABSL_CHECK(per_balancer_stores_.find(lb_id) == per_balancer_stores_.end());
+  ABSL_CHECK(assigned_stores_.find(lb_id) == assigned_stores_.end());
   load_key_to_receiving_lb_ids_[load_key].insert(lb_id);
   std::unique_ptr<PerBalancerStore> per_balancer_store(
       new PerBalancerStore(lb_id, load_key));
@@ -300,14 +300,14 @@ void LoadDataStore::MergeRow(const std::string& hostname,
   if (in_progress_delta != 0) {
     auto it_tracker = unknown_balancer_id_trackers_.find(key.lb_id());
     if (it_tracker == unknown_balancer_id_trackers_.end()) {
-      VLOG(2) << "[LoadDataStore " << this
+      ABSL_VLOG(2) << "[LoadDataStore " << this
               << "] Start tracking unknown balancer (lb_id_: " << key.lb_id()
               << ").";
       unknown_balancer_id_trackers_.insert(
           {key.lb_id(), static_cast<uint64_t>(in_progress_delta)});
     } else if ((it_tracker->second += in_progress_delta) == 0) {
       unknown_balancer_id_trackers_.erase(it_tracker);
-      VLOG(2) << "[LoadDataStore " << this
+      ABSL_VLOG(2) << "[LoadDataStore " << this
               << "] Stop tracking unknown balancer (lb_id_: " << key.lb_id()
               << ").";
     }
@@ -330,7 +330,7 @@ void LoadDataStore::ReportStreamCreated(const std::string& hostname,
 void LoadDataStore::ReportStreamClosed(const std::string& hostname,
                                        const std::string& lb_id) {
   auto it_per_host_store = per_host_stores_.find(hostname);
-  CHECK(it_per_host_store != per_host_stores_.end());
+  ABSL_CHECK(it_per_host_store != per_host_stores_.end());
   it_per_host_store->second.ReportStreamClosed(lb_id);
 }

diff --git a/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter.cc b/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter.cc
index c2aae6635fc9d..f29bb08aecebd 100644
--- a/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter.cc
+++ b/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter.cc
@@ -28,8 +28,8 @@
 #include <set>
 #include <tuple>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "opencensus/tags/tag_key.h"
 #include "src/cpp/server/load_reporter/constants.h"
 #include "src/cpp/server/load_reporter/get_cpu_stats.h"
@@ -167,10 +167,10 @@ double CensusViewProvider::GetRelatedViewDataRowDouble(
     const ViewDataMap& view_data_map, const char* view_name,
     size_t view_name_len, const std::vector<std::string>& tag_values) {
   auto it_vd = view_data_map.find(std::string(view_name, view_name_len));
-  CHECK(it_vd != view_data_map.end());
-  CHECK(it_vd->second.type() == ::opencensus::stats::ViewData::Type::kDouble);
+  ABSL_CHECK(it_vd != view_data_map.end());
+  ABSL_CHECK(it_vd->second.type() == ::opencensus::stats::ViewData::Type::kDouble);
   auto it_row = it_vd->second.double_data().find(tag_values);
-  CHECK(it_row != it_vd->second.double_data().end());
+  ABSL_CHECK(it_row != it_vd->second.double_data().end());
   return it_row->second;
 }

@@ -178,11 +178,11 @@ uint64_t CensusViewProvider::GetRelatedViewDataRowInt(
     const ViewDataMap& view_data_map, const char* view_name,
     size_t view_name_len, const std::vector<std::string>& tag_values) {
   auto it_vd = view_data_map.find(std::string(view_name, view_name_len));
-  CHECK(it_vd != view_data_map.end());
-  CHECK(it_vd->second.type() == ::opencensus::stats::ViewData::Type::kInt64);
+  ABSL_CHECK(it_vd != view_data_map.end());
+  ABSL_CHECK(it_vd->second.type() == ::opencensus::stats::ViewData::Type::kInt64);
   auto it_row = it_vd->second.int_data().find(tag_values);
-  CHECK(it_row != it_vd->second.int_data().end());
-  CHECK_GE(it_row->second, 0);
+  ABSL_CHECK(it_row != it_vd->second.int_data().end());
+  ABSL_CHECK_GE(it_row->second, 0);
   return it_row->second;
 }

@@ -199,17 +199,17 @@ CensusViewProviderDefaultImpl::CensusViewProviderDefaultImpl() {
 }

 CensusViewProvider::ViewDataMap CensusViewProviderDefaultImpl::FetchViewData() {
-  VLOG(2) << "[CVP " << this << "] Starts fetching Census view data.";
+  ABSL_VLOG(2) << "[CVP " << this << "] Starts fetching Census view data.";
   ViewDataMap view_data_map;
   for (auto& p : view_map_) {
     const std::string& view_name = p.first;
     ::opencensus::stats::View& view = p.second;
     if (view.IsValid()) {
       view_data_map.emplace(view_name, view.GetData());
-      VLOG(2) << "[CVP " << this << "] Fetched view data (view: " << view_name
+      ABSL_VLOG(2) << "[CVP " << this << "] Fetched view data (view: " << view_name
               << ").";
     } else {
-      VLOG(2) << "[CVP " << this
+      ABSL_VLOG(2) << "[CVP " << this
               << "] Can't fetch view data because view is invalid (view: "
               << view_name << ").";
     }
@@ -220,13 +220,13 @@ CensusViewProvider::ViewDataMap CensusViewProviderDefaultImpl::FetchViewData() {
 std::string LoadReporter::GenerateLbId() {
   while (true) {
     if (next_lb_id_ > UINT32_MAX) {
-      LOG(ERROR) << "[LR " << this
+      ABSL_LOG(ERROR) << "[LR " << this
                  << "] The LB ID exceeds the max valid value!";
       return "";
     }
     int64_t lb_id = next_lb_id_++;
     // Overflow should never happen.
-    CHECK_GE(lb_id, 0);
+    ABSL_CHECK_GE(lb_id, 0);
     // Convert to padded hex string for a 32-bit LB ID. E.g, "0000ca5b".
     char buf[kLbIdLength + 1];
     snprintf(buf, sizeof(buf), "%08" PRIx64, lb_id);
@@ -295,11 +295,11 @@ LoadReporter::GenerateLoads(const std::string& hostname,
                             const std::string& lb_id) {
   grpc_core::MutexLock lock(&store_mu_);
   auto assigned_stores = load_data_store_.GetAssignedStores(hostname, lb_id);
-  CHECK_NE(assigned_stores, nullptr);
-  CHECK(!assigned_stores->empty());
+  ABSL_CHECK_NE(assigned_stores, nullptr);
+  ABSL_CHECK(!assigned_stores->empty());
   ::google::protobuf::RepeatedPtrField<grpc::lb::v1::Load> loads;
   for (PerBalancerStore* per_balancer_store : *assigned_stores) {
-    CHECK(!per_balancer_store->IsSuspended());
+    ABSL_CHECK(!per_balancer_store->IsSuspended());
     if (!per_balancer_store->load_record_map().empty()) {
       for (const auto& p : per_balancer_store->load_record_map()) {
         const auto& key = p.first;
@@ -384,7 +384,7 @@ void LoadReporter::ReportStreamCreated(const std::string& hostname,
                                        const std::string& load_key) {
   grpc_core::MutexLock lock(&store_mu_);
   load_data_store_.ReportStreamCreated(hostname, lb_id, load_key);
-  LOG(INFO) << "[LR " << this << "] Report stream created (host: " << hostname
+  ABSL_LOG(INFO) << "[LR " << this << "] Report stream created (host: " << hostname
             << ", LB ID: " << lb_id << ", load key: " << load_key << ").";
 }

@@ -392,7 +392,7 @@ void LoadReporter::ReportStreamClosed(const std::string& hostname,
                                       const std::string& lb_id) {
   grpc_core::MutexLock lock(&store_mu_);
   load_data_store_.ReportStreamClosed(hostname, lb_id);
-  LOG(INFO) << "[LR " << this << "] Report stream closed (host: " << hostname
+  ABSL_LOG(INFO) << "[LR " << this << "] Report stream closed (host: " << hostname
             << ", LB ID: " << lb_id << ").";
 }

@@ -433,7 +433,7 @@ void LoadReporter::ProcessViewDataCallEnd(
       // implementation.
       // TODO(juanlishen): Check whether this situation happens in OSS C++.
       if (client_ip_and_token.empty()) {
-        VLOG(2) << "Skipping processing Opencensus record with empty "
+        ABSL_VLOG(2) << "Skipping processing Opencensus record with empty "
                    "client_ip_and_token tag.";
         continue;
       }
@@ -495,7 +495,7 @@ void LoadReporter::ProcessViewDataOtherCallMetrics(
 }

 void LoadReporter::FetchAndSample() {
-  VLOG(2) << "[LR " << this
+  ABSL_VLOG(2) << "[LR " << this
           << "] Starts fetching Census view data and sampling LB feedback "
              "record.";
   CensusViewProvider::ViewDataMap view_data_map =
diff --git a/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter_async_service_impl.cc b/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter_async_service_impl.cc
index 9870bf4d0d6b6..5826afc4044cf 100644
--- a/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter_async_service_impl.cc
+++ b/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter_async_service_impl.cc
@@ -24,8 +24,8 @@
 #include <grpcpp/support/status.h>
 #include <inttypes.h>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/cpp/server/load_reporter/constants.h"

 // IWYU pragma: no_include "google/protobuf/duration.pb.h"
@@ -34,8 +34,8 @@ namespace grpc {
 namespace load_reporter {

 void LoadReporterAsyncServiceImpl::CallableTag::Run(bool ok) {
-  CHECK(handler_function_ != nullptr);
-  CHECK_NE(handler_, nullptr);
+  ABSL_CHECK(handler_function_ != nullptr);
+  ABSL_CHECK_NE(handler_, nullptr);
   handler_function_(std::move(handler_), ok);
 }

@@ -81,15 +81,15 @@ void LoadReporterAsyncServiceImpl::ScheduleNextFetchAndSample() {
     next_fetch_and_sample_alarm_->Set(cq_.get(), next_fetch_and_sample_time,
                                       this);
   }
-  VLOG(2) << "[LRS " << this << "] Next fetch-and-sample scheduled.";
+  ABSL_VLOG(2) << "[LRS " << this << "] Next fetch-and-sample scheduled.";
 }

 void LoadReporterAsyncServiceImpl::FetchAndSample(bool ok) {
   if (!ok) {
-    LOG(INFO) << "[LRS " << this << "] Fetch-and-sample is stopped.";
+    ABSL_LOG(INFO) << "[LRS " << this << "] Fetch-and-sample is stopped.";
     return;
   }
-  VLOG(2) << "[LRS " << this << "] Starting a fetch-and-sample...";
+  ABSL_VLOG(2) << "[LRS " << this << "] Starting a fetch-and-sample...";
   load_reporter_->FetchAndSample();
   ScheduleNextFetchAndSample();
 }
@@ -109,7 +109,7 @@ void LoadReporterAsyncServiceImpl::Work(void* arg) {
   while (true) {
     if (!service->cq_->Next(&tag, &ok)) {
       // The completion queue is shutting down.
-      CHECK(service->shutdown_);
+      ABSL_CHECK(service->shutdown_);
       break;
     }
     if (tag == service) {
@@ -164,7 +164,7 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::OnRequestDelivered(
     // tag will not pop out if the call never starts (
     // https://github.com/grpc/grpc/issues/10136). So we need to manually
     // release the ownership of the handler in this case.
-    CHECK_NE(on_done_notified_.ReleaseHandler(), nullptr);
+    ABSL_CHECK_NE(on_done_notified_.ReleaseHandler(), nullptr);
   }
   if (!ok || shutdown_) {
     // The value of ok being false means that the server is shutting down.
@@ -189,7 +189,7 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::OnRequestDelivered(
   }
   // LB ID is unique for each load reporting stream.
   lb_id_ = load_reporter_->GenerateLbId();
-  LOG(INFO) << "[LRS " << service_
+  ABSL_LOG(INFO) << "[LRS " << service_
             << "] Call request delivered (lb_id_: " << lb_id_
             << ", handler: " << this
             << "). Start reading the initial request...";
@@ -200,7 +200,7 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::OnReadDone(
   if (!ok || shutdown_) {
     if (!ok && call_status_ < INITIAL_REQUEST_RECEIVED) {
       // The client may have half-closed the stream or the stream is broken.
-      LOG(INFO) << "[LRS " << service_
+      ABSL_LOG(INFO) << "[LRS " << service_
                 << "] Failed reading the initial request from the stream "
                    "(lb_id_: "
                 << lb_id_ << ", handler: " << this
@@ -225,7 +225,7 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::OnReadDone(
       load_report_interval_ms_ =
           static_cast<unsigned long>((load_report_interval.seconds() * 1000) +
                                      (load_report_interval.nanos() / 1000));
-      LOG(INFO) << "[LRS " << service_
+      ABSL_LOG(INFO) << "[LRS " << service_
                 << "] Initial request received. Start load reporting (load "
                    "balanced host: "
                 << load_balanced_hostname_
@@ -249,7 +249,7 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::OnReadDone(
     }
   } else {
     // Another request received! This violates the spec.
-    LOG(ERROR) << "[LRS " << service_
+    ABSL_LOG(ERROR) << "[LRS " << service_
                << "] Another request received (lb_id_: " << lb_id_
                << ", handler: " << this << ").";
     Shutdown(std::move(self), "OnReadDone+second_request");
@@ -281,7 +281,7 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::ScheduleNextReport(
     next_report_alarm_ = std::make_unique<Alarm>();
     next_report_alarm_->Set(cq_, next_report_time, &next_outbound_);
   }
-  VLOG(2) << "[LRS " << service_
+  ABSL_VLOG(2) << "[LRS " << service_
           << "] Next load report scheduled (lb_id_: " << lb_id_
           << ", handler: " << this << ").";
 }
@@ -317,7 +317,7 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::SendReport(
                               std::placeholders::_1, std::placeholders::_2),
                     std::move(self));
     stream_.Write(response, &next_outbound_);
-    LOG(INFO) << "[LRS " << service_
+    ABSL_LOG(INFO) << "[LRS " << service_
               << "] Sending load report (lb_id_: " << lb_id_
               << ", handler: " << this
               << ", loads count: " << response.load().size() << ")...";
@@ -326,12 +326,12 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::SendReport(

 void LoadReporterAsyncServiceImpl::ReportLoadHandler::OnDoneNotified(
     std::shared_ptr<ReportLoadHandler> self, bool ok) {
-  CHECK(ok);
+  ABSL_CHECK(ok);
   done_notified_ = true;
   if (ctx_.IsCancelled()) {
     is_cancelled_ = true;
   }
-  LOG(INFO) << "[LRS " << service_
+  ABSL_LOG(INFO) << "[LRS " << service_
             << "] Load reporting call is notified done (handler: " << this
             << ", is_cancelled: " << is_cancelled_ << ").";
   Shutdown(std::move(self), "OnDoneNotified");
@@ -340,7 +340,7 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::OnDoneNotified(
 void LoadReporterAsyncServiceImpl::ReportLoadHandler::Shutdown(
     std::shared_ptr<ReportLoadHandler> self, const char* reason) {
   if (!shutdown_) {
-    LOG(INFO) << "[LRS " << service_
+    ABSL_LOG(INFO) << "[LRS " << service_
               << "] Shutting down the handler (lb_id_: " << lb_id_
               << ", handler: " << this << ", reason: " << reason << ").";
     shutdown_ = true;
@@ -371,7 +371,7 @@ void LoadReporterAsyncServiceImpl::ReportLoadHandler::OnFinishDone(
     // NOLINTNEXTLINE(performance-unnecessary-value-param)
     std::shared_ptr<ReportLoadHandler> /*self*/, bool ok) {
   if (ok) {
-    LOG(INFO) << "[LRS " << service_
+    ABSL_LOG(INFO) << "[LRS " << service_
               << "] Load reporting finished (lb_id_: " << lb_id_
               << ", handler: " << this << ").";
   }
diff --git a/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter_async_service_impl.h b/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter_async_service_impl.h
index e5597a3818855..c383ef0f26d79 100644
--- a/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter_async_service_impl.h
+++ b/third_party/grpc/source/src/cpp/server/load_reporter/load_reporter_async_service_impl.h
@@ -32,7 +32,7 @@
 #include <string>
 #include <utility>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"
 #include "src/core/util/sync.h"
 #include "src/core/util/thd.h"
 #include "src/cpp/server/load_reporter/load_reporter.h"
@@ -80,8 +80,8 @@ class LoadReporterAsyncServiceImpl
     CallableTag(HandlerFunction func,
                 std::shared_ptr<ReportLoadHandler> handler)
         : handler_function_(std::move(func)), handler_(std::move(handler)) {
-      CHECK(handler_function_ != nullptr);
-      CHECK_NE(handler_, nullptr);
+      ABSL_CHECK(handler_function_ != nullptr);
+      ABSL_CHECK_NE(handler_, nullptr);
     }

     // Runs the tag. This should be called only once. The handler is no longer
diff --git a/third_party/grpc/source/src/cpp/server/load_reporter/util.cc b/third_party/grpc/source/src/cpp/server/load_reporter/util.cc
index 4d2ddc9c42c6b..d68615c8b7837 100644
--- a/third_party/grpc/source/src/cpp/server/load_reporter/util.cc
+++ b/third_party/grpc/source/src/cpp/server/load_reporter/util.cc
@@ -25,7 +25,7 @@
 #include <cmath>
 #include <string>

-#include "absl/log/log.h"
+#include "absl/log/absl_log.h"

 namespace grpc {
 namespace load_reporter {
@@ -41,7 +41,7 @@ void AddLoadReportingCost(grpc::ServerContext* ctx,
            cost_name.size());
     ctx->AddTrailingMetadata(GRPC_LB_COST_MD_KEY, buf);
   } else {
-    LOG(ERROR) << "Call metric value is not normal.";
+    ABSL_LOG(ERROR) << "Call metric value is not normal.";
   }
 }

diff --git a/third_party/grpc/source/src/cpp/server/orca/orca_service.cc b/third_party/grpc/source/src/cpp/server/orca/orca_service.cc
index 31f3a07cc1002..aff1e47eefac6 100644
--- a/third_party/grpc/source/src/cpp/server/orca/orca_service.cc
+++ b/third_party/grpc/source/src/cpp/server/orca/orca_service.cc
@@ -35,8 +35,8 @@
 #include <optional>
 #include <utility>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/string_view.h"
 #include "absl/time/time.h"
 #include "google/protobuf/duration.upb.h"
@@ -68,7 +68,7 @@ OrcaService::Reactor::Reactor(OrcaService* service, absl::string_view peer,
   Slice slice;
   grpc::Status status = request_buffer->DumpToSingleSlice(&slice);
   if (!status.ok()) {
-    LOG_EVERY_N_SEC(WARNING, 1)
+    ABSL_LOG_EVERY_N_SEC(WARNING, 1)
         << "OrcaService failed to extract request from peer: " << peer
         << " error:" << status.error_message();
     FinishRpc(Status(StatusCode::INTERNAL, status.error_message()));
@@ -81,7 +81,7 @@ OrcaService::Reactor::Reactor(OrcaService* service, absl::string_view peer,
           reinterpret_cast<const char*>(slice.begin()), slice.size(),
           arena.ptr());
   if (request == nullptr) {
-    LOG_EVERY_N_SEC(WARNING, 1)
+    ABSL_LOG_EVERY_N_SEC(WARNING, 1)
         << "OrcaService failed to parse request proto from peer: " << peer;
     FinishRpc(Status(StatusCode::INTERNAL, "could not parse request proto"));
     return;
@@ -175,7 +175,7 @@ OrcaService::OrcaService(ServerMetricRecorder* const server_metric_recorder,
                          Options options)
     : server_metric_recorder_(server_metric_recorder),
       min_report_duration_(options.min_report_duration) {
-  CHECK_NE(server_metric_recorder_, nullptr);
+  ABSL_CHECK_NE(server_metric_recorder_, nullptr);
   AddMethod(new internal::RpcServiceMethod(
       "/xds.service.orca.v3.OpenRcaService/StreamCoreMetrics",
       internal::RpcMethod::SERVER_STREAMING, /*handler=*/nullptr));
diff --git a/third_party/grpc/source/src/cpp/server/server_builder.cc b/third_party/grpc/source/src/cpp/server/server_builder.cc
index 1e611449931e4..f262236812678 100644
--- a/third_party/grpc/source/src/cpp/server/server_builder.cc
+++ b/third_party/grpc/source/src/cpp/server/server_builder.cc
@@ -44,8 +44,8 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "src/core/ext/transport/chttp2/server/chttp2_server.h"
 #include "src/core/server/server.h"
 #include "src/core/util/string.h"
@@ -137,7 +137,7 @@ ServerBuilder& ServerBuilder::RegisterService(const std::string& host,
 ServerBuilder& ServerBuilder::RegisterAsyncGenericService(
     AsyncGenericService* service) {
   if (generic_service_ || callback_generic_service_) {
-    LOG(ERROR) << "Adding multiple generic services is unsupported for now. "
+    ABSL_LOG(ERROR) << "Adding multiple generic services is unsupported for now. "
                   "Dropping the service "
                << service;
   } else {
@@ -149,7 +149,7 @@ ServerBuilder& ServerBuilder::RegisterAsyncGenericService(
 ServerBuilder& ServerBuilder::RegisterCallbackGenericService(
     CallbackGenericService* service) {
   if (generic_service_ || callback_generic_service_) {
-    LOG(ERROR) << "Adding multiple generic services is unsupported for now. "
+    ABSL_LOG(ERROR) << "Adding multiple generic services is unsupported for now. "
                   "Dropping the service "
                << service;
   } else {
@@ -186,7 +186,7 @@ void ServerBuilder::experimental_type::SetAuthorizationPolicyProvider(
 void ServerBuilder::experimental_type::EnableCallMetricRecording(
     experimental::ServerMetricRecorder* server_metric_recorder) {
   builder_->AddChannelArgument(GRPC_ARG_SERVER_CALL_METRIC_RECORDING, 1);
-  CHECK_EQ(builder_->server_metric_recorder_, nullptr);
+  ABSL_CHECK_EQ(builder_->server_metric_recorder_, nullptr);
   builder_->server_metric_recorder_ = server_metric_recorder;
 }

@@ -387,14 +387,14 @@ std::unique_ptr<grpc::Server> ServerBuilder::BuildAndStart() {

   if (has_sync_methods) {
     // This is a Sync server
-    VLOG(2) << "Synchronous server. Num CQs: " << sync_server_settings_.num_cqs
+    ABSL_VLOG(2) << "Synchronous server. Num CQs: " << sync_server_settings_.num_cqs
             << ", Min pollers: " << sync_server_settings_.min_pollers
             << ", Max Pollers: " << sync_server_settings_.max_pollers
             << ", CQ timeout (msec): " << sync_server_settings_.cq_timeout_msec;
   }

   if (has_callback_methods) {
-    VLOG(2) << "Callback server.";
+    ABSL_VLOG(2) << "Callback server.";
   }

   std::unique_ptr<grpc::Server> server(new grpc::Server(
@@ -439,13 +439,13 @@ std::unique_ptr<grpc::Server> ServerBuilder::BuildAndStart() {
     if (passive_listener != nullptr) {
       auto* creds = unstarted_listener.credentials->c_creds();
       if (creds == nullptr) {
-        LOG(ERROR) << "Credentials missing for PassiveListener";
+        ABSL_LOG(ERROR) << "Credentials missing for PassiveListener";
         return nullptr;
       }
       auto success = grpc_server_add_passive_listener(
           core_server, creds, std::move(passive_listener));
       if (!success.ok()) {
-        LOG(ERROR) << "Failed to create a passive listener: "
+        ABSL_LOG(ERROR) << "Failed to create a passive listener: "
                    << success.ToString();
         return nullptr;
       }
@@ -453,7 +453,7 @@ std::unique_ptr<grpc::Server> ServerBuilder::BuildAndStart() {
   }

   if (!has_frequently_polled_cqs) {
-    LOG(ERROR)
+    ABSL_LOG(ERROR)
         << "At least one of the completion queues must be frequently polled";
     return nullptr;
   }
@@ -477,7 +477,7 @@ std::unique_ptr<grpc::Server> ServerBuilder::BuildAndStart() {
   } else {
     for (const auto& value : services_) {
       if (value->service->has_generic_methods()) {
-        LOG(ERROR) << "Some methods were marked generic but there is no "
+        ABSL_LOG(ERROR) << "Some methods were marked generic but there is no "
                       "generic service registered.";
         return nullptr;
       }
@@ -518,7 +518,7 @@ ServerBuilder& ServerBuilder::EnableWorkaround(grpc_workaround_list id) {
     case GRPC_WORKAROUND_ID_CRONET_COMPRESSION:
       return AddChannelArgument(GRPC_ARG_WORKAROUND_CRONET_COMPRESSION, 1);
     default:
-      LOG(ERROR) << "Workaround " << id << " does not exist or is obsolete.";
+      ABSL_LOG(ERROR) << "Workaround " << id << " does not exist or is obsolete.";
       return *this;
   }
 }
diff --git a/third_party/grpc/source/src/cpp/server/server_cc.cc b/third_party/grpc/source/src/cpp/server/server_cc.cc
index 2d30879de66d5..78c12bf2b34a5 100644
--- a/third_party/grpc/source/src/cpp/server/server_cc.cc
+++ b/third_party/grpc/source/src/cpp/server/server_cc.cc
@@ -63,8 +63,8 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/status/status.h"
 #include "src/core/ext/transport/inproc/inproc_transport.h"
 #include "src/core/lib/iomgr/exec_ctx.h"
@@ -238,7 +238,7 @@ void ServerInterface::RegisteredAsyncRequest::IssueRequest(
     ServerCompletionQueue* notification_cq) {
   // The following call_start_batch is internally-generated so no need for an
   // explanatory log on failure.
-  CHECK(grpc_server_request_registered_call(
+  ABSL_CHECK(grpc_server_request_registered_call(
             server_->server(), registered_method, &call_, &context_->deadline_,
             context_->client_metadata_.arr(), payload, call_cq_->cq(),
             notification_cq->cq(), this) == GRPC_CALL_OK);
@@ -252,8 +252,8 @@ ServerInterface::GenericAsyncRequest::GenericAsyncRequest(
     : BaseAsyncRequest(server, context, stream, call_cq, notification_cq, tag,
                        delete_on_finalize) {
   grpc_call_details_init(&call_details_);
-  CHECK(notification_cq);
-  CHECK(call_cq);
+  ABSL_CHECK(notification_cq);
+  ABSL_CHECK(call_cq);
   if (issue_request) {
     IssueRequest();
   }
@@ -287,7 +287,7 @@ bool ServerInterface::GenericAsyncRequest::FinalizeResult(void** tag,
 void ServerInterface::GenericAsyncRequest::IssueRequest() {
   // The following call_start_batch is internally-generated so no need for an
   // explanatory log on failure.
-  CHECK(grpc_server_request_call(server_->server(), &call_, &call_details_,
+  ABSL_CHECK(grpc_server_request_call(server_->server(), &call_, &call_details_,
                                  context_->client_metadata_.arr(),
                                  call_cq_->cq(), notification_cq_->cq(),
                                  this) == GRPC_CALL_OK);
@@ -444,7 +444,7 @@ class Server::SyncRequest final : public grpc::internal::CompletionQueueTag {
       deserialized_request_ = handler->Deserialize(call_, request_payload_,
                                                    &request_status_, nullptr);
       if (!request_status_.ok()) {
-        VLOG(2) << "Failed to deserialize message.";
+        ABSL_VLOG(2) << "Failed to deserialize message.";
       }
       request_payload_ = nullptr;
       interceptor_methods_.AddInterceptionHookPoint(
@@ -478,7 +478,7 @@ class Server::SyncRequest final : public grpc::internal::CompletionQueueTag {

     // Ensure the cq_ is shutdown
     grpc::PhonyTag ignored_tag;
-    CHECK(cq_.Pluck(&ignored_tag) == false);
+    ABSL_CHECK(cq_.Pluck(&ignored_tag) == false);

     // Cleanup structures allocated during Run/ContinueRunAfterInterception
     wrapped_call_.Destroy();
@@ -640,8 +640,8 @@ class Server::CallbackRequest final
     void Run(bool ok) {
       void* ignored = req_;
       bool new_ok = ok;
-      CHECK(!req_->FinalizeResult(&ignored, &new_ok));
-      CHECK(ignored == req_);
+      ABSL_CHECK(!req_->FinalizeResult(&ignored, &new_ok));
+      ABSL_CHECK(ignored == req_);

       if (!ok) {
         // The call has been shutdown.
@@ -687,7 +687,7 @@ class Server::CallbackRequest final
             req_->call_, req_->request_payload_, &req_->request_status_,
             &req_->handler_data_);
         if (!(req_->request_status_.ok())) {
-          VLOG(2) << "Failed to deserialize message.";
+          ABSL_VLOG(2) << "Failed to deserialize message.";
         }
         req_->request_payload_ = nullptr;
         req_->interceptor_methods_.AddInterceptionHookPoint(
@@ -822,8 +822,8 @@ class Server::SyncRequestThreadManager : public grpc::ThreadManager {

     // Under the AllocatingRequestMatcher model we will never see an invalid tag
     // here.
-    DCHECK_NE(sync_req, nullptr);
-    DCHECK(ok);
+    ABSL_DCHECK_NE(sync_req, nullptr);
+    ABSL_DCHECK(ok);

     sync_req->Run(global_callbacks_, resources);
   }
@@ -995,8 +995,8 @@ Server::~Server() {
 }

 void Server::SetGlobalCallbacks(GlobalCallbacks* callbacks) {
-  CHECK(!grpc::g_callbacks);
-  CHECK(callbacks);
+  ABSL_CHECK(!grpc::g_callbacks);
+  ABSL_CHECK(callbacks);
   grpc::g_callbacks.reset(callbacks);
 }

@@ -1040,7 +1040,7 @@ static grpc_server_register_method_payload_handling PayloadHandlingForMethod(
 bool Server::RegisterService(const std::string* addr, grpc::Service* service) {
   bool has_async_methods = service->has_async_methods();
   if (has_async_methods) {
-    CHECK_EQ(service->server_, nullptr)
+    ABSL_CHECK_EQ(service->server_, nullptr)
         << "Can only register an asynchronous service against one server.";
     service->server_ = this;
   }
@@ -1056,7 +1056,7 @@ bool Server::RegisterService(const std::string* addr, grpc::Service* service) {
         server_, method->name(), addr ? addr->c_str() : nullptr,
         PayloadHandlingForMethod(method.get()), 0);
     if (method_registration_tag == nullptr) {
-      VLOG(2) << "Attempt to register " << method->name() << " multiple times";
+      ABSL_VLOG(2) << "Attempt to register " << method->name() << " multiple times";
       return false;
     }

@@ -1097,7 +1097,7 @@ bool Server::RegisterService(const std::string* addr, grpc::Service* service) {
 }

 void Server::RegisterAsyncGenericService(grpc::AsyncGenericService* service) {
-  CHECK_EQ(service->server_, nullptr)
+  ABSL_CHECK_EQ(service->server_, nullptr)
       << "Can only register an async generic service against one server.";
   service->server_ = this;
   has_async_generic_service_ = true;
@@ -1105,7 +1105,7 @@ void Server::RegisterAsyncGenericService(grpc::AsyncGenericService* service) {

 void Server::RegisterCallbackGenericService(
     grpc::CallbackGenericService* service) {
-  CHECK_EQ(service->server_, nullptr)
+  ABSL_CHECK_EQ(service->server_, nullptr)
       << "Can only register a callback generic service against one server.";
   service->server_ = this;
   has_callback_generic_service_ = true;
@@ -1122,7 +1122,7 @@ void Server::RegisterCallbackGenericService(

 int Server::AddListeningPort(const std::string& addr,
                              grpc::ServerCredentials* creds) {
-  CHECK(!started_);
+  ABSL_CHECK(!started_);
   int port = creds->AddPortToServer(addr, server_);
   global_callbacks_->AddPort(this, addr, creds, port);
   return port;
@@ -1138,7 +1138,7 @@ void Server::UnrefWithPossibleNotify() {
     // No refs outstanding means that shutdown has been initiated and no more
     // callback requests are outstanding.
     grpc::internal::MutexLock lock(&mu_);
-    CHECK(shutdown_);
+    ABSL_CHECK(shutdown_);
     shutdown_done_ = true;
     shutdown_done_cv_.Signal();
   }
@@ -1156,7 +1156,7 @@ void Server::UnrefAndWaitLocked() {
 }

 void Server::Start(grpc::ServerCompletionQueue** cqs, size_t num_cqs) {
-  CHECK(!started_);
+  ABSL_CHECK(!started_);
   global_callbacks_->PreServerStart(this);
   started_ = true;

diff --git a/third_party/grpc/source/src/cpp/server/server_context.cc b/third_party/grpc/source/src/cpp/server/server_context.cc
index ca8e3a4728fd9..4d97574be974f 100644
--- a/third_party/grpc/source/src/cpp/server/server_context.cc
+++ b/third_party/grpc/source/src/cpp/server/server_context.cc
@@ -50,8 +50,8 @@
 #include <utility>
 #include <vector>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_format.h"
 #include "absl/strings/string_view.h"
 #include "src/core/lib/resource_quota/arena.h"
@@ -153,7 +153,7 @@ class ServerContextBase::CompletionOp final
       return;
     }
     // Start a phony op so that we can return the tag
-    CHECK(grpc_call_start_batch(call_.call(), nullptr, 0, core_cq_tag_,
+    ABSL_CHECK(grpc_call_start_batch(call_.call(), nullptr, 0, core_cq_tag_,
                                 nullptr) == GRPC_CALL_OK);
   }

@@ -195,7 +195,7 @@ void ServerContextBase::CompletionOp::FillOps(internal::Call* call) {
   interceptor_methods_.SetCallOpSetInterface(this);
   // The following call_start_batch is internally-generated so no need for an
   // explanatory log on failure.
-  CHECK(grpc_call_start_batch(call->call(), &ops, 1, core_cq_tag_, nullptr) ==
+  ABSL_CHECK(grpc_call_start_batch(call->call(), &ops, 1, core_cq_tag_, nullptr) ==
         GRPC_CALL_OK);
   // No interceptors to run here
 }
@@ -300,7 +300,7 @@ ServerContextBase::CallWrapper::~CallWrapper() {
 void ServerContextBase::BeginCompletionOp(
     internal::Call* call, std::function<void(bool)> callback,
     grpc::internal::ServerCallbackCall* callback_controller) {
-  CHECK(!completion_op_);
+  ABSL_CHECK(!completion_op_);
   if (rpc_info_) {
     rpc_info_->Ref();
   }
@@ -344,7 +344,7 @@ void ServerContextBase::TryCancel() const {
       grpc_call_cancel_with_status(call_.call, GRPC_STATUS_CANCELLED,
                                    "Cancelled on the server side", nullptr);
   if (err != GRPC_CALL_OK) {
-    LOG(ERROR) << "TryCancel failed with: " << err;
+    ABSL_LOG(ERROR) << "TryCancel failed with: " << err;
   }
 }

@@ -372,7 +372,7 @@ void ServerContextBase::set_compression_algorithm(
     grpc_core::Crash(absl::StrFormat(
         "Name for compression algorithm '%d' unknown.", algorithm));
   }
-  CHECK_NE(algorithm_name, nullptr);
+  ABSL_CHECK_NE(algorithm_name, nullptr);
   AddInitialMetadata(GRPC_COMPRESSION_REQUEST_ALGORITHM_MD_KEY, algorithm_name);
 }

@@ -402,7 +402,7 @@ void ServerContextBase::SetLoadReportingCosts(
 void ServerContextBase::CreateCallMetricRecorder(
     experimental::ServerMetricRecorder* server_metric_recorder) {
   if (call_.call == nullptr) return;
-  CHECK_EQ(call_metric_recorder_, nullptr);
+  ABSL_CHECK_EQ(call_metric_recorder_, nullptr);
   grpc_core::Arena* arena = grpc_call_get_arena(call_.call);
   auto* backend_metric_state =
       arena->New<BackendMetricState>(server_metric_recorder);
diff --git a/third_party/grpc/source/src/cpp/server/xds_server_credentials.cc b/third_party/grpc/source/src/cpp/server/xds_server_credentials.cc
index 6ce2d70570b05..debbed215508d 100644
--- a/third_party/grpc/source/src/cpp/server/xds_server_credentials.cc
+++ b/third_party/grpc/source/src/cpp/server/xds_server_credentials.cc
@@ -22,14 +22,14 @@

 #include <memory>

-#include "absl/log/check.h"
+#include "absl/log/absl_check.h"

 namespace grpc {

 std::shared_ptr<ServerCredentials> XdsServerCredentials(
     const std::shared_ptr<ServerCredentials>& fallback_credentials) {
-  CHECK_NE(fallback_credentials, nullptr);
-  CHECK_NE(fallback_credentials->c_creds_, nullptr);
+  ABSL_CHECK_NE(fallback_credentials, nullptr);
+  ABSL_CHECK_NE(fallback_credentials->c_creds_, nullptr);
   return std::shared_ptr<ServerCredentials>(new ServerCredentials(
       grpc_xds_server_credentials_create(fallback_credentials->c_creds_)));
 }
diff --git a/third_party/grpc/source/src/cpp/thread_manager/thread_manager.cc b/third_party/grpc/source/src/cpp/thread_manager/thread_manager.cc
index 6cdf78c95bca8..9a51e8e96492a 100644
--- a/third_party/grpc/source/src/cpp/thread_manager/thread_manager.cc
+++ b/third_party/grpc/source/src/cpp/thread_manager/thread_manager.cc
@@ -20,8 +20,8 @@

 #include <climits>

-#include "absl/log/check.h"
-#include "absl/log/log.h"
+#include "absl/log/absl_check.h"
+#include "absl/log/absl_log.h"
 #include "absl/strings/str_format.h"
 #include "src/core/lib/resource_quota/resource_quota.h"
 #include "src/core/util/crash.h"
@@ -39,7 +39,7 @@ ThreadManager::WorkerThread::WorkerThread(ThreadManager* thd_mgr)
       [](void* th) { static_cast<ThreadManager::WorkerThread*>(th)->Run(); },
       this, &created_);
   if (!created_) {
-    LOG(ERROR) << "Could not create grpc_sync_server worker-thread";
+    ABSL_LOG(ERROR) << "Could not create grpc_sync_server worker-thread";
   }
 }

@@ -67,7 +67,7 @@ ThreadManager::ThreadManager(const char*, grpc_resource_quota* resource_quota,
 ThreadManager::~ThreadManager() {
   {
     grpc_core::MutexLock lock(&mu_);
-    CHECK_EQ(num_threads_, 0);
+    ABSL_CHECK_EQ(num_threads_, 0);
   }

   CleanupCompletedThreads();
@@ -141,7 +141,7 @@ void ThreadManager::Initialize() {

   for (int i = 0; i < min_pollers_; i++) {
     WorkerThread* worker = new WorkerThread(this);
-    CHECK(worker->created());  // Must be able to create the minimum
+    ABSL_CHECK(worker->created());  // Must be able to create the minimum
     worker->Start();
   }
 }
diff --git a/third_party/grpc/source/src/python/grpcio_observability/grpc_observability/observability_util.cc b/third_party/grpc/source/src/python/grpcio_observability/grpc_observability/observability_util.cc
index 54f5c8d36c4d5..d203b0b342751 100644
--- a/third_party/grpc/source/src/python/grpcio_observability/grpc_observability/observability_util.cc
+++ b/third_party/grpc/source/src/python/grpcio_observability/grpc_observability/observability_util.cc
@@ -125,7 +125,7 @@ void AwaitNextBatchLocked(std::unique_lock<std::mutex>& lock, int timeout_ms) {
 void AddCensusDataToBuffer(const CensusData& data) {
   std::unique_lock<std::mutex> lk(g_census_data_buffer_mutex);
   if (g_census_data_buffer->size() >= GetMaxExportBufferSize()) {
-    VLOG(2) << "Reached maximum census data buffer size, discarding this "
+    ABSL_VLOG(2) << "Reached maximum census data buffer size, discarding this "
                "CensusData entry";
   } else {
     g_census_data_buffer->push(data);
--
2.48.1.601.g30ceb7b040-goog

