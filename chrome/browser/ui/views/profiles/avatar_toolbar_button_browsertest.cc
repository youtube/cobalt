// Copyright 2024 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/ui/views/profiles/avatar_toolbar_button.h"

#include <optional>
#include <string>

#include "base/functional/bind.h"
#include "base/functional/callback_helpers.h"
#include "base/run_loop.h"
#include "base/scoped_observation.h"
#include "base/strings/utf_string_conversions.h"
#include "base/test/bind.h"
#include "base/test/scoped_feature_list.h"
#include "base/test/with_feature_override.h"
#include "base/time/time.h"
#include "base/timer/timer.h"
#include "chrome/browser/browser_process.h"
#include "chrome/browser/enterprise/util/managed_browser_utils.h"
#include "chrome/browser/profiles/keep_alive/profile_keep_alive_types.h"
#include "chrome/browser/profiles/keep_alive/scoped_profile_keep_alive.h"
#include "chrome/browser/profiles/profile.h"
#include "chrome/browser/profiles/profile_attributes_entry.h"
#include "chrome/browser/profiles/profile_attributes_storage.h"
#include "chrome/browser/profiles/profile_avatar_icon_util.h"
#include "chrome/browser/profiles/profile_manager.h"
#include "chrome/browser/signin/identity_manager_factory.h"
#include "chrome/browser/sync/sync_service_factory.h"
#include "chrome/browser/themes/theme_service.h"
#include "chrome/browser/themes/theme_service_factory.h"
#include "chrome/browser/ui/browser.h"
#include "chrome/browser/ui/profiles/profile_colors_util.h"
#include "chrome/browser/ui/ui_features.h"
#include "chrome/browser/ui/views/frame/browser_view.h"
#include "chrome/browser/ui/views/toolbar/toolbar_view.h"
#include "chrome/common/pref_names.h"
#include "chrome/test/base/in_process_browser_test.h"
#include "chrome/test/base/profile_destruction_waiter.h"
#include "components/keep_alive_registry/keep_alive_types.h"
#include "components/keep_alive_registry/scoped_keep_alive.h"
#include "components/policy/core/browser/browser_policy_connector.h"
#include "components/policy/core/common/management/management_service.h"
#include "components/policy/core/common/mock_configuration_policy_provider.h"
#include "components/policy/core/common/policy_map.h"
#include "components/policy/policy_constants.h"
#include "components/signin/public/base/consent_level.h"
#include "components/signin/public/base/signin_metrics.h"
#include "components/signin/public/base/signin_switches.h"
#include "components/signin/public/identity_manager/account_info.h"
#include "components/signin/public/identity_manager/accounts_mutator.h"
#include "components/signin/public/identity_manager/identity_manager.h"
#include "components/signin/public/identity_manager/identity_test_utils.h"
#include "components/signin/public/identity_manager/primary_account_mutator.h"
#include "components/sync/service/sync_service.h"
#include "components/sync/test/test_sync_service.h"
#include "content/public/browser/browser_context.h"
#include "content/public/test/browser_test.h"
#include "content/public/test/test_utils.h"
#include "google_apis/gaia/core_account_id.h"
#include "testing/gtest/include/gtest/gtest.h"
#include "third_party/skia/include/core/SkColor.h"
#include "ui/base/mojom/themes.mojom.h"
#include "ui/base/ui_base_features.h"
#include "ui/gfx/image/image.h"
#include "ui/gfx/image/image_skia.h"
#include "ui/gfx/image/image_unittest_util.h"

#if BUILDFLAG(IS_CHROMEOS_ASH)
#include "ash/constants/ash_switches.h"
#include "chrome/common/chrome_switches.h"
#include "chrome/test/base/testing_profile.h"
#include "components/user_manager/user_names.h"
#endif

namespace {
ui::mojom::BrowserColorVariant kColorVariant =
    ui::mojom::BrowserColorVariant::kTonalSpot;

constexpr base::TimeDelta kTestingDuration = base::Milliseconds(10);

const gfx::Image kSignedInImage = gfx::test::CreateImage(20, 20, SK_ColorBLUE);
const char kSignedInImageUrl[] = "SIGNED_IN_IMAGE_URL";

enum class ColorThemeType { kAutogeneratedTheme, kUserColor };

std::unique_ptr<KeyedService> TestingSyncFactoryFunction(
    content::BrowserContext* context) {
  return std::make_unique<syncer::TestSyncService>();
}

class AvatarToolbarButtonTestObserver : public AvatarToolbarButton::Observer {
 public:
  explicit AvatarToolbarButtonTestObserver(AvatarToolbarButton* avatar_button) {
    scoped_avatar_observation_.Observe(avatar_button);
  }

  void WaitForShowNameEnded() {
    if (show_name_ended_) {
      return;
    }

    CHECK(!show_name_run_loop_.running());
    show_name_run_loop_.Run();
  }

  void WaitForShowEnterpriseTextEnded() {
    if (show_enterprise_text_ended_) {
      return;
    }

    CHECK(!show_enterprise_text_run_loop_.running());
    show_enterprise_text_run_loop_.Run();
  }

  void WaitForShowSigninPausedDelayEnded() {
    if (show_signin_paused_delay_ended_) {
      return;
    }

    CHECK(!show_signin_paused_delay_run_loop_.running());
    show_signin_paused_delay_run_loop_.Run();
  }

  bool IsShowSigninPausedDelayEnded() {
    return show_signin_paused_delay_ended_;
  }

 private:
  // AvatarToolbarButton::Observer:
  void OnShowNameClearedForTesting() override {
    show_name_ended_ = true;
    show_name_run_loop_.Quit();
  }

  void OnShowManagementTransientTextClearedForTesting() override {
    show_enterprise_text_ended_ = true;
    show_enterprise_text_run_loop_.Quit();
  }

  void OnShowSigninPausedDelayEnded() override {
    show_signin_paused_delay_ended_ = true;
    show_signin_paused_delay_run_loop_.Quit();
  }

  base::RunLoop show_name_run_loop_;
  bool show_name_ended_ = false;

  base::RunLoop show_enterprise_text_run_loop_;
  bool show_enterprise_text_ended_ = false;

  base::RunLoop show_signin_paused_delay_run_loop_;
  bool show_signin_paused_delay_ended_ = false;

  base::ScopedObservation<AvatarToolbarButton, AvatarToolbarButton::Observer>
      scoped_avatar_observation_{this};
};

class ProfileLoader {
 public:
  Profile* LoadFirstAndOnlyProfile() {
    auto* profile_manager = g_browser_process->profile_manager();
    auto& storage = profile_manager->GetProfileAttributesStorage();
    EXPECT_EQ(1U, storage.GetNumberOfProfiles());

    profile_manager->LoadProfileByPath(
        storage.GetAllProfilesAttributes()[0]->GetPath(), /*incognito=*/false,
        base::BindRepeating(&ProfileLoader::OnProfileLoaded,
                            base::Unretained(this)));

    profile_loading_run_loop_.Run();
    return profile_;
  }

 private:
  void OnProfileLoaded(Profile* profile) {
    profile_ = profile;
    profile_loading_run_loop_.Quit();
  }

  raw_ptr<Profile> profile_ = nullptr;
  base::RunLoop profile_loading_run_loop_;
};

}  // namespace

class AvatarToolbarButtonBrowserTest : public InProcessBrowserTest {
 public:
  AvatarToolbarButtonBrowserTest()
      : dependency_manager_subscription_(
            BrowserContextDependencyManager::GetInstance()
                ->RegisterCreateServicesCallbackForTesting(base::BindRepeating(
                    &AvatarToolbarButtonBrowserTest::SetTestingFactories,
                    base::Unretained(this)))) {
    AvatarToolbarButton::SetTextDurationForTesting(kTestingDuration);
  }
  AvatarToolbarButtonBrowserTest(const AvatarToolbarButtonBrowserTest&) =
      delete;
  AvatarToolbarButtonBrowserTest& operator=(
      const AvatarToolbarButtonBrowserTest&) = delete;
  ~AvatarToolbarButtonBrowserTest() override = default;

  AvatarToolbarButton* GetAvatarToolbarButton(Browser* browser) {
    return BrowserView::GetBrowserViewForBrowser(browser)->toolbar()->avatar_;
  }

  // Returns the window count in avatar button text, if it exists.
  std::optional<int> GetWindowCountInAvatarButtonText(
      AvatarToolbarButton* avatar_button) {
    std::u16string button_text = avatar_button->GetText();

    size_t before_number = button_text.find('(');
    if (before_number == std::string::npos) {
      return std::optional<int>();
    }

    size_t after_number = button_text.find(')');
    EXPECT_NE(std::string::npos, after_number);

    std::u16string number_text =
        button_text.substr(before_number + 1, after_number - before_number - 1);
    int window_count;
    return base::StringToInt(number_text, &window_count)
               ? std::optional<int>(window_count)
               : std::optional<int>();
  }

  ProfileAttributesEntry* GetProfileAttributesEntry(Profile* profile) {
    ProfileAttributesEntry* entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath());
    CHECK(entry);
    return entry;
  }

  // - Helper functions

  signin::IdentityManager* GetIdentityManager() {
    return IdentityManagerFactory::GetForProfile(browser()->profile());
  }

  // Make account primary account with `consent_level` set and sets the account
  // name to `name`.
  AccountInfo MakePrimaryAccountAvailableWithName(
      signin::ConsentLevel consent_level,
      const std::u16string& email,
      const std::u16string& name) {
    AccountInfo account_info = signin::MakePrimaryAccountAvailable(
        GetIdentityManager(), base::UTF16ToUTF8(email), consent_level);
    EXPECT_FALSE(account_info.IsEmpty());

    account_info.given_name = base::UTF16ToUTF8(name);
    account_info.full_name = base::UTF16ToUTF8(name);
    account_info.picture_url = "SOME_FAKE_URL";
    account_info.hosted_domain = kNoHostedDomainFound;
    account_info.locale = "en";

    // Make sure account is valid so that all changes are persisted properly.
    CHECK(account_info.IsValid());

    signin::UpdateAccountInfoForAccount(GetIdentityManager(), account_info);

    return account_info;
  }

  // Signs in to Chrome with `email` and set the `name` to the account name.
  AccountInfo Signin(const std::u16string& email, const std::u16string& name) {
    return MakePrimaryAccountAvailableWithName(signin::ConsentLevel::kSignin,
                                               email, name);
  }

  // Make sure `image_url` is different for each new image in order for the
  // changes to reflect into the profile as well.
  void AddAccountImage(CoreAccountId account_id,
                       gfx::Image image,
                       const std::string& image_url) {
    signin::SimulateAccountImageFetch(GetIdentityManager(), account_id,
                                      image_url, image);
  }

  // Sets `kSignedInImage` by default as the account image.
  void AddSignedInImage(CoreAccountId account_id) {
    AddAccountImage(account_id, kSignedInImage, kSignedInImageUrl);
  }

  // Checks that the current image on the avtar button is the added account
  // image. Uses `kSignedInImage` by default.
  bool IsSignedInImageUsed(gfx::Image account_image = kSignedInImage) {
    AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
    gfx::Image current_avatar_icon = gfx::Image(
        avatar_button->GetImage(views::Button::ButtonState::STATE_NORMAL));
    gfx::Image adapted_signed_in_image = profiles::GetSizedAvatarIcon(
        account_image, avatar_button->GetIconSize(),
        avatar_button->GetIconSize(), profiles::SHAPE_CIRCLE);
    return gfx::test::AreImagesEqual(current_avatar_icon,
                                     adapted_signed_in_image);
  }

  // Sign in and wait for the name to stop showing.
  AccountInfo SigninAndWait(const std::u16string& email) {
    AccountInfo account_info = Signin(email, u"account_name");

    AvatarToolbarButtonTestObserver observer(GetAvatarToolbarButton(browser()));
    AddSignedInImage(account_info.account_id);
    observer.WaitForShowNameEnded();

    return account_info;
  }

#if !BUILDFLAG(IS_CHROMEOS)
  void Signout() {
    ASSERT_TRUE(
        GetIdentityManager()->HasPrimaryAccount(signin::ConsentLevel::kSignin));

    GetIdentityManager()->GetPrimaryAccountMutator()->ClearPrimaryAccount(
        signin_metrics::ProfileSignout::kTest);

    ASSERT_FALSE(
        GetIdentityManager()->HasPrimaryAccount(signin::ConsentLevel::kSignin));
  }
#endif

  void SimulateSigninError(bool web_sign_out) {
    ASSERT_TRUE(
        GetIdentityManager()->HasPrimaryAccount(signin::ConsentLevel::kSignin));

    signin_metrics::SourceForRefreshTokenOperation token_operation_source =
        web_sign_out ? signin_metrics::SourceForRefreshTokenOperation::
                           kDiceResponseHandler_Signout
                     : signin_metrics::SourceForRefreshTokenOperation::kUnknown;

    signin::SetInvalidRefreshTokenForPrimaryAccount(GetIdentityManager(),
                                                    token_operation_source);
  }

  void ClearSigninError() {
    ASSERT_TRUE(
        GetIdentityManager()->HasPrimaryAccount(signin::ConsentLevel::kSignin));

    signin::SetRefreshTokenForPrimaryAccount(GetIdentityManager());
  }

  // Enables sync for account with `email` and set the `name` to the account
  // name.
  AccountInfo EnableSync(const std::u16string& email,
                         const std::u16string name) {
    return MakePrimaryAccountAvailableWithName(signin::ConsentLevel::kSync,
                                               email, name);
  }

  // Enables Sync and Wait for the name to stop showing.
  AccountInfo EnableSyncAndWait(const std::u16string& email) {
    // Name does not matter here since we are waiting.
    AccountInfo account_info = EnableSync(email, u"account_name");

    AvatarToolbarButtonTestObserver observer(GetAvatarToolbarButton(browser()));
    AddSignedInImage(account_info.account_id);
    observer.WaitForShowNameEnded();

    return account_info;
  }

  void SimulateSyncPaused() {
    ASSERT_TRUE(
        GetIdentityManager()->HasPrimaryAccount(signin::ConsentLevel::kSync));

    // Simulates Sync Paused.
    GetTestSyncService()->SetPersistentAuthError();
    GetTestSyncService()->FireStateChanged();
  }

  void ClearSyncPaused() {
    ASSERT_TRUE(
        GetIdentityManager()->HasPrimaryAccount(signin::ConsentLevel::kSync));

    // Clear Sync Paused introduced in `SimulateSyncPaused()`.
    GetTestSyncService()->ClearAuthError();
    GetTestSyncService()->FireStateChanged();
  }

  void ExpectSyncPaused(AvatarToolbarButton* avatar_button) {
    EXPECT_EQ(avatar_button->GetText(), l10n_util::GetStringUTF16(
#if !BUILDFLAG(IS_CHROMEOS)
                                            IDS_AVATAR_BUTTON_SYNC_PAUSED
#else
                                            IDS_AVATAR_BUTTON_SYNC_ERROR
#endif
                                            ));
  }

  void SimulateSyncError() {
    ASSERT_TRUE(
        GetIdentityManager()->HasPrimaryAccount(signin::ConsentLevel::kSync));

    // Triggers Sync Error.
    GetTestSyncService()->SetTrustedVaultKeyRequired(true);
    GetTestSyncService()->SetHasSyncConsent(false);
    GetTestSyncService()->FireStateChanged();
  }

  void ClearSyncError() {
    ASSERT_TRUE(
        GetIdentityManager()->HasPrimaryAccount(signin::ConsentLevel::kSync));

    // Clear Sync Error introduces in `SimulateSyncError()`.
    GetTestSyncService()->SetTrustedVaultKeyRequired(false);
    GetTestSyncService()->SetHasSyncConsent(true);
    GetTestSyncService()->FireStateChanged();
  }

  // Waits for `time`.
  void WaitForTime(base::TimeDelta time) {
    base::RunLoop waiting_run_loop;
    base::OneShotTimer timer;
    timer.Start(FROM_HERE, time, waiting_run_loop.QuitClosure());
    waiting_run_loop.Run();
  }

 private:
  void SetTestingFactories(content::BrowserContext* context) {
    SyncServiceFactory::GetInstance()->SetTestingFactoryAndUse(
        context, base::BindRepeating(&TestingSyncFactoryFunction));
  }

  syncer::TestSyncService* GetTestSyncService() {
    return static_cast<syncer::TestSyncService*>(
        SyncServiceFactory::GetForProfile(browser()->profile()));
  }

  base::CallbackListSubscription dependency_manager_subscription_;
};

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, IncognitoWindowCount) {
  Profile* profile = browser()->profile();
  Browser* browser1 = CreateIncognitoBrowser(profile);
  AvatarToolbarButton* avatar_button1 = GetAvatarToolbarButton(browser1);
  EXPECT_TRUE(avatar_button1->GetEnabled());
  EXPECT_TRUE(avatar_button1->GetVisible());
  EXPECT_FALSE(GetWindowCountInAvatarButtonText(avatar_button1).has_value());

  Browser* browser2 = CreateIncognitoBrowser(profile);
  AvatarToolbarButton* avatar_button2 = GetAvatarToolbarButton(browser2);
  EXPECT_EQ(2, *GetWindowCountInAvatarButtonText(avatar_button1));
  EXPECT_EQ(2, *GetWindowCountInAvatarButtonText(avatar_button2));

  CloseBrowserSynchronously(browser2);
  EXPECT_FALSE(GetWindowCountInAvatarButtonText(avatar_button1).has_value());
}

#if !BUILDFLAG(IS_CHROMEOS_ASH)
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, GuestWindowCount) {
  Browser* browser1 = CreateGuestBrowser();
  AvatarToolbarButton* avatar_button1 = GetAvatarToolbarButton(browser1);
  EXPECT_TRUE(avatar_button1->GetEnabled());
  EXPECT_TRUE(avatar_button1->GetVisible());
  EXPECT_FALSE(GetWindowCountInAvatarButtonText(avatar_button1).has_value());

  Browser* browser2 = CreateGuestBrowser();
  AvatarToolbarButton* avatar_button2 = GetAvatarToolbarButton(browser2);
  EXPECT_EQ(2, *GetWindowCountInAvatarButtonText(avatar_button1));
  EXPECT_EQ(2, *GetWindowCountInAvatarButtonText(avatar_button2));

  CloseBrowserSynchronously(browser2);
  EXPECT_FALSE(GetWindowCountInAvatarButtonText(avatar_button1).has_value());
}
#endif

#if BUILDFLAG(IS_CHROMEOS_ASH)
class AvatarToolbarButtonAshBrowserTest
    : public AvatarToolbarButtonBrowserTest {
 protected:
  void SetUpCommandLine(base::CommandLine* command_line) override {
    // Adding these command lines simulates Ash in Guest mode.
    command_line->AppendSwitch(ash::switches::kGuestSession);
    command_line->AppendSwitchASCII(ash::switches::kLoginUser,
                                    user_manager::kGuestUserName);
    command_line->AppendSwitchASCII(ash::switches::kLoginProfile,
                                    TestingProfile::kTestUserProfileDir);
    command_line->AppendSwitch(switches::kIncognito);
  }
};

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonAshBrowserTest, GuestSession) {
  Profile* guest_profile = browser()->profile();
  ASSERT_TRUE(guest_profile->IsGuestSession());

  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  EXPECT_TRUE(avatar_button->GetVisible());
  EXPECT_FALSE(avatar_button->GetEnabled());

  EXPECT_EQ(avatar_button->GetText(),
            l10n_util::GetPluralStringFUTF16(IDS_AVATAR_BUTTON_GUEST, 1));

  Browser* browser_2 = CreateBrowser(guest_profile);
  AvatarToolbarButton* avatar_button_2 = GetAvatarToolbarButton(browser_2);
  EXPECT_TRUE(avatar_button_2->GetVisible());
  EXPECT_FALSE(avatar_button_2->GetEnabled());

  // Browser count is not taken into consideration on purpose for Ash Guest
  // windows since the button is not enabled, both buttons still show the same
  // text as if it was a single window, which is different from other platforms.
  EXPECT_EQ(avatar_button->GetText(),
            l10n_util::GetPluralStringFUTF16(IDS_AVATAR_BUTTON_GUEST, 1));
  EXPECT_EQ(avatar_button_2->GetText(),
            l10n_util::GetPluralStringFUTF16(IDS_AVATAR_BUTTON_GUEST, 1));
}
#endif

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, DefaultBrowser) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  ASSERT_TRUE(avatar);
#if BUILDFLAG(IS_CHROMEOS_ASH)
  // No avatar button is shown in normal Ash windows.
  EXPECT_FALSE(avatar->GetVisible());
#else
  EXPECT_TRUE(avatar->GetVisible());
  EXPECT_TRUE(avatar->GetEnabled());
#endif
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, IncognitoBrowser) {
  Browser* browser1 = CreateIncognitoBrowser(browser()->profile());
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser1);
  ASSERT_TRUE(avatar);
  // Incognito browsers always show an enabled avatar button.
  EXPECT_TRUE(avatar->GetVisible());
  EXPECT_TRUE(avatar->GetEnabled());
}

#if BUILDFLAG(IS_CHROMEOS)
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, SigninBrowser) {
  // Create an Incognito browser first.
  CreateIncognitoBrowser(browser()->profile());
  // Create a portal signin browser which will not be the Incognito browser.
  Profile::OTRProfileID profile_id(
      Profile::OTRProfileID::CreateUniqueForCaptivePortal());
  Browser* browser1 = Browser::Create(Browser::CreateParams(
      browser()->profile()->GetOffTheRecordProfile(profile_id,
                                                   /*create_if_needed=*/true),
      true));
  AddBlankTabAndShow(browser1);
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser1);
  ASSERT_TRUE(avatar);
  // On ChromeOS (Ash and Lacros), captive portal signin windows show a
  // disabled avatar button to indicate that the window is incognito.
  EXPECT_TRUE(avatar->GetVisible());
  EXPECT_FALSE(avatar->GetEnabled());
}
#endif

class AvatarToolbarButtonBrowserTestWithExplicitBrowserSignin
    : public base::test::WithFeatureOverride,
      public AvatarToolbarButtonBrowserTest {
 public:
  AvatarToolbarButtonBrowserTestWithExplicitBrowserSignin()
      : base::test::WithFeatureOverride(
            switches::kExplicitBrowserSigninUIOnDesktop) {}

  bool is_explicit_browser_signin() const { return IsParamFeatureEnabled(); }
};

// TODO(crbug/327688158): Flaky on chromium/ci/win-asan. Disable for Windows.
// TODO(b/331746545): Check windows issues with time duration/delays.
#if BUILDFLAG(IS_WIN)
#define MAYBE_ShowNameOnSignin_ThenSync DISABLED_ShowNameOnSignin_ThenSync
#else
#define MAYBE_ShowNameOnSignin_ThenSync ShowNameOnSignin_ThenSync
#endif
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonBrowserTestWithExplicitBrowserSignin,
                       MAYBE_ShowNameOnSignin_ThenSync) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  // Normal state.
  ASSERT_TRUE(avatar_button->GetText().empty());

  AvatarToolbarButtonTestObserver observer(avatar_button);
  std::u16string email(u"test@gmail.com");
  std::u16string name(u"TestName");
  AccountInfo account_info = Signin(email, name);
  // The button is in a waiting for image state, the name is not yet displayed.
  EXPECT_EQ(avatar_button->GetText(), std::u16string());

  // The greeting will only show when the image is loaded.
  AddSignedInImage(account_info.account_id);
  EXPECT_EQ(avatar_button->GetText(),
            is_explicit_browser_signin()
                ? l10n_util::GetStringFUTF16(IDS_AVATAR_BUTTON_GREETING, name)
                : name);

  observer.WaitForShowNameEnded();
  // Once the name is not shown anymore, we expect no text.
  EXPECT_EQ(avatar_button->GetText(), std::u16string());

  // Enabling Sync after already being signed in does not show the name again.
  EnableSync(email, name);
  EXPECT_EQ(avatar_button->GetText(), std::u16string());
}

// TODO(crbug/327688158): Flaky on chromium/ci/win-asan. Disable for Windows.
// TODO(b/331746545): Check windows issues with time duration/delays.
#if BUILDFLAG(IS_WIN)
#define MAYBE_ShowNameOnSync DISABLED_ShowNameOnSync
#else
#define MAYBE_ShowNameOnSync ShowNameOnSync
#endif
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonBrowserTestWithExplicitBrowserSignin,
                       MAYBE_ShowNameOnSync) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  // Normal state.
  ASSERT_TRUE(avatar_button->GetText().empty());

  AvatarToolbarButtonTestObserver observer(avatar_button);
  std::u16string email(u"test@gmail.com");
  std::u16string name(u"TestName");
  AccountInfo account_info = EnableSync(email, name);
  // The button is in a waiting for image state, the name is not yet displayed.
  EXPECT_EQ(avatar_button->GetText(), std::u16string());

  // The greeting will only show when the image is loaded.
  AddSignedInImage(account_info.account_id);
  EXPECT_EQ(avatar_button->GetText(),
            is_explicit_browser_signin()
                ? l10n_util::GetStringFUTF16(IDS_AVATAR_BUTTON_GREETING, name)
                : name);

  observer.WaitForShowNameEnded();
  // Once the name is not shown anymore, we expect no text.
  EXPECT_EQ(avatar_button->GetText(), std::u16string());
}

// Check www.crbug.com/331499330: This test makes sure that no states attempt to
// request an update during their construction. But rather do so after all the
// states are created and the view is added to the Widget.
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonBrowserTestWithExplicitBrowserSignin,
                       DISABLED_OpenNewBrowserWhileNameIsShown) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  // Normal state.
  ASSERT_TRUE(avatar_button->GetText().empty());

  std::u16string email(u"test@gmail.com");
  std::u16string name(u"TestName");
  AccountInfo account_info = Signin(email, name);
  // Make a second account available so that the name is shown on browser
  // startup.
  signin::MakeAccountAvailable(GetIdentityManager(), "test2@gmail.com");

  // The button is in a waiting for image state, the name is not yet displayed.
  EXPECT_EQ(avatar_button->GetText(), std::u16string());

  // The greeting will only show when the image is loaded.
  AddSignedInImage(account_info.account_id);
  EXPECT_EQ(avatar_button->GetText(),
            is_explicit_browser_signin()
                ? l10n_util::GetStringFUTF16(IDS_AVATAR_BUTTON_GREETING, name)
                : name);

  ASSERT_TRUE(GetIdentityManager()->AreRefreshTokensLoaded());
  // Increase the text duration length to accommodate for the browser creation
  // and the widget to be properly set.
  AvatarToolbarButton::SetTextDurationForTesting(base::Milliseconds(500));
  // Creating a new browser while the refresh tokens are already loaded and the
  // name showing should not break/crash.
  Browser* new_browser = CreateBrowser(browser()->profile());
  AvatarToolbarButton* new_avatar_button = GetAvatarToolbarButton(new_browser);
  // Name is expected to be shown while it is still shown on the first browser.
  EXPECT_EQ(new_avatar_button->GetText(), name);
}

INSTANTIATE_FEATURE_OVERRIDE_TEST_SUITE(
    AvatarToolbarButtonBrowserTestWithExplicitBrowserSignin);

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       DISABLED_ShowNameDoesNotAppearOnNewBrowserIfNotShowing) {
  // Name is shown and cleared after waiting.
  SigninAndWait(u"test@gmail.com");

  // Increase the text duration length to accommodate for the browser creation
  // and the widget to be properly set.
  AvatarToolbarButton::SetTextDurationForTesting(base::Milliseconds(500));
  Browser* new_browser = CreateBrowser(browser()->profile());
  AvatarToolbarButton* new_avatar_button = GetAvatarToolbarButton(new_browser);
  // Name is not expected to be shown since it was already shown and cleared on
  // the first browser.
  EXPECT_EQ(new_avatar_button->GetText(), std::u16string());
}

// TODO(crbug/327688158): Flaky on chromium/ci/win-asan. Disable for Windows.
// TODO(b/331746545): Check windows issues with time duration/delays.
#if BUILDFLAG(IS_WIN)
#define MAYBE_SyncPaused DISABLED_SyncPaused
#else
#define MAYBE_SyncPaused SyncPaused
#endif
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, MAYBE_SyncPaused) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  // Normal state.
  ASSERT_TRUE(avatar_button->GetText().empty());

  AccountInfo account_info = EnableSyncAndWait(u"test@gmail.com");
  SimulateSyncPaused();
  ExpectSyncPaused(avatar_button);

  ClearSyncPaused();
  EXPECT_EQ(avatar_button->GetText(), std::u16string());
}

// TODO(crbug/327688158): Flaky on chromium/ci/win-asan. Disable for Windows.
// TODO(b/331746545): Check windows issues with time duration/delays.
#if BUILDFLAG(IS_WIN)
#define MAYBE_SyncError DISABLED_SyncError
#else
#define MAYBE_SyncError SyncError
#endif
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, MAYBE_SyncError) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  // Normal state.
  ASSERT_TRUE(avatar_button->GetText().empty());

  EnableSyncAndWait(u"test@gmail.com");
  SimulateSyncError();
  EXPECT_EQ(avatar_button->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SYNC_ERROR));

  ClearSyncError();
  EXPECT_EQ(avatar_button->GetText(), std::u16string());
}

// Explicit text over sync paused/error.
// TODO(crbug/327688158): Flaky on chromium/ci/win-asan. Disable for Windows.
// TODO(b/331746545): Check windows issues with time duration/delays.
#if BUILDFLAG(IS_WIN)
#define MAYBE_SyncPausedThenExplicitText DISABLED_SyncPausedThenExplicitText
#else
#define MAYBE_SyncPausedThenExplicitText SyncPausedThenExplicitText
#endif
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       MAYBE_SyncPausedThenExplicitText) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  // Normal state.
  ASSERT_TRUE(avatar_button->GetText().empty());

  EnableSyncAndWait(u"test@gmail.com");
  SimulateSyncPaused();
  ExpectSyncPaused(avatar_button);

  std::u16string profile_switch_text(u"Profile Switch?");
  base::ScopedClosureRunner hide_callback =
      avatar_button->ShowExplicitText(profile_switch_text);
  EXPECT_EQ(avatar_button->GetText(), profile_switch_text);

  // Clearing explicit text should go back to Sync Pause.
  hide_callback.RunAndReset();
  ExpectSyncPaused(avatar_button);
}

// TODO(crbug/327688158): Flaky on chromium/ci/win-asan. Disable for Windows.
// TODO(b/331746545): Check windows issues with time duration/delays.
#if BUILDFLAG(IS_WIN)
#define MAYBE_ExplicitTextThenSyncPause DISABLED_ExplicitTextThenSyncPause
#else
#define MAYBE_ExplicitTextThenSyncPause ExplicitTextThenSyncPause
#endif
// Explicit text over sync paused/error.
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       MAYBE_ExplicitTextThenSyncPause) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  // Normal state.
  ASSERT_TRUE(avatar_button->GetText().empty());

  EnableSyncAndWait(u"test@gmail.com");
  std::u16string profile_switch_text(u"Profile Switch?");
  base::ScopedClosureRunner hide_callback =
      avatar_button->ShowExplicitText(profile_switch_text);
  EXPECT_EQ(avatar_button->GetText(), profile_switch_text);

  SimulateSyncPaused();
  // Explicit text should still be shown even if Sync is now Paused.
  EXPECT_EQ(avatar_button->GetText(), profile_switch_text);

  // Clearing explicit text should go back to Sync Pause.
  hide_callback.RunAndReset();
  ExpectSyncPaused(avatar_button);
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       ShowExplicitTextAndHide) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  ASSERT_EQ(avatar->GetText(), std::u16string());

  std::u16string new_text(u"Some New Text");
  base::ScopedClosureRunner hide_callback = avatar->ShowExplicitText(new_text);

  EXPECT_EQ(avatar->GetText(), new_text);
  hide_callback.RunAndReset();
  EXPECT_EQ(avatar->GetText(), std::u16string());
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       ShowExplicitTextAndDefaultHide) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  ASSERT_EQ(avatar->GetText(), std::u16string());

  // Simulates a stack that enforces the change of text, but never explicitly
  // call the hide callback. It should still be done on explicitly destroying
  // the caller.
  {
    std::u16string new_text(u"Some New Text");
    base::ScopedClosureRunner hide_callback =
        avatar->ShowExplicitText(new_text);
    EXPECT_EQ(avatar->GetText(), new_text);
  }

  EXPECT_EQ(avatar->GetText(), std::u16string());
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       ShowExplicitTextTwiceAndHide) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  ASSERT_EQ(avatar->GetText(), std::u16string());

  std::u16string initial_new_text(u"Some New Text");
  base::ScopedClosureRunner initial_hide_callback =
      avatar->ShowExplicitText(initial_new_text);

  EXPECT_EQ(avatar->GetText(), initial_new_text);

  std::u16string override_new_text(u"Some New Override Text");
  base::ScopedClosureRunner override_hide_callback =
      avatar->ShowExplicitText(override_new_text);

  EXPECT_EQ(avatar->GetText(), override_new_text);

  // Attempting to reset the initial text should have no effect.
  initial_hide_callback.RunAndReset();
  EXPECT_EQ(avatar->GetText(), override_new_text);

  // Resetting the last text should work fine.
  override_hide_callback.RunAndReset();
  EXPECT_EQ(avatar->GetText(), std::u16string());
}

// Avatar button is not shown on Ash. No need to perform those tests as the info
// checked might not be adapted.
#if !BUILDFLAG(IS_CHROMEOS_ASH)
// TODO(crbug/327688158): SignInOutIconEffect is flaky on Win10 Tests x64.
// Disable for Windows.
#if BUILDFLAG(IS_WIN)
#define MAYBE_SignInOutIconEffect DISABLED_SignInOutIconEffect
#else
#define MAYBE_SignInOutIconEffect SignInOutIconEffect
#endif
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       MAYBE_SignInOutIconEffect) {
  ASSERT_FALSE(IsSignedInImageUsed());

  SigninAndWait(u"test@gmail.com");
  EXPECT_TRUE(IsSignedInImageUsed());

#if !BUILDFLAG(IS_CHROMEOS)
  Signout();
  EXPECT_FALSE(IsSignedInImageUsed());
#endif
}

// TODO(crbug/330202396): Flaky on chromium/ci/win-asan. Disable for Windows.
// TODO(b/331746545): Check windows issues with time duration/delays.
#if BUILDFLAG(IS_WIN)
#define MAYBE_SignedInChangeIcon DISABLED_SignedInChangeIcon
#else
#define MAYBE_SignedInChangeIcon SignedInChangeIcon
#endif
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       MAYBE_SignedInChangeIcon) {
  ASSERT_FALSE(IsSignedInImageUsed());

  AccountInfo account_info = SigninAndWait(u"test@gmail.com");
  EXPECT_TRUE(IsSignedInImageUsed());

  // Same image but different color as `kSignedInImage`.
  gfx::Image updated_image = gfx::test::CreateImage(20, 20, SK_ColorGREEN);
  AddAccountImage(account_info.account_id, updated_image,
                  "UPDATED_IMAGE_FAKE_URL");

  EXPECT_TRUE(IsSignedInImageUsed(updated_image));
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       PRE_SignedInWithNewSessionKeepIcon) {
  ASSERT_FALSE(IsSignedInImageUsed());

  SigninAndWait(u"test@gmail.com");
  EXPECT_TRUE(IsSignedInImageUsed());
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       SignedInWithNewSessionKeepIcon) {
  signin::WaitForRefreshTokensLoaded(GetIdentityManager());
  ASSERT_TRUE(
      GetIdentityManager()->HasPrimaryAccount(signin::ConsentLevel::kSignin));
  // Previously added image on signin should still be shown in the new session.
  EXPECT_TRUE(IsSignedInImageUsed());
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, TooltipText) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  ASSERT_EQ(avatar->GetText(), std::u16string());

  const std::u16string account_name(u"Account name");
  AccountInfo account_info = Signin(u"test@gmail.com", account_name);
  AvatarToolbarButtonTestObserver observer(avatar);
  AddSignedInImage(account_info.account_id);

  EXPECT_EQ(avatar->GetTooltipText(gfx::Point()), account_name);

  observer.WaitForShowNameEnded();

  EXPECT_EQ(avatar->GetTooltipText(gfx::Point()), account_name);
}
#endif

// Test suite for testing `AvatarToolbarButton`'s responsibility of updating
// color information in `ProfileAttributesStorage`.
class AvatarToolbarButtonProfileColorBrowserTest
    : public AvatarToolbarButtonBrowserTest,
      public testing::WithParamInterface<ColorThemeType> {
 public:
  AvatarToolbarButtonProfileColorBrowserTest() {
    std::vector<base::test::FeatureRef> chrome_refresh_features = {
        features::kChromeRefresh2023};
    if (GetParam() == ColorThemeType::kUserColor) {
      scoped_feature_list_.InitWithFeatures(
          /*enabled_features=*/chrome_refresh_features,
          /*disabled_features=*/{});
    } else {
      scoped_feature_list_.InitWithFeatures(
          /*enabled_features=*/{},
          /*disabled_features=*/chrome_refresh_features);
    }
  }

  void SetUpOnMainThread() override {
    AvatarToolbarButtonBrowserTest::SetUpOnMainThread();
    theme_service(browser()->profile())
        ->SetBrowserColorScheme(ThemeService::BrowserColorScheme::kLight);
  }

  void SetColorTheme(Profile* profile, SkColor color) {
    ThemeService* service = theme_service(profile);
    switch (GetParam()) {
      case ColorThemeType::kAutogeneratedTheme:
        service->BuildAutogeneratedThemeFromColor(color);
        break;
      case ColorThemeType::kUserColor:
        service->SetUserColorAndBrowserColorVariant(color, kColorVariant);
        service->UseDeviceTheme(false);
        break;
    }
  }

  void SetDefaultTheme(Profile* profile) {
    ThemeService* service = theme_service(profile);
    switch (GetParam()) {
      case ColorThemeType::kAutogeneratedTheme:
        service->UseDefaultTheme();
        break;
      case ColorThemeType::kUserColor:
        service->SetUserColorAndBrowserColorVariant(SK_ColorTRANSPARENT,
                                                    kColorVariant);
        service->UseDeviceTheme(false);
        break;
    }
  }

  ThemeService* theme_service(Profile* profile) {
    return ThemeServiceFactory::GetForProfile(profile);
  }

  ProfileThemeColors ComputeProfileThemeColorsForBrowser(
      Browser* target_browser = nullptr) {
    target_browser = target_browser ? target_browser : browser();
    return GetCurrentProfileThemeColors(
        *target_browser->window()->GetColorProvider());
  }

 private:
  base::test::ScopedFeatureList scoped_feature_list_;
};

// Tests that the profile theme colors are updated when an autogenerated theme
// is set up.
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonProfileColorBrowserTest,
                       PRE_AutogeneratedTheme) {
  Profile* profile = browser()->profile();
  ProfileAttributesEntry* entry = GetProfileAttributesEntry(profile);
  SetDefaultTheme(profile);
  EXPECT_EQ(entry->GetProfileThemeColors(),
            ComputeProfileThemeColorsForBrowser());

  SetColorTheme(profile, SK_ColorGREEN);
  ProfileThemeColors theme_colors = entry->GetProfileThemeColors();
  EXPECT_EQ(theme_colors, ComputeProfileThemeColorsForBrowser());

  // Check that a switch to another autogenerated theme updates the colors.
  SetColorTheme(profile, SK_ColorMAGENTA);
  ProfileThemeColors theme_colors2 = entry->GetProfileThemeColors();
  EXPECT_NE(theme_colors, theme_colors2);
  EXPECT_NE(theme_colors2, GetDefaultProfileThemeColors());
  EXPECT_EQ(theme_colors2, ComputeProfileThemeColorsForBrowser());

  // Reset the cached colors to test that they're recreated on the next startup.
  entry->SetProfileThemeColors(std::nullopt);
  EXPECT_EQ(entry->GetProfileThemeColors(), GetDefaultProfileThemeColors());
}

// Tests that the profile theme colors are updated to reflect the autogenerated
// colors on startup.
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonProfileColorBrowserTest,
                       AutogeneratedTheme) {
  EXPECT_EQ(
      GetProfileAttributesEntry(browser()->profile())->GetProfileThemeColors(),
      ComputeProfileThemeColorsForBrowser());
}

// Tests that switching to the default theme updates profile colors.
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonProfileColorBrowserTest,
                       DefaultTheme) {
  Profile* profile = browser()->profile();
  ProfileAttributesEntry* entry = GetProfileAttributesEntry(profile);

  SetColorTheme(profile, SK_ColorGREEN);
  ProfileThemeColors theme_colors = entry->GetProfileThemeColors();
  EXPECT_EQ(theme_colors, ComputeProfileThemeColorsForBrowser());

  SetDefaultTheme(profile);
  ProfileThemeColors theme_colors2 = entry->GetProfileThemeColors();
  EXPECT_NE(theme_colors, theme_colors2);
  EXPECT_EQ(theme_colors2, ComputeProfileThemeColorsForBrowser());
}

// Tests that a theme is updated after opening a browser.
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonProfileColorBrowserTest,
                       UpdateThemeOnBrowserUpdate) {
  Profile* profile = browser()->profile();
  // Keeps the browser process and the profile alive while a browser window is
  // closed.
  ScopedKeepAlive keep_alive(KeepAliveOrigin::BROWSER,
                             KeepAliveRestartOption::DISABLED);
  ScopedProfileKeepAlive profile_keep_alive(
      profile, ProfileKeepAliveOrigin::kBackgroundMode);
  SetDefaultTheme(profile);
  ProfileAttributesEntry* entry = GetProfileAttributesEntry(profile);
  ProfileThemeColors theme_colors = entry->GetProfileThemeColors();
  CloseBrowserSynchronously(browser());

  SetColorTheme(profile, SK_ColorGREEN);
  // Colors haven't been changed yet because the profile has no active browsers.
  EXPECT_EQ(theme_colors, entry->GetProfileThemeColors());

  auto* target_browser = CreateBrowser(profile);
  ProfileThemeColors theme_colors2 = entry->GetProfileThemeColors();
  EXPECT_EQ(theme_colors2, ComputeProfileThemeColorsForBrowser(target_browser));
}

// Tests profile colors are updated when the browser's color scheme has changed.
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonProfileColorBrowserTest,
                       ProfileColorsUpdateOnColorSchemeChange) {
  theme_service(browser()->profile())
      ->SetBrowserColorScheme(ThemeService::BrowserColorScheme::kDark);
  Profile* profile = browser()->profile();
  ProfileAttributesEntry* entry = GetProfileAttributesEntry(profile);

  SetDefaultTheme(profile);
  ProfileThemeColors theme_colors = entry->GetProfileThemeColors();
  EXPECT_EQ(theme_colors, ComputeProfileThemeColorsForBrowser());

  theme_service(browser()->profile())
      ->SetBrowserColorScheme(ThemeService::BrowserColorScheme::kLight);
  ProfileThemeColors theme_colors2 = entry->GetProfileThemeColors();
  EXPECT_NE(theme_colors, theme_colors2);
  EXPECT_EQ(theme_colors2, ComputeProfileThemeColorsForBrowser());
}

INSTANTIATE_TEST_SUITE_P(,
                         AvatarToolbarButtonProfileColorBrowserTest,
                         testing::Values(ColorThemeType::kAutogeneratedTheme,
                                         ColorThemeType::kUserColor),
                         [](const auto& info) {
                           switch (info.param) {
                             case ColorThemeType::kAutogeneratedTheme:
                               return "AutogeneratedTheme";
                             case ColorThemeType::kUserColor:
                               return "UserColor";
                           }
                         });

#if BUILDFLAG(ENABLE_DICE_SUPPORT)
class AvatarToolbarButtonEnterpriseBadgingBrowserTest
    : public AvatarToolbarButtonBrowserTest {
 public:
  void EnableToolbarAvatarLabelByPolicy(bool transient) {
    policy::PolicyMap policies;
    policies.Set(policy::key::kToolbarAvatarLabelSettings,
                 policy::POLICY_LEVEL_MANDATORY, policy::POLICY_SCOPE_MACHINE,
                 policy::POLICY_SOURCE_CLOUD, base::Value(transient ? 1 : 0),
                 nullptr);
    provider_.UpdateChromePolicy(policies);
  }

  void SetPolicyLabelType(AvatarToolbarButton::ProfileLabelType label_type) {
    policy::PolicyMap policies;
    policies.Set(policy::key::kProfileLabel, policy::POLICY_LEVEL_MANDATORY,
                 policy::POLICY_SCOPE_USER, policy::POLICY_SOURCE_CLOUD,
                 base::Value(label_type), nullptr);
    provider_.UpdateChromePolicy(policies);
  }

  void SetUpInProcessBrowserTestFixture() override {
    provider_.SetDefaultReturns(
        true /* is_initialization_complete_return */,
        true /* is_first_policy_load_complete_return */);
    policy::BrowserPolicyConnector::SetPolicyProviderForTesting(&provider_);
  }

  void SetUpOnMainThread() override {
    // // Ensure enterprise badging can be shown.
    browser()->profile()->GetPrefs()->SetInteger(
        prefs::kEnterpriseBadgingTemporarySetting,
        chrome::enterprise_util::EnterpriseProfileBadgingTemporarySetting::
            kShowOnAllDevices);
    AvatarToolbarButtonBrowserTest::SetUpOnMainThread();
  }

 protected:
  testing::NiceMock<policy::MockConfigurationPolicyProvider> provider_;
  base::test::ScopedFeatureList scoped_feature_list_{
      features::kEnterpriseProfileBadging};
};

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       WorkProfileTextBadging) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  // Ensure enterprise badging can be shown.
  std::u16string work_label = u"Work";

  {
    chrome::enterprise_util::SetUserAcceptedAccountManagement(
        browser()->profile(), true);
    EXPECT_EQ(avatar_button->GetText(), work_label);
    auto clear_closure = avatar_button->ShowExplicitText(u"Explicit text");
    EXPECT_NE(avatar_button->GetText(), work_label);
    clear_closure.RunAndReset();
    EXPECT_EQ(avatar_button->GetText(), work_label);
  }

  {
    chrome::enterprise_util::SetUserAcceptedAccountManagement(
        browser()->profile(), false);
    EXPECT_NE(avatar_button->GetText(), work_label);
    auto clear_closure = avatar_button->ShowExplicitText(u"Explicit text");
    EXPECT_NE(avatar_button->GetText(), work_label);
    clear_closure.RunAndReset();
    EXPECT_NE(avatar_button->GetText(), work_label);
  }
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       WorkProfileTextBadgingUpdating) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  // Ensure enterprise badging can be shown.
  std::u16string work_label = u"Work";
  chrome::enterprise_util::SetUserAcceptedAccountManagement(
      browser()->profile(), true);
  EXPECT_EQ(avatar_button->GetText(), work_label);

  browser()->profile()->GetPrefs()->SetInteger(
      prefs::kEnterpriseBadgingTemporarySetting,
      chrome::enterprise_util::EnterpriseProfileBadgingTemporarySetting::kHide);
  EXPECT_NE(avatar_button->GetText(), work_label);

  browser()->profile()->GetPrefs()->SetInteger(
      prefs::kEnterpriseBadgingTemporarySetting,
      chrome::enterprise_util::EnterpriseProfileBadgingTemporarySetting::
          kShowOnAllDevices);

  EXPECT_EQ(avatar_button->GetText(), work_label);
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       WorkBadgeOnTransientModeTimesOut) {
  std::u16string work_label = u"Work";
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  AvatarToolbarButtonTestObserver observer(avatar_button);
  EnableToolbarAvatarLabelByPolicy(/*transient=*/true);
  chrome::enterprise_util::SetUserAcceptedAccountManagement(
      browser()->profile(), true);
  EXPECT_EQ(avatar_button->GetText(), work_label);

  observer.WaitForShowEnterpriseTextEnded();
  // After timeout the normal state is expect - no text.
  EXPECT_EQ(avatar_button->GetText(), std::u16string());
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       WorkBadgeOnTransientModeTimesOutToNonTransient) {
  std::u16string work_label = u"Work";
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  AvatarToolbarButtonTestObserver observer(avatar_button);
  EnableToolbarAvatarLabelByPolicy(/*transient=*/true);
  chrome::enterprise_util::SetUserAcceptedAccountManagement(
      browser()->profile(), true);
  EXPECT_EQ(avatar_button->GetText(), work_label);

  observer.WaitForShowEnterpriseTextEnded();
  // After timeout the normal state is expect - no text.
  EXPECT_EQ(avatar_button->GetText(), std::u16string());

  // Reset the policy to not be transient.
  EnableToolbarAvatarLabelByPolicy(/*transient=*/false);
  EXPECT_EQ(avatar_button->GetText(), work_label);

  // Reset the policy to be transient again.
  EnableToolbarAvatarLabelByPolicy(/*transient=*/true);
  EXPECT_EQ(avatar_button->GetText(), std::u16string());
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       WorkBadgeOnNonTransientModeDoesNotTimesOut) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  ASSERT_TRUE(avatar_button->GetText().empty());

  EnableToolbarAvatarLabelByPolicy(/*transient=*/false);

  std::u16string work_label = u"Work";
  chrome::enterprise_util::SetUserAcceptedAccountManagement(
      browser()->profile(), true);
  EXPECT_EQ(avatar_button->GetText(), work_label);

  // Simulate waiting for some time, twice the expected duration of showing the
  // badge in normal in transient mode.
  WaitForTime(2 * kTestingDuration);
  // Work label is still expected as it should be permanent.
  EXPECT_EQ(avatar_button->GetText(), work_label);
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       WorkBrowserShowsBadgeWithLabelPresets) {
  auto* prefs = browser()->profile()->GetPrefs();
  chrome::enterprise_util::SetUserAcceptedAccountManagement(
      browser()->profile(), true);
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());

  // Work label
  SetPolicyLabelType(AvatarToolbarButton::ProfileLabelType::kWork);
  EXPECT_EQ(avatar_button->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_WORK));
  prefs->SetString(prefs::kCustomProfileLabel, "Custom Label");
  EXPECT_EQ(avatar_button->GetText(), u"Custom Label");

  // School label
  prefs->ClearPref(prefs::kCustomProfileLabel);
  SetPolicyLabelType(AvatarToolbarButton::ProfileLabelType::kSchool);
  EXPECT_EQ(avatar_button->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SCHOOL));
  prefs->SetString(prefs::kCustomProfileLabel, "Custom Label");
  EXPECT_EQ(avatar_button->GetText(), u"Custom Label");
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       WorkNewBrowserShowsBadgeWithCustomLabel) {
  browser()->profile()->GetPrefs()->SetString(prefs::kCustomProfileLabel,
                                              "Custom Label");
  chrome::enterprise_util::SetUserAcceptedAccountManagement(
      browser()->profile(), true);

  Browser* second_browser = CreateBrowser(browser()->profile());
  AvatarToolbarButton* second_browser_avatar_button =
      GetAvatarToolbarButton(second_browser);
  EXPECT_EQ(second_browser_avatar_button->GetText(), u"Custom Label");

  browser()->profile()->GetPrefs()->SetString(prefs::kCustomProfileLabel,
                                              "Updated Label");
  EXPECT_EQ(second_browser_avatar_button->GetText(), u"Updated Label");
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       WorkNewBrowserShowsBadge) {
  std::u16string work_label = u"Work";
  chrome::enterprise_util::SetUserAcceptedAccountManagement(
      browser()->profile(), true);

  Browser* second_browser = CreateBrowser(browser()->profile());
  AvatarToolbarButton* second_browser_avatar_button =
      GetAvatarToolbarButton(second_browser);
  EXPECT_EQ(second_browser_avatar_button->GetText(), work_label);
}

// Sync Pause/Error has priority over WorkBadge.
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       WorkBadgeNonTransientModeAndSyncPause) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  ASSERT_TRUE(avatar_button->GetText().empty());

  EnableToolbarAvatarLabelByPolicy(/*transient=*/false);
  std::u16string work_label = u"Work";
  chrome::enterprise_util::SetUserAcceptedAccountManagement(
      browser()->profile(), true);
  EXPECT_EQ(avatar_button->GetText(), work_label);

  EnableSyncAndWait(u"work@managed.com");
  SimulateSyncPaused();
  // Sync Paused has priority over the Work badge.
  ExpectSyncPaused(avatar_button);

  ClearSyncPaused();
  // Non transient mode should permanently show the work badge by default.
  // TODO(b/324018028): This test result might change with the ongoing changes.
  // At the end, the exact behavior could be set again. To review.
  EXPECT_EQ(avatar_button->GetText(), work_label);
}

// Sync Pause/Error has priority over WorkBadge.
// TODO(crbug/330202396): Flaky on chromium/ci/win-asan. Disable for Windows.
// TODO(b/331746545): Check windows issues with time duration/delays.
#if BUILDFLAG(IS_WIN)
#define MAYBE_WorkBadgeTransientModeAndSyncPause \
  DISABLED_WorkBadgeTransientModeAndSyncPause
#else
#define MAYBE_WorkBadgeTransientModeAndSyncPause \
  WorkBadgeTransientModeAndSyncPause
#endif
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       MAYBE_WorkBadgeTransientModeAndSyncPause) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  ASSERT_TRUE(avatar_button->GetText().empty());

  EnableSyncAndWait(u"work@managed.com");

  EnableToolbarAvatarLabelByPolicy(/*transient=*/true);
  std::u16string work_label = u"Work";
  AvatarToolbarButtonTestObserver observer(avatar_button);
  chrome::enterprise_util::SetUserAcceptedAccountManagement(
      browser()->profile(), true);
  EXPECT_EQ(avatar_button->GetText(), work_label);

  SimulateSyncPaused();
  // Sync Paused has priority over the Work badge.
  ExpectSyncPaused(avatar_button);

  observer.WaitForShowEnterpriseTextEnded();
  // Sync paused is still shown.
  ExpectSyncPaused(avatar_button);

  ClearSyncPaused();
  EXPECT_EQ(avatar_button->GetText(), std::u16string());
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       DecliningManagementShouldRemoveWorkBadge) {
  AvatarToolbarButton* avatar_button = GetAvatarToolbarButton(browser());
  ASSERT_TRUE(avatar_button->GetText().empty());

  EnableToolbarAvatarLabelByPolicy(/*transient=*/false);
  std::u16string work_label = u"Work";
  chrome::enterprise_util::SetUserAcceptedAccountManagement(
      browser()->profile(), true);
  EXPECT_EQ(avatar_button->GetText(), work_label);

  chrome::enterprise_util::SetUserAcceptedAccountManagement(
      browser()->profile(), false);
  EXPECT_EQ(avatar_button->GetText(), std::u16string());
}

class AvatarToolbarButtonWithExplicitBrowserSigninBrowserTest
    : public AvatarToolbarButtonBrowserTest {
 private:
  base::test::ScopedFeatureList scoped_feature_list_{
      switches::kExplicitBrowserSigninUIOnDesktop};
};

// TODO(b/331746545): The delay enforced in tests seems not to be enough for
// windows bots causing falkiness in tests running on Windows. Investigate how
// to fix this, or if it is feasible not to test on windows.
#if !BUILDFLAG(IS_WIN)
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonWithExplicitBrowserSigninBrowserTest,
                       SigninPausedFromExternalError_ThenReauth) {
  SigninAndWait(u"test@gmail.com");

  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  ASSERT_EQ(avatar->GetText(), std::u16string());

  // Browser opened before the error.
  Browser* opened_browser = CreateBrowser(browser()->profile());
  AvatarToolbarButton* opened_browser_avatar_button =
      GetAvatarToolbarButton(opened_browser);
  ASSERT_EQ(opened_browser_avatar_button->GetText(), std::u16string());

  SimulateSigninError(/*web_sign_out=*/false);
  EXPECT_EQ(avatar->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SIGNIN_PAUSED));
  EXPECT_EQ(opened_browser_avatar_button->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SIGNIN_PAUSED));

  // New browser opened after the error -- error should be shown directly.
  Browser* new_browser = CreateBrowser(browser()->profile());
  AvatarToolbarButton* new_browser_avatar_button =
      GetAvatarToolbarButton(new_browser);
  EXPECT_EQ(new_browser_avatar_button->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SIGNIN_PAUSED));

  ClearSigninError();
  EXPECT_EQ(avatar->GetText(), std::u16string());
  EXPECT_EQ(opened_browser_avatar_button->GetText(), std::u16string());
  EXPECT_EQ(new_browser_avatar_button->GetText(), std::u16string());
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonWithExplicitBrowserSigninBrowserTest,
                       DISABLED_SigninPausedFromWebSignout) {
  SigninAndWait(u"test@gmail.com");

  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  AvatarToolbarButtonTestObserver observer(avatar);
  ASSERT_EQ(avatar->GetText(), std::u16string());

  // Browser opened before the error.
  Browser* opened_browser = CreateBrowser(browser()->profile());
  AvatarToolbarButton* opened_browser_avatar_button =
      GetAvatarToolbarButton(opened_browser);
  ASSERT_EQ(opened_browser_avatar_button->GetText(), std::u16string());

  // Increase the delay to accommodate for a new browser creation in the test.
  AvatarToolbarButton::SetTextDurationForTesting(base::Milliseconds(300));
  SimulateSigninError(/*web_sign_out=*/true);
  // Text does not appear directly after a web sign out, a timer is started.
  EXPECT_EQ(avatar->GetText(), std::u16string());
  EXPECT_EQ(opened_browser_avatar_button->GetText(), std::u16string());

  // New browser opened after the error and before timer ends -- error is not
  // shown directly.
  Browser* new_browser = CreateBrowser(browser()->profile());
  AvatarToolbarButton* new_browser_avatar_button =
      GetAvatarToolbarButton(new_browser);
  EXPECT_EQ(new_browser_avatar_button->GetText(), std::u16string());

  ASSERT_FALSE(observer.IsShowSigninPausedDelayEnded());

  // On time delay end, the error should be displayed on all browsers.
  observer.WaitForShowSigninPausedDelayEnded();
  // Add a small delay to make sure that all buttons are notified.
  WaitForTime(base::Milliseconds(10));
  EXPECT_EQ(avatar->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SIGNIN_PAUSED));
  EXPECT_EQ(opened_browser_avatar_button->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SIGNIN_PAUSED));
  EXPECT_EQ(new_browser_avatar_button->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SIGNIN_PAUSED));

  ClearSigninError();
  EXPECT_EQ(avatar->GetText(), std::u16string());
  EXPECT_EQ(opened_browser_avatar_button->GetText(), std::u16string());
  EXPECT_EQ(new_browser_avatar_button->GetText(), std::u16string());
}

// The purpose of this test is to make sure that when a user first signs out of
// the web, and then signs back in prior to the signin paused error text being
// shown, doing a second web sign out will trigger a new error delay and not
// rely on the first triggered that potentially reached after the second sign
// out.
IN_PROC_BROWSER_TEST_F(
    AvatarToolbarButtonWithExplicitBrowserSigninBrowserTest,
    DISABLED_SigninPausedFromWebSignout_ThenSigninAndSignoutAgain) {
  SigninAndWait(u"test@gmail.com");

  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  ASSERT_EQ(avatar->GetText(), std::u16string());

  base::Time first_error_time = base::Time::Now();
  base::TimeDelta test_error_delay = base::Milliseconds(100);
  AvatarToolbarButton::SetTextDurationForTesting(test_error_delay);
  SimulateSigninError(/*web_sign_out=*/true);
  EXPECT_EQ(avatar->GetText(), std::u16string());

  ClearSigninError();
  // Error should not be shown since the error is fixed.
  EXPECT_EQ(avatar->GetText(), std::u16string());

  // Wait for some time to create a forced delay between the two sign outs.
  WaitForTime(base::Milliseconds(10));

  base::Time second_error_time = base::Time::Now();
  // Simulate second error within the first error time delay.
  AvatarToolbarButtonTestObserver second_observer(avatar);
  SimulateSigninError(/*web_sign_out=*/true);
  // Error should still not be shown after a second error yet.
  EXPECT_EQ(avatar->GetText(), std::u16string());

  base::TimeDelta first_elapsed_time = base::Time::Now() - first_error_time;
  ASSERT_LT(first_elapsed_time, test_error_delay);

  // Wait for slightly more than the expected first error time out to make it
  // did not affect (error text still not shown), but less than the second timer
  // timeout (that should trigger the text error to be displayed).
  WaitForTime(test_error_delay - first_elapsed_time + base::Milliseconds(2));
  // Assert that the first time error time out has reached.
  ASSERT_GT(base::Time::Now() - first_error_time, test_error_delay);
  // Make sure first timer timing out (+ buffer time) does not trigger error
  // text yet.
  EXPECT_EQ(avatar->GetText(), std::u16string());
  base::TimeDelta second_elapsed_time = base::Time::Now() - second_error_time;
  // Make sure that the elapsed time is less than the time for the second error
  // timer to reach so that the above test on the avatar text is accurate.
  ASSERT_LT(second_elapsed_time, test_error_delay);

  // We should finally see the text after the second error delayed passed.
  second_observer.WaitForShowSigninPausedDelayEnded();
  EXPECT_EQ(avatar->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SIGNIN_PAUSED));
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonWithExplicitBrowserSigninBrowserTest,
                       DISABLED_SigninPausedFromWebSignoutThenRestartChrome) {
  // Needed because the current profile will be destroyed.
  ScopedKeepAlive keep_alive(KeepAliveOrigin::SESSION_RESTORE,
                             KeepAliveRestartOption::DISABLED);

  SigninAndWait(u"test@gmail.com");

  // `max_time` is used as the delay for the error text to show. In order for
  // this test to be successful and meaningful, the test should finish before
  // this time to make sure the error text does not appear because of the timer
  // finishing, which is not the purpose of the test.
  base::TimeDelta max_time = base::Seconds(5);
  base::Time time_of_error = base::Time::Now();
  // We can set a relativley high testing time since we do not expect to reach
  // it. If we do, the test would probably fail.
  AvatarToolbarButton::SetTextDurationForTesting(max_time);

  SimulateSigninError(/*web_sign_out=*/true);
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  ASSERT_EQ(avatar->GetText(), std::u16string());

  ProfileDestructionWaiter destruction_waiter(browser()->profile());
  // Closing the browser will destroy profile from the memory.
  CloseAllBrowsers();
  destruction_waiter.Wait();

  // Load the profile again to open a new browser and check the butto state.
  Profile* loaded_profile = ProfileLoader().LoadFirstAndOnlyProfile();
  Browser* new_browser = CreateBrowser(loaded_profile);
  AvatarToolbarButton* new_avatar = GetAvatarToolbarButton(new_browser);
  // The error text is expected to be shown even if the error delay has not
  // reached yet.
  EXPECT_EQ(new_avatar->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SIGNIN_PAUSED));
  // Make sure the elapsted time is less than `max_time` to make sure the test
  // is meaningful.
  ASSERT_LT(base::Time::Now() - time_of_error, max_time);
}

#endif  // !BUILDFLAG(IS_WIN)

// TODO(b/335775210): Flaky on win-asan and Win10 Tests x64
#if BUILDFLAG(IS_WIN)
#define MAYBE_SigninPaused_ThenSignout DISABLED_SigninPaused_ThenSignout
#else
#define MAYBE_SigninPaused_ThenSignout SigninPaused_ThenSignout
#endif
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonWithExplicitBrowserSigninBrowserTest,
                       MAYBE_SigninPaused_ThenSignout) {
  SigninAndWait(u"test@gmail.com");

  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  ASSERT_EQ(avatar->GetText(), std::u16string());

  SimulateSigninError(/*web_sign_out=*/false);

  EXPECT_EQ(avatar->GetText(),
            l10n_util::GetStringUTF16(IDS_AVATAR_BUTTON_SIGNIN_PAUSED));

  Signout();

  EXPECT_EQ(avatar->GetText(), std::u16string());
}

#endif  // BUILDFLAG(ENABLE_DICE_SUPPORT)
