name: 'Gemini Commit Message Generator'

# 1. New Trigger Logic
# This workflow is now triggered when a new Pull Request is opened/reopened,
# or when a new comment is created on a Pull Request.
on:
  pull_request:
    types: [opened, reopened, synchronize]
  issue_comment:
    types: [created]

# This block defines the job that will run.
jobs:
  generate_commit_message:
    # New Condition:
    # The job runs if:
    # 1. The event is a 'pull_request' (opened/reopened).
    # 2. OR the event is an 'issue_comment' AND the comment body is '/generate-commit-message'.
    if: >
      github.event_name == 'pull_request' ||
      (github.event_name == 'issue_comment' && github.event.issue.pull_request && github.event.comment.body == '/generate-commit-message')

    # The workflow will run on the latest version of Ubuntu.
    runs-on: ubuntu-latest

    # We need to grant the workflow permission to write comments on pull requests.
    permissions:
      issues: write
      pull-requests: write

    steps:
      # --- Step 1: Get PR Details (Modified to handle both pull_request and issue_comment events) ---
      - name: 'Set PR Details'
        id: pr_details
        run: |
          set -eux

          # 1. SIMPLE VALUES (Number, URL)
          # We do NOT use toJson() here to avoid issues with quotes in URLs.
          # These values are system-generated and safe from injection.

          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "PR_NUMBER=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            echo "PR_URL=${{ github.event.pull_request.url }}" >> $GITHUB_OUTPUT
            echo "PR_HTML_URL=${{ github.event.pull_request.html_url }}" >> $GITHUB_OUTPUT
          else
            echo "PR_NUMBER=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
            echo "PR_URL=${{ github.event.issue.pull_request.url }}" >> $GITHUB_OUTPUT
            echo "PR_HTML_URL=${{ github.event.issue.html_url }}" >> $GITHUB_OUTPUT
          fi

          # 2. UNTRUSTED STRINGS (Title, Body)
          # We MUST use toJson() here to satisfy the security scanner and prevent script injection.
          # The quotes added by toJson() are handled correctly by the shell echo command.

          echo "PR_TITLE<<EOF" >> $GITHUB_OUTPUT
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "${{ github.event.pull_request.title | toJson }}" >> $GITHUB_OUTPUT
          else
            echo "${{ github.event.issue.title | toJson }}" >> $GITHUB_OUTPUT
          fi
          echo "EOF" >> $GITHUB_OUTPUT

          echo "PR_BODY<<EOF" >> $GITHUB_OUTPUT
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "${{ github.event.pull_request.body | toJson }}" >> $GITHUB_OUTPUT
          else
            echo "${{ github.event.issue.body | toJson }}" >> $GITHUB_OUTPUT
          fi
          echo "EOF" >> $GITHUB_OUTPUT

      # Step 2: Get the code changes (the "diff") from the pull request.
      - name: 'Get PR Diff'
        id: diff
        # Use the PR_URL from the previous step.
        run: |
          set -eux
          # Fetch the diff content directly from the PR's diff URL.
          diff_content=$(curl -fsSL -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -H "Accept: application/vnd.github.v3.diff" ${{ steps.pr_details.outputs.PR_URL }})

          # The following lines save the diff content into a GitHub Actions output variable.
          echo "diff_content<<EOF" >> $GITHUB_OUTPUT
          echo "$diff_content" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Step 3: Call the Gemini API directly with a detailed prompt.
      - name: 'Generate Commit Message with Gemini'
        id: gemini
        env:
          # Store the multiline prompt in an environment variable to handle special characters safely.
          PROMPT: |
            Act as an expert software engineer specializing in the Cobalt codebase, which is a fork of Chromium. Your task is to generate a professional and informative Git commit message based on the provided pull request details. The final output should be only the commit message itself, without any extra conversational text or markdown formatting. Do not use backticks (`) in your response.

            You must strictly adhere to the following rules:

            **Commit Message Structure:**
            1.  **Tag Prefix:** The subject line MUST be prefixed with a tag followed by a colon (e.g., "media: Add support for AV1"). Prefer component tags over type tags.
            2.  **Subject:** Capitalize the subject line, use the imperative mood, limit it to 50 characters, and do not end it with a period.
            3.  **Body:** Separate the subject from the body with a blank line. The body should explain the 'what' and 'why' of the change, not the 'how', and wrap at 72 characters.

            **Tag Selection (Prefix the subject line with one of these):**
            * **Component Tags (Preferred):**
                * `android`: Android-specific changes.
                * `tvos`: tvOS-specific changes.
                * `build`: Changes to the build system (GN files, build scripts).
                * `cobalt`: Changes specific to the Cobalt browser logic.
                * `evergreen`: For Evergreen-specific changes.
                * `linux`: Linux-specific changes.
                * `media`: Changes related to the media pipeline (player, demuxer, etc.).
                * `net`: For networking changes (e.g., QUIC, sockets).
                * `posix`: POSIX-related changes.
                * `starboard`: Changes to the Starboard abstraction layer.
            * **Type Tags (Use if no component tag applies):**
                * `ci`: Changes to CI/CD workflows.
                * `cleanup`: Code cleanup (e.g., removing unused code, style fixes).
                * `docs`: Documentation updates.
                * `feat`: A new feature.
                * `fix`: A bug fix.
                * `refactor`: Code refactoring without changing functionality.
                * `revert`: Reverting a previous commit.
                * `test`: For changes to tests (e.g., nplb, unit tests).

            Given your expertise with Cobalt/Chromium, infer the context of the changes to select the most relevant tag.

            **Analyze the following pull request information and generate the commit message:**

            **Pull Request URL:** ${{ steps.pr_details.outputs.PR_HTML_URL }}
            **Pull Request Title:** ${{ steps.pr_details.outputs.PR_TITLE }}
            **Original PR Description:**
            ${{ steps.pr_details.outputs.PR_BODY }}

            **Code Diff to Analyze:**
            ${{ steps.diff.outputs.diff_content }}
        run: |
          set -eux
          # Use jq to safely construct the JSON payload, reading the prompt from the environment variable.
          json_payload=$(jq -n --arg prompt "$PROMPT" '{ "contents": [ { "parts": [ { "text": $prompt } ] } ] }')

          api_response=$(curl -s -X POST \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent" \
            -H "Content-Type: application/json" \
            -H "x-goog-api-key: ${{ secrets.GEMINI_ACTIONS_API_KEY }}" \
            -d "$json_payload")

          # Extract only the text content from the API's JSON response using jq.
          # The 'jq -r' command outputs the raw string without quotes.
          # The fallback message provides clearer error handling if the response is unexpected.
          gemini_text_response=$(echo "$api_response" | jq -r '.candidates[0].content.parts[0].text // "Error: Could not parse a valid response from the Gemini API. Please check the API response logs in the workflow run."')

          # Set the final text as an output variable for the next step to use.
          echo "response<<EOF" >> $GITHUB_OUTPUT
          echo "$gemini_text_response" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # 4. Modified Step 4: Post Commit Message as Comment
      # This step now includes helpful suggestions for the PR author.
      - name: 'Post Commit Message as Comment'
        uses: actions/github-script@v7
        env:
          COMMENT_BODY: |
            ### ðŸ¤– Gemini Suggested Commit Message

            ---

            ```
            ${{ steps.gemini.outputs.response }}
            ```

            ---

            **ðŸ’¡ Pro Tips for a Better Commit Message:**

            1.  **Influence the Result:** The commit message quality is highly dependent on the information provided.
                * To get a better result, add more **contextual details** to the **Pull Request description**. The model analyzes the description and the code diff to generate the message.
            2.  **Re-run the Generator:** If you update the code or the PR description, you can easily re-run this generation by posting a new comment with the exact text:
                * `/generate-commit-message`
        with:
          script: |
            const body = process.env.COMMENT_BODY;
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.pr_details.outputs.PR_NUMBER }},
              body: body
            });
