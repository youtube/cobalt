/* Copyright 2025 The Chromium Authors
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file. */

/* #css_wrapper_metadata_start
 * #type=style-lit
 * #scheme=relative
 * #css_wrapper_metadata_end */

:host {
  --drag-placeholder-font-color: rgba(86, 89, 94, 1);
  --drag-placeholder-font-family: inherit;
  --drag-placeholder-line-height: 24px;
  --drag-placeholder-font-size: 16px;

  --end-angle-expand_: 245deg;
  --end-angle-listen_: 210deg;
  --end-angle-submit_: 330deg;

  --expand-timing_: var(--glif-rotation-duration_)
      var(--standard-curve, --search-animated-glow-standard-curve);

  /* All gradient rotation and background blur/border shrinking needs to be at
   * interval, otherwise border-radius due to border width
   * may not be at right size at right time. */
  --glif-rotation-duration_: var(--search-animated-glif-rotation-duration,
      2s);

  --glow-stroke-width_: 2px;

  --search-animated-glow-background: rgb(255, 255, 255);
  --search-animated-glow-background-z-index: 103;
  --search-animated-glow-drag-drop-placeholder-z-index: 104;
  --search-animated-glow-gradient-after-z-index: 101;
  --search-animated-glow-gradient-z-index: 102;
  --search-animated-glow-brand-gradient: conic-gradient(
    rgba(52, 168, 82, 0) 0deg,
    rgba(52, 168, 82, 1) 38.9738deg,
    rgba(255, 211, 20, 1) 62.3678deg,
    rgba(255, 70, 65, 1) 87.0062deg,
    rgba(49, 134, 255, 1) 107.428deg,
    rgba(49, 134, 255, 0.5) 204.48deg,
    rgba(49, 134, 255, 0) 308.88deg,
    rgba(52, 168, 82, 0) 360deg
  );

  --search-animated-glow-gradient-curve: cubic-bezier(0.2, 0, 0, 1);

  /* Expand duration and standard curve vars
   * are taken from parent, if any; otherwise use default here. */
  --search-animated-glow-expand-duration: 600ms;
  --search-animated-glow-standard-curve: cubic-bezier(0.4, 0, 0.2, 1);

  --start-angle-expand_: 30deg;
  --start-angle-submit_: 200deg;
  --start-angle-listen_: 35deg;
  border-radius: inherit;
}

#dragDropPlaceholder {
  color: var(--drag-placeholder-font-color);
  display: none;
  font-family: var(--drag-placeholder-font-family);
  font-size: var(--drag-placeholder-font-size);
  left: 20px;
  line-height: var(--drag-placeholder-line-height);
  opacity: 0;
  pointer-events: none;
  position: absolute;
  /* Top var defined by whoever uses this parent; default: 21px. */
  top: var(--search-animated-glow-drag-drop-placeholder-top, 21px);
  transition: opacity 300ms;
}

:host([animation-state='dragging']) #dragDropPlaceholder {
  display: block;
  opacity: 1;
  z-index: var(--search-animated-glow-drag-drop-placeholder-z-index, 4);
}

.gradient, .double-gradient, .double-gradient-mask {
  border-radius: inherit;
  contain: paint;
  inset: 0;
  position: absolute;
}

:host([animation-state='expanding']) .gradient.gradient-outer-glow {
  /* Standard-curve can be defined by parent; otherwise use default. */
  animation: blur-expand var(--expand-timing_)
}

@keyframes blur-expand {
  17% {
    filter: blur(30px);
    opacity: 17.5%;
  }
}

.gradient::before, .double-gradient::before {
  /*
  * The actual gradient border and inner glow. In
  * its raw form without .background's effects, it's a
  * colored pinwheel circle. 2 gradients so the effect is brighter,
  * but only for dragging animation (not needed for others).
  */
  aspect-ratio: 1 / 1; /* Square shape. */
  background: var(--search-animated-glow-brand-gradient);
  /* 50% == circle, so it looks like it isn't moving when rotating. */
  border-radius: 50%;
  contain: paint;
  content: '';
  height: auto; /* Controlled by aspect-ratio. */
  left: 50%;
  opacity: 0;
  position: absolute;
  rotate: 0deg;
  /*
  * Scale squashes the gradient vertically so its middle is not shown,
  * making it a glow, not a pinwheel. Too much, and it will be too
  * tall of a glow.
  */
  scale: 1 0.6;
  top: 50%;
  translate: -50% -50%;
  /*
   * Hypotenuse rule - for rotating circle to be as wide as composebox
   * (which is a rectangle) is at all points, its width and height must
   *  be >= diagonal of composebox. Thus, use width of 145%
   * (height set by aspect ratio) since sqrt(2) = ~141%.
   * Take triangle half of rectangle composebox to find diagonal:
   * a^2 + b^2 = c^2 -> c = sqrt(a^2 + b^2). Let x be max(a,b) via cqmax.
   * sqrt(2x^2) -> 141% of max of container (x). Chose 145% for slight buffer.
   * Take max of either height or width of parent (outer box). In this case,
   * it must be width given all searchboxes are wider than tall. Therefore, let
   * x = parent width in this case. Could try to use cqMax, but will fail debug
   * check due to asking for element attributes that do not exist yet.
   * ***IMPORTANT***: Swap height and width definitions in this class
   * if your height is bigger than width in the searchbox.
  */
  width: 145%;
}

:host([entrypoint-name='Omnibox'][animation-state='expanding']) .double-gradient::before,
:host(:not([entrypoint-name='Omnibox'])[animation-state='expanding']) .gradient::before {
  animation: gradient-spin-expand var(--glif-rotation-duration_)
    var(--search-animated-glow-gradient-curve) forwards;
}

:host([entrypoint-name='Omnibox'][animation-state='expanding']) .gradient::before {
   --gradient-spin-expand-peak-opacity_: 0.4;
  animation: gradient-spin-expand var(--glif-rotation-duration_)
    var(--search-animated-glow-gradient-curve) forwards;
}

@media (prefers-color-scheme: dark) {
  :host([entrypoint-name='Omnibox'][animation-state='expanding']) .gradient::before {
    --gradient-spin-expand-peak-opacity_: 0.3;
  }
}

:host([entrypoint-name='Omnibox'][animation-state='expanding']) .background,
:host([entrypoint-name='Omnibox'][animation-state='expanding']) .gradient {
  border: var(--glow-stroke-width_) solid transparent;
}

:host([animation-state='dragging']) .gradient,
:host(:not([entrypoint-name='Omnibox'])) .double-gradient {
  pointer-events: none;
  z-index: var(--search-animated-glow-gradient-z-index, 2);
}

:host([animation-state='listening']) {
  --search-animated-glif-rotation-duration: 1.5s;
}

:host([animation-state='listening']) .gradient::before {
  animation: gradient-spin-listen var(--glif-rotation-duration_)
    var(--search-animated-glow-gradient-curve) forwards;
}

:host([animation-state='dragging']) .gradient::before,
:host([animation-state='dragging']) .double-gradient::before {
  animation: ambient-spin 6s linear infinite;
  filter: blur(20px);
  opacity: 1;
  scale: 1 0.8;
  z-index: var(--search-animated-glow-gradient-z-index, 2);
}

:host([animation-state='submitting']) .gradient::before,
:host([animation-state='submitting']) .gradient.gradient-outer-glow::before {
  animation: gradient-spin-submit var(--glif-rotation-duration_)
    var(--search-animated-glow-gradient-curve) forwards;
}

:host([animation-state='submitting']) .gradient.gradient-outer-glow {
  animation: blur-close var(--glif-rotation-duration_)
    var(--search-animated-glow-gradient-curve);
}

.gradient::after {
  /*
  * Deepest backdrop, behind .gradient, to block input text
  * in dragging mode.
  */
  background-color: var(--cr-composebox-background-color,
      --search-animated-glow-background);
  border-radius: inherit;
  content: '';
  inset: 0px;
  opacity: 0;
  pointer-events: none;
  position: absolute;
  transition: opacity 500ms;
  z-index: var(--search-animated-glow-gradient-after-z-index, 1);
}

:host([animation-state='dragging']) .gradient::after {
  opacity: 1;
}

@keyframes ambient-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@keyframes blur-close {
  17% {
    filter: blur(30px);
    opacity: 17.5%;
  }
}

@keyframes gradient-spin-expand {
  0% {
    opacity: 0;
    transform: rotate(var(--start-angle-expand_));
  }
  17% {
    opacity: var(--gradient-spin-expand-peak-opacity_, 1);
  }
  100% {
    opacity: 0;
    transform: rotate(var(--end-angle-expand_));
  }
}

/* So can go from "expanding" to "submit" and still trigger gradient-spin
 * (same animation not run twice unless it's a new animation or class). */
@keyframes gradient-spin-submit {
  0% {
    opacity: 0;
    transform: rotate(var(--start-angle-submit_));
  }
  17% {
    opacity: 1;
  }
  100% {
    opacity: 0;
    transform: rotate(var(--end-angle-submit_));
  }
}

/* So can go from "expanding" to "listen" and still trigger gradient-spin. */
@keyframes gradient-spin-listen {
  0% {
    opacity: 0;
    transform: rotate(var(--start-angle-listen_));
  }
  8% {
    opacity: 1;
  }
  100% {
    opacity: 0;
    transform: rotate(var(--end-angle-listen_));
  }
}

.background {
  /* The peephole whose border shrinks the background::before
   * element so the gradient shows up behind it as a border.
   * Activates once upon init; again whenever gradient-border-width-close
   * triggered */
  animation: gradient-border-width var(--expand-timing_);
  border: 0 solid transparent;
  border-radius: inherit;
  contain: paint;
  inset: 0;
  transition: border-width 100ms;
  position: absolute;
}

@keyframes gradient-border-width {
  0% {
    border-width: 0;
  }
  17% {
    border-width: var(--glow-stroke-width_);
  }
  100% {
    border-width: 0;
  }
}

.double-gradient-mask::before,
.background::before {
  /* In expand/submit mode: is the deepest background covering
   * .gradient. The input is layered on top of this.
   * In dragging mode: the frosted glass middle background on top
   * of the gradient. .gradient::after is the deepest background
   * in dragging mode. Because .background and the gradient
   * are blurred, it makes the gradient glow instead
   * of being fully solid. */
  background-color: var(--cr-composebox-background-color,
      --search-animated-glow-background);
  border-radius: inherit;
  content: '';
  contain: paint;
  filter: blur(0);
  position: absolute;
}

.background::before {
  /*
  * In expand/submit mode: is the deepest background covering
  * .gradient. The input is layered on top of this.
  * In dragging mode: the frosted glass middle background on top of the
  * gradient. .gradient::after is the deepest background in dragging mode.
  * Because .background and the gradient are blurred,
  * it makes the gradient glow instead of being fully solid.
  */
  inset: 0;
  transition:
    opacity 300ms,
    z-index 1ms 300ms;
}

.double-gradient-mask::before {
  inset: var(--glow-stroke-width_);
}

:host([animation-state='expanding']) .background::before {
  animation: plate-background-blur-on-expand var(--expand-timing_);
}

:host([animation-state='expanding'][is-collapsible]) .background::before {
  animation: color-pulse-on-expand var(--expand-duration,
      --search-animated-glow-expand-duration)
      var(--standard-curve, --search-animated-glow-standard-curve);
}

:host([animation-state='listening']) .background::before {
  animation:
      plate-background-blur-on-expand var(--expand-timing_),
      color-pulse-on-expand-listen var(--expand-timing_)
}

@keyframes plate-background-blur-on-expand {
  0% {
    filter: blur(0);
  }
  17% {
    filter: blur(2px);
  }
  100% {
    filter: blur(0);
  }
}

@keyframes color-pulse-on-expand {
  40% {
    background: var(--color-composebox-scrim-background);
  }
  58% {
    background: var(--color-composebox-scrim-background);
  }
}

@keyframes color-pulse-on-expand-listen {
  17% {
    background: var(--color-composebox-scrim-background);
  }
  100% {
    background: var(--color-composebox-scrim-background);
  }
}

:host([entrypoint-name='Omnibox'][animation-state='expanding']) .background::before {
  animation: none;
  filter: blur(8px);
}

:host([animation-state='dragging']) .background {
  /*
  * Set transparent border to let gradient
  * pop out. Make it static compared to animated to make
  * border more slow/steady with stable thickness.
  */
  animation: none;
  border-width: 2px;
  pointer-events: none;
  z-index: var(--search-animated-glow-background-z-index, 3);
}

:host([animation-state='expanding']) .background {
  animation: gradient-border-width-close-expand var(--expand-timing_);
}

:host([animation-state='submitting']) .background {
  animation: gradient-border-width-close-submit var(--expand-timing_);
}

:host([animation-state='listening']) .background {
  animation: gradient-border-width-close-listen var(--expand-timing_);
}

:host([animation-state='dragging']) .background::before {
  animation: none;
  background-color: rgba(240, 242, 245);
  filter: blur(28px);
  z-index: var(--search-animated-glow-background-z-index, 3);
}

@keyframes gradient-border-width-close-expand {
  0% {
    border-width: 0;
  }
  17% {
    border-width: var(--glow-stroke-width_);
  }
  100% {
    border-width: 0;
  }
}

@keyframes gradient-border-width-close-listen {
  0% {
    border-width: 0;
  }
  11% {
    border-width: var(--glow-stroke-width_);
  }
  100% {
    border-width: 0;
  }
}

@keyframes gradient-border-width-close-submit {
  0% {
    border-width: 0;
  }
  17% {
    border-width: var(--glow-stroke-width_);
  }
  100% {
    border-width: 0;
  }
}
