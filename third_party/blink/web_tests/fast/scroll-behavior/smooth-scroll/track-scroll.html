<!DOCTYPE html>
<script src="../../../resources/testharness.js"></script>
<script src="../../../resources/testharnessreport.js"></script>
<script src="../../../resources/gesture-util.js"></script>
<style>
body {
    height: 1800px;
}
</style>
<script>
  // Compute ScrollableArea::pageStep.
  var pageStep = innerHeight * 0.875;
  if (navigator.userAgent.indexOf("Mac OS X") >= 0)
      pageStep = Math.max(pageStep, innerHeight - 40);

  promise_test(async () => {
      // Click in the vertical scrollbar track, below the thumb, and hold the
      // mouse button down. The animation shouldn't continue past the initial
      // page step since the initial page step will take the scrollbar thumb
      // under the cursor.
      await mouseMoveTo(790, 280);
      await mouseDownAt(790, 280);

      // TODO(crbug.com/1172003): This needs to be fixed for track autoscrolls.
      // Impulse based animations have a longer duration than the default ease
      // in/out curve. So when an autoscroll animation is initiated (~250ms
      // after the initial mousedown), the animation generated by the initial
      // mousedown on the scrollbar track will need to be aborted by the
      // cc::ScrollbarController (as the cc::KeyframeModel doesn't allow multiple
      // sources animating the scroll offset). As a result, the thumb can be
      // anywhere between 0 and pageStep. As long as the thumb doesn't cross the
      // pointer location (i.e the offset at pageStep), this test is considered
      // successful. (Note that this is not an issue while using the default ease
      // in/out curve because the initial mousedown animation would've already
      // finished by the time the autoscroll animation is being kicked off)
      await waitForAnimationEndTimeBased( () => { return scrollY; } );
      assert_true(window.scrollY > 0 && window.scrollY <= pageStep,
      "window.scrollY = " + window.scrollY + " ");
  }, 'Scrollbar track autoscrolling doesn\'t overshoot cursor.');
</script>