<!DOCTYPE html>
<html>
  <head>
    <title>
      setTargetAtTime: immediate value change with zero time constant
    </title>
    <script src="../../resources/testharness.js"></script>
    <script src="../../resources/testharnessreport.js"></script>
  </head>
  <body>
    <script>
      // Fairly arbitrary sample rate and number of frames, so choose a low
      // sample rate, and short rendering length.
      const sampleRate = 8000;
      const renderFrames = 128;

      // Array specifying parameters for setTargetAtTime.  |frame| is the frame
      // (not necessarily an integer) at which setTargetAtTime starts, and
      // |value| is the target value.  Non-integral values for |frame| tests
      // that we started the setTargetAtTime at the right time.
      const targetValueInfo = [
        {frame: 10.1, value: 0}, {frame: 20.3, value: 0.5},
        {frame: 100.5, value: 1}
      ];

      promise_test(async () => {
        const context = new OfflineAudioContext(1, renderFrames, sampleRate);

        // Simple constant source for testing.
        const src = new ConstantSourceNode(context);

        // We're going to automate the gain node to test setTargetAtTime.
        const gain = new GainNode(context, {gain: 1});

        src.connect(gain).connect(context.destination);

        for (let k = 0; k < targetValueInfo.length; ++k) {
          gain.gain.setTargetAtTime(
              targetValueInfo[k].value,
              targetValueInfo[k].frame / context.sampleRate, 0);
        }

        src.start();

        const resultBuffer = await context.startRendering();
        const channelData = resultBuffer.getChannelData(0);
        // Because the time constant is 0, the automation should instantly
        // jump to the target value at the start time.  Verify that the
        // output has the expected value.
        for (let k = 0; k < targetValueInfo.length; ++k) {
          const startFrame = Math.ceil(targetValueInfo[k].frame);
          const endFrame = k < targetValueInfo.length - 1
              ? Math.ceil(targetValueInfo[k + 1].frame)
              : renderFrames;
          const value = targetValueInfo[k].value;
          const actual = channelData.slice(startFrame, endFrame);
          const expected = new Float32Array(actual.length).fill(value);

          assert_array_equals(
              actual,
              expected,
              'Output for frame [' + startFrame + ', ' + endFrame + ')' +
                  ' should be constant value of ' + value);

        }
      }, 'timeconstant-0');
    </script>
  </body>
</html>
