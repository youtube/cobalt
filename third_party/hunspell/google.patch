diff --git a/src/hunspell/affixmgr.cxx b/src/hunspell/affixmgr.cxx
index 87ab6c5..4499a06 100644
--- a/src/hunspell/affixmgr.cxx
+++ b/src/hunspell/affixmgr.cxx
@@ -85,11 +85,19 @@
 
 #include "csutil.hxx"
 
+#ifdef HUNSPELL_CHROME_CLIENT
+AffixMgr::AffixMgr(hunspell::BDictReader* reader,
+                   const std::vector<HashMgr*>& ptr)
+  : alldic(ptr)
+  , pHMgr(ptr[0]) {
+  bdict_reader = reader;
+#else
 AffixMgr::AffixMgr(const char* affpath,
                    const std::vector<HashMgr*>& ptr,
                    const char* key)
   : alldic(ptr)
   , pHMgr(ptr[0]) {
+#endif
 
   // register hash manager and load affix data from aff file
   csconv = NULL;
@@ -163,9 +171,17 @@ AffixMgr::AffixMgr(const char* affpath,
     sFlag[i] = NULL;
   }
 
+#ifdef HUNSPELL_CHROME_CLIENT
+  // Define dummy parameters for parse_file() to avoid changing the parameters
+  // of parse_file(). This may make it easier to merge the changes of the
+  // original hunspell.
+  const char* affpath = NULL;
+  const char* key = NULL;
+#else
   for (int j = 0; j < CONTSIZE; j++) {
     contclasses[j] = 0;
   }
+#endif
 
   if (parse_file(affpath, key)) {
     HUNSPELL_WARNING(stderr, "Failure loading aff file %s\n", affpath);
@@ -243,7 +259,44 @@ void AffixMgr::finishFileMgr(FileMgr* afflst) {
 
 // read in aff file and build up prefix and suffix entry objects
 int AffixMgr::parse_file(const char* affpath, const char* key) {
+  std::string line;
+#ifdef HUNSPELL_CHROME_CLIENT
+  // open the affix file
+  // We're always UTF-8
+  utf8 = 1;
+
+  // A BDICT file stores PFX and SFX lines in a special section and it provides
+  // a special line iterator for reading PFX and SFX lines.
+  // We create a FileMgr object from this iterator and parse PFX and SFX lines
+  // before parsing other lines.
+  hunspell::LineIterator affix_iterator = bdict_reader->GetAffixLineIterator();
+  FileMgr* iterator = new FileMgr(&affix_iterator);
+  if (!iterator) {
+    HUNSPELL_WARNING(stderr,
+        "error: could not create a FileMgr from an affix line iterator.\n");
+    return 1;
+  }
+
+  while (iterator->getline(line)) {
+    char ft = ' ';
+    if (line.compare(0, 3, "PFX") == 0) ft = complexprefixes ? 'S' : 'P';
+    if (line.compare(0, 3, "SFX") == 0) ft = complexprefixes ? 'P' : 'S';
+    if (ft != ' ')
+      parse_affix(line, ft, iterator, NULL);
+  }
+  delete iterator;
 
+  // Create a FileMgr object for reading lines except PFX and SFX lines.
+  // We don't need to change the loop below since our FileMgr emulates the
+  // original one.
+  hunspell::LineIterator other_iterator = bdict_reader->GetOtherLineIterator();
+  FileMgr * afflst = new FileMgr(&other_iterator);
+  if (!afflst) {
+    HUNSPELL_WARNING(stderr,
+        "error: could not create a FileMgr from an other line iterator.\n");
+    return 1;
+  }
+#else
   // checking flag duplication
   char dupflags[CONTSIZE];
   char dupflags_ini = 1;
@@ -258,16 +311,17 @@ int AffixMgr::parse_file(const char* affpath, const char* key) {
         stderr, "error: could not open affix description file %s\n", affpath);
     return 1;
   }
+#endif
 
   // step one is to parse the affix file building up the internal
   // affix data structures
 
   // read in each line ignoring any that do not
   // start with a known line type indicator
-  std::string line;
   while (afflst->getline(line)) {
     mychomp(line);
 
+#ifndef HUNSPELL_CHROME_CLIENT
     /* remove byte order mark */
     if (firstline) {
       firstline = 0;
@@ -277,6 +331,7 @@ int AffixMgr::parse_file(const char* affpath, const char* key) {
         line.erase(0, 3);
       }
     }
+#endif
 
     /* parse in the keyboard string */
     if (line.compare(0, 3, "KEY", 3) == 0) {
@@ -677,6 +732,7 @@ int AffixMgr::parse_file(const char* affpath, const char* key) {
       checksharps = 1;
     }
 
+#ifndef HUNSPELL_CHROME_CLIENT
     /* parse this affix: P - prefix, S - suffix */
     // affix type
     char ft = ' ';
@@ -694,6 +750,7 @@ int AffixMgr::parse_file(const char* affpath, const char* key) {
         return 1;
       }
     }
+#endif
   }
 
   finishFileMgr(afflst);
@@ -1270,6 +1327,24 @@ std::string AffixMgr::prefix_check_twosfx_morph(const char* word,
 // Is word a non-compound with a REP substitution (see checkcompoundrep)?
 int AffixMgr::cpdrep_check(const char* word, int wl) {
 
+#ifdef HUNSPELL_CHROME_CLIENT
+  const char *pattern, *pattern2;
+  hunspell::ReplacementIterator iterator = bdict_reader->GetReplacementIterator();
+  while (iterator.GetNext(&pattern, &pattern2)) {
+    const char* r = word;
+    const size_t lenr = strlen(pattern2);
+    const size_t lenp = strlen(pattern);
+
+    // search every occurence of the pattern in the word
+    while ((r=strstr(r, pattern)) != NULL) {
+      std::string candidate(word);
+      candidate.replace(r-word, lenp, pattern2);
+      if (candidate_check(candidate.c_str(), candidate.size())) return 1;
+      r++; // search for the next letter
+    }
+  }
+
+#else
   if ((wl < 2) || get_reptable().empty())
     return 0;
 
@@ -1288,6 +1363,7 @@ int AffixMgr::cpdrep_check(const char* word, int wl) {
       }
     }
   }
+#endif
 
  return 0;
 }
@@ -4359,7 +4435,7 @@ void AffixMgr::reverse_condition(std::string& piece) {
       case '^': {
         if (*(k - 1) == ']')
           neg = 1;
-        else
+        else if (neg)
           *(k - 1) = *k;
         break;
       }
@@ -4457,6 +4533,7 @@ bool AffixMgr::parse_affix(const std::string& line,
       case 1: {
         np++;
         aflag = pHMgr->decode_flag(std::string(start_piece, iter).c_str());
+#ifndef HUNSPELL_CHROME_CLIENT // We don't check for duplicates.
         if (((at == 'S') && (dupflags[aflag] & dupSFX)) ||
             ((at == 'P') && (dupflags[aflag] & dupPFX))) {
           HUNSPELL_WARNING(
@@ -4465,6 +4542,7 @@ bool AffixMgr::parse_affix(const std::string& line,
               af->getlinenum());
         }
         dupflags[aflag] += (char)((at == 'S') ? dupSFX : dupPFX);
+#endif
         break;
       }
       // piece 3 - is cross product indicator
diff --git a/src/hunspell/affixmgr.hxx b/src/hunspell/affixmgr.hxx
index 38842a3..e03a4a3 100644
--- a/src/hunspell/affixmgr.hxx
+++ b/src/hunspell/affixmgr.hxx
@@ -89,6 +89,40 @@
 class PfxEntry;
 class SfxEntry;
 
+#ifdef HUNSPELL_CHROME_CLIENT
+
+#include <vector>
+
+// This class provides an implementation of the contclasses array in AffixMgr
+// that is normally a large static array. We should almost never need more than
+// 256 elements, so this class only allocates that much to start off with. If
+// elements higher than that are actually used, we'll automatically expand.
+class ContClasses {
+ public:
+  ContClasses() {
+    // Pre-allocate a buffer so that typically, we'll never have to resize.
+    EnsureSizeIs(256);
+  }
+
+  char& operator[](size_t index) {
+    EnsureSizeIs(index + 1);
+    return data[index];
+  }
+
+  void EnsureSizeIs(size_t new_size) {
+    if (data.size() >= new_size)
+      return;  // Nothing to do.
+
+    size_t old_size = data.size();
+    data.resize(new_size);
+    memset(&data[old_size], 0, new_size - old_size);
+  }
+
+  std::vector<char> data;
+};
+
+#endif  // HUNSPELL_CHROME_CLIENT
+
 class AffixMgr {
   PfxEntry* pStart[SETSIZE];
   SfxEntry* sStart[SETSIZE];
@@ -170,11 +204,19 @@ class AffixMgr {
   int fullstrip;
 
   int havecontclass;           // boolean variable
+#ifdef HUNSPELL_CHROME_CLIENT
+  ContClasses         contclasses;
+#else
   char contclasses[CONTSIZE];  // flags of possible continuing classes (twofold
                                // affix)
+#endif
 
  public:
+#ifdef HUNSPELL_CHROME_CLIENT
+  AffixMgr(hunspell::BDictReader* reader, const std::vector<HashMgr*>& ptr);
+#else
   AffixMgr(const char* affpath, const std::vector<HashMgr*>& ptr, const char* key = NULL);
+#endif
   ~AffixMgr();
   struct hentry* affix_check(const char* word,
                              int len,
@@ -334,6 +376,10 @@ class AffixMgr {
   int get_fullstrip() const;
 
  private:
+#ifdef HUNSPELL_CHROME_CLIENT
+  // Not owned by us, owned by the Hunspell object.
+  hunspell::BDictReader* bdict_reader;
+#endif
   int parse_file(const char* affpath, const char* key);
   bool parse_flag(const std::string& line, unsigned short* out, FileMgr* af);
   bool parse_num(const std::string& line, int* out, FileMgr* af);
diff --git a/src/hunspell/filemgr.cxx b/src/hunspell/filemgr.cxx
index 4a14de8..1671db8 100644
--- a/src/hunspell/filemgr.cxx
+++ b/src/hunspell/filemgr.cxx
@@ -75,6 +75,32 @@
 #include "filemgr.hxx"
 #include "csutil.hxx"
 
+#ifdef HUNSPELL_CHROME_CLIENT
+#include "third_party/hunspell/google/bdict_reader.h"
+
+FileMgr::FileMgr(hunspell::LineIterator* iterator) : iterator_(iterator) {
+}
+
+FileMgr::~FileMgr() {
+}
+
+bool FileMgr::getline(std::string& line) {
+  // Read one line from a BDICT file and return it, if we can read a line
+  // without errors.
+  const char* result = iterator_->Advance();
+  if (result)
+    line = result;
+  return result;
+}
+
+int FileMgr::getlinenum() {
+  // This function is used only for displaying a line number that causes a
+  // parser error. For a BDICT file, providing a line number doesn't help
+  // identifying the place where causes a parser error so much since it is a
+  // binary file. So, we just return 0.
+  return 0;
+}
+#else
 int FileMgr::fail(const char* err, const char* par) {
   fprintf(stderr, err, par);
   return -1;
@@ -115,3 +141,4 @@ bool FileMgr::getline(std::string& dest) {
 int FileMgr::getlinenum() {
   return linenum;
 }
+#endif
diff --git a/src/hunspell/filemgr.hxx b/src/hunspell/filemgr.hxx
index 62433ae..9016822 100644
--- a/src/hunspell/filemgr.hxx
+++ b/src/hunspell/filemgr.hxx
@@ -77,6 +77,29 @@
 #include <string>
 #include <fstream>
 
+#ifdef HUNSPELL_CHROME_CLIENT
+namespace hunspell {
+class LineIterator;
+}  // namespace hunspell
+
+// A class which encapsulates operations of reading a BDICT file.
+// Chrome uses a BDICT file to compress hunspell dictionaries. A BDICT file is
+// a binary file converted from a DIC file and an AFF file. (See
+// "bdict_reader.h" for its format.)
+// This class encapsulates the operations of reading a BDICT file and emulates
+// the original FileMgr operations for AffixMgr so that it can read a BDICT
+// file without so many changes.
+class FileMgr {
+ public:
+  FileMgr(hunspell::LineIterator* iterator);
+  ~FileMgr();
+  bool getline(std::string& line);
+  int getlinenum();
+
+ protected:
+  hunspell::LineIterator* iterator_;
+};
+#else
 class FileMgr {
  private:
   FileMgr(const FileMgr&);
@@ -96,3 +119,4 @@ class FileMgr {
   int getlinenum();
 };
 #endif
+#endif
diff --git a/src/hunspell/hashmgr.cxx b/src/hunspell/hashmgr.cxx
index 7e843c3..fbebdbf 100644
--- a/src/hunspell/hashmgr.cxx
+++ b/src/hunspell/hashmgr.cxx
@@ -82,8 +82,14 @@
 
 // build a hash table from a munched word list
 
+#ifdef HUNSPELL_CHROME_CLIENT
+HashMgr::HashMgr(hunspell::BDictReader* reader)
+    : bdict_reader(reader),
+#else
 HashMgr::HashMgr(const char* tpath, const char* apath, const char* key)
-    : tablesize(0),
+    :
+#endif
+      tablesize(0),
       tableptr(NULL),
       flag_mode(FLAG_CHAR),
       complexprefixes(0),
@@ -97,8 +103,14 @@ HashMgr::HashMgr(const char* tpath, const char* apath, const char* key)
       aliasm(NULL) {
   langnum = 0;
   csconv = 0;
+#ifdef HUNSPELL_CHROME_CLIENT
+  // No tables to load, just the AF lines.
+  load_config(NULL, NULL);
+  int ec = LoadAFLines();
+#else
   load_config(apath, key);
   int ec = load_tables(tpath, key);
+#endif
   if (ec) {
     /* error condition - what should we do here */
     HUNSPELL_WARNING(stderr, "Hash Manager Error : %d\n", ec);
@@ -156,14 +168,57 @@ HashMgr::~HashMgr() {
 #endif
 #endif
 
+#ifdef HUNSPELL_CHROME_CLIENT
+  EmptyHentryCache();
+  for (std::vector<std::string*>::iterator it = pointer_to_strings_.begin();
+       it != pointer_to_strings_.end(); ++it) {
+    delete *it;
+  }
+#endif
 #ifdef MOZILLA_CLIENT
   delete[] csconv;
 #endif
 }
 
+#ifdef HUNSPELL_CHROME_CLIENT
+void HashMgr::EmptyHentryCache() {
+  // We need to delete each cache entry, and each additional one in the linked
+  // list of homonyms.
+  for (HEntryCache::iterator i = hentry_cache.begin();
+       i != hentry_cache.end(); ++i) {
+    hentry* cur = i->second;
+    while (cur) {
+      hentry* next = cur->next_homonym;
+      DeleteHashEntry(cur);
+      cur = next;
+    }
+  }
+  hentry_cache.clear();
+}
+#endif
+
 // lookup a root word in the hashtable
 
 struct hentry* HashMgr::lookup(const char* word) const {
+#ifdef HUNSPELL_CHROME_CLIENT
+  int affix_ids[hunspell::BDict::MAX_AFFIXES_PER_WORD];
+  int affix_count = bdict_reader->FindWord(word, affix_ids);
+  if (affix_count == 0) { // look for custom added word
+    std::map<std::string_view, int>::const_iterator iter = 
+      custom_word_to_affix_id_map_.find(word);
+    if (iter != custom_word_to_affix_id_map_.end()) {
+      affix_count = 1;
+      affix_ids[0] = iter->second;
+    }
+  }
+
+  static const int kMaxWordLen = 128;
+  static char word_buf[kMaxWordLen];
+  // To take account of null-termination, we use upto 127.
+  strncpy(word_buf, word, kMaxWordLen - 1);
+
+  return AffixIDsToHentry(word_buf, affix_ids, affix_count);
+#else
   struct hentry* dp;
   if (tableptr) {
     dp = tableptr[hash(word)];
@@ -175,6 +230,7 @@ struct hentry* HashMgr::lookup(const char* word) const {
     }
   }
   return NULL;
+#endif
 }
 
 // add a word to the hash table (private)
@@ -185,6 +241,8 @@ int HashMgr::add_word(const std::string& in_word,
                       const std::string* in_desc,
                       bool onlyupcase,
                       int captype) {
+// TODO: The following 40 lines or so are actually new. Should they be included?
+#ifndef HUNSPELL_CHROME_CLIENT
   const std::string* word = &in_word;
   const std::string* desc = in_desc;
 
@@ -416,6 +474,17 @@ int HashMgr::add_word(const std::string& in_word,
 
   delete desc_copy;
   delete word_copy;
+#else
+  std::map<std::string_view, int>::iterator iter =
+      custom_word_to_affix_id_map_.find(in_word);
+  if (iter == custom_word_to_affix_id_map_.end()) {  // word needs to be added
+    std::string* new_string_word = new std::string(in_word);
+    pointer_to_strings_.push_back(new_string_word);
+    std::string_view sp(*(new_string_word));
+    custom_word_to_affix_id_map_[sp] = 0; // no affixes for custom words
+    return 1;
+  }
+#endif
   return 0;
 }
 
@@ -480,6 +549,12 @@ int HashMgr::get_clen_and_captype(const std::string& word, int* captype) {
 
 // remove word (personal dictionary function for standalone applications)
 int HashMgr::remove(const std::string& word) {
+#ifdef HUNSPELL_CHROME_CLIENT
+  std::map<std::string_view, int>::iterator iter =
+      custom_word_to_affix_id_map_.find(word);
+  if (iter != custom_word_to_affix_id_map_.end())
+      custom_word_to_affix_id_map_.erase(iter);
+#else
   struct hentry* dp = lookup(word.c_str());
   while (dp) {
     if (dp->alen == 0 || !TESTAFF(dp->astr, forbiddenword, dp->alen)) {
@@ -497,6 +572,7 @@ int HashMgr::remove(const std::string& word) {
     }
     dp = dp->next_homonym;
   }
+#endif
   return 0;
 }
 
@@ -555,6 +631,44 @@ int HashMgr::add_with_affix(const std::string& word, const std::string& example)
 // walk the hash table entry by entry - null at end
 // initialize: col=-1; hp = NULL; hp = walk_hashtable(&col, hp);
 struct hentry* HashMgr::walk_hashtable(int& col, struct hentry* hp) const {
+#ifdef HUNSPELL_CHROME_CLIENT
+  // Return NULL if dictionary is not valid.
+  if (!bdict_reader->IsValid())
+    return NULL;
+
+  // This function is only ever called by one place and not nested. We can
+  // therefore keep static state between calls and use |col| as a "reset" flag
+  // to avoid changing the API. It is set to -1 for the first call.
+  // Allocate the iterator on the heap to prevent an exit time destructor.
+  static hunspell::WordIterator& word_iterator =
+      *new hunspell::WordIterator(bdict_reader->GetAllWordIterator());
+  if (col < 0) {
+    col = 1;
+    word_iterator = bdict_reader->GetAllWordIterator();
+  }
+
+  int affix_ids[hunspell::BDict::MAX_AFFIXES_PER_WORD];
+  static const int kMaxWordLen = 128;
+  static char word[kMaxWordLen];
+  int affix_count = word_iterator.Advance(word, kMaxWordLen, affix_ids);
+  if (affix_count == 0)
+    return NULL;
+  short word_len = static_cast<short>(strlen(word));
+
+  // Since hunspell 1.2.8, an hentry struct becomes a variable-length struct,
+  // i.e. a struct which uses its array 'word[1]' as a variable-length array.
+  // As noted above, this function is not nested. So, we just use a static
+  // struct which consists of an hentry and a char[kMaxWordLen], and initialize
+  // the static struct and return it for now.
+  // No need to create linked lists for the extra affixes.
+  static struct {
+    hentry entry;
+    char word[kMaxWordLen];
+  } hash_entry;
+
+  return InitHashEntry(&hash_entry.entry, sizeof(hash_entry),
+                       &word[0], word_len, affix_ids[0]);
+#else
   if (hp && hp->next != NULL)
     return hp->next;
   for (col++; col < tablesize; col++) {
@@ -564,10 +678,12 @@ struct hentry* HashMgr::walk_hashtable(int& col, struct hentry* hp) const {
   // null at end and reset to start
   col = -1;
   return NULL;
+#endif
 }
 
 // load a munched word list and build a hash table on the fly
 int HashMgr::load_tables(const char* tpath, const char* key) {
+#ifndef HUNSPELL_CHROME_CLIENT
   // open dictionary file
   FileMgr* dict = new FileMgr(tpath, key);
   if (dict == NULL)
@@ -698,12 +814,16 @@ int HashMgr::load_tables(const char* tpath, const char* key) {
   }
 
   delete dict;
+#endif
   return 0;
 }
 
 // the hash function is a simple load and rotate
 // algorithm borrowed
 int HashMgr::hash(const char* word) const {
+#ifdef HUNSPELL_CHROME_CLIENT
+    return 0;
+#else
   unsigned long hv = 0;
   for (int i = 0; i < 4 && *word != 0; i++)
     hv = (hv << 8) | (*word++);
@@ -712,6 +832,7 @@ int HashMgr::hash(const char* word) const {
     hv ^= (*word++);
   }
   return (unsigned long)hv % tablesize;
+#endif
 }
 
 int HashMgr::decode_flags(unsigned short** result, const std::string& flags, FileMgr* af) const {
@@ -921,7 +1042,12 @@ int HashMgr::load_config(const char* affpath, const char* key) {
   int firstline = 1;
 
   // open the affix file
+#ifdef HUNSPELL_CHROME_CLIENT
+  hunspell::LineIterator iterator = bdict_reader->GetOtherLineIterator();
+  FileMgr * afflst = new FileMgr(&iterator);
+#else
   FileMgr* afflst = new FileMgr(affpath, key);
+#endif
   if (!afflst) {
     HUNSPELL_WARNING(
         stderr, "Error - could not open affix description file %s\n", affpath);
@@ -1161,6 +1287,132 @@ bool HashMgr::parse_aliasf(const std::string& line, FileMgr* af) {
   return true;
 }
 
+#ifdef HUNSPELL_CHROME_CLIENT
+int HashMgr::LoadAFLines()
+{
+  utf8 = 1;  // We always use UTF-8.
+
+  // Read in all the AF lines which tell us the rules for each affix group ID.
+  hunspell::LineIterator iterator = bdict_reader->GetAfLineIterator();
+  FileMgr afflst(&iterator);
+  std::string line;
+  while (afflst.getline(line)) {
+    int rv = parse_aliasf(line, &afflst);
+    if (rv)
+      return rv;
+  }
+
+  return 0;
+}
+
+hentry* HashMgr::InitHashEntry(hentry* entry,
+                               size_t item_size,
+                               const char* word,
+                               int word_length,
+                               int affix_index) const {
+  // Return if the given buffer doesn't have enough space for a hentry struct
+  // or the given word is too long.
+  // Our BDICT cannot handle words longer than (128 - 1) bytes. So, it is
+  // better to return an error if the given word is too long and prevent
+  // an unexpected result caused by a long word.
+  const int kMaxWordLen = 128;
+  if (item_size < sizeof(hentry) + word_length + 1 ||
+      word_length >= kMaxWordLen)
+    return NULL;
+
+  // Initialize a hentry struct with the given parameters, and
+  // append the given string at the end of this hentry struct.
+  memset(entry, 0, item_size);
+
+  // `get_aliasf` only uses the dictionary file in the case of an error.
+  // Should that occur, `FileMgr::getlinenum` is called. But for a BDICT file,
+  // the line number doesn't help identify the place which caused the parser
+  // error. As a result, `getlinenum` always returns 0. Since we don't actually
+  // need the dictionary file, and since `InitHashEntry` is called for every
+  // dictionary entry, eliminate the overhead of creating the `FileMgr` object
+  // every time.
+  static FileMgr dummyDictionaryFile(NULL);
+  entry->alen = static_cast<short>(const_cast<HashMgr*>(this)->get_aliasf(
+      affix_index, &entry->astr, &dummyDictionaryFile));
+  entry->blen = static_cast<unsigned char>(word_length);
+  std::vector<w_char> w;
+  entry->clen = u8_u16(w, word);
+  memcpy(&entry->word, word, word_length);
+
+  return entry;
+}
+
+hentry* HashMgr::CreateHashEntry(const char* word,
+                                 int word_length,
+                                 int affix_index) const {
+  // Return if the given word is too long.
+  // (See the comment in HashMgr::InitHashEntry().)
+  const int kMaxWordLen = 128;
+  if (word_length >= kMaxWordLen)
+    return NULL;
+
+  const size_t kEntrySize = sizeof(hentry) + word_length + 1;
+  struct hentry* entry = reinterpret_cast<hentry*>(malloc(kEntrySize));
+  if (entry)
+    InitHashEntry(entry, kEntrySize, word, word_length, affix_index);
+
+  return entry;
+}
+
+void HashMgr::DeleteHashEntry(hentry* entry) const {
+  free(entry);
+}
+
+hentry* HashMgr::AffixIDsToHentry(char* word,
+                                  int* affix_ids, 
+                                  int affix_count) const
+{
+  if (affix_count == 0)
+    return NULL;
+
+  HEntryCache& cache = const_cast<HashMgr*>(this)->hentry_cache;
+  std::string std_word(word);
+  HEntryCache::iterator found = cache.find(std_word);
+  if (found != cache.end()) {
+    // We must return an existing hentry for the same word if we've previously
+    // handed one out. Hunspell will compare pointers in some cases to see if
+    // two words it has found are the same.
+    return found->second;
+  }
+
+  short word_len = static_cast<short>(strlen(word));
+
+  // We can get a number of prefixes per word. There will normally be only one,
+  // but if not, there will be a linked list of "hentry"s for the "homonym"s 
+  // for the word.
+  struct hentry* first_he = NULL;
+  struct hentry* prev_he = NULL;  // For making linked list.
+  for (int i = 0; i < affix_count; i++) {
+    struct hentry* he = CreateHashEntry(word, word_len, affix_ids[i]);
+    if (!he)
+      break;
+    if (i == 0)
+      first_he = he;
+    if (prev_he)
+      prev_he->next_homonym = he;
+    prev_he = he;
+  }
+
+  cache[std_word] = first_he;  // Save this word in the cache for later.
+  return first_he;
+}
+
+hentry* HashMgr::GetHentryFromHEntryCache(char* word) {
+  HEntryCache& cache = const_cast<HashMgr*>(this)->hentry_cache;
+  std::string std_word(word);
+  HEntryCache::iterator found = cache.find(std_word);
+  if (found != cache.end())
+    return found->second;
+  else
+    return NULL;
+}
+#endif
+
 int HashMgr::is_aliasf() const {
   return (aliasf != NULL);
 }
diff --git a/src/hunspell/hashmgr.hxx b/src/hunspell/hashmgr.hxx
index b6eaddd..7328b4c 100644
--- a/src/hunspell/hashmgr.hxx
+++ b/src/hunspell/hashmgr.hxx
@@ -79,6 +79,13 @@
 #include "filemgr.hxx"
 #include "w_char.hxx"
 
+#ifdef HUNSPELL_CHROME_CLIENT
+#include <map>
+#include <string_view>
+
+#include "third_party/hunspell/google/bdict_reader.h"
+#endif
+
 enum flag { FLAG_CHAR, FLAG_LONG, FLAG_NUM, FLAG_UNI };
 
 // morphological description of a dictionary item can contain
@@ -88,6 +95,12 @@ enum flag { FLAG_CHAR, FLAG_LONG, FLAG_NUM, FLAG_UNI };
 #define MORPH_PHON_RATIO 500
 
 class HashMgr {
+#ifdef HUNSPELL_CHROME_CLIENT
+  // Not owned by this class, owned by the Hunspell object.
+  hunspell::BDictReader* bdict_reader;
+  std::map<std::string_view, int> custom_word_to_affix_id_map_;
+  std::vector<std::string*> pointer_to_strings_;
+#endif
   int tablesize;
   struct hentry** tableptr;
   flag flag_mode;
@@ -111,7 +124,23 @@ class HashMgr {
   std::vector<replentry> reptable;
 
  public:
+#ifdef HUNSPELL_CHROME_CLIENT
+  HashMgr(hunspell::BDictReader* reader);
+
+  // Return the hentry corresponding to the given word. Returns NULL if the
+  // word is not there in the cache.
+  hentry* GetHentryFromHEntryCache(char* word);
+
+  // Called before we do a new operation. This will empty the cache of pointers
+  // to hentries that we have cached. In Chrome, we make these on-demand, but
+  // they must live as long as the single spellcheck operation that they're part
+  // of since Hunspell will save pointers to various ones as it works.
+  //
+  // This function allows that cache to be emptied and not grow infinitely.
+  void EmptyHentryCache();
+#else
   HashMgr(const char* tpath, const char* apath, const char* key = NULL);
+#endif
   ~HashMgr();
 
   struct hentry* lookup(const char*) const;
@@ -144,6 +173,40 @@ class HashMgr {
                int captype);
   int load_config(const char* affpath, const char* key);
   bool parse_aliasf(const std::string& line, FileMgr* af);
+
+#ifdef HUNSPELL_CHROME_CLIENT
+  // Loads the AF lines from a BDICT.
+  // A BDICT file compresses its AF lines to save memory.
+  // This function decompresses each AF line and call parse_aliasf().
+  int LoadAFLines();
+
+  // Helper functions that create a new hentry struct, initialize it, and
+  // delete it.
+  // These functions encapsulate non-trivial operations in creating and
+  // initializing a hentry struct from BDICT data to avoid changing code so much
+  // even when a hentry struct is changed.
+  hentry* InitHashEntry(hentry* entry,
+                        size_t item_size,
+                        const char* word,
+                        int word_length,
+                        int affix_index) const;
+  hentry* CreateHashEntry(const char* word,
+                          int word_length,
+                          int affix_index) const;
+  void DeleteHashEntry(hentry* entry) const;
+
+  // Converts the list of affix IDs to a linked list of hentry structures. The
+  // hentry structures will point to the given word. The returned pointer will
+  // be a statically allocated variable that will change for the next call. The
+  // |word| buffer must be the same.
+  hentry* AffixIDsToHentry(char* word, int* affix_ids, int affix_count) const;
+
+  // See EmptyHentryCache above. Note that each one is actually a linked list
+  // followed by the homonym pointer.
+  typedef std::map<std::string, hentry*> HEntryCache;
+  HEntryCache hentry_cache;
+#endif
+
   int add_hidden_capitalized_word(const std::string& word,
                                   int wcl,
                                   unsigned short* flags,
diff --git a/src/hunspell/htypes.hxx b/src/hunspell/htypes.hxx
index 8e03a03..f96ea1d 100644
--- a/src/hunspell/htypes.hxx
+++ b/src/hunspell/htypes.hxx
@@ -38,6 +38,16 @@
 #ifndef HTYPES_HXX_
 #define HTYPES_HXX_
 
+#ifdef HUNSPELL_CHROME_CLIENT
+// This is a workaround for preventing errors in parsing Turkish BDICs, which
+// contain very long AF lines (~ 12,000 chars).
+// TODO(hbono) change the HashMgr::parse_aliasf() function to be able to parse
+// longer lines than MAXDELEN.
+#define MAXDELEN    (8192 * 2)
+#else
+#define MAXDELEN    8192
+#endif  // HUNSPELL_CHROME_CLIENT
+
 #define ROTATE_LEN 5
 
 #define ROTATE(v, q) \
diff --git a/src/hunspell/hunspell.cxx b/src/hunspell/hunspell.cxx
index 35266c9..bab2ff2 100644
--- a/src/hunspell/hunspell.cxx
+++ b/src/hunspell/hunspell.cxx
@@ -77,19 +77,28 @@
 #include "hunspell.hxx"
 #include "suggestmgr.hxx"
 #include "hunspell.h"
+#ifndef HUNSPELL_CHROME_CLIENT
+#    include "config.h"
+#endif
 #include "csutil.hxx"
 
 #include <limits>
 #include <string>
 
-#define MAXWORDUTF8LEN (MAXWORDLEN * 3)
+#define MAXWORDUTF8LEN (MAXWORDLEN * 2)
 
 class HunspellImpl
 {
 public:
+#ifdef HUNSPELL_CHROME_CLIENT
+  explicit HunspellImpl(base::span<const unsigned char> bdict_data);
+#else
   HunspellImpl(const char* affpath, const char* dpath, const char* key = NULL);
+#endif
   ~HunspellImpl();
+#ifndef HUNSPELL_CHROME_CLIENT
   int add_dic(const char* dpath, const char* key = NULL);
+#endif
   std::vector<std::string> suffix_suggest(const std::string& root_word);
   std::vector<std::string> generate(const std::string& word, const std::vector<std::string>& pl);
   std::vector<std::string> generate(const std::string& word, const std::string& pattern);
@@ -127,7 +136,9 @@ private:
   AffixMgr* pAMgr;
   std::vector<HashMgr*> m_HMgrs;
   SuggestMgr* pSMgr;
+#ifndef HUNSPELL_CHROME_CLIENT // We are using BDict instead.
   char* affixpath;
+#endif
   std::string encoding;
   struct cs_info* csconv;
   int langnum;
@@ -135,6 +146,11 @@ private:
   int complexprefixes;
   std::vector<std::string> wordbreak;
 
+#ifdef HUNSPELL_CHROME_CLIENT
+  // Not owned by us, owned by the Hunspell object.
+  hunspell::BDictReader* bdict_reader;
+#endif
+
 private:
   std::vector<std::string> analyze_internal(const std::string& word);
   bool spell_internal(const std::string& word, int* info = NULL, std::string* root = NULL);
@@ -169,18 +185,34 @@ private:
   HunspellImpl& operator=(const HunspellImpl&);
 };
 
+#ifdef HUNSPELL_CHROME_CLIENT
+HunspellImpl::HunspellImpl(base::span<const unsigned char> bdict_data) {
+#else
 HunspellImpl::HunspellImpl(const char* affpath, const char* dpath, const char* key) {
+#endif
   csconv = NULL;
   utf8 = 0;
   complexprefixes = 0;
+#ifndef HUNSPELL_CHROME_CLIENT
   affixpath = mystrdup(affpath);
+#endif
+
+#ifdef HUNSPELL_CHROME_CLIENT
+  bdict_reader = new hunspell::BDictReader;
+  bdict_reader->Init(bdict_data);
+
+  /* first set up the hash manager */
+  m_HMgrs.push_back(new HashMgr(bdict_reader));
 
+  pAMgr = new AffixMgr(bdict_reader, m_HMgrs); // TODO: 'key' ?
+#else
   /* first set up the hash manager */
   m_HMgrs.push_back(new HashMgr(dpath, affpath, key));
 
   /* next set up the affix manager */
   /* it needs access to the hash manager lookup methods */
   pAMgr = new AffixMgr(affpath, m_HMgrs, key);
+#endif
 
   /* get the preferred try string and the dictionary */
   /* encoding from the Affix Manager for that dictionary */
@@ -194,7 +226,11 @@ HunspellImpl::HunspellImpl(const char* affpath, const char* dpath, const char* k
   wordbreak = pAMgr->get_breaktable();
 
   /* and finally set up the suggestion manager */
+#ifdef HUNSPELL_CHROME_CLIENT
+  pSMgr = new SuggestMgr(bdict_reader, try_string, MAXSUGGESTION, pAMgr);
+#else
   pSMgr = new SuggestMgr(try_string, MAXSUGGESTION, pAMgr);
+#endif
   if (try_string)
     free(try_string);
 }
@@ -210,11 +246,17 @@ HunspellImpl::~HunspellImpl() {
   delete[] csconv;
 #endif
   csconv = NULL;
+#ifdef HUNSPELL_CHROME_CLIENT
+    if (bdict_reader) delete bdict_reader;
+    bdict_reader = NULL;
+#else
   if (affixpath)
     free(affixpath);
   affixpath = NULL;
+#endif
 }
 
+#ifndef HUNSPELL_CHROME_CLIENT
 // load extra dictionaries
 int HunspellImpl::add_dic(const char* dpath, const char* key) {
   if (!affixpath)
@@ -222,6 +264,7 @@ int HunspellImpl::add_dic(const char* dpath, const char* key) {
   m_HMgrs.push_back(new HashMgr(dpath, affixpath, key));
   return 0;
 }
+#endif
 
 
 // make a copy of src at dest while removing all characters
@@ -450,6 +493,9 @@ bool HunspellImpl::spell(const std::string& word, int* info, std::string* root)
 }
 
 bool HunspellImpl::spell_internal(const std::string& word, int* info, std::string* root) {
+#ifdef HUNSPELL_CHROME_CLIENT
+  if (m_HMgrs[0]) m_HMgrs[0]->EmptyHentryCache();
+#endif
   struct hentry* rv = NULL;
 
   int info2 = 0;
@@ -785,6 +831,13 @@ struct hentry* HunspellImpl::checkword(const std::string& w, int* info, std::str
   if (!len)
     return NULL;
 
+#ifdef HUNSPELL_CHROME_CLIENT
+  // We need to check if the word length is valid to make coverity (Event
+  // fixed_size_dest: Possible overrun of N byte fixed size buffer) happy.
+  if ((utf8 && strlen(word) >= MAXWORDUTF8LEN) || (!utf8 && strlen(word) >= MAXWORDLEN))
+    return NULL;
+#endif
+
   // word reversing wrapper for complex prefixes
   if (complexprefixes) {
     if (!usebuffer) {
@@ -985,6 +1038,9 @@ std::vector<std::string> HunspellImpl::suggest(const std::string& word) {
 
 std::vector<std::string> HunspellImpl::suggest_internal(const std::string& word,
         bool& capwords, size_t& abbv, int& captype) {
+#ifdef HUNSPELL_CHROME_CLIENT
+  if (m_HMgrs[0]) m_HMgrs[0]->EmptyHentryCache();
+#endif
   captype = NOCAP;
   abbv = 0;
   capwords = false;
@@ -2021,18 +2077,25 @@ int HunspellImpl::input_conv(const char* word, char* dest, size_t destsize) {
   return 0;
 }
 
+#ifdef HUNSPELL_CHROME_CLIENT
+Hunspell::Hunspell(base::span<const unsigned char> bdict_data)
+  : m_Impl(new HunspellImpl(bdict_data)) {
+#else
 Hunspell::Hunspell(const char* affpath, const char* dpath, const char* key)
   : m_Impl(new HunspellImpl(affpath, dpath, key)) {
+#endif
 }
 
 Hunspell::~Hunspell() {
   delete m_Impl;
 }
 
+#ifndef HUNSPELL_CHROME_CLIENT
 // load extra dictionaries
 int Hunspell::add_dic(const char* dpath, const char* key) {
   return m_Impl->add_dic(dpath, key);
 }
+#endif
 
 bool Hunspell::spell(const std::string& word, int* info, std::string* root) {
   return m_Impl->spell(word, info, root);
@@ -2159,22 +2222,32 @@ int Hunspell::input_conv(const char* word, char* dest, size_t destsize) {
 }
 
 Hunhandle* Hunspell_create(const char* affpath, const char* dpath) {
+#ifdef HUNSPELL_CHROME_CLIENT
+        return NULL;
+#else
   return reinterpret_cast<Hunhandle*>(new HunspellImpl(affpath, dpath));
+#endif
 }
 
 Hunhandle* Hunspell_create_key(const char* affpath,
                                const char* dpath,
                                const char* key) {
+#ifdef HUNSPELL_CHROME_CLIENT
+        return NULL;
+#else
   return reinterpret_cast<Hunhandle*>(new HunspellImpl(affpath, dpath, key));
+#endif
 }
 
 void Hunspell_destroy(Hunhandle* pHunspell) {
   delete reinterpret_cast<HunspellImpl*>(pHunspell);
 }
 
+#ifndef HUNSPELL_CHROME_CLIENT
 int Hunspell_add_dic(Hunhandle* pHunspell, const char* dpath) {
   return reinterpret_cast<HunspellImpl*>(pHunspell)->add_dic(dpath);
 }
+#endif
 
 int Hunspell_spell(Hunhandle* pHunspell, const char* word) {
   return reinterpret_cast<HunspellImpl*>(pHunspell)->spell(word);
diff --git a/src/hunspell/hunspell.hxx b/src/hunspell/hunspell.hxx
index a06bdd4..d3c2689 100644
--- a/src/hunspell/hunspell.hxx
+++ b/src/hunspell/hunspell.hxx
@@ -76,9 +76,14 @@
 #include <string>
 #include <vector>
 
+#ifdef HUNSPELL_CHROME_CLIENT
+#include "base/containers/span.h"
+#include "third_party/hunspell/google/bdict_reader.h"
+#endif
+
 #define SPELL_XML "<?xml?>"
 
-#define MAXSUGGESTION 15
+#define MAXSUGGESTION 5
 #define MAXSHARPS 5
 
 #ifndef MAXWORDLEN
@@ -112,11 +117,17 @@ class LIBHUNSPELL_DLL_EXPORTED Hunspell {
    * long path names (without the long path prefix Hunspell will use fopen()
    * with system-dependent character encoding instead of _wfopen()).
    */
+#ifdef HUNSPELL_CHROME_CLIENT
+  explicit Hunspell(base::span<const unsigned char> bdict_data);
+#else
   Hunspell(const char* affpath, const char* dpath, const char* key = NULL);
+#endif
   ~Hunspell();
 
+#ifndef HUNSPELL_CHROME_CLIENT
   /* load extra dictionaries (only dic files) */
   int add_dic(const char* dpath, const char* key = NULL);
+#endif
 
   /* spell(word) - spellcheck word
    * output: false = bad word, true = good word
diff --git a/src/hunspell/replist.cxx b/src/hunspell/replist.cxx
index cabe382..a6dc708 100644
--- a/src/hunspell/replist.cxx
+++ b/src/hunspell/replist.cxx
@@ -161,6 +161,7 @@ int RepList::add(const std::string& in_pat1, const std::string& pat2) {
   mystrrep(r->outstrings[type], "_", " ");
   dat[pos++] = r;
   // sort to the right place in the list
+#if 0
   int i;
   for (i = pos - 1; i > 0; i--) {
     if (strcmp(r->pattern.c_str(), dat[i - 1]->pattern.c_str()) < 0) {
@@ -169,6 +170,15 @@ int RepList::add(const std::string& in_pat1, const std::string& pat2) {
       break;
   }
   dat[i] = r;
+#else
+  for (int i = pos - 1; i > 0; i--) {
+    r = dat[i];
+    if (r->pattern < dat[i - 1]->pattern) {
+      dat[i] = dat[i - 1];
+      dat[i - 1] = r;
+    } else break;
+  }
+#endif
   return 0;
 }
 
diff --git a/src/hunspell/replist.hxx b/src/hunspell/replist.hxx
index 1e3efa4..c35a373 100644
--- a/src/hunspell/replist.hxx
+++ b/src/hunspell/replist.hxx
@@ -72,6 +72,12 @@
 #ifndef REPLIST_HXX_
 #define REPLIST_HXX_
 
+#ifdef HUNSPELL_CHROME_CLIENT
+// Compilation issues in spellchecker.cc think near is a macro, therefore
+// removing it here solves that problem.
+#undef near
+#endif
+
 #include "w_char.hxx"
 
 #include <string>
diff --git a/src/hunspell/suggestmgr.cxx b/src/hunspell/suggestmgr.cxx
index dba084e..a37100d 100644
--- a/src/hunspell/suggestmgr.cxx
+++ b/src/hunspell/suggestmgr.cxx
@@ -82,7 +82,112 @@ const w_char W_VLINE = {'\0', '|'};
 
 #define MAX_CHAR_DISTANCE 4
 
+#ifdef HUNSPELL_CHROME_CLIENT
+namespace {
+// A simple class which creates temporary hentry objects which are available
+// only in a scope. To conceal memory operations from SuggestMgr functions,
+// this object automatically deletes all hentry objects created through
+// CreateScopedHashEntry() calls in its destructor. So, the following snippet
+// raises a memory error.
+//
+//   hentry* bad_copy = NULL;
+//   {
+//     ScopedHashEntryFactory factory;
+//     hentry* scoped_copy = factory.CreateScopedHashEntry(0, source);
+//     ...
+//     bad_copy = scoped_copy;
+//   }
+//   if (bad_copy->word[0])  // memory for scoped_copy has been deleted!
+//
+// As listed in the above snippet, it is simple to use this class.
+// 1. Declare an instance of this ScopedHashEntryFactory, and;
+// 2. Call its CreateHashEntry() member instead of using 'new hentry' or
+//    'operator='.
+//
+class ScopedHashEntryFactory {
+ public:
+  ScopedHashEntryFactory();
+  ~ScopedHashEntryFactory();
+
+  // Creates a temporary copy of the given hentry struct.
+  // The returned copy is available only while this object is available.
+  // NOTE: this function just calls memcpy() in creating a copy of the given
+  // hentry struct, i.e. it does NOT copy objects referred by pointers of the
+  // given hentry struct.
+  hentry* CreateScopedHashEntry(int index, const hentry* source);
+
+ private:
+  // A struct which encapsulates the new hentry struct introduced in hunspell
+  // 1.2.8. For a pointer to an hentry struct 'h', hunspell 1.2.8 stores a word
+  // (including a NUL character) into 'h->word[0]',...,'h->word[h->blen]' even
+  // though arraysize(h->word[]) is 1. Also, it changed 'astr' to a pointer so
+  // it can store affix flags into 'h->astr[0]',...,'h->astr[alen-1]'. To handle
+  // this new hentry struct, we define a struct which combines three values: an
+  // hentry struct 'hentry'; a char array 'word[kMaxWordLen]', and; an unsigned
+  // short array 'astr' so a hentry struct 'h' returned from
+  // CreateScopedHashEntry() satisfies the following equations:
+  //   hentry* h = factory.CreateScopedHashEntry(0, source);
+  //   h->word[0] == ((HashEntryItem*)h)->entry.word[0].
+  //   h->word[1] == ((HashEntryItem*)h)->word[0].
+  //   ...
+  //   h->word[h->blen] == ((HashEntryItem*)h)->word[h->blen-1].
+  //   h->astr[0] == ((HashEntryItem*)h)->astr[0].
+  //   h->astr[1] == ((HashEntryItem*)h)->astr[1].
+  //   ...
+  //   h->astr[h->alen-1] == ((HashEntryItem*)h)->astr[h->alen-1].
+  enum {
+    kMaxWordLen = 128,
+    kMaxAffixLen = 8,
+  };
+  struct HashEntryItem {
+    hentry entry;
+    char word[kMaxWordLen];
+    unsigned short astr[kMaxAffixLen];
+  };
+
+  HashEntryItem hash_items_[MAX_ROOTS];
+};
+
+ScopedHashEntryFactory::ScopedHashEntryFactory() {
+  memset(&hash_items_[0], 0, sizeof(hash_items_));
+}
+
+ScopedHashEntryFactory::~ScopedHashEntryFactory() {
+}
+
+hentry* ScopedHashEntryFactory::CreateScopedHashEntry(int index,
+                                                      const hentry* source) {
+  if (index >= MAX_ROOTS || source->blen >= kMaxWordLen)
+    return NULL;
+
+  // Retrieve a HashEntryItem struct from our spool, initialize it, and
+  // returns the address of its 'hentry' member.
+  size_t source_size = sizeof(hentry) + source->blen + 1;
+  HashEntryItem* hash_item = &hash_items_[index];
+  memcpy(&hash_item->entry, source, source_size);
+  if (source->astr) {
+    hash_item->entry.alen = source->alen;
+    if (hash_item->entry.alen > kMaxAffixLen)
+      hash_item->entry.alen = kMaxAffixLen;
+    memcpy(hash_item->astr, source->astr, hash_item->entry.alen * sizeof(hash_item->astr[0]));
+    hash_item->entry.astr = &hash_item->astr[0];
+  }
+  return &hash_item->entry;
+}
+
+}  // namespace
+#endif
+
+
+#ifdef HUNSPELL_CHROME_CLIENT
+SuggestMgr::SuggestMgr(hunspell::BDictReader* reader,
+                       const char * tryme, int maxn, 
+                       AffixMgr * aptr)
+{
+  bdict_reader = reader;
+#else
 SuggestMgr::SuggestMgr(const char* tryme, unsigned int maxn, AffixMgr* aptr) {
+#endif
   // register affix manager and check in string of chars to
   // try when building candidate suggestions
   pAMgr = aptr;
@@ -455,6 +560,21 @@ int SuggestMgr::replchars(std::vector<std::string>& wlst,
   int wl = strlen(word);
   if (wl < 2 || !pAMgr)
     return wlst.size();
+
+// TODO: wrong, 'ns' doesn't exist any more
+#ifdef HUNSPELL_CHROME_CLIENT
+  const char *pattern, *pattern2;
+  hunspell::ReplacementIterator iterator = bdict_reader->GetReplacementIterator();
+  while (iterator.GetNext(&pattern, &pattern2)) {
+    const char* r = word;
+    size_t lenr = strlen(pattern2);
+    size_t lenp = strlen(pattern);
+
+    // search every occurence of the pattern in the word
+    while ((r=strstr(r, pattern)) != NULL) {
+      candidate = word;
+      candidate.replace(r-word, lenp, pattern2);
+#else
   const std::vector<replentry>& reptable = pAMgr->get_reptable();
   for (size_t i = 0; i < reptable.size(); ++i) {
     const char* r = word;
@@ -474,6 +594,7 @@ int SuggestMgr::replchars(std::vector<std::string>& wlst,
       candidate.resize(r - word);
       candidate.append(reptable[i].outstrings[type]);
       candidate.append(r + reptable[i].pattern.size());
+#endif
       testsug(wlst, candidate, cpdsuggest, NULL, NULL);
       // check REP suggestions with space
       size_t sp = candidate.find(' ');
@@ -1131,6 +1252,9 @@ void SuggestMgr::ngsuggest(std::vector<std::string>& wlst,
 
   struct hentry* hp = NULL;
   int col = -1;
+#ifdef HUNSPELL_CHROME_CLIENT
+  ScopedHashEntryFactory hash_entry_factory;
+#endif
   phonetable* ph = (pAMgr) ? pAMgr->get_phonetable() : NULL;
   std::string target;
   std::string candidate;
@@ -1257,7 +1381,11 @@ void SuggestMgr::ngsuggest(std::vector<std::string>& wlst,
 
       if (sc > scores[lp]) {
         scores[lp] = sc;
+#ifdef HUNSPELL_CHROME_CLIENT
+        roots[lp] = hash_entry_factory.CreateScopedHashEntry(lp, hp);
+#else
         roots[lp] = hp;
+#endif
         lval = sc;
         for (int j = 0; j < MAX_ROOTS; j++)
           if (scores[j] < lval) {
@@ -2197,8 +2325,8 @@ void SuggestMgr::lcs(const char* s,
     m = strlen(s);
     n = strlen(s2);
   }
-  c = (char*)malloc((m + 1) * (n + 1));
-  b = (char*)malloc((m + 1) * (n + 1));
+  c = (char *) calloc(m + 1, n + 1);
+  b = (char *) calloc(m + 1, n + 1);
   if (!c || !b) {
     if (c)
       free(c);
@@ -2207,10 +2335,6 @@ void SuggestMgr::lcs(const char* s,
     *result = NULL;
     return;
   }
-  for (i = 1; i <= m; i++)
-    c[i * (n + 1)] = 0;
-  for (j = 0; j <= n; j++)
-    c[j] = 0;
   for (i = 1; i <= m; i++) {
     for (j = 1; j <= n; j++) {
       if (((utf8) && (su[i - 1] == su2[j - 1])) ||
diff --git a/src/hunspell/suggestmgr.hxx b/src/hunspell/suggestmgr.hxx
index 7137be2..237d670 100644
--- a/src/hunspell/suggestmgr.hxx
+++ b/src/hunspell/suggestmgr.hxx
@@ -116,7 +116,11 @@ class SuggestMgr {
   int complexprefixes;
 
  public:
+#ifdef HUNSPELL_CHROME_CLIENT
+  SuggestMgr(hunspell::BDictReader* reader, const char * tryme, int maxn, AffixMgr *aptr);
+#else
   SuggestMgr(const char* tryme, unsigned int maxn, AffixMgr* aptr);
+#endif
   ~SuggestMgr();
 
   bool suggest(std::vector<std::string>& slst, const char* word, int* onlycmpdsug);
@@ -126,6 +130,10 @@ class SuggestMgr {
   std::string suggest_gen(const std::vector<std::string>& pl, const std::string& pattern);
 
  private:
+#ifdef HUNSPELL_CHROME_CLIENT
+   // Not owned by us, owned by the Hunspell object.
+   hunspell::BDictReader* bdict_reader;
+#endif
   void testsug(std::vector<std::string>& wlst,
                const std::string& candidate,
                int cpdsuggest,
