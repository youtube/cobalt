// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module blink.mojom;

import "cc/mojom/browser_controls_state.mojom";
import "cc/mojom/browser_controls_offset_tag_modifications.mojom";
import "mojo/public/mojom/base/byte_string.mojom";
import "mojo/public/mojom/base/shared_memory.mojom";
import "mojo/public/mojom/base/string16.mojom";
import "mojo/public/mojom/base/text_direction.mojom";
import "mojo/public/mojom/base/time.mojom";
import "mojo/public/mojom/base/unguessable_token.mojom";
import "mojo/public/mojom/base/values.mojom";
import "services/network/public/mojom/content_security_policy.mojom";
import "services/network/public/mojom/cross_origin_opener_policy.mojom";
import "services/network/public/mojom/fetch_api.mojom";
import "services/network/public/mojom/load_timing_info.mojom";
import "services/network/public/mojom/network_types.mojom";
import "services/network/public/mojom/source_location.mojom";
import "services/network/public/mojom/storage_access_api.mojom";
import "services/network/public/mojom/url_loader_completion_status.mojom";
import "services/network/public/mojom/attribution.mojom";
import "services/viz/public/mojom/compositing/offset_tag.mojom";
import "skia/public/mojom/bitmap.mojom";
import "skia/public/mojom/skcolor.mojom";
import "skia/public/mojom/skcolor4f.mojom";
import "third_party/blink/public/mojom/blob/blob.mojom";
import "third_party/blink/public/mojom/blob/blob_url_store.mojom";
import "third_party/blink/public/mojom/choosers/popup_menu.mojom";
import "third_party/blink/public/mojom/close_watcher/close_listener.mojom";
import "third_party/blink/public/mojom/confidence_level.mojom";
import "third_party/blink/public/mojom/context_menu/context_menu.mojom";
import "third_party/blink/public/mojom/navigation/navigation_params.mojom";
import "third_party/blink/public/mojom/css/preferred_color_scheme.mojom";
import "third_party/blink/public/mojom/devtools/console_message.mojom";
import "third_party/blink/public/mojom/devtools/devtools_agent.mojom";
import "third_party/blink/public/mojom/devtools/inspector_issue.mojom";
import "third_party/blink/public/mojom/dom_storage/storage_area.mojom";
import "third_party/blink/public/mojom/drag/drag.mojom";
import "third_party/blink/public/mojom/favicon/favicon_url.mojom";
import "third_party/blink/public/mojom/fenced_frame/fenced_frame.mojom";
import "third_party/blink/public/mojom/fenced_frame/fenced_frame_config.mojom";
import "third_party/blink/public/mojom/fetch/fetch_api_request.mojom";
import "third_party/blink/public/mojom/frame/blocked_navigation_types.mojom";
import "third_party/blink/public/mojom/frame/frame_owner_properties.mojom";
import "third_party/blink/public/mojom/frame/frame_policy.mojom";
import "third_party/blink/public/mojom/frame/frame_replication_state.mojom";
import "third_party/blink/public/mojom/frame/fullscreen.mojom";
import "third_party/blink/public/mojom/frame/lifecycle.mojom";
import "third_party/blink/public/mojom/frame/media_player_action.mojom";
import "third_party/blink/public/mojom/frame/remote_frame.mojom";
import "third_party/blink/public/mojom/frame/reporting_observer.mojom";
import "third_party/blink/public/mojom/frame/sudden_termination_disabler_type.mojom";
import "third_party/blink/public/mojom/frame/text_autosizer_page_info.mojom";
import "third_party/blink/public/mojom/frame/user_activation_notification_type.mojom";
import "third_party/blink/public/mojom/frame/user_activation_update_types.mojom";
import "third_party/blink/public/mojom/frame/view_transition_state.mojom";
import "third_party/blink/public/mojom/input/focus_type.mojom";
import "third_party/blink/public/mojom/input/scroll_direction.mojom";
import "third_party/blink/public/mojom/loader/referrer.mojom";
import "third_party/blink/public/mojom/loader/keep_alive_handle_factory.mojom";
import "third_party/blink/public/mojom/messaging/delegated_capability.mojom";
import "third_party/blink/public/mojom/messaging/task_attribution_id.mojom";
import "third_party/blink/public/mojom/messaging/transferable_message.mojom";
import "third_party/blink/public/mojom/navigation/navigation_api_history_entry_arrays.mojom";
import "third_party/blink/public/mojom/opengraph/metadata.mojom";
import "third_party/blink/public/mojom/page/draggable_region.mojom";
import "third_party/blink/public/mojom/page/widget.mojom";
import "third_party/blink/public/mojom/scroll/scroll_into_view_params.mojom";
import "third_party/blink/public/mojom/security_context/insecure_request_policy.mojom";
import "third_party/blink/public/mojom/timing/resource_timing.mojom";
import "third_party/blink/public/mojom/tokens/tokens.mojom";
import "third_party/blink/public/mojom/use_counter/metrics/web_feature.mojom";
import "third_party/blink/public/mojom/widget/platform_widget.mojom";
import "third_party/blink/public/mojom/window_features/window_features.mojom";
import "ui/base/ime/mojom/virtual_keyboard_types.mojom";
import "ui/base/mojom/window_open_disposition.mojom";
import "ui/events/mojom/scroll_granularity.mojom";
import "ui/gfx/geometry/mojom/geometry.mojom";
import "ui/gfx/image/mojom/image.mojom";
import "ui/gfx/range/mojom/range.mojom";
import "url/mojom/origin.mojom";
import "url/mojom/url.mojom";

[EnableIf=is_mac]
import "ui/base/mojom/attributed_string.mojom";

// Information about a subframe being saved as "complete html".
struct SavableSubframe {
  // Original url of the subframe (i.e. based the parent's html sources).
  url.mojom.Url original_url;

  // The unique identifier of the RenderFrameHost or RenderFrameProxy for the
  // subframe.
  blink.mojom.FrameToken subframe_token;
};

struct GetSavableResourceLinksReply {
  array<url.mojom.Url> resources_list;
  blink.mojom.Referrer referrer;
  array<SavableSubframe> subframes;
};

struct FindInPageResultAXParams {
  // The find in page request id.
  int32 request_id;

  // The index of the result match.
  int32 match_index;

  // The id of the accessibility object for the start of the match range.
  int32 start_id;

  // The character offset into the text of the start object.
  int32 start_offset;

  // The id of the accessibility object for the end of the match range.
  int32 end_id;

  // The character offset into the text of the end object.
  int32 end_offset;
};

// This struct holds parameters sent by the renderer to the browser, that are
// needed to download an URL.
struct DownloadURLParams {
  url.mojom.Url url;
  blink.mojom.Referrer? referrer;
  url.mojom.Origin? initiator_origin;
  mojo_base.mojom.String16? suggested_name;
  network.mojom.RedirectMode cross_origin_redirects;

  // Non-null when |url| is for "blob:".
  pending_remote<BlobURLToken>? blob_url_token;

  // Non-null when |url| is for "data:", eg. when saving an image.
  pending_remote<Blob>? data_url_blob;

  // Whether the download is from context menu.
  bool is_context_menu_save = false;

  // True when the download was preceded by a recent gesture from the user.
  bool has_user_gesture = false;
};

// Actions browser can ask renderer to perform on a Plugin.
enum PluginActionType {
  kRotate90Clockwise,
  kRotate90Counterclockwise,
};

// The result of executing JavaScript within a frame.
enum JavaScriptExecutionResultType {
  kSuccess,
  kException,
};

// The reason why a navigation API traversal was cancelled in the browser
// process, so the navigation API can report the appropriate error.
// https://wicg.github.io/navigation-api/#perform-a-navigation-api-traversal
enum TraverseCancelledReason {
  kNotFound,
  kSandboxViolation,
  kAbortedBeforeCommit,
};

// The ViewTransitionOnNavigation opt-in state for a Document. This indicates
// whether this Document wants to enable a ViewTransition for same-origin
// cross-document navigations initiated from it.
enum ViewTransitionSameOriginOptIn {
  kDisabled,
  kEnabled,
};

enum FrameOwnerElementType {
  kNone,
  kIframe,
  kObject,
  kEmbed,
  kFrame,
  kFencedframe
};

enum NavigationApiEntryRestoreReason {
  kBFCache,
  kPrerenderActivationPush,
  kPrerenderActivationReplace
};

enum StorageTypeAccessed {
    kCacheStorage,
    kIndexedDB,
    kFileSystem,
    kWebLocks,
    kLocalStorage,
    kSessionStorage
};

// This is directly cast to a UKM enum of the same name and logged,
// be sure not to change ordering or delete lines.
enum WindowProxyAccessType {
    kLocation,
    kClosed,
    kLength,
    kSelf,
    kWindow,
    kFrames,
    kOpener,
    kParent,
    kTop,
    kPostMessage,
    kAnonymousIndexedGetter,
    kClose,
    kFocus,
    kBlur,
    kAnonymousNamedGetter
};

// The maximum number of characters of the document's title that we're willing
// to accept in the browser process.
const uint16 kMaxTitleChars = 4096; // 4 * 1024;

// This struct holds iframe's HTML attributes that are needed in the browser.
// id, name and src are used to report back/forward cache NotRestoredReasons.
// If 'id', 'name' or 'src' are too long, it is cut down to a certain character
// limit.
// TODO(crbug.com/1345849): The char limit can be different on renderer and
// browser. Enforce the same char limit on both sides.
struct IframeAttributes {
  // Parsed value of the 'csp' attribute of the iframe.
  network.mojom.ContentSecurityPolicy? parsed_csp_attribute;
  // 'credentialless' attribute of the iframe.
  bool credentialless;
  // 'browsingtopics' attribute of the iframe.
  bool browsing_topics;
  // 'adauctionheaders' attribute of the iframe.
  bool ad_auction_headers;
  // 'sharedstoragewritable' attribute of the iframe.
  bool shared_storage_writable_opted_in;
  // 'id' attribute of the iframe. This can be optional because id might not be set.
  string? id;
  // 'name' attribute of the iframe. This is different from window.name, which is
  // tracked in FrameReplicationState. Optional because it might not be set.
  string? name;
  // 'src' attribute of the iframe. Optional because it might not be set.
  string? src;
};

// Code location for an enterprise legacy technology event. The data will be
// uploaded to the enterprise management server without being parsed by the
// browser process.
struct LegacyTechEventCodeLocation {
  string filename;
  uint64 line;
  uint64 column;
};

// The maximum allowed size of a crash report storage shared memory buffer. This
// is used when the renderer requests a shared memory buffer for crash report
// data; see `CreateCrashReportStorage()`.
const uint64 kMaxCrashReportStorageSize = 5242880; // 5 * 1024 * 1024.

// Implemented in Browser, this interface defines frame-specific methods that
// will be invoked from the render process (e.g. content::RenderFrameHostImpl).
//
// Note that this is different than content/common/frame.mojom in that the
// methods defined here are called directly in Blink without passing through
// content. In the future this interface will likely host more methods as the
// Onion Soup project advances, which can potentially lead to the removal of
// content/common/frame.mojom if enough code is moved to Blink.
interface LocalFrameHost {
  // Request to the browser that the frame wishes to enter fullscreen mode.
  // Returns either true if fullscreen is allowed to be entered, or false if the
  // request to enter fullscreen was denied. Note that the actual transition to
  // fullscreen will occur on the next visual update, when the next
  // Widget::UpdateVisualProperties is sent.
  EnterFullscreen(FullscreenOptions options) => (bool granted);

  // Request to the browser to exit fullscreen mode.
  ExitFullscreen();

  // Notifies the browser that the current frame has either become or is no
  // longer fullscreen. |options| is only provided if |is_fullscreen == true|.
  FullscreenStateChanged(bool is_fullscreen, FullscreenOptions? options);

  // Register a new handler for URL requests with the given scheme. |scheme|
  // and |url| are provided directly from javascript. See
  // https://html.spec.whatwg.org/multipage/system-state.html#custom-handlers
  // |user_gesture| indicates if the javascript API was called in context of
  // having an active transient user gesture.
  RegisterProtocolHandler(string scheme, url.mojom.Url url, bool user_gesture);

  // Unregister the registered handler for URL requests with the given scheme.
  // |scheme|, and |url| are provided directly from javascript. See
  // https://html.spec.whatwg.org/multipage/system-state.html#custom-handlers
  // |user_gesture| indicates if the javascript API was called in context of
  // having an active transient user gesture.
  UnregisterProtocolHandler(string scheme, url.mojom.Url url, bool user_gesture);

  // Indication that the associated frame has displayed inactive content
  // (such as an image) from an insecure source. Inactive content cannot spread
  // to other frames.
  DidDisplayInsecureContent();

  // Indication that the associated frame contains a form that submits to an
  // insecure target url.
  DidContainInsecureFormAction();

  // Indicates that the document element is available for the top-level frame.
  // This happens after the page starts loading, but before all resources are
  // finished.
  MainDocumentElementAvailable(bool uses_temporary_zoom_level);

  // Indicates that a child frame requires its parent frame to send it
  // information about whether it is occluded or has visual effects applied,
  // in order to service IntersectionObserver's that track visibility.
  SetNeedsOcclusionTracking(bool needs_tracking);

  // Indicates that the associated frame would like to change the policy of how
  // the virtual keyboard interacts with Blink's viewports.
  SetVirtualKeyboardMode(ui.mojom.VirtualKeyboardMode type);

  // Notifies the browser that the associated frame has changed its visibility
  // status. Visibility status changes occur when the frame moves in/out
  // of the viewport, or the need for a layout object changes, e.g. if the
  // frame owner assigns a display: none style.
  VisibilityChanged(blink.mojom.FrameVisibility visibility);

  // Notifies the browser that the associated frame has changed theme color.
  // This will only be called on main-frames only. |theme_color| is optional
  // and indicates if a theme color has been specified or not, e.g. removal
  // of a theme color meta tag will generate a null value.
  DidChangeThemeColor(skia.mojom.SkColor? theme_color);

  // Notifies the browser that the associated frame has changed its computed CSS
  // background color. This will be called on main-frames only.
  // |color_adjust| is true if the background is forced by color adjustments.
  DidChangeBackgroundColor(skia.mojom.SkColor4f background_color, bool color_adjust);

  // Sent when the renderer fails to load with |error_code| which means a net
  // error code.
  DidFailLoadWithError(url.mojom.Url url, int32 error_code);

  // Sent by the renderer when the associated frame becomes focused.
  DidFocusFrame();

  // Called to notify the browser process counterpart of this local frame that
  // |window.focus()| on a page has been invoked in the renderer process.
  DidCallFocus();

  // Sent when the frame starts enforcing an insecure request policy. Sending
  // this information in DidCommitProvisionalLoad isn't sufficient; this
  // message is needed because, for example, a document can dynamically insert
  // a <meta> tag that causes strict mixed content checking to be enforced.
  // |policy_bitmap| is a bitfield for InsecureRequestPolicy.
  EnforceInsecureRequestPolicy(blink.mojom.InsecureRequestPolicy policy_bitmap);

  // Elements of |set| are hashes of hosts to upgrade.
  EnforceInsecureNavigationsSet(array<uint32> set);

  // Sent when a new sudden termination disabler condition is either introduced
  // or removed.
  SuddenTerminationDisablerChanged(bool present,
                                   SuddenTerminationDisablerType disabler_type);

  // Notifies the browser that the associated frame received a user gesture on
  // a previous navigation on the same eTLD+1. This ensures the state is
  // propagated to any remote frames.
  HadStickyUserActivationBeforeNavigationChanged(bool has_gesture);

  // Sent by a local root to request scrolling in its parent process.
  ScrollRectToVisibleInParentFrame(gfx.mojom.RectF rect_to_scroll,
                                   ScrollIntoViewParams params);

  // Sent by a local root to continue bubbling a logical scroll in its parent
  // process.
  BubbleLogicalScrollInParentFrame(ScrollDirection direction,
                                   ui.mojom.ScrollGranularity granularity);

  // Sent by the renderer to indicate that a same document navigation
  // commit was requested, but was deferred by script via the NavigationApi. The
  // browser should show loading UI while waiting for the script to undefer and
  // allow the commit to proceed.
  StartLoadingForAsyncNavigationApiCommit();

  // Indicates an attempt by the associated frame to navigate to |blocked_url|,
  // but the navigation was blocked because of |reason|.
  DidBlockNavigation(url.mojom.Url blocked_url,
                       blink.mojom.NavigationBlockedReason reason);

  // Sent when the renderer changed the progress of a load.
  DidChangeLoadProgress(double load_progress);

  // Notifies the browser that a frame finished loading.
  DidFinishLoad(url.mojom.Url validated_url);

  // Dispatch a load event for this frame in the iframe element of an
  // out-of-process parent frame. Once handled, the browser process should
  // call RemoteFrame::DispatchLoadEventForFrameOwner() in the renderer.
  DispatchLoad();

  // Tells the browser to navigate back or forward in session history by
  // the given offset (relative to the current position in session
  // history). |has_user_gesture| tells whether or not this is the consequence
  // of a user action. |actual_navigation_start| is the time the navigation
  // began in the renderer process. |soft_navigation_heuristics_task_id| is the
  // task ID of the initiator of the navigation, if any. It is restricted to
  // same-document main-frame navigation initiated by the top-level document.
  GoToEntryAtOffset(int32 offset,
                    bool has_user_gesture,
                    mojo_base.mojom.TimeTicks actual_navigation_start,
                    TaskAttributionId? soft_navigation_heuristics_task_id);

  // Tells the browser to navigate back or forward in session history to the
  // history entry associated with |key|. |key| is a renderer-generated random
  // UUID, per
  // https://wicg.github.io/navigation-api/#session-history-entry-navigation-api-key
  //
  // The key is only used to trigger a back/forward navigation, so it is
  // fundamentally similar to |offset| in GoToEntryAtOffset(). However, the
  // navigation API also requires that |key| match a FrameNavigationEntry in
  // this frame, and that the target FNE is contiguously same-origin and
  // same-site-instance with the current FNE, so navigating via this
  // function is more restrictive than GoToEntryAtOffset().
  // |actual_navigation_start| is the time the navigation began in the renderer
  // process. |soft_navigation_heuristics_task_id| is the task ID of the
  // initiator of the navigation, if any. It is sent back to the renderer when
  // the navigation commits, and is limited to same-document main-frame
  // navigations initiated by the top-level document.
  NavigateToNavigationApiKey(string key, bool has_user_gesture,
                    mojo_base.mojom.TimeTicks actual_navigation_start,
                    TaskAttributionId? soft_navigation_heuristics_task_id);

  // Called with |true| when the first navigate event handler is added, and with
  // |false| when the last navigate event handler is removed.
  NavigateEventHandlerPresenceChanged(bool present);

  // Changes the title for the page in the UI when the page is navigated or the
  // title changes. Sent for top-level frames. This can be null when loading an
  // initial empty document (and in some tests).
  UpdateTitle(mojo_base.mojom.String16? title,
              mojo_base.mojom.TextDirection title_direction);

  // Updates the application title for a document. If non-empty, a web app
  // displayed in an app window may use this string instead of the regular
  // title. See
  // https://github.com/MicrosoftEdge/MSEdgeExplainers/blob/main/DocumentSubtitle/explainer.md
  UpdateApplicationTitle(mojo_base.mojom.String16 application_title);

  // Indicates that the user activation state in the current frame has been
  // updated, so the replicated states need to be synced (in the browser process
  // as well as in all other renderer processes).
  //
  // The |notification_type| parameter is used for histograms, only for the case
  // |update_state == kNotifyActivation|.
  UpdateUserActivationState(UserActivationUpdateType update_type,
                            UserActivationNotificationType notification_type);

  // Called when a history navigation action that could potentially be used to
  // back-trap a user is invoked. Keeps HistoryUserActivationState in sync
  // between renderer and browser.
  DidConsumeHistoryUserActivation();

  // Provides accessibility information about a find in page result.
  HandleAccessibilityFindInPageResult(FindInPageResultAXParams params);

  // Provides accessibility information about the termination of a find
  // in page operation.
  HandleAccessibilityFindInPageTermination();

  // Sent after the onload handler has been invoked for the document
  // in this frame. Sent for top-level frames.
  DocumentOnLoadCompleted();

  // Notifies the browser that resource timing information is available and
  // should be added to the performance entries of the parent frame.
  ForwardResourceTimingToParent(ResourceTimingInfo timing);

  // Notifies the browser that the DOMContentLoaded event was dispatched
  // for the document in this frame.
  DidDispatchDOMContentLoadedEvent();

  // A request to run a JavaScript dialog displaying |alert_message|.
  [Sync]
  RunModalAlertDialog(mojo_base.mojom.String16 alert_message,
                      bool disable_third_party_subframe_suppresion) => ();

  // A request to run a JavaScript dialog displaying |alert_message|.
  // |success| will be true if the user clicked 'OK', false if the
  // dialog was canceled.
  [Sync]
  RunModalConfirmDialog(mojo_base.mojom.String16 alert_message,
                        bool disable_third_party_subframe_suppresion) =>
                        (bool success);

  // A request to run a confirm JavaScript dialog displaying
  // |alert_message| with an editable text area with |default_value|.
  // |success| will be true if the user clicked 'OK', false if the
  // dialog was canceled. |result| will contain the result of
  // the editable text area.
  [Sync]
  RunModalPromptDialog(mojo_base.mojom.String16 alert_message,
                       mojo_base.mojom.String16 default_value,
                       bool disable_third_party_subframe_suppresion) =>
                       (bool success, mojo_base.mojom.String16 result);

  // A request to run a confirmation JavaScript dialog. |is_reload|
  // contains it the navigation causing the unload is a reload event.
  // |success| contains whether the page should be unloaded or not.
  [Sync]
  RunBeforeUnloadConfirm(bool is_reload) => (bool success);

  // Notifies that the urls for the favicon of a site has been determined.
  UpdateFaviconURL(array<FaviconURL> favicon_urls);

  // Initiates a download based on user actions like 'ALT+click'.
  DownloadURL(DownloadURLParams params);

  // Sent to the browser when focus changes inside the frame.
  // - is_editable_element: Whether the newly focused element needs
  //   keyboard input (true for textfields, text areas and content
  //   editable divs).
  // - is_richly_editable_element: Whether the newly focused element
  //   is richly editable (true for content editable divs).
  // - bounds_in_frame_widget: The newly focused element's bounds
  //   relative to local root's view, and it will be an empty bounds
  //   if there is no focused element.
  // - foucus_type: Focus type.
  FocusedElementChanged(bool is_editable_element,
                        bool is_richly_editable_element,
                        gfx.mojom.Rect bounds_in_frame_widget,
                        blink.mojom.FocusType focus_type);

  // Notification that the text selection has changed.
  // Note: The second parameter is the character based offset of the
  // std::u16string text in the document.
  TextSelectionChanged(mojo_base.mojom.BigString16 text,
                       uint32 offset,
                       gfx.mojom.Range range);

  // Show a popup menu using native controls on Mac or Android.
  // The popup menu is hidden when the mojo channel is closed.
  ShowPopupMenu(pending_remote<PopupMenuClient> popup_client,
                gfx.mojom.Rect bounds,
                double font_size,
                int32 selected_item,
                array<MenuItem> menu_items,
                bool right_aligned,
                bool allow_multiple_selection);

  // Similar to content.mojom.FrameHost::CreateNewWindow, except used for
  // sub-widgets, like <select> dropdowns. Upon return, the renderer side popup
  // will be live until the PopupWidgetHost is disconnected by the browser.
  // This is used on platforms that do not use the native controls via
  // ShowPopupMenu, OpenDateTimeDialog, or OpenColorChooser.
  CreateNewPopupWidget(
         pending_associated_receiver<PopupWidgetHost> popup_host,
         pending_associated_receiver<WidgetHost> blink_widget_host,
         pending_associated_remote<Widget> blink_widget);

  // Used to tell the parent that the user right clicked on an area of the
  // content area, and a context menu should be shown for it. The params
  // object contains information about the node(s) that were selected when the
  // user right clicked.
  ShowContextMenu(pending_associated_remote<ContextMenuClient> client,
                  UntrustworthyContextMenuParams params);

  // Sent when the renderer loads a resource from its memory cache. This message
  // lets the browser know we loaded a resource from the memory cache and is
  // needed to display the correct SSL indicators.
  // TODO(kinuko): Need to check if this comment is still relevant.
  //
  // The recipients of this message have no use for data: URLs: they don't
  // affect the page's insecure content list and are not in the disk cache. To
  // prevent large (1M+) data: URLs from crashing in the Mojo system, we simply
  // filter them out before calling this message.
  //
  // Note: May only be sent once per URL per frame per committed load.
  DidLoadResourceFromMemoryCache(
      url.mojom.Url url, string http_method,
      string mime_type, network.mojom.RequestDestination request_destination,
      bool include_credentials);

  // Notifies the browser that frame owner properties have changed.
  //
  // Frame owner properties currently include: name, scrollbar_mode,
  // margin_width and margin_height, among others.
  DidChangeFrameOwnerProperties(
    blink.mojom.FrameToken child_frame_token,
    blink.mojom.FrameOwnerProperties frame_owner_properties);

  // Sent when a local renderer frame either updates its opener to another
  // frame identified by |opener_frame|, or, if |opener_frame| is "empty",
  // the frame disowns its opener for the lifetime of the window.
  DidChangeOpener(blink.mojom.LocalFrameToken? opener_frame);

  // Notifies the browser that sandbox flags or container policy have changed
  // for a subframe of this frame.
  DidChangeFramePolicy(
      blink.mojom.FrameToken child_frame_token,
      blink.mojom.FramePolicy frame_policy);

  // Notifies the browser that one of the iframe attributes tracked by the
  // browser process changed.
  DidChangeIframeAttributes(
      blink.mojom.FrameToken child_frame_token, IframeAttributes attributes);

  // Sent by the renderer to request a paint preview of a subframe. |clip_rect|
  // is the size of the frame in it's parent. |guid| is an an identifier for
  // all the capture work (regardless of the process captures are happening in)
  // that allows the results to be grouped together, even if there are multiple
  // requests in-flight.
  CapturePaintPreviewOfSubframe(
      gfx.mojom.Rect clip_rect, mojo_base.mojom.UnguessableToken guid);

  // Sent when a CloseListener becomes active so the browser can notify if
  // a close signal occurs.
  SetCloseListener(
      pending_remote<blink.mojom.CloseListener> listener);

  // Notifies the browser that a child frame is detached from the DOM.
  Detach();

  // Returns the associated KeepAliveHandleFactory.
  GetKeepAliveHandleFactory(
      pending_receiver<blink.mojom.KeepAliveHandleFactory> factory);

  // Blink and JavaScript error messages to log to the console, debugger UI, or
  // error reporting service. |source_id| is usually a URL.
  // |untrusted_stack_trace| should only be printed or sent to other services;
  // it's untrusted and should not be parsed to get a structured stack trace.
  // The stack trace is only present if
  // content.mojom.Frame.SetWantErrorMessageStackTrace has been called for this
  // frame and the log_level is kError.
  DidAddMessageToConsole(
      ConsoleMessageLevel log_level,
      mojo_base.mojom.BigString16 msg,
      uint32 line_number,
      mojo_base.mojom.String16? source_id,
      mojo_base.mojom.BigString16? untrusted_stack_trace);

  // The frame's size is replicated in the browser so that the browser can
  // correctly set the initial size of the frame in case of a cross-process
  // navigation.
  FrameSizeChanged(gfx.mojom.Size size);

  // Notifies the frame that the document's color scheme has been inferred.
  DidInferColorScheme(PreferredColorScheme color_scheme);

  // Notifies the browser that a subframe's srcdoc attribute has changed, and
  // sends the new value to the browser. Also sent when a subframe's content
  // frame is changed.
  DidChangeSrcDoc(blink.mojom.FrameToken child_frame_token,
                  string srcdoc_value);

  // Notifies the browser that this frame received a message from a local frame
  // with a delegated capability (https://wicg.github.io/capability-delegation).
  // `delegated_capability` is the capability delegated via postMessage().
  // RemoteFrameHost messages already signal the browser via RouteMessageEvent.
  ReceivedDelegatedCapability(DelegatedCapability delegated_capability);

  // See:
  // https://github.com/WICG/turtledove/blob/main/Fenced_Frames_Ads_Reporting.md
  //
  // This implements the API:
  // window.fence.reportEvent({eventType, eventData, destination})
  //
  // A document in a fenced frame can invoke the reportEvent API to request the
  // browser to send `eventData` in a beacon toward the URL registered against
  // `eventType` by the worklet in registerAdBeacon. Depending on the declared
  // `destination`, the beacon is sent to the reporting destination's
  // registered URL.
  // Note the `destination` above is a WebIDL sequence, which means it may
  // contain multiple destinations. It is forwarded as a collection in a single
  // IPC call, instead of making an IPC call for each destination.
  // For the list of available reporting destinations, see enum
  // ReportingDestination defined in:
  // third_party/blink/public/mojom/fenced_frame/fenced_frame_config.mojom
  // `cross_origin_exposed` determines if this event can be used with reporting
  // metadata that lives in a cross-origin frame. See the comment in
  // "fence_event.idl" for more details.
  SendFencedFrameReportingBeacon(
      string event_data,
      string event_type,
      array<ReportingDestination> destinations,
      bool cross_origin_exposed);

  // See:
  // https://github.com/WICG/turtledove/blob/main/Fenced_Frames_Ads_Reporting.md
  //
  // This implements the API:
  // window.fence.reportEvent({destinationURL})
  //
  // A document in a fenced frame can invoke the reportEvent API to request the
  // browser to send a beacon to the https URL `destinationURL`, where macros
  // in `destinationURL` will be substituted using the values specified by
  // registerAdMacro in the Protected Audience auction's buyer worklet.
  // `cross_origin_exposed` determines if this event can be used with reporting
  // metadata that lives in a cross-origin frame. See the comment in
  // "fence_event.idl" for more details.
  //
  SendFencedFrameReportingBeaconToCustomURL(
      url.mojom.Url destination_url,
      bool cross_origin_exposed);

  // See:
  // https://github.com/WICG/fenced-frame/blob/master/explainer/fenced_frames_with_local_unpartitioned_data_access.md
  //
  // This implements the API:
  // window.fence.disableUntrustedNetwork()
  //
  // A document in a fenced frame can invoke the disableUntrustedNetwork API to
  // disable the frame tree's access to the network (except trusted servers in
  // the future) and gain access to unpartitioned storage.
  DisableUntrustedNetworkInFencedFrame() => ();

  // A test-only IPC to exempt `exempted_url` from fenced frames network
  // revocation immediately above (`DisableUntrustedNetworkInFencedFrame`).
  // Used primarily to exempt the fenced frames remote context executor pattern
  // in WPT from network revocation.
  ExemptUrlFromNetworkRevocationForTesting(url.mojom.Url exempted_url) => ();

  // Notify the browser that there is a legacy technology used by the page.
  // The event contains the technology `type` and code location from the
  // ExecutionContext.
  // The event will only be sent when legacy tech report feature is turned on by
  // the browser.
  // All data will be later uploaded to the enterprise management service as is.
  // Note that we don't guarantee any data here is valid, data will be valided
  // by the server.
  SendLegacyTechEvent(
    string type,
    LegacyTechEventCodeLocation code_location);

  // Fenced frames can send beacons automatically when an event happens.
  //
  // For now, only "reserved.top_navigation_start" and
  // "reserved.top_navigation_commit" is supported ("reserved.top_navigation"
  // will still work, but is deprecated). The `event_data` is installed in the
  // RenderFrameHost and will be sent toward `destinations` on the next
  // cross-document top-frame navigation.
  // `cross_origin_exposed` determines if this data can be used for an automatic
  // beacon that originates from a cross-origin subframe. See the comment in
  // "fence_event.idl" for more details.
  SetFencedFrameAutomaticBeaconReportEventData(
      AutomaticBeaconType event_type,
      string event_data,
      array<ReportingDestination> destinations,
      bool once,
      bool cross_origin_exposed);

  // See:
  // https://github.com/WICG/turtledove/blob/main/FLEDGE_extended_PA_reporting.md
  //
  // This implements the API:
  // window.fence.reportEvent(eventType)
  //
  // A document in a fenced frame can invoke the reportEvent API to request the
  // browser to send private aggregation requests associated with `event_type`.
  SendPrivateAggregationRequestsForFencedFrameEvent(string event_type);

  // Sent by the frame in a renderer process that hosts/owns a <fencedframe>
  // element, to the browser process requesting the creation of a new fenced
  // frame tree that will host the contents of the <fencedframe> element.
  // `fenced_frame` - the receiver that the browser will bind to receive
  //                  messages from the renderer.
  // `frame_token` - the unique identifier of the RenderFrameProxy
  // `devtools_frame_token` - the unique identifier of the main FrameTreeNode in
  //                          the "inner" fenced frame FrameTree
  CreateFencedFrame(
      pending_associated_receiver<blink.mojom.FencedFrameOwnerHost>
        fenced_frame,
      RemoteFrameInterfacesFromRenderer remote_frame_interfaces,
      blink.mojom.RemoteFrameToken frame_token,
      mojo_base.mojom.UnguessableToken devtools_frame_token);

  // Can be called when a DOM event named `event_type` fires within a fenced
  // frame's DOM tree. Propagates a censored version of the event to the
  // embedder that omits privacy-sensitive information like mouse coordinates or
  // timestamps. User activation is also consumed in the fenced frame tree and
  // notified to the embedder's DOM tree, if this method determines that
  // `event_type` should result in the embedder receiving user activation.
  ForwardFencedFrameEventAndUserActivationToEmbedder(string event_type);

  // Notifies when the ViewTransition opt-in state for the current Document
  // changes.
  // See https://drafts.csswg.org/css-view-transitions-2/#view-transition-rule
  OnViewTransitionOptInChanged(
    ViewTransitionSameOriginOptIn view_transition_opt_in);

  // Used to tell the browser the user started dragging in the content area.
  // |drag_data| contains contextual information about the pieces of the page
  // the user dragged. The browser uses this notification to initiate a drag
  // session at the OS level.
  StartDragging(DragData drag_data,
                AllowedDragOperations operations_allowed,
                skia.mojom.BitmapN32? image,
                gfx.mojom.Vector2d cursor_offset_in_dip,
                gfx.mojom.Rect drag_obj_rect_in_dip,
                DragEventSourceInfo event_info);

  // Register the remote corresponding to |receiver| as a keep alive handle for
  // browser-process navigation state associated with this LocalFrameHost.
  IssueKeepAliveHandle(
      pending_receiver<NavigationStateKeepAliveHandle> receiver);

  // Used to tell the browser that storage access was requested and whether it was allowed.
  NotifyStorageAccessed(StorageTypeAccessed storageType, bool blocked);

  // Used to tell the browser to record metrics. This method should not be trusted except for metrics purposes.
  RecordWindowProxyUsageMetrics(blink.mojom.FrameToken target_frame_token,
                                WindowProxyAccessType access_type);

  // Notify the browser the document readystate has changed to 'interactive'.
  // Sent for top-level frames.
  NotifyDocumentInteractive();

  // Sets the StorageAccessApiStatus for the given frame.
  SetStorageAccessApiStatus(network.mojom.StorageAccessApiStatus status);

  // This IPC lets the browser initialize memory reserved for crash reporting
  // API of size `length`. Note that the maximum allowed size is
  // `kMaxCrashReportStorageSize`. In the future, if we decide that shared
  // memory is to be the backing storage mechanism for this feature, then this
  // method's async callback will contain an `UnsafeSharedMemoryRegion` that the
  // renderer can use to write crash report data that the browser will read,
  // instead of using the two synchronous IPCs below.
  //
  // Note that this API must be called, and its callback run in the renderer,
  // before the below set and remove IPCs are called. A renderer process that
  // does not obey this requirement will be terminated.
  InitializeCrashReportStorage(uint64 length) => ();

  // Called by `blink::CrashReportStorage`.
  // TODO(https://crbug.com/400432195): Consider removing this IPC, and
  // refactoring the implementation to use a shared memory region with the
  // browser process, and some abstraction that serializes the internal map to
  // bytes in the shared memory region.
  //
  // This and the following IPC needs to be synchronous so that the browser
  // process can obtain the relevant crash data before the JavaScript that
  // triggered this IPC moves to the next line of code, which might crash the
  // renderer process. See
  // https://github.com/WICG/crash-reporting/blob/gh-pages/crashReport-explainer.md.
  [Sync]
  SetCrashReportStorageKey(string key, string value) => ();

  // Called by `blink::CrashReportStorage`.
  [Sync]
  RemoveCrashReportStorageKey(string key) => ();
};

// Implemented in Browser, this interface defines frame-specific methods
// that will be invoked from the renderer process
// (e.g. blink::LocalFrame).
//
// Note this interface is not a channel-associated interface and as such
// there are no ordering guarantees for messages sent on this interface
// against messages sent to LocalFrameHost. These messages are only
// meaningful if they arrive before navigation because these messages
// are intended to prepare for navigation. This is why this interface is
// not a channel-associated interface. This interface is for
// experimental purposes (https://crbug.com/1377753,
// https://crbug.com/1431792).
interface NonAssociatedLocalFrameHost {
  // Notifies that a renderer-initiated navigation to `urls` will
  // potentially start.
  // This is fired in the following situations so that the browser can
  // speculatively start or warm-up service workers, which might take a
  // long time to start.
  // - The anchor tag is in the viewport.
  // - The mouse hovered the anchor tag.
  // - The mousedown event gets dispatched on the anchor tag.
  // - The beforeunload event gets dispatched.
  // Note that the navigation might not actually start.
  MaybeStartOutermostMainFrameNavigation(array<url.mojom.Url> urls);
};

// Implemented in Blink, this interface defines frame-specific methods that will
// be invoked from the browser process (e.g. content::RenderFrameHostImpl).
//
// Note that this is different than content/common/frame.mojom in that the
// methods defined here are handled directly in Blink without passing through
// content. In the future this interface will likely host more methods as the
// Onion Soup project advances, which can potentially lead to the removal of
// content/common/frame.mojom if enough code is moved to Blink.
interface LocalFrame {
  // Retrieves the text surrounding the current selection for the frame up to
  // the length specified by |max_length|, along with its start and end offsets.
  GetTextSurroundingSelection(uint32 max_length)
      => (mojo_base.mojom.String16 content, uint32 start_offset,
          uint32 end_offset);

  // Queues an intervention report for this frame or a specific child frame.
  //
  // This report is always sent via the context of *this* frame.
  //
  // Args:
  //   `id`: Identifies the intervention type (e.g., "HeavyAdIntervention").
  //   `message`: A human-readable string providing additional context about
  //       why the intervention occurred.
  //   `child_frame_token`:
  //       - If null, the intervention report pertains directly to *this* frame.
  //       - If provided, the intervention report pertains to the specified
  //         child frame (which could be a LocalFrame or RemoteFrame proxy).
  //         `message` may be augmented with additional info about the child
  //         frame. The report is still sent from this frame, which contains
  //         the child frame's owner element.
  SendInterventionReport(string id, string message,
                         blink.mojom.FrameToken? child_frame_token);

  // Updates this frame's FrameOwner properties, such as scrolling, margin,
  // or allowfullscreen.  This is used when this frame's parent is in
  // another process and it dynamically updates these properties.
  // TODO(dcheng): Currently, the update only takes effect on next frame
  // navigation.  This matches the in-process frame behavior.
  SetFrameOwnerProperties(FrameOwnerProperties properties);

  // Notifies the RenderFrame about a user activation detected in the browser
  // side (e.g. during Android voice search). The |notification_type| parameter
  // is used for histograms only.
  NotifyUserActivation(UserActivationNotificationType notification_type);

  // Notifies the |LocalFrame| about the Virtual keyboard rectangle that is
  // occluding the web content.
  NotifyVirtualKeyboardOverlayRect(gfx.mojom.Rect keyboard_rect);

  // This call will "show interest" in the Element with the provided DOMNodeID,
  // which is presumed to have an `interestfor` attribute.
  ShowInterestInElement(int32 nodeID);

  // Add message to the frame console.
  AddMessageToConsole(ConsoleMessageLevel level, string message,
                    bool discard_duplicates);

  // Requests that a provisional frame swap itself into the frame tree,
  // immediately replacing the RemoteFrame that it is associated with. Normally,
  // this swap happens when the navigation commits in the provisional frame.
  // However, if the RemoteFrame corresponds to a crashed (and non-live) frame,
  // the browser will immediately call this method to stop showing the sad
  // iframe without having to wait for the navigation to commit.
  SwapInImmediately();

  // Sent to a frame when one of its remote children finishes loading, so that
  // the frame can update its loading state.
  CheckCompleted();

  // Instructs the frame to stop the load in progress, if any.
  StopLoading();

  // Sent to the process that owns this frame's HTMLFrameOwnerElement to
  // control whether the element is collapsed or not. If the element is
  // collapsed, it will be removed from the layout tree of its parent
  // frame's document.
  Collapse(bool collapsed);

  // Used to instruct the frame to go into "view source" mode. This should
  // only be sent to the main frame.
  EnableViewSourceMode();

  // Notifies this frame that it is now focused.  This is used to
  // support cross-process focused frame changes.
  Focus();

  // Notifies this frame to clear the focused element (if any).
  ClearFocusedElement();

  // Copies the image at |window_point| to the clipboard (if there indeed is an
  // image at that |window_point|).
  CopyImageAt(gfx.mojom.Point window_point);

  // Saves the image at |window_point| to the disk (if there indeed is an image
  // at that |window_point|).
  SaveImageAt(gfx.mojom.Point window_point);

  // Updates the frame with a list of unique WebFeature values representing
  // Blink features used, performed or encountered by the browser during the
  // current page load happening on the frame.
  ReportBlinkFeatureUsage(array<blink.mojom.WebFeature> features);

  // Sent to this frame in parent frame's process to render fallback contents.
  // This is only used for <object> elements that failed a navigation with a
  // network error.
  RenderFallbackContent();

  // Instructs the frame to invoke the beforeunload event handler.
  //
  // The closure callback is invoked to acknowledge the browser that
  // the beforeunload event is handled. |proceed| matches the return value
  // of the frame's beforeunload handler: true if the user decided to proceed
  // with leaving the page.
  //
  // The [SupportsUrgent] attribute enables marking this message as urgent by
  // calling the method in an UrgentMessageScope. Urgent messages cause the
  // renderer to prioritize the IPC task queue while there are urgent messages
  // pending, which increases their priority while maintaining ordering
  // guarantees. See also mojo/public/tools/bindings/README.md.
  [SupportsUrgent]
  BeforeUnload(bool is_reload)
      => (bool proceed, mojo_base.mojom.TimeTicks before_unload_start_time,
          mojo_base.mojom.TimeTicks before_unload_end_time);

  // Tells the renderer to perform the given action on the media player location
  // at the given point in the view coordinate space.
  MediaPlayerActionAt(gfx.mojom.Point location,
                      blink.mojom.MediaPlayerAction action);

  // Requests the current video frame and bounds of the media player at
  // `location`. The returned image is scaled if needed to be bounded by
  // `max_size` with aspect ratio preserved, unless the original area is already
  // less than `max_area`, where `max_size` and `max_area` are both in
  // device-independent pixels. This is to avoid scaling images with very
  // large/small aspect ratio to avoid losing information. If any of the
  // dimensions is non-positive, no scaling will be performed. The bounds
  // originate from the DOM layer, are in DIP and are relative to the local
  // root's widget (see Element::BoundsInWidget()). No guarantee is made about
  // their correlation with the bounds of the video frame as displayed in the
  // presentation layer. The returned bounds are also not guaranteed to
  // correspond to the result of returned video frame.
  RequestVideoFrameAtWithBoundsHint(gfx.mojom.Point location,
                                    gfx.mojom.Size max_size,
                                    int32 max_area)
      => (skia.mojom.BitmapN32? bitmap, gfx.mojom.Rect bounds);

  // Tells the renderer to perform the given action on the plugin location at
  // the given point in the view coordinate space.
  PluginActionAt(gfx.mojom.Point location, blink.mojom.PluginActionType action);

  // Request to continue running the sequential focus navigation algorithm in
  // this frame. |source_frame_token| identifies the frame that issued this
  // request. This message is sent when finding the next focusable element would
  // require moving onto a frame from a different process.
  AdvanceFocusInFrame(blink.mojom.FocusType focus_type,
                      blink.mojom.RemoteFrameToken? source_frame_token);

  // Notifies this Frame to advance the focus to next input node within its form
  // by moving in specified direction if the currently focused node is a Text
  // node (textfield, text area or content editable nodes). The next input node
  // chosen (if available) will always have the same form owner as the currently
  // focused node.
  AdvanceFocusForIME(blink.mojom.FocusType focus_type);

  // Notifies the document navigation was blocked because a content security
  // policy was violated.
  ReportContentSecurityPolicyViolation(network.mojom.CSPViolation violation);

  // Notifies the frame that its parent has changed the frame's sandbox flags or
  // container policy.
  DidUpdateFramePolicy(blink.mojom.FramePolicy frame_policy);

  // Notifies the renderer process that the associated frame has changed its
  // visibility status. Visibility status changes occur when the frame moves
  // in/out of the viewport, or when the render status of the object changes,
  // e.g. if the frame gets set a "display: none" or "visibility: hidden" style.
  OnFrameVisibilityChanged(blink.mojom.FrameVisibility visibility);

  // Posts a message from a frame in another process to the current renderer:
  //
  // |source_frame_token| is the frame token of the RemoteFrame in the current
  // renderer representing the frame (from a different renderer) where this
  // message is coming from.
  //
  // |source_origin| is the origin of the source from which the message was
  // sent. This will usually be the origin of the execution context that posted
  // a message but can be null in a few cases. Most notably, messages posted
  // via a `MessagePort` (which includes those posted from Dedicated Workers)
  // do not set an origin. Certain embedders, like WebView, also provide APIs
  // which result in messages being posted without an associated origin.
  //
  // |target_origin| specifies the origin of the message's intended target. If
  // the intended origin does not match the destination frame's origin, the
  // message will be discarded. If |target_origin| is null, then the caller
  // has specified a wildcard, allowing the message to be delivered regardless
  // of the destination frame's origin.
  //
  // |message| is the encoded data, and any extra properties such as
  // transferred ports or blobs.
  PostMessageEvent(blink.mojom.RemoteFrameToken? source_frame_token,
                   url.mojom.Origin? source_origin,
                   url.mojom.Origin? target_origin,
                   blink.mojom.TransferableMessage message);

  // Request for the renderer to execute a given JavaScript method on a given
  // object (both identified by name) in the frame's context.
  //
  // |object_name| is the global name of the object.
  //
  // |method_name| is the name of the method on the object.
  //
  // |arguments| is the list of arguments to pass to the method invocation.
  //
  // |wants_result| is true if the result of this execution is required by the
  // caller. If it is false, a reply is still required by Mojo, but a null value
  // should be returned to avoid issues serializing a large, unwanted reply.
  JavaScriptMethodExecuteRequest(
      mojo_base.mojom.String16 object_name,
      mojo_base.mojom.String16 method_name,
      mojo_base.mojom.ListValue arguments,
      bool wants_result) => (mojo_base.mojom.Value result);

  // Request for the renderer to execute JavaScript in the frame's context.
  //
  // |javascript| is the string containing the JavaScript to be executed in the
  // target frame's context. Note that this uses BigString16 rather than
  // String16 as this is used in contexts, like DevTools, where the contents of
  // the JavaScript script is user-provided, and therefore we can't guarantee
  // the size of the script.
  //
  // |wants_result| is true if the result of this execution is required by the
  // caller. If it is false, a reply is still required by Mojo, but a null value
  // should be returned to avoid issues serializing a large, unwanted reply.
  //
  JavaScriptExecuteRequest(
      mojo_base.mojom.BigString16 javascript,
      bool wants_result) => (mojo_base.mojom.Value result);

  // ONLY FOR TESTS: Same as above but this can optionally:
  // - Trigger a fake user activation notification to test functionalities that
  //   are gated by user activation.
  // - Can block until a resulting promise is resolved.
  // - Can choose to not honor JS content settings.
  // Content settings are a mechanism that allows users to disable various
  // functions of the browser. One content setting disables javascript. This bit
  // controls whether this content setting is ignored or honored.
  JavaScriptExecuteRequestForTests(
      mojo_base.mojom.BigString16 javascript,
      bool has_user_gesture,
      bool resolve_promises,
      bool honor_js_content_settings,
      int32 world_id)
      => (JavaScriptExecutionResultType result_type,
          mojo_base.mojom.Value result);

  // Same as JavaScriptExecuteRequest above except the script is run in the
  // isolated world specified by the fourth parameter.
  JavaScriptExecuteRequestInIsolatedWorld(
      mojo_base.mojom.BigString16 javascript,
      bool wants_result,
      int32 world_id) => (mojo_base.mojom.Value result);


  // Requests the index of a character in the frame's text stream at the given
  // point. The point is in the viewport coordinate space. Replies using
  // TextInputHost.
  [EnableIf=is_mac]
  GetCharacterIndexAtPoint(gfx.mojom.Point location);

  // Requests the rectangle for a given character range. Replies using
  // TextInputHost.
  [EnableIf=is_mac]
  GetFirstRectForRange(gfx.mojom.Range range);

  // Requests the text fragment in a given range.
  [EnableIf=is_mac]
  GetStringForRange(gfx.mojom.Range range)
      => (ui.mojom.AttributedString? string, gfx.mojom.Point baseline_point);

  // Binds |receiver| to the document of this frame.
  BindReportingObserver(
      pending_receiver<blink.mojom.ReportingObserver> receiver);

  // Requests that the blink::LocalFrame updates its opener to the specified
  // frame. The frame token may be "empty" if the opener was disowned.
  UpdateOpener(blink.mojom.FrameToken? opener_frame_token);

  // Request to enumerate and return links to all savable resources in the frame
  // Note: this covers only the immediate frame / doesn't cover subframes.
  GetSavableResourceLinks() => (GetSavableResourceLinksReply? reply);

  // Sent to a frame to notify about mixed content found externally.
  MixedContentFound(url.mojom.Url main_resource_url,
                    url.mojom.Url mixed_content_url,
                    RequestContextType request_context,
                    bool was_allowed,
                    url.mojom.Url url_before_redirects,
                    bool had_redirect,
                    network.mojom.SourceLocation? source_location);

  // Returns a DevToolsAgent interface for this frame, used for
  // remote debugging. See DevToolsAgent for details.
  // Returned DevToolsAgent must be associated with navigation control,
  // due to various ordering dependencies between DevTools protocol and
  // navigation.
  BindDevToolsAgent(
      pending_associated_remote<blink.mojom.DevToolsAgentHost> agent_host,
      pending_associated_receiver<blink.mojom.DevToolsAgent> agent);

  // Samsung Galaxy Note-specific "smart clip" stylus text getter.
  // Extracts the data at the given rect.
  [EnableIf=is_android]
  ExtractSmartClipData(gfx.mojom.Rect rect)
      => (mojo_base.mojom.String16 text, mojo_base.mojom.String16 html,
              gfx.mojom.Rect clip_rect);

  // Asks the renderer to handle a renderer-debug URL.
  HandleRendererDebugURL(url.mojom.Url url);

  // Requests the link-rel calnonical URL. The canonical url could be null if
  // the document of this frame doesn't have the HTMLLinkElement.
  GetCanonicalUrlForSharing() => (url.mojom.Url? canonical_url);

  // Requests the OpenGraph metadata for the page. See https://ogp.me/. If the
  // page has no OpenGraph tags that are understood by this implementation, or
  // if it has no OpenGraph tags at all, an empty OpenGraphMetadata is returned.
  GetOpenGraphMetadata() => (blink.mojom.OpenGraphMetadata metadata);

  // Updates navigation.entries() when restoring from bfcache.
  // navigation.entries() represents a subset of the back/forward list visible
  // to this frame, and that subset may have changed while the page was in
  // bfcache.
  SetNavigationApiHistoryEntriesForRestore(
      NavigationApiHistoryEntryArrays entry_arrays,
      NavigationApiEntryRestoreReason restore_reason);

  // Updates the URL for a prerender ready to be activated via No-Vary-Search
  // matching.
  UpdatePrerenderURL(url.mojom.Url matched_url) => ();

  // Updates navigation.entries() when entries are disposed from the session
  // history.
  NotifyNavigationApiOfDisposedEntries(array<string> keys);

  // Called when a traversal requested by the NavigationApi is cancelled in the
  // browser.
  // When the NavigationApi requests a traversal, it provides
  // |navigation_api_key| to the browser, which is an opaque reference to a
  // session history entry for this frame. It is sent back to the renderer here
  // to indicate which traversal failed.
  TraverseCancelled(string navigation_api_key, TraverseCancelledReason reason);

  // Dispatches a (uninterceptable, uncancelable) navigate event to the current
  // document when the browser process determines that this frame will perform
  // a same-origin cross-document traversal. `is_browser_initiated` will be
  // false iff this traversal was triggered by a web API (i.e.,
  // history.back()/forward()/go() or navigation.back()/forward()/traverseTo()).
  DispatchNavigateEventForCrossDocumentTraversal(
      url.mojom.Url url, mojo_base.mojom.ByteString page_state,
      bool is_browser_initiated);

  // Requests a one-time snapshot of the document state for a ViewTransition.
  // See https://drafts.csswg.org/css-view-transitions-1/ for details.
  //
  // The transition_token is used to preserve the identity of the transition
  // between old and new documents so they can share captured pixel state in
  // viz.
  SnapshotDocumentForViewTransition(
    blink.mojom.ViewTransitionToken transition_token,
    PageSwapEventParams page_swap_event_params) => (
      blink.mojom.ViewTransitionState view_transition_state);

  // Notifies the old Document that the ViewTransition associated with a
  // navigation was aborted, for example if the navigation was cancelled before
  // the renderer responds.
  NotifyViewTransitionAbortedToOldDocument();

  // Dispatches a `pageswap` event on the previous Document before the
  // navigation is committed. This API is used for navigations which don't have
  // a ViewTransition.
  // For ViewTransition the event must be dispatched before snapshotting the old
  // Document with a `ViewTransition` object passed to script. So the dispatch
  // is done as a part of the `SnapshotDocumentForViewTransition` API above.
  DispatchPageSwap(
    PageSwapEventParams? page_swap_event_params);

  // Allows the browser to add a resource timing entry for a subframe
  // navigation that has failed before committing - a non-ok object navigation
  // or a no-content response (204/205).
  AddResourceTimingEntryForFailedSubframeNavigation(
    blink.mojom.FrameToken subframe_token,
    url.mojom.Url initial_url,
    mojo_base.mojom.TimeTicks start_time,
    mojo_base.mojom.TimeTicks redirect_time,
    mojo_base.mojom.TimeTicks request_start,
    mojo_base.mojom.TimeTicks response_start,
    uint32 response_code,
    string mime_type,
    network.mojom.LoadTimingInfo load_timing_info,
    network.mojom.ConnectionInfo connection_info,
    string alpn_negotiated_protocol,
    bool is_secure_transport,
    bool is_validated,
    string normalized_server_timing,
    network.mojom.URLLoaderCompletionStatus completion_status
  );

  // Retrieves the scroll position of the frame.
  GetScrollPosition() => (gfx.mojom.Point scroll_position);

  // Request to perform spell check for full text content.
  [EnableIf=is_android]
  PerformSpellCheck();
};

// Implemented in Blink, this interface defines main-frame-specific methods that
// will be invoked from the browser process (e.g. content::WebContentsImpl).
//
// There is only ever one local main frame for a given tab in all renderer
// processes.
//
// This interface will only be provided when the LocalFrame is a main frame.
interface LocalMainFrame {
  // Requests performing a page scale animation based on the point/rect provided.
  AnimateDoubleTapZoom(gfx.mojom.Point point, gfx.mojom.Rect rect);

  // Scales the view without affecting layout by using the visual viewport.
  SetScaleFactor(float scale);

  // Instructs the renderer to close the current page, including running the
  // onunload event handler.
  ClosePage() => ();

  // Get width and height of the whole page content from the main frame.
  GetFullPageSize() => (gfx.mojom.Size full_page_size);

  // Tells the renderer to focus the first (last if reverse is true) focusable
  // node.
  SetInitialFocus(bool reverse);

  // Instructs the renderer to send back updates to the preferred size.
  EnablePreferredSizeChangedMode();

  // Sent to the main-frame to request performing a zoom-to-find-in-page
  // based on the rect provided.
  ZoomToFindInPageRect(gfx.mojom.Rect rect_in_root_frame);

  // Cross-Origin-Opener-Policy(COOP):
  // Check accesses made from this window to |accessed_window|. If this happens,
  // 1) A network report will be sent to |reporter|.
  // 2) A ReportingObserver event will be dispatched.
  // 3) Devtool will be notified.
  //
  InstallCoopAccessMonitor(
      blink.mojom.FrameToken accessed_window,
      network.mojom.CrossOriginOpenerPolicyReporterParams coop_reporter_info);

  // Notifies the renderer whether hiding/showing the browser controls is
  // enabled, what the current state should be, and whether or not to
  // animate to the proper state.
  //
  // offset_tag_modifications consists of OffsetTags and additional metadata
  // for moving browser controls. It is passed to the renderer and used to tag the
  // browser controls scroll offsets in the compositor frame's metadata, with
  // the goal of allowing viz to scroll the top controls by applying the
  // offset. The slim::Layers for the top controls in the browser must be
  // tagged with the same token.
  // A zero token is passed when the browser is forcing the controls to be
  // shown/hidden. When this happens, the browser process will have removed
  // the renderer's OffsetTagDefinition from the associated SurfaceLayer, so
  // viz will not look for scroll offsets or OffsetTags in the compositor frame
  // metadata anymore. The renderer should also not tag any scroll offsets with
  // OffsetTags, as they won't be seen by viz.
  // A null token is passed when scrolling top controls is viz is not
  // applicable (ex. chromeos, UI elements that overlay on top of chrome,
  // tests, etc.)
  UpdateBrowserControlsState(
      cc.mojom.BrowserControlsState constraints,
      cc.mojom.BrowserControlsState current,
      bool animate,
      cc.mojom.BrowserControlsOffsetTagModifications? offset_tag_modifications);

  // Transmits data to V8CrowdsourcedCompileHintsConsumer in the renderer. The
  // data is a Bloom filter describing which JavaScript functions on the page
  // should be eagerly parsed & compiled by the JS engine.
  SetV8CompileHints(mojo_base.mojom.ReadOnlySharedMemoryRegion data);

  // Replaces the active document with an empty document to free resources,
  // e.g. for supporting tab discard.
  Discard() => ();

  // Updates the frame's finalized locally differentially private
  // navigation confidence.
  FinalizeNavigationConfidence(
    double randomized_trigger_rate,
    ConfidenceLevel confidence);
};

// Implemented in Browser, this interface defines local-main-frame-specific
// methods that will be invoked from the renderer process (e.g. WebViewImpl).
//
// TODO(https://crbug.com/334100817): Remove this attribute.
[DispatchDebugAlias]
interface LocalMainFrameHost {
  // Indicates the scale of the view has changed.
  ScaleFactorChanged(float scale);

  // Notifies that the preferred size of the view has changed.
  ContentsPreferredSizeChanged(gfx.mojom.Size pref_size);

  // Informs the browser that page metrics relevant to Blink's TextAutosizer
  // have changed, so that they can be shared with other renderers. The
  // browser will share this information with other renderers that have frames
  // in the page.
  TextAutosizerPageInfoChanged(TextAutosizerPageInfo page_info);

  // Asks the browser process to activate the page associated to the main frame.
  FocusPage();

  // Asks the browser to transfer focus cross-process on behalf of the renderer
  // in the focus hierarchy. This may focus an element in the browser ui or a
  // cross-process frame, as appropriate.
  TakeFocus(bool reverse);

  // Notifies the browser that we want to show a destination url for a potential
  // action (e.g. when the user is hovering over a link). Implementation of this
  // method will reply back to the renderer once the target URL gets received,
  // in order to prevent target URLs spamming the browser.
  UpdateTargetURL(url.mojom.Url url) => ();

  // Request close of the window. This corresponds to a window.close() javascript API call.
  // Frame unload handlers should have already been called before this method is called.
  RequestClose();

  // Causes a window previously opened via content.mojom.FrameHost::CreateNewWindow
  // to be shown on the screen. This message contains the opener_frame_token
  // which is always set. This is called on the main frame of the window to be shown.
  ShowCreatedWindow(blink.mojom.LocalFrameToken opener_frame_token,
                    ui.mojom.WindowOpenDisposition disposition,
                    blink.mojom.WindowFeatures window_features,
                    bool opened_by_user_gesture) => ();

  // Request that the browser change the bounds of the window.
  // This corresponds to the window.resizeTo() and window.moveTo() APIs, and the browser
  // may ignore this message.
  SetWindowRect(gfx.mojom.Rect bounds) => ();

  // Sent once a paint happens after the first non empty layout. In other words,
  // after the frame has painted something.
  DidFirstVisuallyNonEmptyPaint();

  // Indicates that another page has accessed the DOM of the initial empty
  // document of a main frame. After this, it is no longer safe to show a
  // pending navigation's URL, because a URL spoof is possible.
  DidAccessInitialMainDocument();

  // Request browser to maximize window. Link to I2P:
  // https://groups.google.com/a/chromium.org/g/blink-dev/c/oCxWg8q_OQY/m/LUTw0T5cCQAJ
  [EnableIfNot=is_android|is_ios]
  Maximize();

  // Request browser to minimize window. Link to I2P:
  // https://groups.google.com/a/chromium.org/g/blink-dev/c/oCxWg8q_OQY/m/LUTw0T5cCQAJ
  [EnableIfNot=is_android|is_ios]
  Minimize();

  // Request browser to restore window. Link to I2P:
  // https://groups.google.com/a/chromium.org/g/blink-dev/c/oCxWg8q_OQY/m/LUTw0T5cCQAJ
  [EnableIfNot=is_android|is_ios]
  Restore();

  // Set the browser window to resizable or not. Link to I2P:
  // https://groups.google.com/a/chromium.org/g/blink-dev/c/oCxWg8q_OQY/m/LUTw0T5cCQAJ
  [EnableIfNot=is_android|is_ios]
  SetResizable(bool resizable);

  // Notify the browser that the draggable regions defined by the app-region
  // CSS property have been updated.
  DraggableRegionsChanged(array<DraggableRegion> regions);

  // Called when the main frame did a first contentful paint.
  OnFirstContentfulPaint(mojo_base.mojom.TimeDelta duration);
};
