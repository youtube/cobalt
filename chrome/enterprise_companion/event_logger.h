// Copyright 2024 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_ENTERPRISE_COMPANION_EVENT_LOGGER_H_
#define CHROME_ENTERPRISE_COMPANION_EVENT_LOGGER_H_

#include <memory>
#include <optional>
#include <string>

#include "base/files/file.h"
#include "base/files/file_path.h"
#include "base/files/platform_file.h"
#include "base/functional/callback_forward.h"
#include "base/memory/ref_counted.h"
#include "base/memory/scoped_refptr.h"
#include "base/threading/sequence_bound.h"
#include "base/time/default_clock.h"
#include "base/time/time.h"
#include "chrome/enterprise_companion/enterprise_companion_status.h"
#include "chrome/enterprise_companion/telemetry_logger/proto/log_request.pb.h"
#include "chrome/enterprise_companion/telemetry_logger/telemetry_logger.h"
#include "mojo/public/cpp/bindings/pending_remote.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "services/network/public/cpp/shared_url_loader_factory.h"
#include "services/network/public/mojom/cookie_manager.mojom.h"

namespace enterprise_companion {

extern const char kLoggingCookieName[];
extern const char kLoggingCookieDefaultValue[];

namespace proto {
class EnterpriseCompanionEvent;
}

using EventTelemetryLogger =
    telemetry_logger::TelemetryLogger<proto::EnterpriseCompanionEvent>;

// Handles the initial population and persistence of the event logging cookie
// for the duration of its lifetime.
class EventLoggerCookieHandler {
 public:
  virtual ~EventLoggerCookieHandler() = default;

  virtual void Init(mojo::PendingRemote<network::mojom::CookieManager>
                        cookie_manager_pending_remote,
                    base::OnceClosure callback) = 0;
};

std::optional<base::File> OpenDefaultEventLoggerCookieFile();

// Creates an EventLoggerCookieHandler which persists the logging cookie to
// `logging_cookie_file`. If the provided optional has no value, an invalid
// SequenceBound will be returned. Because the file is accessible only by
// elevated users, a handle is used instead of a path by this interface. This
// allows the net worker process on MacOS to open the file while it is still
// root, become the "nobody" user, and still access the cookie file.
base::SequenceBound<EventLoggerCookieHandler> CreateEventLoggerCookieHandler(
    std::optional<base::File> logging_cookie_file =
        OpenDefaultEventLoggerCookieFile());

// Interface class to log the events that are generated by this companion app.
class EnterpriseCompanionEventLogger
    : public base::RefCountedThreadSafe<EnterpriseCompanionEventLogger> {
 public:
  static scoped_refptr<EnterpriseCompanionEventLogger> Create(
      scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory);
  virtual void LogRegisterPolicyAgentEvent(
      base::Time start_time,
      StatusCallback callback,
      const EnterpriseCompanionStatus& status) = 0;
  virtual void LogPolicyFetchEvent(base::Time start_time,
                                   StatusCallback callback,
                                   const EnterpriseCompanionStatus& status) = 0;
  virtual void Flush(base::OnceClosure callback) = 0;

 protected:
  friend class base::RefCountedThreadSafe<EnterpriseCompanionEventLogger>;
  virtual ~EnterpriseCompanionEventLogger() = default;
};

}  // namespace enterprise_companion

#endif  // CHROME_ENTERPRISE_COMPANION_EVENT_LOGGER_H_
