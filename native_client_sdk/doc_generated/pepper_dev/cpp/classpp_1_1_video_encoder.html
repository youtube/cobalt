{{+bindTo:partials.standard_nacl_api}}
<h1>pp::VideoEncoder Class Reference</h1>
<div id="doxygen-ref">
{{- dummy div to appease doxygen -}}
  <div>
<!-- Generated by Doxygen 1.7.6.1 -->



</div>
<!--header-->
<div class="contents">
<!-- doxytag: class="pp::VideoEncoder" --><!-- doxytag: inherits="pp::Resource" --><div class="dynheader">
Inheritance diagram for pp::VideoEncoder:</div>
<div class="dyncontent">
<div class="center"><img src="classpp_1_1_video_encoder__inherit__graph.png" border="0" usemap="#pp_1_1_video_encoder_inherit__map" alt="Inheritance graph" /></div>
<map name="pp_1_1_video_encoder_inherit__map" id="pp_1_1_video_encoder_inherit__map">
<area shape="rect" id="node2" href="classpp_1_1_resource.html" title="A reference counted module resource." alt="" coords="20,5,124,32"></area></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<p><a href="classpp_1_1_video_encoder-members.html">List of all members.</a></p>
<h2>
Public Member Functions</h2><table class="memberdecls">

<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_encoder.html#a6a84b977ee05e00bb2c00519d1893d08">VideoEncoder</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_encoder.html#a479c6cbd73b497c98871d877ef9e0b29">VideoEncoder</a> (const <a class="el" href="classpp_1_1_instance_handle.html">InstanceHandle</a> &amp;instance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_encoder.html#ad9d09d444a0480153aa5086fda13f064">VideoEncoder</a> (const <a class="el" href="classpp_1_1_video_encoder.html">VideoEncoder</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_encoder.html#a5c264d3b6ec0a5970cc1dee74dbfaf55">GetSupportedProfiles</a> (const <a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a>&lt; std::vector&lt; PP_VideoProfileDescription &gt; &gt; &amp;cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_encoder.html#ad2c47c10cfe92a3bf41e204d326560c7">Initialize</a> (const PP_VideoFrame_Format &amp;input_format, const <a class="el" href="classpp_1_1_size.html">Size</a> &amp;input_visible_size, const PP_VideoProfile &amp;output_profile, const uint32_t initial_bitrate, PP_HardwareAcceleration acceleration, const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_encoder.html#ae673a5ebfed4fc3198a405cccecfbe54">GetFramesRequired</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_encoder.html#a2112ec6caf60385c1625b85e3697d777">GetFrameCodedSize</a> (<a class="el" href="classpp_1_1_size.html">Size</a> *coded_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_encoder.html#a5c5fabe6a00afe6b8849bbc612183bb2">GetVideoFrame</a> (const <a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a>&lt; <a class="el" href="classpp_1_1_video_frame.html">VideoFrame</a> &gt; &amp;cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_encoder.html#a39755b4e3aee295d8ba509da9904e5cd">Encode</a> (const <a class="el" href="classpp_1_1_video_frame.html">VideoFrame</a> &amp;video_frame, bool force_keyframe, const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_encoder.html#a9c0861d91f7c93cb15cf917ca6d6cf95">GetBitstreamBuffer</a> (const <a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a>&lt; PP_BitstreamBuffer &gt; &amp;cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_encoder.html#a81aec23c26a3f9c16ff90efdc38b2895">RecycleBitstreamBuffer</a> (const PP_BitstreamBuffer &amp;bitstream_buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_encoder.html#a727159fe366c6ce146dce4c42a608fd7">RequestEncodingParametersChange</a> (uint32_t bitrate, uint32_t framerate)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpp_1_1_video_encoder.html#a411036495143eb6484b668e2d26c1170">Close</a> ()</td></tr>
</table>
<hr /><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Video encoder interface. </p>
<p>Typical usage:</p>
<ul>
<li>Call Create() to create a new video encoder resource.</li>
<li>Call GetSupportedFormats() to determine which codecs and profiles are available.</li>
<li>Call <a class="el" href="classpp_1_1_video_encoder.html#ad2c47c10cfe92a3bf41e204d326560c7" title="Initializes a video encoder resource.">Initialize()</a> to initialize the encoder for a supported profile.</li>
<li>Call <a class="el" href="classpp_1_1_video_encoder.html#a5c5fabe6a00afe6b8849bbc612183bb2" title="Gets a blank video frame which can be filled with video data and passed to the encoder.">GetVideoFrame()</a> to get a blank frame and fill it in, or get a video frame from another resource, e.g. <code>PPB_MediaStreamVideoTrack</code>.</li>
<li>Call <a class="el" href="classpp_1_1_video_encoder.html#a39755b4e3aee295d8ba509da9904e5cd" title="Encodes a video frame.">Encode()</a> to push the video frame to the encoder. If an external frame is pushed, wait for completion to recycle the frame.</li>
<li>Call <a class="el" href="classpp_1_1_video_encoder.html#a9c0861d91f7c93cb15cf917ca6d6cf95" title="Gets the next encoded bitstream buffer from the encoder.">GetBitstreamBuffer()</a> continuously (waiting for each previous call to complete) to pull encoded pictures from the encoder.</li>
<li>Call <a class="el" href="classpp_1_1_video_encoder.html#a81aec23c26a3f9c16ff90efdc38b2895" title="Recycles a bitstream buffer back to the encoder.">RecycleBitstreamBuffer()</a> after consuming the data in the bitstream buffer.</li>
<li>To destroy the encoder, the plugin should release all of its references to it. Any pending callbacks will abort before the encoder is destroyed.</li>
</ul>
<p>Available video codecs vary by platform. All: vp8 (software). ChromeOS, depending on your device: h264 (hardware), vp8 (hardware) </p>
</div><hr /><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6a84b977ee05e00bb2c00519d1893d08"></a><!-- doxytag: member="pp::VideoEncoder::VideoEncoder" ref="a6a84b977ee05e00bb2c00519d1893d08" args="()" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_video_encoder.html#a6a84b977ee05e00bb2c00519d1893d08">pp::VideoEncoder::VideoEncoder</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Default constructor for creating an <a class="el" href="classpp_1_1_resource.html#a859068e34cdc2dc0b78754c255323aa9" title="This functions determines if this resource is invalid or uninitialized.">is_null()</a> <code><a class="el" href="classpp_1_1_video_encoder.html" title="Video encoder interface.">VideoEncoder</a></code> object. </p>
</div>
</div>
<a class="anchor" id="a479c6cbd73b497c98871d877ef9e0b29"></a><!-- doxytag: member="pp::VideoEncoder::VideoEncoder" ref="a479c6cbd73b497c98871d877ef9e0b29" args="(const InstanceHandle &amp;instance)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_video_encoder.html#a6a84b977ee05e00bb2c00519d1893d08">pp::VideoEncoder::VideoEncoder</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_instance_handle.html">InstanceHandle</a> &amp;&#160;</td>
<td class="paramname"><em>instance</em></td><td>)</td>
<td><code> [explicit]</code></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>A constructor used to create a <code><a class="el" href="classpp_1_1_video_encoder.html" title="Video encoder interface.">VideoEncoder</a></code> and associate it with the provided <code><a class="el" href="classpp_1_1_instance.html">Instance</a></code>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">instance</td><td>The instance with which this resource will be associated. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad9d09d444a0480153aa5086fda13f064"></a><!-- doxytag: member="pp::VideoEncoder::VideoEncoder" ref="ad9d09d444a0480153aa5086fda13f064" args="(const VideoEncoder &amp;other)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classpp_1_1_video_encoder.html#a6a84b977ee05e00bb2c00519d1893d08">pp::VideoEncoder::VideoEncoder</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_video_encoder.html">VideoEncoder</a> &amp;&#160;</td>
<td class="paramname"><em>other</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>The copy constructor for <code><a class="el" href="classpp_1_1_video_encoder.html" title="Video encoder interface.">VideoEncoder</a></code>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>A reference to a <code><a class="el" href="classpp_1_1_video_encoder.html" title="Video encoder interface.">VideoEncoder</a></code>. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<hr /><h2>Member Function Documentation</h2>
<a class="anchor" id="a411036495143eb6484b668e2d26c1170"></a><!-- doxytag: member="pp::VideoEncoder::Close" ref="a411036495143eb6484b668e2d26c1170" args="()" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void <a class="el" href="classpp_1_1_video_encoder.html#a411036495143eb6484b668e2d26c1170">pp::VideoEncoder::Close</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Closes the video encoder, and cancels any pending encodes. </p>
<p>Any pending callbacks will still run, reporting <code>PP_ERROR_ABORTED</code> . It is not valid to call any encoder functions after a call to this method. <b>Note:</b> Destroying the video encoder closes it implicitly, so you are not required to call <a class="el" href="classpp_1_1_video_encoder.html#a411036495143eb6484b668e2d26c1170" title="Closes the video encoder, and cancels any pending encodes.">Close()</a>. </p>
</div>
</div>
<a class="anchor" id="a39755b4e3aee295d8ba509da9904e5cd"></a><!-- doxytag: member="pp::VideoEncoder::Encode" ref="a39755b4e3aee295d8ba509da9904e5cd" args="(const VideoFrame &amp;video_frame, bool force_keyframe, const CompletionCallback &amp;cc)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_video_encoder.html#a39755b4e3aee295d8ba509da9904e5cd">pp::VideoEncoder::Encode</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_video_frame.html">VideoFrame</a> &amp;&#160;</td>
<td class="paramname"><em>video_frame</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool&#160;</td>
<td class="paramname"><em>force_keyframe</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;&#160;</td>
<td class="paramname"><em>cc</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Encodes a video frame. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">video_frame</td><td>The <code><a class="el" href="classpp_1_1_video_frame.html">VideoFrame</a></code> to be encoded. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">force_keyframe</td><td>A <code>PP_Bool&gt; specifying whether the encoder should emit a key frame for this video frame. </code></td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td><code>A </code><code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> to be called upon completion. Plugins that pass <code><a class="el" href="classpp_1_1_video_frame.html">VideoFrame</a></code> resources owned by other resources should wait for completion before reusing them.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code> An int32_t containing an error code from </code><code>pp_errors.h</code>. Returns PP_ERROR_FAILED if <a class="el" href="classpp_1_1_video_encoder.html#ad2c47c10cfe92a3bf41e204d326560c7" title="Initializes a video encoder resource.">Initialize()</a> has not successfully completed. </dd></dl>
</div>
</div>
<a class="anchor" id="a9c0861d91f7c93cb15cf917ca6d6cf95"></a><!-- doxytag: member="pp::VideoEncoder::GetBitstreamBuffer" ref="a9c0861d91f7c93cb15cf917ca6d6cf95" args="(const CompletionCallbackWithOutput&lt; PP_BitstreamBuffer &gt; &amp;cc)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_video_encoder.html#a9c0861d91f7c93cb15cf917ca6d6cf95">pp::VideoEncoder::GetBitstreamBuffer</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a>&lt; PP_BitstreamBuffer &gt; &amp;&#160;</td>
<td class="paramname"><em>cc</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Gets the next encoded bitstream buffer from the encoder. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">bitstream_buffer</td><td>A <code>PP_BitstreamBuffer</code> containing encoded video data. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A <code><a class="el" href="classpp_1_1_completion_callback_with_output.html" title="A CompletionCallbackWithOutput defines a completion callback that additionally stores a pointer to so...">CompletionCallbackWithOutput</a></code> to be called upon completion with the next bitstream buffer. The plugin can call GetBitstreamBuffer from the callback in order to continuously "pull" bitstream buffers from the encoder.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing an error code from <code>pp_errors.h</code>. Returns PP_ERROR_FAILED if <a class="el" href="classpp_1_1_video_encoder.html#ad2c47c10cfe92a3bf41e204d326560c7" title="Initializes a video encoder resource.">Initialize()</a> has not successfully completed. Returns PP_ERROR_INPROGRESS if a prior call to <a class="el" href="classpp_1_1_video_encoder.html#a9c0861d91f7c93cb15cf917ca6d6cf95" title="Gets the next encoded bitstream buffer from the encoder.">GetBitstreamBuffer()</a> has not completed. </dd></dl>
</div>
</div>
<a class="anchor" id="a2112ec6caf60385c1625b85e3697d777"></a><!-- doxytag: member="pp::VideoEncoder::GetFrameCodedSize" ref="a2112ec6caf60385c1625b85e3697d777" args="(Size *coded_size)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_video_encoder.html#a2112ec6caf60385c1625b85e3697d777">pp::VideoEncoder::GetFrameCodedSize</a> </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classpp_1_1_size.html">Size</a> *&#160;</td>
<td class="paramname"><em>coded_size</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Gets the coded size of the video frames required by the encoder. </p>
<p>Coded size is the logical size of the input frames, in pixels. The encoder may have hardware alignment requirements that make this different from |input_visible_size|, as requested in the call to <a class="el" href="classpp_1_1_video_encoder.html#ad2c47c10cfe92a3bf41e204d326560c7" title="Initializes a video encoder resource.">Initialize()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">coded_size</td><td>A <code><a class="el" href="classpp_1_1_size.html" title="A size of an object based on width and height.">Size</a></code> to hold the coded size.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing a result code from <code>pp_errors.h</code>. Returns PP_ERROR_FAILED if <a class="el" href="classpp_1_1_video_encoder.html#ad2c47c10cfe92a3bf41e204d326560c7" title="Initializes a video encoder resource.">Initialize()</a> has not successfully completed. </dd></dl>
</div>
</div>
<a class="anchor" id="ae673a5ebfed4fc3198a405cccecfbe54"></a><!-- doxytag: member="pp::VideoEncoder::GetFramesRequired" ref="ae673a5ebfed4fc3198a405cccecfbe54" args="()" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_video_encoder.html#ae673a5ebfed4fc3198a405cccecfbe54">pp::VideoEncoder::GetFramesRequired</a> </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Gets the number of input video frames that the encoder may hold while encoding. </p>
<p>If the plugin is providing the video frames, it should have at least this many available.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing the number of frames required, or an error code from <code>pp_errors.h</code>. Returns PP_ERROR_FAILED if <a class="el" href="classpp_1_1_video_encoder.html#ad2c47c10cfe92a3bf41e204d326560c7" title="Initializes a video encoder resource.">Initialize()</a> has not successfully completed. </dd></dl>
</div>
</div>
<a class="anchor" id="a5c264d3b6ec0a5970cc1dee74dbfaf55"></a><!-- doxytag: member="pp::VideoEncoder::GetSupportedProfiles" ref="a5c264d3b6ec0a5970cc1dee74dbfaf55" args="(const CompletionCallbackWithOutput&lt; std::vector&lt; PP_VideoProfileDescription &gt; &gt; &amp;cc)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_video_encoder.html#a5c264d3b6ec0a5970cc1dee74dbfaf55">pp::VideoEncoder::GetSupportedProfiles</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a>&lt; std::vector&lt; PP_VideoProfileDescription &gt; &gt; &amp;&#160;</td>
<td class="paramname"><em>cc</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Gets an array of supported video encoder profiles. </p>
<p>These can be used to choose a profile before calling <a class="el" href="classpp_1_1_video_encoder.html#ad2c47c10cfe92a3bf41e204d326560c7" title="Initializes a video encoder resource.">Initialize()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A <code><a class="el" href="classpp_1_1_completion_callback_with_output.html" title="A CompletionCallbackWithOutput defines a completion callback that additionally stores a pointer to so...">CompletionCallbackWithOutput</a></code> to be called upon completion with the PP_VideoProfileDescription structs.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If &gt;= 0, the number of supported profiles returned, otherwise an error code from <code>pp_errors.h</code>. </dd></dl>
</div>
</div>
<a class="anchor" id="a5c5fabe6a00afe6b8849bbc612183bb2"></a><!-- doxytag: member="pp::VideoEncoder::GetVideoFrame" ref="a5c5fabe6a00afe6b8849bbc612183bb2" args="(const CompletionCallbackWithOutput&lt; VideoFrame &gt; &amp;cc)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_video_encoder.html#a5c5fabe6a00afe6b8849bbc612183bb2">pp::VideoEncoder::GetVideoFrame</a> </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback_with_output.html">CompletionCallbackWithOutput</a>&lt; <a class="el" href="classpp_1_1_video_frame.html">VideoFrame</a> &gt; &amp;&#160;</td>
<td class="paramname"><em>cc</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Gets a blank video frame which can be filled with video data and passed to the encoder. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A <code><a class="el" href="classpp_1_1_completion_callback_with_output.html" title="A CompletionCallbackWithOutput defines a completion callback that additionally stores a pointer to so...">CompletionCallbackWithOutput</a></code> to be called upon completion with the blank <code><a class="el" href="classpp_1_1_video_frame.html">VideoFrame</a></code> resource.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing an error code from <code>pp_errors.h</code>. </dd></dl>
</div>
</div>
<a class="anchor" id="ad2c47c10cfe92a3bf41e204d326560c7"></a><!-- doxytag: member="pp::VideoEncoder::Initialize" ref="ad2c47c10cfe92a3bf41e204d326560c7" args="(const PP_VideoFrame_Format &amp;input_format, const Size &amp;input_visible_size, const PP_VideoProfile &amp;output_profile, const uint32_t initial_bitrate, PP_HardwareAcceleration acceleration, const CompletionCallback &amp;cc)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int32_t <a class="el" href="classpp_1_1_video_encoder.html#ad2c47c10cfe92a3bf41e204d326560c7">pp::VideoEncoder::Initialize</a> </td>
<td>(</td>
<td class="paramtype">const PP_VideoFrame_Format &amp;&#160;</td>
<td class="paramname"><em>input_format</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_size.html">Size</a> &amp;&#160;</td>
<td class="paramname"><em>input_visible_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const PP_VideoProfile &amp;&#160;</td>
<td class="paramname"><em>output_profile</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const uint32_t&#160;</td>
<td class="paramname"><em>initial_bitrate</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">PP_HardwareAcceleration&#160;</td>
<td class="paramname"><em>acceleration</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classpp_1_1_completion_callback.html">CompletionCallback</a> &amp;&#160;</td>
<td class="paramname"><em>cc</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Initializes a video encoder resource. </p>
<p>This should be called after <a class="el" href="classpp_1_1_video_encoder.html#a5c264d3b6ec0a5970cc1dee74dbfaf55" title="Gets an array of supported video encoder profiles.">GetSupportedProfiles()</a> and before any functions below.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">input_format</td><td>The <code>PP_VideoFrame_Format</code> of the frames which will be encoded. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">input_visible_size</td><td>A <code><a class="el" href="classpp_1_1_size.html" title="A size of an object based on width and height.">Size</a></code> specifying the dimensions of the visible part of the input frames. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">output_profile</td><td>A <code>PP_VideoProfile</code> specifying the codec profile of the encoded output stream. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">acceleration</td><td>A <code>PP_HardwareAcceleration</code> specifying whether to use a hardware accelerated or a software implementation. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A <code><a class="el" href="classpp_1_1_completion_callback.html" title="This API enables you to implement and receive callbacks when Pepper operations complete asynchronousl...">CompletionCallback</a></code> to be called upon completion.</td></tr>
</table>
</dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An int32_t containing an error code from <code>pp_errors.h</code>. Returns PP_ERROR_NOTSUPPORTED if video encoding is not available, or the requested codec profile is not supported. Returns PP_ERROR_NOMEMORY if frame and bitstream buffers can't be created. </dd></dl>
</div>
</div>
<a class="anchor" id="a81aec23c26a3f9c16ff90efdc38b2895"></a><!-- doxytag: member="pp::VideoEncoder::RecycleBitstreamBuffer" ref="a81aec23c26a3f9c16ff90efdc38b2895" args="(const PP_BitstreamBuffer &amp;bitstream_buffer)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void <a class="el" href="classpp_1_1_video_encoder.html#a81aec23c26a3f9c16ff90efdc38b2895">pp::VideoEncoder::RecycleBitstreamBuffer</a> </td>
<td>(</td>
<td class="paramtype">const PP_BitstreamBuffer &amp;&#160;</td>
<td class="paramname"><em>bitstream_buffer</em></td><td>)</td>
<td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Recycles a bitstream buffer back to the encoder. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">bitstream_buffer</td><td>A <code>PP_BitstreamBuffer</code> that is no longer needed by the plugin. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a727159fe366c6ce146dce4c42a608fd7"></a><!-- doxytag: member="pp::VideoEncoder::RequestEncodingParametersChange" ref="a727159fe366c6ce146dce4c42a608fd7" args="(uint32_t bitrate, uint32_t framerate)" -->
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void <a class="el" href="classpp_1_1_video_encoder.html#a727159fe366c6ce146dce4c42a608fd7">pp::VideoEncoder::RequestEncodingParametersChange</a> </td>
<td>(</td>
<td class="paramtype">uint32_t&#160;</td>
<td class="paramname"><em>bitrate</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t&#160;</td>
<td class="paramname"><em>framerate</em>&#160;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div>
<div class="memdoc">
<p>Requests a change to encoding parameters. </p>
<p>This is only a request, fulfilled on a best-effort basis.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">bitrate</td><td>The requested new bitrate, in bits per second. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">framerate</td><td>The requested new framerate, in frames per second. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<hr />The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="video__encoder_8h.html">video_encoder.h</a></li>
</ul>
</div><!-- contents -->
</div>
{{/partials.standard_nacl_api}}
